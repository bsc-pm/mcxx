/*
    Mercurium C/C++ Compiler
    Copyright (C) 2006-2009 - Roger Ferrer Ibanez <roger.ferrer@bsc.es>
    Barcelona Supercomputing Center - Centro Nacional de Supercomputacion
    Universitat Politecnica de Catalunya

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
extern const int gtkmm_major_version;
extern const int gtkmm_minor_version;
extern const int gtkmm_micro_version;
namespace std __attribute__((__visibility__("default"))) {
}
typedef long int ptrdiff_t;
typedef long unsigned int size_t;
namespace std __attribute__((__visibility__("default"))) {
    using ::ptrdiff_t;
    using ::size_t;
}
namespace std __attribute__((__visibility__("default"))) {
    void __throw_bad_exception(void) __attribute__((__noreturn__));
    void __throw_bad_alloc(void) __attribute__((__noreturn__));
    void __throw_bad_cast(void) __attribute__((__noreturn__));
    void __throw_bad_typeid(void) __attribute__((__noreturn__));
    void __throw_logic_error(const char *) __attribute__((__noreturn__));
    void __throw_domain_error(const char *) __attribute__((__noreturn__));
    void __throw_invalid_argument(const char *) __attribute__((__noreturn__));
    void __throw_length_error(const char *) __attribute__((__noreturn__));
    void __throw_out_of_range(const char *) __attribute__((__noreturn__));
    void __throw_runtime_error(const char *) __attribute__((__noreturn__));
    void __throw_range_error(const char *) __attribute__((__noreturn__));
    void __throw_overflow_error(const char *) __attribute__((__noreturn__));
    void __throw_underflow_error(const char *) __attribute__((__noreturn__));
    void __throw_ios_failure(const char *) __attribute__((__noreturn__));
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
    template<typename _Iterator, typename _Container >
    class __normal_iterator;
}
namespace std __attribute__((__visibility__("default"))) {
    struct __true_type
    {
    };
    struct __false_type
    {
    };
    template<bool >
    struct __truth_type
    {
            typedef __false_type __type;
    };
    template<>
    struct __truth_type< true >
    {
            typedef __true_type __type;
    };
    template<class _Sp, class _Tp >
    struct __traitor
    {
            enum 
            {
                __value = bool(_Sp::__value) || bool(_Tp::__value)
            };
            typedef typename __truth_type< __value >::__type __type;
    };
    template<class _Sp, class _Tp >
    struct __traitand
    {
            enum 
            {
                __value = bool(_Sp::__value) && bool(_Tp::__value)
            };
            typedef typename __truth_type< __value >::__type __type;
    };
    template<typename , typename  >
    struct __are_same
    {
            enum 
            {
                __value = 0
            };
            typedef __false_type __type;
    };
    template<typename _Tp >
    struct __are_same< _Tp, _Tp >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<typename _Tp >
    struct __is_void
    {
            enum 
            {
                __value = 0
            };
            typedef __false_type __type;
    };
    template<>
    struct __is_void< void >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<typename _Tp >
    struct __is_integer
    {
            enum 
            {
                __value = 0
            };
            typedef __false_type __type;
    };
    template<>
    struct __is_integer< bool >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<>
    struct __is_integer< char >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<>
    struct __is_integer< signed char >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<>
    struct __is_integer< unsigned char >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<>
    struct __is_integer< wchar_t >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<>
    struct __is_integer< short >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<>
    struct __is_integer< unsigned short >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<>
    struct __is_integer< int >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<>
    struct __is_integer< unsigned int >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<>
    struct __is_integer< long >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<>
    struct __is_integer< unsigned long >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<>
    struct __is_integer< long long >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<>
    struct __is_integer< unsigned long long >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<typename _Tp >
    struct __is_floating
    {
            enum 
            {
                __value = 0
            };
            typedef __false_type __type;
    };
    template<>
    struct __is_floating< float >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<>
    struct __is_floating< double >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<>
    struct __is_floating< long double >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<typename _Tp >
    struct __is_pointer
    {
            enum 
            {
                __value = 0
            };
            typedef __false_type __type;
    };
    template<typename _Tp >
    struct __is_pointer< _Tp * >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<typename _Tp >
    struct __is_normal_iterator
    {
            enum 
            {
                __value = 0
            };
            typedef __false_type __type;
    };
    template<typename _Iterator, typename _Container >
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator< _Iterator, _Container > >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<typename _Tp >
    struct __is_arithmetic : public __traitor< __is_integer< _Tp >, __is_floating< _Tp > >
    {
    };
    template<typename _Tp >
    struct __is_fundamental : public __traitor< __is_void< _Tp >, __is_arithmetic< _Tp > >
    {
    };
    template<typename _Tp >
    struct __is_scalar : public __traitor< __is_arithmetic< _Tp >, __is_pointer< _Tp > >
    {
    };
    template<typename _Tp >
    struct __is_char
    {
            enum 
            {
                __value = 0
            };
            typedef __false_type __type;
    };
    template<>
    struct __is_char< char >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<>
    struct __is_char< wchar_t >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<typename _Tp >
    struct __is_byte
    {
            enum 
            {
                __value = 0
            };
            typedef __false_type __type;
    };
    template<>
    struct __is_byte< char >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<>
    struct __is_byte< signed char >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<>
    struct __is_byte< unsigned char >
    {
            enum 
            {
                __value = 1
            };
            typedef __true_type __type;
    };
    template<typename _Tp >
    struct __is_move_iterator
    {
            enum 
            {
                __value = 0
            };
            typedef __false_type __type;
    };
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
    template<bool, typename  >
    struct __enable_if
    {
    };
    template<typename _Tp >
    struct __enable_if< true, _Tp >
    {
            typedef _Tp __type;
    };
    template<bool _Cond, typename _Iftrue, typename _Iffalse >
    struct __conditional_type
    {
            typedef _Iftrue __type;
    };
    template<typename _Iftrue, typename _Iffalse >
    struct __conditional_type< false, _Iftrue, _Iffalse >
    {
            typedef _Iffalse __type;
    };
    template<typename _Tp >
    struct __add_unsigned
    {
        private :
            typedef __enable_if< std::__is_integer< _Tp >::__value, _Tp > __if_type;
        public :
            typedef typename __if_type::__type __type;
    };
    template<>
    struct __add_unsigned< char >
    {
            typedef unsigned char __type;
    };
    template<>
    struct __add_unsigned< signed char >
    {
            typedef unsigned char __type;
    };
    template<>
    struct __add_unsigned< short >
    {
            typedef unsigned short __type;
    };
    template<>
    struct __add_unsigned< int >
    {
            typedef unsigned int __type;
    };
    template<>
    struct __add_unsigned< long >
    {
            typedef unsigned long __type;
    };
    template<>
    struct __add_unsigned< long long >
    {
            typedef unsigned long long __type;
    };
    template<>
    struct __add_unsigned< bool >;
    template<>
    struct __add_unsigned< wchar_t >;
    template<typename _Tp >
    struct __remove_unsigned
    {
        private :
            typedef __enable_if< std::__is_integer< _Tp >::__value, _Tp > __if_type;
        public :
            typedef typename __if_type::__type __type;
    };
    template<>
    struct __remove_unsigned< char >
    {
            typedef signed char __type;
    };
    template<>
    struct __remove_unsigned< unsigned char >
    {
            typedef signed char __type;
    };
    template<>
    struct __remove_unsigned< unsigned short >
    {
            typedef short __type;
    };
    template<>
    struct __remove_unsigned< unsigned int >
    {
            typedef int __type;
    };
    template<>
    struct __remove_unsigned< unsigned long >
    {
            typedef long __type;
    };
    template<>
    struct __remove_unsigned< unsigned long long >
    {
            typedef long long __type;
    };
    template<>
    struct __remove_unsigned< bool >;
    template<>
    struct __remove_unsigned< wchar_t >;
    template<typename _Type >
    inline bool __is_null_pointer(_Type * __ptr)
    {
        return __ptr == 0;
    }
    template<typename _Type >
    inline bool __is_null_pointer(_Type)
    {
        return false;
    }
    template<typename _Tp, bool = std::__is_integer< _Tp >::__value >
    struct __promote
    {
            typedef double __type;
    };
    template<typename _Tp >
    struct __promote< _Tp, false >
    {
            typedef _Tp __type;
    };
    template<typename _Tp, typename _Up >
    struct __promote_2
    {
        private :
            typedef typename __promote< _Tp >::__type __type1;
            typedef typename __promote< _Up >::__type __type2;
        public :
            typedef __typeof__ (__type1() + __type2()) __type;
    };
    template<typename _Tp, typename _Up, typename _Vp >
    struct __promote_3
    {
        private :
            typedef typename __promote< _Tp >::__type __type1;
            typedef typename __promote< _Up >::__type __type2;
            typedef typename __promote< _Vp >::__type __type3;
        public :
            typedef __typeof__ (__type1() + __type2() + __type3()) __type;
    };
    template<typename _Tp, typename _Up, typename _Vp, typename _Wp >
    struct __promote_4
    {
        private :
            typedef typename __promote< _Tp >::__type __type1;
            typedef typename __promote< _Up >::__type __type2;
            typedef typename __promote< _Vp >::__type __type3;
            typedef typename __promote< _Wp >::__type __type4;
        public :
            typedef __typeof__ (__type1() + __type2() + __type3() + __type4()) __type;
    };
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
    template<typename _Value >
    struct __numeric_traits_integer
    {
            static const _Value __min = (((_Value) (-1) < 0) ? (_Value) 1 << (sizeof(_Value) * 8 - ((_Value) (-1) < 0)) : (_Value) 0);
            static const _Value __max = (((_Value) (-1) < 0) ? (((((_Value) 1 << ((sizeof(_Value) * 8 - ((_Value) (-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value) 0);
            static const bool __is_signed = ((_Value) (-1) < 0);
            static const int __digits = (sizeof(_Value) * 8 - ((_Value) (-1) < 0));
    };
    template<typename _Value >
    const _Value __numeric_traits_integer< _Value >::__min;
    template<typename _Value >
    const _Value __numeric_traits_integer< _Value >::__max;
    template<typename _Value >
    const bool __numeric_traits_integer< _Value >::__is_signed;
    template<typename _Value >
    const int __numeric_traits_integer< _Value >::__digits;
    template<typename _Value >
    struct __numeric_traits_floating
    {
            static const int __max_digits10 = (2 + (std::__are_same< _Value, float >::__value ? 24 : std::__are_same< _Value, double >::__value ? 53 : 64) * 3010 / 10000);
            static const bool __is_signed = true;
            static const int __digits10 = (std::__are_same< _Value, float >::__value ? 6 : std::__are_same< _Value, double >::__value ? 15 : 18);
            static const int __max_exponent10 = (std::__are_same< _Value, float >::__value ? 38 : std::__are_same< _Value, double >::__value ? 308 : 4932);
    };
    template<typename _Value >
    const int __numeric_traits_floating< _Value >::__max_digits10;
    template<typename _Value >
    const bool __numeric_traits_floating< _Value >::__is_signed;
    template<typename _Value >
    const int __numeric_traits_floating< _Value >::__digits10;
    template<typename _Value >
    const int __numeric_traits_floating< _Value >::__max_exponent10;
    template<typename _Value >
    struct __numeric_traits : public __conditional_type< std::__is_integer< _Value >::__value, __numeric_traits_integer< _Value >, __numeric_traits_floating< _Value > >::__type
    {
    };
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Tp >
    inline void swap(_Tp & __a, _Tp & __b)
    {
        _Tp __tmp = (__a);
        __a = (__b);
        __b = (__tmp);
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<class _T1, class _T2 >
    struct pair
    {
            typedef _T1 first_type;
            typedef _T2 second_type;
            _T1 first;
            _T2 second;
            pair()
                : first(), second() 
            {
            }
            pair(const _T1 & __a, const _T2 & __b)
                : first(__a), second(__b) 
            {
            }
            template<class _U1, class _U2 >
            pair(const pair< _U1, _U2 > & __p)
                : first(__p.first), second(__p.second) 
            {
            }
    };
    template<class _T1, class _T2 >
    inline bool operator ==(const pair< _T1, _T2 > & __x, const pair< _T1, _T2 > & __y)
    {
        return __x.first == __y.first && __x.second == __y.second;
    }
    template<class _T1, class _T2 >
    inline bool operator <(const pair< _T1, _T2 > & __x, const pair< _T1, _T2 > & __y)
    {
        return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
    }
    template<class _T1, class _T2 >
    inline bool operator !=(const pair< _T1, _T2 > & __x, const pair< _T1, _T2 > & __y)
    {
        return !(__x == __y);
    }
    template<class _T1, class _T2 >
    inline bool operator >(const pair< _T1, _T2 > & __x, const pair< _T1, _T2 > & __y)
    {
        return __y < __x;
    }
    template<class _T1, class _T2 >
    inline bool operator <=(const pair< _T1, _T2 > & __x, const pair< _T1, _T2 > & __y)
    {
        return !(__y < __x);
    }
    template<class _T1, class _T2 >
    inline bool operator >=(const pair< _T1, _T2 > & __x, const pair< _T1, _T2 > & __y)
    {
        return !(__x < __y);
    }
    template<class _T1, class _T2 >
    inline pair< _T1, _T2 > make_pair(_T1 __x, _T2 __y)
    {
        return pair< _T1, _T2 >(__x, __y);
    }
}
namespace std __attribute__((__visibility__("default"))) {
    struct input_iterator_tag
    {
    };
    struct output_iterator_tag
    {
    };
    struct forward_iterator_tag : public input_iterator_tag
    {
    };
    struct bidirectional_iterator_tag : public forward_iterator_tag
    {
    };
    struct random_access_iterator_tag : public bidirectional_iterator_tag
    {
    };
    template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t, typename _Pointer = _Tp *, typename _Reference = _Tp & >
    struct iterator
    {
            typedef _Category iterator_category;
            typedef _Tp value_type;
            typedef _Distance difference_type;
            typedef _Pointer pointer;
            typedef _Reference reference;
    };
    template<typename _Iterator >
    struct iterator_traits
    {
            typedef typename _Iterator::iterator_category iterator_category;
            typedef typename _Iterator::value_type value_type;
            typedef typename _Iterator::difference_type difference_type;
            typedef typename _Iterator::pointer pointer;
            typedef typename _Iterator::reference reference;
    };
    template<typename _Tp >
    struct iterator_traits< _Tp * >
    {
            typedef random_access_iterator_tag iterator_category;
            typedef _Tp value_type;
            typedef ptrdiff_t difference_type;
            typedef _Tp * pointer;
            typedef _Tp & reference;
    };
    template<typename _Tp >
    struct iterator_traits< const _Tp * >
    {
            typedef random_access_iterator_tag iterator_category;
            typedef _Tp value_type;
            typedef ptrdiff_t difference_type;
            typedef const _Tp * pointer;
            typedef const _Tp & reference;
    };
    template<typename _Iter >
    inline typename iterator_traits< _Iter >::iterator_category __iterator_category(const _Iter &)
    {
        return typename iterator_traits< _Iter >::iterator_category();
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _InputIterator >
    inline typename iterator_traits< _InputIterator >::difference_type __distance(_InputIterator __first, _InputIterator __last, input_iterator_tag)
    {
        typename iterator_traits< _InputIterator >::difference_type __n = 0;
        while (__first != __last)
        {
            ++__first;
            ++__n;
        }
        return __n;
    }
    template<typename _RandomAccessIterator >
    inline typename iterator_traits< _RandomAccessIterator >::difference_type __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)
    {
        return __last - __first;
    }
    template<typename _InputIterator >
    inline typename iterator_traits< _InputIterator >::difference_type distance(_InputIterator __first, _InputIterator __last)
    {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<typename _InputIterator, typename _Distance >
    inline void __advance(_InputIterator & __i, _Distance __n, input_iterator_tag)
    {
        while (__n--)
            ++__i;
    }
    template<typename _BidirectionalIterator, typename _Distance >
    inline void __advance(_BidirectionalIterator & __i, _Distance __n, bidirectional_iterator_tag)
    {
        if (__n > 0)
            while (__n--)
                ++__i;
        else
            while (__n++)
                --__i;
    }
    template<typename _RandomAccessIterator, typename _Distance >
    inline void __advance(_RandomAccessIterator & __i, _Distance __n, random_access_iterator_tag)
    {
        __i += __n;
    }
    template<typename _InputIterator, typename _Distance >
    inline void advance(_InputIterator & __i, _Distance __n)
    {
        typename iterator_traits< _InputIterator >::difference_type __d = __n;
        std::__advance(__i, __d, std::__iterator_category(__i));
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Iterator >
    class reverse_iterator : public iterator< typename iterator_traits< _Iterator >::iterator_category, typename iterator_traits< _Iterator >::value_type, typename iterator_traits< _Iterator >::difference_type, typename iterator_traits< _Iterator >::pointer, typename iterator_traits< _Iterator >::reference >
    {
        protected :
            _Iterator current;
        public :
            typedef _Iterator iterator_type;
            typedef typename iterator_traits< _Iterator >::difference_type difference_type;
            typedef typename iterator_traits< _Iterator >::reference reference;
            typedef typename iterator_traits< _Iterator >::pointer pointer;
        public :
            reverse_iterator()
                : current() 
            {
            }
            explicit reverse_iterator(iterator_type __x)
                : current(__x) 
            {
            }
            reverse_iterator(const reverse_iterator & __x)
                : current(__x.current) 
            {
            }
            template<typename _Iter >
            reverse_iterator(const reverse_iterator< _Iter > & __x)
                : current(__x.base()) 
            {
            }
            iterator_type base() const
            {
                return current;
            }
            reference operator *() const
            {
                _Iterator __tmp = current;
                return *--__tmp;
            }
            pointer operator ->() const
            {
                return &(operator *());
            }
            reverse_iterator & operator ++()
            {
                --current;
                return *this;
            }
            reverse_iterator operator ++(int)
            {
                reverse_iterator __tmp = *this;
                --current;
                return __tmp;
            }
            reverse_iterator & operator --()
            {
                ++current;
                return *this;
            }
            reverse_iterator operator --(int)
            {
                reverse_iterator __tmp = *this;
                ++current;
                return __tmp;
            }
            reverse_iterator operator +(difference_type __n) const
            {
                return reverse_iterator(current - __n);
            }
            reverse_iterator & operator +=(difference_type __n)
            {
                current -= __n;
                return *this;
            }
            reverse_iterator operator -(difference_type __n) const
            {
                return reverse_iterator(current + __n);
            }
            reverse_iterator & operator -=(difference_type __n)
            {
                current += __n;
                return *this;
            }
            reference operator [](difference_type __n) const
            {
                return *(*this + __n);
            }
    };
    template<typename _Iterator >
    inline bool operator ==(const reverse_iterator< _Iterator > & __x, const reverse_iterator< _Iterator > & __y)
    {
        return __x.base() == __y.base();
    }
    template<typename _Iterator >
    inline bool operator <(const reverse_iterator< _Iterator > & __x, const reverse_iterator< _Iterator > & __y)
    {
        return __y.base() < __x.base();
    }
    template<typename _Iterator >
    inline bool operator !=(const reverse_iterator< _Iterator > & __x, const reverse_iterator< _Iterator > & __y)
    {
        return !(__x == __y);
    }
    template<typename _Iterator >
    inline bool operator >(const reverse_iterator< _Iterator > & __x, const reverse_iterator< _Iterator > & __y)
    {
        return __y < __x;
    }
    template<typename _Iterator >
    inline bool operator <=(const reverse_iterator< _Iterator > & __x, const reverse_iterator< _Iterator > & __y)
    {
        return !(__y < __x);
    }
    template<typename _Iterator >
    inline bool operator >=(const reverse_iterator< _Iterator > & __x, const reverse_iterator< _Iterator > & __y)
    {
        return !(__x < __y);
    }
    template<typename _Iterator >
    inline typename reverse_iterator< _Iterator >::difference_type operator -(const reverse_iterator< _Iterator > & __x, const reverse_iterator< _Iterator > & __y)
    {
        return __y.base() - __x.base();
    }
    template<typename _Iterator >
    inline reverse_iterator< _Iterator > operator +(typename reverse_iterator< _Iterator >::difference_type __n, const reverse_iterator< _Iterator > & __x)
    {
        return reverse_iterator< _Iterator >(__x.base() - __n);
    }
    template<typename _IteratorL, typename _IteratorR >
    inline bool operator ==(const reverse_iterator< _IteratorL > & __x, const reverse_iterator< _IteratorR > & __y)
    {
        return __x.base() == __y.base();
    }
    template<typename _IteratorL, typename _IteratorR >
    inline bool operator <(const reverse_iterator< _IteratorL > & __x, const reverse_iterator< _IteratorR > & __y)
    {
        return __y.base() < __x.base();
    }
    template<typename _IteratorL, typename _IteratorR >
    inline bool operator !=(const reverse_iterator< _IteratorL > & __x, const reverse_iterator< _IteratorR > & __y)
    {
        return !(__x == __y);
    }
    template<typename _IteratorL, typename _IteratorR >
    inline bool operator >(const reverse_iterator< _IteratorL > & __x, const reverse_iterator< _IteratorR > & __y)
    {
        return __y < __x;
    }
    template<typename _IteratorL, typename _IteratorR >
    inline bool operator <=(const reverse_iterator< _IteratorL > & __x, const reverse_iterator< _IteratorR > & __y)
    {
        return !(__y < __x);
    }
    template<typename _IteratorL, typename _IteratorR >
    inline bool operator >=(const reverse_iterator< _IteratorL > & __x, const reverse_iterator< _IteratorR > & __y)
    {
        return !(__x < __y);
    }
    template<typename _IteratorL, typename _IteratorR >
    inline typename reverse_iterator< _IteratorL >::difference_type operator -(const reverse_iterator< _IteratorL > & __x, const reverse_iterator< _IteratorR > & __y)
    {
        return __y.base() - __x.base();
    }
    template<typename _Container >
    class back_insert_iterator : public iterator< output_iterator_tag, void, void, void, void >
    {
        protected :
            _Container * container;
        public :
            typedef _Container container_type;
            explicit back_insert_iterator(_Container & __x)
                : container(&__x) 
            {
            }
            back_insert_iterator & operator =(typename _Container::const_reference __value)
            {
                container->push_back(__value);
                return *this;
            }
            back_insert_iterator & operator *()
            {
                return *this;
            }
            back_insert_iterator & operator ++()
            {
                return *this;
            }
            back_insert_iterator operator ++(int)
            {
                return *this;
            }
    };
    template<typename _Container >
    inline back_insert_iterator< _Container > back_inserter(_Container & __x)
    {
        return back_insert_iterator< _Container >(__x);
    }
    template<typename _Container >
    class front_insert_iterator : public iterator< output_iterator_tag, void, void, void, void >
    {
        protected :
            _Container * container;
        public :
            typedef _Container container_type;
            explicit front_insert_iterator(_Container & __x)
                : container(&__x) 
            {
            }
            front_insert_iterator & operator =(typename _Container::const_reference __value)
            {
                container->push_front(__value);
                return *this;
            }
            front_insert_iterator & operator *()
            {
                return *this;
            }
            front_insert_iterator & operator ++()
            {
                return *this;
            }
            front_insert_iterator operator ++(int)
            {
                return *this;
            }
    };
    template<typename _Container >
    inline front_insert_iterator< _Container > front_inserter(_Container & __x)
    {
        return front_insert_iterator< _Container >(__x);
    }
    template<typename _Container >
    class insert_iterator : public iterator< output_iterator_tag, void, void, void, void >
    {
        protected :
            _Container * container;
            typename _Container::iterator iter;
        public :
            typedef _Container container_type;
            insert_iterator(_Container & __x, typename _Container::iterator __i)
                : container(&__x), iter(__i) 
            {
            }
            insert_iterator & operator =(typename _Container::const_reference __value)
            {
                iter = container->insert(iter, __value);
                ++iter;
                return *this;
            }
            insert_iterator & operator *()
            {
                return *this;
            }
            insert_iterator & operator ++()
            {
                return *this;
            }
            insert_iterator & operator ++(int)
            {
                return *this;
            }
    };
    template<typename _Container, typename _Iterator >
    inline insert_iterator< _Container > inserter(_Container & __x, _Iterator __i)
    {
        return insert_iterator< _Container >(__x, typename _Container::iterator(__i));
    }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
    using std::iterator_traits;
    using std::iterator;
    template<typename _Iterator, typename _Container >
    class __normal_iterator
    {
        protected :
            _Iterator _M_current;
        public :
            typedef _Iterator iterator_type;
            typedef typename iterator_traits< _Iterator >::iterator_category iterator_category;
            typedef typename iterator_traits< _Iterator >::value_type value_type;
            typedef typename iterator_traits< _Iterator >::difference_type difference_type;
            typedef typename iterator_traits< _Iterator >::reference reference;
            typedef typename iterator_traits< _Iterator >::pointer pointer;
            __normal_iterator()
                : _M_current(_Iterator()) 
            {
            }
            explicit __normal_iterator(const _Iterator & __i)
                : _M_current(__i) 
            {
            }
            template<typename _Iter >
            __normal_iterator(const __normal_iterator< _Iter, typename __enable_if< (std::__are_same< _Iter, typename _Container::pointer >::__value), _Container >::__type > & __i)
                : _M_current(__i.base()) 
            {
            }
            reference operator *() const
            {
                return *_M_current;
            }
            pointer operator ->() const
            {
                return _M_current;
            }
            __normal_iterator & operator ++()
            {
                ++_M_current;
                return *this;
            }
            __normal_iterator operator ++(int)
            {
                return __normal_iterator(_M_current++);
            }
            __normal_iterator & operator --()
            {
                --_M_current;
                return *this;
            }
            __normal_iterator operator --(int)
            {
                return __normal_iterator(_M_current--);
            }
            reference operator [](const difference_type & __n) const
            {
                return _M_current[__n];
            }
            __normal_iterator & operator +=(const difference_type & __n)
            {
                _M_current += __n;
                return *this;
            }
            __normal_iterator operator +(const difference_type & __n) const
            {
                return __normal_iterator(_M_current + __n);
            }
            __normal_iterator & operator -=(const difference_type & __n)
            {
                _M_current -= __n;
                return *this;
            }
            __normal_iterator operator -(const difference_type & __n) const
            {
                return __normal_iterator(_M_current - __n);
            }
            const _Iterator & base() const
            {
                return _M_current;
            }
    };
    template<typename _IteratorL, typename _IteratorR, typename _Container >
    inline bool operator ==(const __normal_iterator< _IteratorL, _Container > & __lhs, const __normal_iterator< _IteratorR, _Container > & __rhs)
    {
        return __lhs.base() == __rhs.base();
    }
    template<typename _Iterator, typename _Container >
    inline bool operator ==(const __normal_iterator< _Iterator, _Container > & __lhs, const __normal_iterator< _Iterator, _Container > & __rhs)
    {
        return __lhs.base() == __rhs.base();
    }
    template<typename _IteratorL, typename _IteratorR, typename _Container >
    inline bool operator !=(const __normal_iterator< _IteratorL, _Container > & __lhs, const __normal_iterator< _IteratorR, _Container > & __rhs)
    {
        return __lhs.base() != __rhs.base();
    }
    template<typename _Iterator, typename _Container >
    inline bool operator !=(const __normal_iterator< _Iterator, _Container > & __lhs, const __normal_iterator< _Iterator, _Container > & __rhs)
    {
        return __lhs.base() != __rhs.base();
    }
    template<typename _IteratorL, typename _IteratorR, typename _Container >
    inline bool operator <(const __normal_iterator< _IteratorL, _Container > & __lhs, const __normal_iterator< _IteratorR, _Container > & __rhs)
    {
        return __lhs.base() < __rhs.base();
    }
    template<typename _Iterator, typename _Container >
    inline bool operator <(const __normal_iterator< _Iterator, _Container > & __lhs, const __normal_iterator< _Iterator, _Container > & __rhs)
    {
        return __lhs.base() < __rhs.base();
    }
    template<typename _IteratorL, typename _IteratorR, typename _Container >
    inline bool operator >(const __normal_iterator< _IteratorL, _Container > & __lhs, const __normal_iterator< _IteratorR, _Container > & __rhs)
    {
        return __lhs.base() > __rhs.base();
    }
    template<typename _Iterator, typename _Container >
    inline bool operator >(const __normal_iterator< _Iterator, _Container > & __lhs, const __normal_iterator< _Iterator, _Container > & __rhs)
    {
        return __lhs.base() > __rhs.base();
    }
    template<typename _IteratorL, typename _IteratorR, typename _Container >
    inline bool operator <=(const __normal_iterator< _IteratorL, _Container > & __lhs, const __normal_iterator< _IteratorR, _Container > & __rhs)
    {
        return __lhs.base() <= __rhs.base();
    }
    template<typename _Iterator, typename _Container >
    inline bool operator <=(const __normal_iterator< _Iterator, _Container > & __lhs, const __normal_iterator< _Iterator, _Container > & __rhs)
    {
        return __lhs.base() <= __rhs.base();
    }
    template<typename _IteratorL, typename _IteratorR, typename _Container >
    inline bool operator >=(const __normal_iterator< _IteratorL, _Container > & __lhs, const __normal_iterator< _IteratorR, _Container > & __rhs)
    {
        return __lhs.base() >= __rhs.base();
    }
    template<typename _Iterator, typename _Container >
    inline bool operator >=(const __normal_iterator< _Iterator, _Container > & __lhs, const __normal_iterator< _Iterator, _Container > & __rhs)
    {
        return __lhs.base() >= __rhs.base();
    }
    template<typename _IteratorL, typename _IteratorR, typename _Container >
    inline typename __normal_iterator< _IteratorL, _Container >::difference_type operator -(const __normal_iterator< _IteratorL, _Container > & __lhs, const __normal_iterator< _IteratorR, _Container > & __rhs)
    {
        return __lhs.base() - __rhs.base();
    }
    template<typename _Iterator, typename _Container >
    inline typename __normal_iterator< _Iterator, _Container >::difference_type operator -(const __normal_iterator< _Iterator, _Container > & __lhs, const __normal_iterator< _Iterator, _Container > & __rhs)
    {
        return __lhs.base() - __rhs.base();
    }
    template<typename _Iterator, typename _Container >
    inline __normal_iterator< _Iterator, _Container > operator +(typename __normal_iterator< _Iterator, _Container >::difference_type __n, const __normal_iterator< _Iterator, _Container > & __i)
    {
        return __normal_iterator< _Iterator, _Container >(__i.base() + __n);
    }
}
namespace std {
    namespace __debug {
    }
}
namespace __gnu_debug {
    using namespace std::__debug;
}
namespace std __attribute__((__visibility__("default"))) {
    template<bool _BoolType >
    struct __iter_swap
    {
            template<typename _ForwardIterator1, typename _ForwardIterator2 >
            static void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
            {
                typedef typename iterator_traits< _ForwardIterator1 >::value_type _ValueType1;
                _ValueType1 __tmp = (*__a);
                *__a = (*__b);
                *__b = (__tmp);
            }
    };
    template<>
    struct __iter_swap< true >
    {
            template<typename _ForwardIterator1, typename _ForwardIterator2 >
            static void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
            {
                swap(*__a, *__b);
            }
    };
    template<typename _ForwardIterator1, typename _ForwardIterator2 >
    inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
        typedef typename iterator_traits< _ForwardIterator1 >::value_type _ValueType1;
        typedef typename iterator_traits< _ForwardIterator2 >::value_type _ValueType2;
        typedef typename iterator_traits< _ForwardIterator1 >::reference _ReferenceType1;
        typedef typename iterator_traits< _ForwardIterator2 >::reference _ReferenceType2;
        std::__iter_swap< __are_same< _ValueType1, _ValueType2 >::__value && __are_same< _ValueType1 &, _ReferenceType1 >::__value && __are_same< _ValueType2 &, _ReferenceType2 >::__value >::iter_swap(__a, __b);
    }
    template<typename _ForwardIterator1, typename _ForwardIterator2 >
    _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
    {
        ;
        for (;
            __first1 != __last1;
            ++__first1 , ++__first2)
        std::iter_swap(__first1, __first2);
        return __first2;
    }
    template<typename _Tp >
    inline const _Tp & min(const _Tp & __a, const _Tp & __b)
    {
        if (__b < __a)
            return __b;
        return __a;
    }
    template<typename _Tp >
    inline const _Tp & max(const _Tp & __a, const _Tp & __b)
    {
        if (__a < __b)
            return __b;
        return __a;
    }
    template<typename _Tp, typename _Compare >
    inline const _Tp & min(const _Tp & __a, const _Tp & __b, _Compare __comp)
    {
        if (__comp(__b, __a))
            return __b;
        return __a;
    }
    template<typename _Tp, typename _Compare >
    inline const _Tp & max(const _Tp & __a, const _Tp & __b, _Compare __comp)
    {
        if (__comp(__a, __b))
            return __b;
        return __a;
    }
    template<typename _Iterator, bool _IsNormal = __is_normal_iterator< _Iterator >::__value >
    struct __niter_base
    {
            static _Iterator __b(_Iterator __it)
            {
                return __it;
            }
    };
    template<typename _Iterator >
    struct __niter_base< _Iterator, true >
    {
            static typename _Iterator::iterator_type __b(_Iterator __it)
            {
                return __it.base();
            }
    };
    template<typename _Iterator, bool _IsMove = __is_move_iterator< _Iterator >::__value >
    struct __miter_base
    {
            static _Iterator __b(_Iterator __it)
            {
                return __it;
            }
    };
    template<typename _Iterator >
    struct __miter_base< _Iterator, true >
    {
            static typename _Iterator::iterator_type __b(_Iterator __it)
            {
                return __it.base();
            }
    };
    template<bool, bool, typename  >
    struct __copy_move
    {
            template<typename _II, typename _OI >
            static _OI __copy_m(_II __first, _II __last, _OI __result)
            {
                for (;
                    __first != __last;
                    ++__result , ++__first)
                *__result = *__first;
                return __result;
            }
    };
    template<>
    struct __copy_move< false, false, random_access_iterator_tag >
    {
            template<typename _II, typename _OI >
            static _OI __copy_m(_II __first, _II __last, _OI __result)
            {
                typedef typename iterator_traits< _II >::difference_type _Distance;
                for (_Distance __n = __last - __first;
                    __n > 0;
                    --__n)
                {
                    *__result = *__first;
                    ++__first;
                    ++__result;
                }
                return __result;
            }
    };
    template<bool _IsMove >
    struct __copy_move< _IsMove, true, random_access_iterator_tag >
    {
            template<typename _Tp >
            static _Tp * __copy_m(const _Tp * __first, const _Tp * __last, _Tp * __result)
            {
                __builtin_memmove(__result, __first, sizeof(_Tp) * (__last - __first));
                return __result + (__last - __first);
            }
    };
    template<bool _IsMove, typename _II, typename _OI >
    inline _OI __copy_move_a(_II __first, _II __last, _OI __result)
    {
        typedef typename iterator_traits< _II >::value_type _ValueTypeI;
        typedef typename iterator_traits< _OI >::value_type _ValueTypeO;
        typedef typename iterator_traits< _II >::iterator_category _Category;
        const bool __simple = (__is_pod(_ValueTypeI) && __is_pointer< _II >::__value && __is_pointer< _OI >::__value && __are_same< _ValueTypeI, _ValueTypeO >::__value);
        return std::__copy_move< _IsMove, __simple, _Category >::__copy_m(__first, __last, __result);
    }
    template<typename _CharT >
    struct char_traits;
    template<typename _CharT, typename _Traits >
    class istreambuf_iterator;
    template<typename _CharT, typename _Traits >
    class ostreambuf_iterator;
    template<bool _IsMove, typename _CharT >
    typename __gnu_cxx::__enable_if< __is_char< _CharT >::__value, ostreambuf_iterator< _CharT, char_traits< _CharT > > >::__type __copy_move_a2(_CharT *, _CharT *, ostreambuf_iterator< _CharT, char_traits< _CharT > >);
    template<bool _IsMove, typename _CharT >
    typename __gnu_cxx::__enable_if< __is_char< _CharT >::__value, ostreambuf_iterator< _CharT, char_traits< _CharT > > >::__type __copy_move_a2(const _CharT *, const _CharT *, ostreambuf_iterator< _CharT, char_traits< _CharT > >);
    template<bool _IsMove, typename _CharT >
    typename __gnu_cxx::__enable_if< __is_char< _CharT >::__value, _CharT * >::__type __copy_move_a2(istreambuf_iterator< _CharT, char_traits< _CharT > >, istreambuf_iterator< _CharT, char_traits< _CharT > >, _CharT *);
    template<bool _IsMove, typename _II, typename _OI >
    inline _OI __copy_move_a2(_II __first, _II __last, _OI __result)
    {
        return _OI(std::__copy_move_a< _IsMove >(std::__niter_base< _II >::__b(__first), std::__niter_base< _II >::__b(__last), std::__niter_base< _OI >::__b(__result)));
    }
    template<typename _II, typename _OI >
    inline _OI copy(_II __first, _II __last, _OI __result)
    {
        ;
        return (std::__copy_move_a2< __is_move_iterator< _II >::__value >(std::__miter_base< _II >::__b(__first), std::__miter_base< _II >::__b(__last), __result));
    }
    template<bool, bool, typename  >
    struct __copy_move_backward
    {
            template<typename _BI1, typename _BI2 >
            static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
            {
                while (__first != __last)
                    *--__result = *--__last;
                return __result;
            }
    };
    template<>
    struct __copy_move_backward< false, false, random_access_iterator_tag >
    {
            template<typename _BI1, typename _BI2 >
            static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
            {
                typename iterator_traits< _BI1 >::difference_type __n;
                for (__n = __last - __first;
                    __n > 0;
                    --__n)
                *--__result = *--__last;
                return __result;
            }
    };
    template<bool _IsMove >
    struct __copy_move_backward< _IsMove, true, random_access_iterator_tag >
    {
            template<typename _Tp >
            static _Tp * __copy_move_b(const _Tp * __first, const _Tp * __last, _Tp * __result)
            {
                const ptrdiff_t _Num = __last - __first;
                __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
                return __result - _Num;
            }
    };
    template<bool _IsMove, typename _BI1, typename _BI2 >
    inline _BI2 __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
        typedef typename iterator_traits< _BI1 >::value_type _ValueType1;
        typedef typename iterator_traits< _BI2 >::value_type _ValueType2;
        typedef typename iterator_traits< _BI1 >::iterator_category _Category;
        const bool __simple = (__is_pod(_ValueType1) && __is_pointer< _BI1 >::__value && __is_pointer< _BI2 >::__value && __are_same< _ValueType1, _ValueType2 >::__value);
        return std::__copy_move_backward< _IsMove, __simple, _Category >::__copy_move_b(__first, __last, __result);
    }
    template<bool _IsMove, typename _BI1, typename _BI2 >
    inline _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
        return _BI2(std::__copy_move_backward_a< _IsMove >(std::__niter_base< _BI1 >::__b(__first), std::__niter_base< _BI1 >::__b(__last), std::__niter_base< _BI2 >::__b(__result)));
    }
    template<typename _BI1, typename _BI2 >
    inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {
        ;
        return (std::__copy_move_backward_a2< __is_move_iterator< _BI1 >::__value >(std::__miter_base< _BI1 >::__b(__first), std::__miter_base< _BI1 >::__b(__last), __result));
    }
    template<typename _ForwardIterator, typename _Tp >
    inline typename __gnu_cxx::__enable_if< !__is_scalar< _Tp >::__value, void >::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __value)
    {
        for (;
            __first != __last;
            ++__first)
        *__first = __value;
    }
    template<typename _ForwardIterator, typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_scalar< _Tp >::__value, void >::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __value)
    {
        const _Tp __tmp = __value;
        for (;
            __first != __last;
            ++__first)
        *__first = __tmp;
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_byte< _Tp >::__value, void >::__type __fill_a(_Tp * __first, _Tp * __last, const _Tp & __c)
    {
        const _Tp __tmp = __c;
        __builtin_memset(__first, static_cast<unsigned char >(__tmp), __last - __first);
    }
    template<typename _ForwardIterator, typename _Tp >
    inline void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __value)
    {
        ;
        std::__fill_a(std::__niter_base< _ForwardIterator >::__b(__first), std::__niter_base< _ForwardIterator >::__b(__last), __value);
    }
    template<typename _OutputIterator, typename _Size, typename _Tp >
    inline typename __gnu_cxx::__enable_if< !__is_scalar< _Tp >::__value, _OutputIterator >::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp & __value)
    {
        for (;
            __n > 0;
            --__n , ++__first)
        *__first = __value;
        return __first;
    }
    template<typename _OutputIterator, typename _Size, typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_scalar< _Tp >::__value, _OutputIterator >::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp & __value)
    {
        const _Tp __tmp = __value;
        for (;
            __n > 0;
            --__n , ++__first)
        *__first = __tmp;
        return __first;
    }
    template<typename _Size, typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_byte< _Tp >::__value, _Tp * >::__type __fill_n_a(_Tp * __first, _Size __n, const _Tp & __c)
    {
        std::__fill_a(__first, __first + __n, __c);
        return __first + __n;
    }
    template<typename _OI, typename _Size, typename _Tp >
    inline _OI fill_n(_OI __first, _Size __n, const _Tp & __value)
    {
        return _OI(std::__fill_n_a(std::__niter_base< _OI >::__b(__first), __n, __value));
    }
    template<bool _BoolType >
    struct __equal
    {
            template<typename _II1, typename _II2 >
            static bool equal(_II1 __first1, _II1 __last1, _II2 __first2)
            {
                for (;
                    __first1 != __last1;
                    ++__first1 , ++__first2)
                if (!(*__first1 == *__first2))
                    return false;
                return true;
            }
    };
    template<>
    struct __equal< true >
    {
            template<typename _Tp >
            static bool equal(const _Tp * __first1, const _Tp * __last1, const _Tp * __first2)
            {
                return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * (__last1 - __first1));
            }
    };
    template<typename _II1, typename _II2 >
    inline bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
        typedef typename iterator_traits< _II1 >::value_type _ValueType1;
        typedef typename iterator_traits< _II2 >::value_type _ValueType2;
        const bool __simple = (__is_integer< _ValueType1 >::__value && __is_pointer< _II1 >::__value && __is_pointer< _II2 >::__value && __are_same< _ValueType1, _ValueType2 >::__value);
        return std::__equal< __simple >::equal(__first1, __last1, __first2);
    }
    template<typename , typename  >
    struct __lc_rai
    {
            template<typename _II1, typename _II2 >
            static _II1 __newlast1(_II1, _II1 __last1, _II2, _II2)
            {
                return __last1;
            }
            template<typename _II >
            static bool __cnd2(_II __first, _II __last)
            {
                return __first != __last;
            }
    };
    template<>
    struct __lc_rai< random_access_iterator_tag, random_access_iterator_tag >
    {
            template<typename _RAI1, typename _RAI2 >
            static _RAI1 __newlast1(_RAI1 __first1, _RAI1 __last1, _RAI2 __first2, _RAI2 __last2)
            {
                const typename iterator_traits< _RAI1 >::difference_type __diff1 = __last1 - __first1;
                const typename iterator_traits< _RAI2 >::difference_type __diff2 = __last2 - __first2;
                return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
            }
            template<typename _RAI >
            static bool __cnd2(_RAI, _RAI)
            {
                return true;
            }
    };
    template<bool _BoolType >
    struct __lexicographical_compare
    {
            template<typename _II1, typename _II2 >
            static bool __lc(_II1, _II1, _II2, _II2);
    };
    template<bool _BoolType >
    template<typename _II1, typename _II2 >
    bool __lexicographical_compare< _BoolType >::__lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
        typedef typename iterator_traits< _II1 >::iterator_category _Category1;
        typedef typename iterator_traits< _II2 >::iterator_category _Category2;
        typedef std::__lc_rai< _Category1, _Category2 > __rai_type;
        __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
        for (;
            __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
            ++__first1 , ++__first2)
        {
            if (*__first1 < *__first2)
                return true;
            if (*__first2 < *__first1)
                return false;
        }
        return __first1 == __last1 && __first2 != __last2;
    }
    template<>
    struct __lexicographical_compare< true >
    {
            template<typename _Tp, typename _Up >
            static bool __lc(const _Tp * __first1, const _Tp * __last1, const _Up * __first2, const _Up * __last2)
            {
                const size_t __len1 = __last1 - __first1;
                const size_t __len2 = __last2 - __first2;
                const int __result = __builtin_memcmp(__first1, __first2, std::min(__len1, __len2));
                return __result != 0 ? __result < 0 : __len1 < __len2;
            }
    };
    template<typename _II1, typename _II2 >
    inline bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
        typedef typename iterator_traits< _II1 >::value_type _ValueType1;
        typedef typename iterator_traits< _II2 >::value_type _ValueType2;
        const bool __simple = (__is_byte< _ValueType1 >::__value && __is_byte< _ValueType2 >::__value && !__gnu_cxx::__numeric_traits< _ValueType1 >::__is_signed && !__gnu_cxx::__numeric_traits< _ValueType2 >::__is_signed && __is_pointer< _II1 >::__value && __is_pointer< _II2 >::__value);
        return std::__lexicographical_compare< __simple >::__lc(__first1, __last1, __first2, __last2);
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _II1, typename _II2 >
    inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {
        ;
        return std::__equal_aux(std::__niter_base< _II1 >::__b(__first1), std::__niter_base< _II1 >::__b(__last1), std::__niter_base< _II2 >::__b(__first2));
    }
    template<typename _IIter1, typename _IIter2, typename _BinaryPredicate >
    inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred)
    {
        ;
        for (;
            __first1 != __last1;
            ++__first1 , ++__first2)
        if (!bool(__binary_pred(*__first1, *__first2)))
            return false;
        return true;
    }
    template<typename _II1, typename _II2 >
    inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
        typedef typename iterator_traits< _II1 >::value_type _ValueType1;
        typedef typename iterator_traits< _II2 >::value_type _ValueType2;
        ;
        ;
        return std::__lexicographical_compare_aux(std::__niter_base< _II1 >::__b(__first1), std::__niter_base< _II1 >::__b(__last1), std::__niter_base< _II2 >::__b(__first2), std::__niter_base< _II2 >::__b(__last2));
    }
    template<typename _II1, typename _II2, typename _Compare >
    bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)
    {
        typedef typename iterator_traits< _II1 >::iterator_category _Category1;
        typedef typename iterator_traits< _II2 >::iterator_category _Category2;
        typedef std::__lc_rai< _Category1, _Category2 > __rai_type;
        ;
        ;
        __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
        for (;
            __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
            ++__first1 , ++__first2)
        {
            if (__comp(*__first1, *__first2))
                return true;
            if (__comp(*__first2, *__first1))
                return false;
        }
        return __first1 == __last1 && __first2 != __last2;
    }
    template<typename _InputIterator1, typename _InputIterator2 >
    pair< _InputIterator1, _InputIterator2 > mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
    {
        ;
        while (__first1 != __last1 && *__first1 == *__first2)
        {
            ++__first1;
            ++__first2;
        }
        return pair< _InputIterator1, _InputIterator2 >(__first1, __first2);
    }
    template<typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate >
    pair< _InputIterator1, _InputIterator2 > mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
        ;
        while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
            ++__first1;
            ++__first2;
        }
        return pair< _InputIterator1, _InputIterator2 >(__first1, __first2);
    }
}
extern "C"
{
    union wait
    {
            int w_status;
            struct 
            {
                    unsigned int __w_termsig : 7;
                    unsigned int __w_coredump : 1;
                    unsigned int __w_retcode : 8;
                    unsigned int : 16;
            } __wait_terminated;
            struct 
            {
                    unsigned int __w_stopval : 8;
                    unsigned int __w_stopsig : 8;
                    unsigned int : 16;
            } __wait_stopped;
    };
    typedef struct 
    {
            int quot;
            int rem;
    } div_t;
    typedef struct 
    {
            long int quot;
            long int rem;
    } ldiv_t;
    __extension__
    typedef struct 
    {
            long long int quot;
            long long int rem;
    } lldiv_t;
    extern size_t __ctype_get_mb_cur_max(void) throw ();
    extern double atof(__const char * __nptr) throw () __attribute__((__pure__)) __attribute__((__nonnull__(1)));
    extern int atoi(__const char * __nptr) throw () __attribute__((__pure__)) __attribute__((__nonnull__(1)));
    extern long int atol(__const char * __nptr) throw () __attribute__((__pure__)) __attribute__((__nonnull__(1)));
    __extension__
    extern long long int atoll(__const char * __nptr) throw () __attribute__((__pure__)) __attribute__((__nonnull__(1)));
    extern double strtod(__const char *__restrict __nptr, char * *__restrict __endptr) throw () __attribute__((__nonnull__(1)));
    extern float strtof(__const char *__restrict __nptr, char * *__restrict __endptr) throw () __attribute__((__nonnull__(1)));
    extern long double strtold(__const char *__restrict __nptr, char * *__restrict __endptr) throw () __attribute__((__nonnull__(1)));
    extern long int strtol(__const char *__restrict __nptr, char * *__restrict __endptr, int __base) throw () __attribute__((__nonnull__(1)));
    extern unsigned long int strtoul(__const char *__restrict __nptr, char * *__restrict __endptr, int __base) throw () __attribute__((__nonnull__(1)));
    __extension__
    extern long long int strtoq(__const char *__restrict __nptr, char * *__restrict __endptr, int __base) throw () __attribute__((__nonnull__(1)));
    __extension__
    extern unsigned long long int strtouq(__const char *__restrict __nptr, char * *__restrict __endptr, int __base) throw () __attribute__((__nonnull__(1)));
    __extension__
    extern long long int strtoll(__const char *__restrict __nptr, char * *__restrict __endptr, int __base) throw () __attribute__((__nonnull__(1)));
    __extension__
    extern unsigned long long int strtoull(__const char *__restrict __nptr, char * *__restrict __endptr, int __base) throw () __attribute__((__nonnull__(1)));
    typedef struct __locale_struct
    {
            struct locale_data * __locales[13];
            const unsigned short int * __ctype_b;
            const int * __ctype_tolower;
            const int * __ctype_toupper;
            const char * __names[13];
    } * __locale_t;
    extern long int strtol_l(__const char *__restrict __nptr, char * *__restrict __endptr, int __base, __locale_t __loc) throw () __attribute__((__nonnull__(1, 4)));
    extern unsigned long int strtoul_l(__const char *__restrict __nptr, char * *__restrict __endptr, int __base, __locale_t __loc) throw () __attribute__((__nonnull__(1, 4)));
    __extension__
    extern long long int strtoll_l(__const char *__restrict __nptr, char * *__restrict __endptr, int __base, __locale_t __loc) throw () __attribute__((__nonnull__(1, 4)));
    __extension__
    extern unsigned long long int strtoull_l(__const char *__restrict __nptr, char * *__restrict __endptr, int __base, __locale_t __loc) throw () __attribute__((__nonnull__(1, 4)));
    extern double strtod_l(__const char *__restrict __nptr, char * *__restrict __endptr, __locale_t __loc) throw () __attribute__((__nonnull__(1, 3)));
    extern float strtof_l(__const char *__restrict __nptr, char * *__restrict __endptr, __locale_t __loc) throw () __attribute__((__nonnull__(1, 3)));
    extern long double strtold_l(__const char *__restrict __nptr, char * *__restrict __endptr, __locale_t __loc) throw () __attribute__((__nonnull__(1, 3)));
    extern char * l64a(long int __n) throw ();
    extern long int a64l(__const char * __s) throw () __attribute__((__pure__)) __attribute__((__nonnull__(1)));
    extern "C"
    {
        typedef unsigned char __u_char;
        typedef unsigned short int __u_short;
        typedef unsigned int __u_int;
        typedef unsigned long int __u_long;
        typedef signed char __int8_t;
        typedef unsigned char __uint8_t;
        typedef signed short int __int16_t;
        typedef unsigned short int __uint16_t;
        typedef signed int __int32_t;
        typedef unsigned int __uint32_t;
        typedef signed long int __int64_t;
        typedef unsigned long int __uint64_t;
        typedef long int __quad_t;
        typedef unsigned long int __u_quad_t;
        typedef unsigned long int __dev_t;
        typedef unsigned int __uid_t;
        typedef unsigned int __gid_t;
        typedef unsigned long int __ino_t;
        typedef unsigned long int __ino64_t;
        typedef unsigned int __mode_t;
        typedef unsigned long int __nlink_t;
        typedef long int __off_t;
        typedef long int __off64_t;
        typedef int __pid_t;
        typedef struct 
        {
                int __val[2];
        } __fsid_t;
        typedef long int __clock_t;
        typedef unsigned long int __rlim_t;
        typedef unsigned long int __rlim64_t;
        typedef unsigned int __id_t;
        typedef long int __time_t;
        typedef unsigned int __useconds_t;
        typedef long int __suseconds_t;
        typedef int __daddr_t;
        typedef long int __swblk_t;
        typedef int __key_t;
        typedef int __clockid_t;
        typedef void * __timer_t;
        typedef long int __blksize_t;
        typedef long int __blkcnt_t;
        typedef long int __blkcnt64_t;
        typedef unsigned long int __fsblkcnt_t;
        typedef unsigned long int __fsblkcnt64_t;
        typedef unsigned long int __fsfilcnt_t;
        typedef unsigned long int __fsfilcnt64_t;
        typedef long int __ssize_t;
        typedef __off64_t __loff_t;
        typedef __quad_t * __qaddr_t;
        typedef char * __caddr_t;
        typedef long int __intptr_t;
        typedef unsigned int __socklen_t;
        typedef __u_char u_char;
        typedef __u_short u_short;
        typedef __u_int u_int;
        typedef __u_long u_long;
        typedef __quad_t quad_t;
        typedef __u_quad_t u_quad_t;
        typedef __fsid_t fsid_t;
        typedef __loff_t loff_t;
        typedef __ino_t ino_t;
        typedef __ino64_t ino64_t;
        typedef __dev_t dev_t;
        typedef __gid_t gid_t;
        typedef __mode_t mode_t;
        typedef __nlink_t nlink_t;
        typedef __uid_t uid_t;
        typedef __off_t off_t;
        typedef __off64_t off64_t;
        typedef __pid_t pid_t;
        typedef __id_t id_t;
        typedef __ssize_t ssize_t;
        typedef __daddr_t daddr_t;
        typedef __caddr_t caddr_t;
        typedef __key_t key_t;
        typedef __clock_t clock_t;
        typedef __time_t time_t;
        typedef __clockid_t clockid_t;
        typedef __timer_t timer_t;
        typedef __useconds_t useconds_t;
        typedef __suseconds_t suseconds_t;
        typedef unsigned long int ulong;
        typedef unsigned short int ushort;
        typedef unsigned int uint;
        typedef int int8_t __attribute__((__mode__(__QI__)));
        typedef int int16_t __attribute__((__mode__(__HI__)));
        typedef int int32_t __attribute__((__mode__(__SI__)));
        typedef int int64_t __attribute__((__mode__(__DI__)));
        typedef unsigned int u_int8_t __attribute__((__mode__(__QI__)));
        typedef unsigned int u_int16_t __attribute__((__mode__(__HI__)));
        typedef unsigned int u_int32_t __attribute__((__mode__(__SI__)));
        typedef unsigned int u_int64_t __attribute__((__mode__(__DI__)));
        typedef int register_t __attribute__((__mode__(__word__)));
        typedef int __sig_atomic_t;
        typedef struct 
        {
                unsigned long int __val[(1024 / (8 * sizeof(unsigned long int)))];
        } __sigset_t;
        typedef __sigset_t sigset_t;
        struct timespec
        {
                __time_t tv_sec;
                long int tv_nsec;
        };
        struct timeval
        {
                __time_t tv_sec;
                __suseconds_t tv_usec;
        };
        typedef long int __fd_mask;
        typedef struct 
        {
                __fd_mask fds_bits[1024 / (8 * sizeof(__fd_mask))];
        } fd_set;
        typedef __fd_mask fd_mask;
        extern "C"
        {
            extern int select(int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, struct timeval *__restrict __timeout);
            extern int pselect(int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, const struct timespec *__restrict __timeout, const __sigset_t *__restrict __sigmask);
        }
        __extension__
        extern unsigned int gnu_dev_major(unsigned long long int __dev) throw ();
        __extension__
        extern unsigned int gnu_dev_minor(unsigned long long int __dev) throw ();
        __extension__
        extern unsigned long long int gnu_dev_makedev(unsigned int __major, unsigned int __minor) throw ();
        typedef __blksize_t blksize_t;
        typedef __blkcnt_t blkcnt_t;
        typedef __fsblkcnt_t fsblkcnt_t;
        typedef __fsfilcnt_t fsfilcnt_t;
        typedef __blkcnt64_t blkcnt64_t;
        typedef __fsblkcnt64_t fsblkcnt64_t;
        typedef __fsfilcnt64_t fsfilcnt64_t;
        typedef unsigned long int pthread_t;
        typedef union 
        {
                char __size[56];
                long int __align;
        } pthread_attr_t;
        typedef struct __pthread_internal_list
        {
                struct __pthread_internal_list * __prev;
                struct __pthread_internal_list * __next;
        } __pthread_list_t;
        typedef union 
        {
                struct __pthread_mutex_s
                {
                        int __lock;
                        unsigned int __count;
                        int __owner;
                        unsigned int __nusers;
                        int __kind;
                        int __spins;
                        __pthread_list_t __list;
                } __data;
                char __size[40];
                long int __align;
        } pthread_mutex_t;
        typedef union 
        {
                char __size[4];
                int __align;
        } pthread_mutexattr_t;
        typedef union 
        {
                struct 
                {
                        int __lock;
                        unsigned int __futex;
                        __extension__
                        unsigned long long int __total_seq;
                        __extension__
                        unsigned long long int __wakeup_seq;
                        __extension__
                        unsigned long long int __woken_seq;
                        void * __mutex;
                        unsigned int __nwaiters;
                        unsigned int __broadcast_seq;
                } __data;
                char __size[48];
                __extension__
                long long int __align;
        } pthread_cond_t;
        typedef union 
        {
                char __size[4];
                int __align;
        } pthread_condattr_t;
        typedef unsigned int pthread_key_t;
        typedef int pthread_once_t;
        typedef union 
        {
                struct 
                {
                        int __lock;
                        unsigned int __nr_readers;
                        unsigned int __readers_wakeup;
                        unsigned int __writer_wakeup;
                        unsigned int __nr_readers_queued;
                        unsigned int __nr_writers_queued;
                        int __writer;
                        int __shared;
                        unsigned long int __pad1;
                        unsigned long int __pad2;
                        unsigned int __flags;
                } __data;
                char __size[56];
                long int __align;
        } pthread_rwlock_t;
        typedef union 
        {
                char __size[8];
                long int __align;
        } pthread_rwlockattr_t;
        typedef volatile int pthread_spinlock_t;
        typedef union 
        {
                char __size[32];
                long int __align;
        } pthread_barrier_t;
        typedef union 
        {
                char __size[4];
                int __align;
        } pthread_barrierattr_t;
    }
    extern long int random(void) throw ();
    extern void srandom(unsigned int __seed) throw ();
    extern char * initstate(unsigned int __seed, char * __statebuf, size_t __statelen) throw () __attribute__((__nonnull__(2)));
    extern char * setstate(char * __statebuf) throw () __attribute__((__nonnull__(1)));
    struct random_data
    {
            int32_t * fptr;
            int32_t * rptr;
            int32_t * state;
            int rand_type;
            int rand_deg;
            int rand_sep;
            int32_t * end_ptr;
    };
    extern int random_r(struct random_data *__restrict __buf, int32_t *__restrict __result) throw () __attribute__((__nonnull__(1, 2)));
    extern int srandom_r(unsigned int __seed, struct random_data * __buf) throw () __attribute__((__nonnull__(2)));
    extern int initstate_r(unsigned int __seed, char *__restrict __statebuf, size_t __statelen, struct random_data *__restrict __buf) throw () __attribute__((__nonnull__(2, 4)));
    extern int setstate_r(char *__restrict __statebuf, struct random_data *__restrict __buf) throw () __attribute__((__nonnull__(1, 2)));
    extern int rand(void) throw ();
    extern void srand(unsigned int __seed) throw ();
    extern int rand_r(unsigned int * __seed) throw ();
    extern double drand48(void) throw ();
    extern double erand48(unsigned short int __xsubi[3]) throw () __attribute__((__nonnull__(1)));
    extern long int lrand48(void) throw ();
    extern long int nrand48(unsigned short int __xsubi[3]) throw () __attribute__((__nonnull__(1)));
    extern long int mrand48(void) throw ();
    extern long int jrand48(unsigned short int __xsubi[3]) throw () __attribute__((__nonnull__(1)));
    extern void srand48(long int __seedval) throw ();
    extern unsigned short int * seed48(unsigned short int __seed16v[3]) throw () __attribute__((__nonnull__(1)));
    extern void lcong48(unsigned short int __param[7]) throw () __attribute__((__nonnull__(1)));
    struct drand48_data
    {
            unsigned short int __x[3];
            unsigned short int __old_x[3];
            unsigned short int __c;
            unsigned short int __init;
            unsigned long long int __a;
    };
    extern int drand48_r(struct drand48_data *__restrict __buffer, double *__restrict __result) throw () __attribute__((__nonnull__(1, 2)));
    extern int erand48_r(unsigned short int __xsubi[3], struct drand48_data *__restrict __buffer, double *__restrict __result) throw () __attribute__((__nonnull__(1, 2)));
    extern int lrand48_r(struct drand48_data *__restrict __buffer, long int *__restrict __result) throw () __attribute__((__nonnull__(1, 2)));
    extern int nrand48_r(unsigned short int __xsubi[3], struct drand48_data *__restrict __buffer, long int *__restrict __result) throw () __attribute__((__nonnull__(1, 2)));
    extern int mrand48_r(struct drand48_data *__restrict __buffer, long int *__restrict __result) throw () __attribute__((__nonnull__(1, 2)));
    extern int jrand48_r(unsigned short int __xsubi[3], struct drand48_data *__restrict __buffer, long int *__restrict __result) throw () __attribute__((__nonnull__(1, 2)));
    extern int srand48_r(long int __seedval, struct drand48_data * __buffer) throw () __attribute__((__nonnull__(2)));
    extern int seed48_r(unsigned short int __seed16v[3], struct drand48_data * __buffer) throw () __attribute__((__nonnull__(1, 2)));
    extern int lcong48_r(unsigned short int __param[7], struct drand48_data * __buffer) throw () __attribute__((__nonnull__(1, 2)));
    extern void * malloc(size_t __size) throw () __attribute__((__malloc__));
    extern void * calloc(size_t __nmemb, size_t __size) throw () __attribute__((__malloc__));
    extern void * realloc(void * __ptr, size_t __size) throw () __attribute__((__warn_unused_result__));
    extern void free(void * __ptr) throw ();
    extern void cfree(void * __ptr) throw ();
    extern "C"
    {
        extern void * alloca(size_t __size) throw ();
    }
    extern void * valloc(size_t __size) throw () __attribute__((__malloc__));
    extern int posix_memalign(void * * __memptr, size_t __alignment, size_t __size) throw () __attribute__((__nonnull__(1)));
    extern void abort(void) throw () __attribute__((__noreturn__));
    extern int atexit(void (* __func)(void)) throw () __attribute__((__nonnull__(1)));
    extern int on_exit(void (* __func)(int __status, void * __arg), void * __arg) throw () __attribute__((__nonnull__(1)));
    extern void exit(int __status) throw () __attribute__((__noreturn__));
    extern void _Exit(int __status) throw () __attribute__((__noreturn__));
    extern char * getenv(__const char * __name) throw () __attribute__((__nonnull__(1)));
    extern char * __secure_getenv(__const char * __name) throw () __attribute__((__nonnull__(1)));
    extern int putenv(char * __string) throw () __attribute__((__nonnull__(1)));
    extern int setenv(__const char * __name, __const char * __value, int __replace) throw () __attribute__((__nonnull__(2)));
    extern int unsetenv(__const char * __name) throw ();
    extern int clearenv(void) throw ();
    extern char * mktemp(char * __template) throw () __attribute__((__nonnull__(1)));
    extern int mkstemp(char * __template) __attribute__((__nonnull__(1)));
    extern int mkstemp64(char * __template) __attribute__((__nonnull__(1)));
    extern char * mkdtemp(char * __template) throw () __attribute__((__nonnull__(1)));
    extern int mkostemp(char * __template, int __flags) __attribute__((__nonnull__(1)));
    extern int mkostemp64(char * __template, int __flags) __attribute__((__nonnull__(1)));
    extern int system(__const char * __command);
    extern char * canonicalize_file_name(__const char * __name) throw () __attribute__((__nonnull__(1)));
    extern char * realpath(__const char *__restrict __name, char *__restrict __resolved) throw ();
    typedef int (* __compar_fn_t)(__const void *, __const void *);
    typedef __compar_fn_t comparison_fn_t;
    extern void * bsearch(__const void * __key, __const void * __base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__((__nonnull__(1, 2, 5)));
    extern void qsort(void * __base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__((__nonnull__(1, 4)));
    extern int abs(int __x) throw () __attribute__((__const__));
    extern long int labs(long int __x) throw () __attribute__((__const__));
    __extension__
    extern long long int llabs(long long int __x) throw () __attribute__((__const__));
    extern div_t div(int __numer, int __denom) throw () __attribute__((__const__));
    extern ldiv_t ldiv(long int __numer, long int __denom) throw () __attribute__((__const__));
    __extension__
    extern lldiv_t lldiv(long long int __numer, long long int __denom) throw () __attribute__((__const__));
    extern char * ecvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw () __attribute__((__nonnull__(3, 4)));
    extern char * fcvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw () __attribute__((__nonnull__(3, 4)));
    extern char * gcvt(double __value, int __ndigit, char * __buf) throw () __attribute__((__nonnull__(3)));
    extern char * qecvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw () __attribute__((__nonnull__(3, 4)));
    extern char * qfcvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw () __attribute__((__nonnull__(3, 4)));
    extern char * qgcvt(long double __value, int __ndigit, char * __buf) throw () __attribute__((__nonnull__(3)));
    extern int ecvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw () __attribute__((__nonnull__(3, 4, 5)));
    extern int fcvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw () __attribute__((__nonnull__(3, 4, 5)));
    extern int qecvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw () __attribute__((__nonnull__(3, 4, 5)));
    extern int qfcvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw () __attribute__((__nonnull__(3, 4, 5)));
    extern int mblen(__const char * __s, size_t __n) throw ();
    extern int mbtowc(wchar_t *__restrict __pwc, __const char *__restrict __s, size_t __n) throw ();
    extern int wctomb(char * __s, wchar_t __wchar) throw ();
    extern size_t mbstowcs(wchar_t *__restrict __pwcs, __const char *__restrict __s, size_t __n) throw ();
    extern size_t wcstombs(char *__restrict __s, __const wchar_t *__restrict __pwcs, size_t __n) throw ();
    extern int rpmatch(__const char * __response) throw () __attribute__((__nonnull__(1)));
    extern int getsubopt(char * *__restrict __optionp, char *__const *__restrict __tokens, char * *__restrict __valuep) throw () __attribute__((__nonnull__(1, 2, 3)));
    extern void setkey(__const char * __key) throw () __attribute__((__nonnull__(1)));
    extern int posix_openpt(int __oflag);
    extern int grantpt(int __fd) throw ();
    extern int unlockpt(int __fd) throw ();
    extern char * ptsname(int __fd) throw ();
    extern int ptsname_r(int __fd, char * __buf, size_t __buflen) throw () __attribute__((__nonnull__(2)));
    extern int getpt(void);
    extern int getloadavg(double __loadavg[], int __nelem) throw () __attribute__((__nonnull__(1)));
}
namespace std __attribute__((__visibility__("default"))) {
    using ::div_t;
    using ::ldiv_t;
    using ::abort;
    using ::abs;
    using ::atexit;
    using ::atof;
    using ::atoi;
    using ::atol;
    using ::bsearch;
    using ::calloc;
    using ::div;
    using ::exit;
    using ::free;
    using ::getenv;
    using ::labs;
    using ::ldiv;
    using ::malloc;
    using ::mblen;
    using ::mbstowcs;
    using ::mbtowc;
    using ::qsort;
    using ::rand;
    using ::realloc;
    using ::srand;
    using ::strtod;
    using ::strtol;
    using ::strtoul;
    using ::system;
    using ::wcstombs;
    using ::wctomb;
    inline long abs(long __i)
    {
        return labs(__i);
    }
    inline ldiv_t div(long __i, long __j)
    {
        return ldiv(__i, __j);
    }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
    using ::lldiv_t;
    using ::_Exit;
    inline long long abs(long long __x)
    {
        return __x >= 0 ? __x : -__x;
    }
    using ::llabs;
    inline lldiv_t div(long long __n, long long __d)
    {
        lldiv_t __q;
        __q.quot = __n / __d;
        __q.rem = __n % __d;
        return __q;
    }
    using ::lldiv;
    using ::atoll;
    using ::strtoll;
    using ::strtoull;
    using ::strtof;
    using ::strtold;
}
namespace std __attribute__((__visibility__("default"))) {
    using ::__gnu_cxx::lldiv_t;
    using ::__gnu_cxx::_Exit;
    using ::__gnu_cxx::abs;
    using ::__gnu_cxx::llabs;
    using ::__gnu_cxx::div;
    using ::__gnu_cxx::lldiv;
    using ::__gnu_cxx::atoll;
    using ::__gnu_cxx::strtof;
    using ::__gnu_cxx::strtoll;
    using ::__gnu_cxx::strtoull;
    using ::__gnu_cxx::strtold;
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _FIter, typename _Tp >
    bool binary_search(_FIter, _FIter, const _Tp &);
    template<typename _FIter, typename _Tp, typename _Compare >
    bool binary_search(_FIter, _FIter, const _Tp &, _Compare);
    template<typename _IIter, typename _OIter >
    _OIter copy(_IIter, _IIter, _OIter);
    template<typename _BIter1, typename _BIter2 >
    _BIter2 copy_backward(_BIter1, _BIter1, _BIter2);
    template<typename _FIter, typename _Tp >
    pair< _FIter, _FIter > equal_range(_FIter, _FIter, const _Tp &);
    template<typename _FIter, typename _Tp, typename _Compare >
    pair< _FIter, _FIter > equal_range(_FIter, _FIter, const _Tp &, _Compare);
    template<typename _FIter, typename _Tp >
    void fill(_FIter, _FIter, const _Tp &);
    template<typename _OIter, typename _Size, typename _Tp >
    _OIter fill_n(_OIter, _Size, const _Tp &);
    template<typename _FIter1, typename _FIter2 >
    _FIter1 find_end(_FIter1, _FIter1, _FIter2, _FIter2);
    template<typename _FIter1, typename _FIter2, typename _BinaryPredicate >
    _FIter1 find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);
    template<typename _IIter1, typename _IIter2 >
    bool includes(_IIter1, _IIter1, _IIter2, _IIter2);
    template<typename _IIter1, typename _IIter2, typename _Compare >
    bool includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);
    template<typename _BIter >
    void inplace_merge(_BIter, _BIter, _BIter);
    template<typename _BIter, typename _Compare >
    void inplace_merge(_BIter, _BIter, _BIter, _Compare);
    template<typename _FIter1, typename _FIter2 >
    void iter_swap(_FIter1, _FIter2);
    template<typename _FIter, typename _Tp >
    _FIter lower_bound(_FIter, _FIter, const _Tp &);
    template<typename _FIter, typename _Tp, typename _Compare >
    _FIter lower_bound(_FIter, _FIter, const _Tp &, _Compare);
    template<typename _RAIter >
    void make_heap(_RAIter, _RAIter);
    template<typename _RAIter, typename _Compare >
    void make_heap(_RAIter, _RAIter, _Compare);
    template<typename _Tp >
    const _Tp & max(const _Tp &, const _Tp &);
    template<typename _Tp, typename _Compare >
    const _Tp & max(const _Tp &, const _Tp &, _Compare);
    template<typename _Tp >
    const _Tp & min(const _Tp &, const _Tp &);
    template<typename _Tp, typename _Compare >
    const _Tp & min(const _Tp &, const _Tp &, _Compare);
    template<typename _BIter >
    bool next_permutation(_BIter, _BIter);
    template<typename _BIter, typename _Compare >
    bool next_permutation(_BIter, _BIter, _Compare);
    template<typename _IIter, typename _RAIter >
    _RAIter partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);
    template<typename _IIter, typename _RAIter, typename _Compare >
    _RAIter partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);
    template<typename _RAIter >
    void pop_heap(_RAIter, _RAIter);
    template<typename _RAIter, typename _Compare >
    void pop_heap(_RAIter, _RAIter, _Compare);
    template<typename _BIter >
    bool prev_permutation(_BIter, _BIter);
    template<typename _BIter, typename _Compare >
    bool prev_permutation(_BIter, _BIter, _Compare);
    template<typename _RAIter >
    void push_heap(_RAIter, _RAIter);
    template<typename _RAIter, typename _Compare >
    void push_heap(_RAIter, _RAIter, _Compare);
    template<typename _FIter, typename _Tp >
    _FIter remove(_FIter, _FIter, const _Tp &);
    template<typename _FIter, typename _Predicate >
    _FIter remove_if(_FIter, _FIter, _Predicate);
    template<typename _IIter, typename _OIter, typename _Tp >
    _OIter remove_copy(_IIter, _IIter, _OIter, const _Tp &);
    template<typename _IIter, typename _OIter, typename _Predicate >
    _OIter remove_copy_if(_IIter, _IIter, _OIter, _Predicate);
    template<typename _IIter, typename _OIter, typename _Tp >
    _OIter replace_copy(_IIter, _IIter, _OIter, const _Tp &, const _Tp &);
    template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp >
    _OIter replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp &);
    template<typename _BIter >
    void reverse(_BIter, _BIter);
    template<typename _BIter, typename _OIter >
    _OIter reverse_copy(_BIter, _BIter, _OIter);
    template<typename _FIter >
    void rotate(_FIter, _FIter, _FIter);
    template<typename _FIter, typename _OIter >
    _OIter rotate_copy(_FIter, _FIter, _FIter, _OIter);
    template<typename _RAIter >
    void sort_heap(_RAIter, _RAIter);
    template<typename _RAIter, typename _Compare >
    void sort_heap(_RAIter, _RAIter, _Compare);
    template<typename _BIter, typename _Predicate >
    _BIter stable_partition(_BIter, _BIter, _Predicate);
    template<typename _Tp >
    void swap(_Tp &, _Tp &);
    template<typename _FIter1, typename _FIter2 >
    _FIter2 swap_ranges(_FIter1, _FIter1, _FIter2);
    template<typename _FIter >
    _FIter unique(_FIter, _FIter);
    template<typename _FIter, typename _BinaryPredicate >
    _FIter unique(_FIter, _FIter, _BinaryPredicate);
    template<typename _FIter, typename _Tp >
    _FIter upper_bound(_FIter, _FIter, const _Tp &);
    template<typename _FIter, typename _Tp, typename _Compare >
    _FIter upper_bound(_FIter, _FIter, const _Tp &, _Compare);
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _FIter >
    _FIter adjacent_find(_FIter, _FIter);
    template<typename _FIter, typename _BinaryPredicate >
    _FIter adjacent_find(_FIter, _FIter, _BinaryPredicate);
    template<typename _IIter, typename _Tp >
    typename iterator_traits< _IIter >::difference_type count(_IIter, _IIter, const _Tp &);
    template<typename _IIter, typename _Predicate >
    typename iterator_traits< _IIter >::difference_type count_if(_IIter, _IIter, _Predicate);
    template<typename _IIter1, typename _IIter2 >
    bool equal(_IIter1, _IIter1, _IIter2);
    template<typename _IIter1, typename _IIter2, typename _BinaryPredicate >
    bool equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);
    template<typename _IIter, typename _Tp >
    _IIter find(_IIter, _IIter, const _Tp &);
    template<typename _FIter1, typename _FIter2 >
    _FIter1 find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);
    template<typename _FIter1, typename _FIter2, typename _BinaryPredicate >
    _FIter1 find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);
    template<typename _IIter, typename _Predicate >
    _IIter find_if(_IIter, _IIter, _Predicate);
    template<typename _IIter, typename _Funct >
    _Funct for_each(_IIter, _IIter, _Funct);
    template<typename _FIter, typename _Generator >
    void generate(_FIter, _FIter, _Generator);
    template<typename _OIter, typename _Size, typename _Generator >
    _OIter generate_n(_OIter, _Size, _Generator);
    template<typename _IIter1, typename _IIter2 >
    bool lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);
    template<typename _IIter1, typename _IIter2, typename _Compare >
    bool lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);
    template<typename _FIter >
    _FIter max_element(_FIter, _FIter);
    template<typename _FIter, typename _Compare >
    _FIter max_element(_FIter, _FIter, _Compare);
    template<typename _IIter1, typename _IIter2, typename _OIter >
    _OIter merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);
    template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare >
    _OIter merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);
    template<typename _FIter >
    _FIter min_element(_FIter, _FIter);
    template<typename _FIter, typename _Compare >
    _FIter min_element(_FIter, _FIter, _Compare);
    template<typename _IIter1, typename _IIter2 >
    pair< _IIter1, _IIter2 > mismatch(_IIter1, _IIter1, _IIter2);
    template<typename _IIter1, typename _IIter2, typename _BinaryPredicate >
    pair< _IIter1, _IIter2 > mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);
    template<typename _RAIter >
    void nth_element(_RAIter, _RAIter, _RAIter);
    template<typename _RAIter, typename _Compare >
    void nth_element(_RAIter, _RAIter, _RAIter, _Compare);
    template<typename _RAIter >
    void partial_sort(_RAIter, _RAIter, _RAIter);
    template<typename _RAIter, typename _Compare >
    void partial_sort(_RAIter, _RAIter, _RAIter, _Compare);
    template<typename _BIter, typename _Predicate >
    _BIter partition(_BIter, _BIter, _Predicate);
    template<typename _RAIter >
    void random_shuffle(_RAIter, _RAIter);
    template<typename _RAIter, typename _Generator >
    void random_shuffle(_RAIter, _RAIter, _Generator &);
    template<typename _FIter, typename _Tp >
    void replace(_FIter, _FIter, const _Tp &, const _Tp &);
    template<typename _FIter, typename _Predicate, typename _Tp >
    void replace_if(_FIter, _FIter, _Predicate, const _Tp &);
    template<typename _FIter1, typename _FIter2 >
    _FIter1 search(_FIter1, _FIter1, _FIter2, _FIter2);
    template<typename _FIter1, typename _FIter2, typename _BinaryPredicate >
    _FIter1 search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);
    template<typename _FIter, typename _Size, typename _Tp >
    _FIter search_n(_FIter, _FIter, _Size, const _Tp &);
    template<typename _FIter, typename _Size, typename _Tp, typename _BinaryPredicate >
    _FIter search_n(_FIter, _FIter, _Size, const _Tp &, _BinaryPredicate);
    template<typename _IIter1, typename _IIter2, typename _OIter >
    _OIter set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);
    template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare >
    _OIter set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);
    template<typename _IIter1, typename _IIter2, typename _OIter >
    _OIter set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);
    template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare >
    _OIter set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);
    template<typename _IIter1, typename _IIter2, typename _OIter >
    _OIter set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);
    template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare >
    _OIter set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);
    template<typename _IIter1, typename _IIter2, typename _OIter >
    _OIter set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);
    template<typename _IIter1, typename _IIter2, typename _OIter, typename _Compare >
    _OIter set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);
    template<typename _RAIter >
    void sort(_RAIter, _RAIter);
    template<typename _RAIter, typename _Compare >
    void sort(_RAIter, _RAIter, _Compare);
    template<typename _RAIter >
    void stable_sort(_RAIter, _RAIter);
    template<typename _RAIter, typename _Compare >
    void stable_sort(_RAIter, _RAIter, _Compare);
    template<typename _IIter, typename _OIter, typename _UnaryOperation >
    _OIter transform(_IIter, _IIter, _OIter, _UnaryOperation);
    template<typename _IIter1, typename _IIter2, typename _OIter, typename _BinaryOperation >
    _OIter transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);
    template<typename _IIter, typename _OIter >
    _OIter unique_copy(_IIter, _IIter, _OIter);
    template<typename _IIter, typename _OIter, typename _BinaryPredicate >
    _OIter unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _RandomAccessIterator, typename _Distance >
    _Distance __is_heap_until(_RandomAccessIterator __first, _Distance __n)
    {
        _Distance __parent = 0;
        for (_Distance __child = 1;
            __child < __n;
            ++__child)
        {
            if (__first[__parent] < __first[__child])
                return __child;
            if ((__child & 1) == 0)
                ++__parent;
        }
        return __n;
    }
    template<typename _RandomAccessIterator, typename _Distance, typename _Compare >
    _Distance __is_heap_until(_RandomAccessIterator __first, _Distance __n, _Compare __comp)
    {
        _Distance __parent = 0;
        for (_Distance __child = 1;
            __child < __n;
            ++__child)
        {
            if (__comp(__first[__parent], __first[__child]))
                return __child;
            if ((__child & 1) == 0)
                ++__parent;
        }
        return __n;
    }
    template<typename _RandomAccessIterator, typename _Distance >
    inline bool __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
        return std::__is_heap_until(__first, __n) == __n;
    }
    template<typename _RandomAccessIterator, typename _Compare, typename _Distance >
    inline bool __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    {
        return std::__is_heap_until(__first, __n, __comp) == __n;
    }
    template<typename _RandomAccessIterator >
    inline bool __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
        return std::__is_heap(__first, std::distance(__first, __last));
    }
    template<typename _RandomAccessIterator, typename _Compare >
    inline bool __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
    {
        return std::__is_heap(__first, __comp, std::distance(__first, __last));
    }
    template<typename _RandomAccessIterator, typename _Distance, typename _Tp >
    void __push_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
        _Distance __parent = (__holeIndex - 1) / 2;
        while (__holeIndex > __topIndex && *(__first + __parent) < __value)
        {
            *(__first + __holeIndex) = (*(__first + __parent));
            __holeIndex = __parent;
            __parent = (__holeIndex - 1) / 2;
        }
        *(__first + __holeIndex) = (__value);
    }
    template<typename _RandomAccessIterator >
    inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        typedef typename iterator_traits< _RandomAccessIterator >::difference_type _DistanceType;
        ;
        ;
        _ValueType __value = (*(__last - 1));
        std::__push_heap(__first, _DistanceType((__last - __first) - 1), _DistanceType(0), (__value));
    }
    template<typename _RandomAccessIterator, typename _Distance, typename _Tp, typename _Compare >
    void __push_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value, _Compare __comp)
    {
        _Distance __parent = (__holeIndex - 1) / 2;
        while (__holeIndex > __topIndex && __comp(*(__first + __parent), __value))
        {
            *(__first + __holeIndex) = (*(__first + __parent));
            __holeIndex = __parent;
            __parent = (__holeIndex - 1) / 2;
        }
        *(__first + __holeIndex) = (__value);
    }
    template<typename _RandomAccessIterator, typename _Compare >
    inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        typedef typename iterator_traits< _RandomAccessIterator >::difference_type _DistanceType;
        ;
        ;
        _ValueType __value = (*(__last - 1));
        std::__push_heap(__first, _DistanceType((__last - __first) - 1), _DistanceType(0), (__value), __comp);
    }
    template<typename _RandomAccessIterator, typename _Distance, typename _Tp >
    void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value)
    {
        const _Distance __topIndex = __holeIndex;
        _Distance __secondChild = __holeIndex;
        while (__secondChild < (__len - 1) / 2)
        {
            __secondChild = 2 * (__secondChild + 1);
            if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
                __secondChild--;
            *(__first + __holeIndex) = (*(__first + __secondChild));
            __holeIndex = __secondChild;
        }
        if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
        {
            __secondChild = 2 * (__secondChild + 1);
            *(__first + __holeIndex) = (*(__first + (__secondChild - 1)));
            __holeIndex = __secondChild - 1;
        }
        std::__push_heap(__first, __holeIndex, __topIndex, (__value));
    }
    template<typename _RandomAccessIterator >
    inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        typedef typename iterator_traits< _RandomAccessIterator >::difference_type _DistanceType;
        _ValueType __value = (*__result);
        *__result = (*__first);
        std::__adjust_heap(__first, _DistanceType(0), _DistanceType(__last - __first), (__value));
    }
    template<typename _RandomAccessIterator >
    inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        ;
        ;
        std::__pop_heap(__first, __last - 1, __last - 1);
    }
    template<typename _RandomAccessIterator, typename _Distance, typename _Tp, typename _Compare >
    void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value, _Compare __comp)
    {
        const _Distance __topIndex = __holeIndex;
        _Distance __secondChild = __holeIndex;
        while (__secondChild < (__len - 1) / 2)
        {
            __secondChild = 2 * (__secondChild + 1);
            if (__comp(*(__first + __secondChild), *(__first + (__secondChild - 1))))
                __secondChild--;
            *(__first + __holeIndex) = (*(__first + __secondChild));
            __holeIndex = __secondChild;
        }
        if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
        {
            __secondChild = 2 * (__secondChild + 1);
            *(__first + __holeIndex) = (*(__first + (__secondChild - 1)));
            __holeIndex = __secondChild - 1;
        }
        std::__push_heap(__first, __holeIndex, __topIndex, (__value), __comp);
    }
    template<typename _RandomAccessIterator, typename _Compare >
    inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result, _Compare __comp)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        typedef typename iterator_traits< _RandomAccessIterator >::difference_type _DistanceType;
        _ValueType __value = (*__result);
        *__result = (*__first);
        std::__adjust_heap(__first, _DistanceType(0), _DistanceType(__last - __first), (__value), __comp);
    }
    template<typename _RandomAccessIterator, typename _Compare >
    inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
    {
        ;
        ;
        std::__pop_heap(__first, __last - 1, __last - 1, __comp);
    }
    template<typename _RandomAccessIterator >
    void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        typedef typename iterator_traits< _RandomAccessIterator >::difference_type _DistanceType;
        ;
        if (__last - __first < 2)
            return;
        const _DistanceType __len = __last - __first;
        _DistanceType __parent = (__len - 2) / 2;
        while (true)
        {
            _ValueType __value = (*(__first + __parent));
            std::__adjust_heap(__first, __parent, __len, (__value));
            if (__parent == 0)
                return;
            __parent--;
        }
    }
    template<typename _RandomAccessIterator, typename _Compare >
    void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        typedef typename iterator_traits< _RandomAccessIterator >::difference_type _DistanceType;
        ;
        if (__last - __first < 2)
            return;
        const _DistanceType __len = __last - __first;
        _DistanceType __parent = (__len - 2) / 2;
        while (true)
        {
            _ValueType __value = (*(__first + __parent));
            std::__adjust_heap(__first, __parent, __len, (__value), __comp);
            if (__parent == 0)
                return;
            __parent--;
        }
    }
    template<typename _RandomAccessIterator >
    void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
        ;
        ;
        while (__last - __first > 1)
            std::pop_heap(__first, _RandomAccessIterator(__last--));
    }
    template<typename _RandomAccessIterator, typename _Compare >
    void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
    {
        ;
        ;
        while (__last - __first > 1)
            std::pop_heap(__first, _RandomAccessIterator(__last--), __comp);
    }
}
#pragma GCC visibility push(default)
extern "C++"
{
    namespace std {
        class exception
        {
            public :
                exception() throw ()
                {
                }
                virtual ~exception() throw ();
                virtual const char * what() const throw ();
        };
        class bad_exception : public exception
        {
            public :
                bad_exception() throw ()
                {
                }
                virtual ~bad_exception() throw ();
                virtual const char * what() const throw ();
        };
        typedef void (* terminate_handler)();
        typedef void (* unexpected_handler)();
        terminate_handler set_terminate(terminate_handler) throw ();
        void terminate() __attribute__((__noreturn__));
        unexpected_handler set_unexpected(unexpected_handler) throw ();
        void unexpected() __attribute__((__noreturn__));
        bool uncaught_exception() throw ();
    }
    namespace __gnu_cxx __attribute__((__visibility__("default"))) {
        void __verbose_terminate_handler();
    }
}
#pragma GCC visibility pop
#pragma GCC visibility push(default)
extern "C++"
{
    namespace std {
        class bad_alloc : public exception
        {
            public :
                bad_alloc() throw ()
                {
                }
                virtual ~bad_alloc() throw ();
                virtual const char * what() const throw ();
        };
        struct nothrow_t
        {
        };
        extern const nothrow_t nothrow;
        typedef void (* new_handler)();
        new_handler set_new_handler(new_handler) throw ();
    }
    void * operator new(std::size_t) throw (std::bad_alloc);
    void * operator new[](std::size_t) throw (std::bad_alloc);
    void operator delete(void *) throw ();
    void operator delete[](void *) throw ();
    void * operator new(std::size_t, const std::nothrow_t &) throw ();
    void * operator new[](std::size_t, const std::nothrow_t &) throw ();
    void operator delete(void *, const std::nothrow_t &) throw ();
    void operator delete[](void *, const std::nothrow_t &) throw ();
    inline void * operator new(std::size_t, void * __p) throw ()
    {
        return __p;
    }
    inline void * operator new[](std::size_t, void * __p) throw ()
    {
        return __p;
    }
    inline void operator delete(void *, void *) throw ()
    {
    }
    inline void operator delete[](void *, void *) throw ()
    {
    }
}
#pragma GCC visibility pop
namespace std __attribute__((__visibility__("default"))) {
    template<typename _T1, typename _T2 >
    inline void _Construct(_T1 * __p, const _T2 & __value)
    {
        ::new (static_cast<void * >(__p)) _T1 (__value);
    }
    template<typename _Tp >
    inline void _Destroy(_Tp * __pointer)
    {
        __pointer->~_Tp();
    }
    template<typename _ForwardIterator >
    inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
        typedef typename iterator_traits< _ForwardIterator >::value_type _Value_type;
        if (!__has_trivial_destructor(_Value_type))
            for (;
                __first != __last;
                ++__first)
            std::_Destroy(&*__first);
    }
    template<typename _Tp >
    class allocator;
    template<typename _ForwardIterator, typename _Allocator >
    void _Destroy(_ForwardIterator __first, _ForwardIterator __last, _Allocator & __alloc)
    {
        for (;
            __first != __last;
            ++__first)
        __alloc.destroy(&*__first);
    }
    template<typename _ForwardIterator, typename _Tp >
    inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last, allocator< _Tp > &)
    {
        _Destroy(__first, __last);
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<bool >
    struct __uninitialized_copy
    {
            template<typename _InputIterator, typename _ForwardIterator >
            static _ForwardIterator uninitialized_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result)
            {
                _ForwardIterator __cur = __result;
                try
                {
                    for (;
                        __first != __last;
                        ++__first , ++__cur)
                    ::new (static_cast<void * >(&*__cur)) typename iterator_traits< _ForwardIterator >::value_type (*__first);
                    return __cur;
                }
                catch (...)
                {
                    std::_Destroy(__result, __cur);
                    throw;
                }
            }
    };
    template<>
    struct __uninitialized_copy< true >
    {
            template<typename _InputIterator, typename _ForwardIterator >
            static _ForwardIterator uninitialized_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result)
            {
                return std::copy(__first, __last, __result);
            }
    };
    template<typename _InputIterator, typename _ForwardIterator >
    inline _ForwardIterator uninitialized_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result)
    {
        typedef typename iterator_traits< _InputIterator >::value_type _ValueType1;
        typedef typename iterator_traits< _ForwardIterator >::value_type _ValueType2;
        return std::__uninitialized_copy< (__is_pod(_ValueType1) && __is_pod(_ValueType2)) >::uninitialized_copy(__first, __last, __result);
    }
    template<bool >
    struct __uninitialized_fill
    {
            template<typename _ForwardIterator, typename _Tp >
            static void uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __x)
            {
                _ForwardIterator __cur = __first;
                try
                {
                    for (;
                        __cur != __last;
                        ++__cur)
                    std::_Construct(&*__cur, __x);
                }
                catch (...)
                {
                    std::_Destroy(__first, __cur);
                    throw;
                }
            }
    };
    template<>
    struct __uninitialized_fill< true >
    {
            template<typename _ForwardIterator, typename _Tp >
            static void uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __x)
            {
                std::fill(__first, __last, __x);
            }
    };
    template<typename _ForwardIterator, typename _Tp >
    inline void uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __x)
    {
        typedef typename iterator_traits< _ForwardIterator >::value_type _ValueType;
        std::__uninitialized_fill< __is_pod(_ValueType) >::uninitialized_fill(__first, __last, __x);
    }
    template<bool >
    struct __uninitialized_fill_n
    {
            template<typename _ForwardIterator, typename _Size, typename _Tp >
            static void uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp & __x)
            {
                _ForwardIterator __cur = __first;
                try
                {
                    for (;
                        __n > 0;
                        --__n , ++__cur)
                    std::_Construct(&*__cur, __x);
                }
                catch (...)
                {
                    std::_Destroy(__first, __cur);
                    throw;
                }
            }
    };
    template<>
    struct __uninitialized_fill_n< true >
    {
            template<typename _ForwardIterator, typename _Size, typename _Tp >
            static void uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp & __x)
            {
                std::fill_n(__first, __n, __x);
            }
    };
    template<typename _ForwardIterator, typename _Size, typename _Tp >
    inline void uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp & __x)
    {
        typedef typename iterator_traits< _ForwardIterator >::value_type _ValueType;
        std::__uninitialized_fill_n< __is_pod(_ValueType) >::uninitialized_fill_n(__first, __n, __x);
    }
    template<typename _InputIterator, typename _ForwardIterator, typename _Allocator >
    _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator & __alloc)
    {
        _ForwardIterator __cur = __result;
        try
        {
            for (;
                __first != __last;
                ++__first , ++__cur)
            __alloc.construct(&*__cur, *__first);
            return __cur;
        }
        catch (...)
        {
            std::_Destroy(__result, __cur, __alloc);
            throw;
        }
    }
    template<typename _InputIterator, typename _ForwardIterator, typename _Tp >
    inline _ForwardIterator __uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, allocator< _Tp > &)
    {
        return std::uninitialized_copy(__first, __last, __result);
    }
    template<typename _InputIterator, typename _ForwardIterator, typename _Allocator >
    inline _ForwardIterator __uninitialized_move_a(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator & __alloc)
    {
        return std::__uninitialized_copy_a((__first), (__last), __result, __alloc);
    }
    template<typename _ForwardIterator, typename _Tp, typename _Allocator >
    void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __x, _Allocator & __alloc)
    {
        _ForwardIterator __cur = __first;
        try
        {
            for (;
                __cur != __last;
                ++__cur)
            __alloc.construct(&*__cur, __x);
        }
        catch (...)
        {
            std::_Destroy(__first, __cur, __alloc);
            throw;
        }
    }
    template<typename _ForwardIterator, typename _Tp, typename _Tp2 >
    inline void __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __x, allocator< _Tp2 > &)
    {
        std::uninitialized_fill(__first, __last, __x);
    }
    template<typename _ForwardIterator, typename _Size, typename _Tp, typename _Allocator >
    void __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp & __x, _Allocator & __alloc)
    {
        _ForwardIterator __cur = __first;
        try
        {
            for (;
                __n > 0;
                --__n , ++__cur)
            __alloc.construct(&*__cur, __x);
        }
        catch (...)
        {
            std::_Destroy(__first, __cur, __alloc);
            throw;
        }
    }
    template<typename _ForwardIterator, typename _Size, typename _Tp, typename _Tp2 >
    inline void __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp & __x, allocator< _Tp2 > &)
    {
        std::uninitialized_fill_n(__first, __n, __x);
    }
    template<typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator >
    inline _ForwardIterator __uninitialized_copy_move(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator & __alloc)
    {
        _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1, __result, __alloc);
        try
        {
            return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
        }
        catch (...)
        {
            std::_Destroy(__result, __mid, __alloc);
            throw;
        }
    }
    template<typename _InputIterator1, typename _InputIterator2, typename _ForwardIterator, typename _Allocator >
    inline _ForwardIterator __uninitialized_move_copy(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator & __alloc)
    {
        _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1, __result, __alloc);
        try
        {
            return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
        }
        catch (...)
        {
            std::_Destroy(__result, __mid, __alloc);
            throw;
        }
    }
    template<typename _ForwardIterator, typename _Tp, typename _InputIterator, typename _Allocator >
    inline _ForwardIterator __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid, const _Tp & __x, _InputIterator __first, _InputIterator __last, _Allocator & __alloc)
    {
        std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
        try
        {
            return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
        }
        catch (...)
        {
            std::_Destroy(__result, __mid, __alloc);
            throw;
        }
    }
    template<typename _InputIterator, typename _ForwardIterator, typename _Tp, typename _Allocator >
    inline void __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, const _Tp & __x, _Allocator & __alloc)
    {
        _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1, __first2, __alloc);
        try
        {
            std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
        }
        catch (...)
        {
            std::_Destroy(__first2, __mid2, __alloc);
            throw;
        }
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Tp >
    pair< _Tp *, ptrdiff_t > get_temporary_buffer(ptrdiff_t __len)
    {
        const ptrdiff_t __max = __gnu_cxx::__numeric_traits< ptrdiff_t >::__max / sizeof(_Tp);
        if (__len > __max)
            __len = __max;
        while (__len > 0)
        {
            _Tp * __tmp = static_cast<_Tp * >(::operator new(__len * sizeof(_Tp), std::nothrow));
            if (__tmp != 0)
                return std::pair< _Tp *, ptrdiff_t >(__tmp, __len);
            __len /= 2;
        }
        return std::pair< _Tp *, ptrdiff_t >(static_cast<_Tp * >(0), 0);
    }
    template<typename _Tp >
    inline void return_temporary_buffer(_Tp * __p)
    {
        ::operator delete(__p, std::nothrow);
    }
    template<typename _ForwardIterator, typename _Tp >
    class _Temporary_buffer
    {
        public :
            typedef _Tp value_type;
            typedef value_type * pointer;
            typedef pointer iterator;
            typedef ptrdiff_t size_type;
        protected :
            size_type _M_original_len;
            size_type _M_len;
            pointer _M_buffer;
        public :
            size_type size() const
            {
                return _M_len;
            }
            size_type requested_size() const
            {
                return _M_original_len;
            }
            iterator begin()
            {
                return _M_buffer;
            }
            iterator end()
            {
                return _M_buffer + _M_len;
            }
            _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);
            ~_Temporary_buffer()
            {
                std::_Destroy(_M_buffer, _M_buffer + _M_len);
                std::return_temporary_buffer(_M_buffer);
            }
        private :
            _Temporary_buffer(const _Temporary_buffer &);
            void operator =(const _Temporary_buffer &);
    };
    template<typename _ForwardIterator, typename _Tp >
    _Temporary_buffer< _ForwardIterator, _Tp >::_Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
        : _M_original_len(std::distance(__first, __last)), _M_len(0), _M_buffer(0) 
    {
        try
        {
            std::pair< pointer, size_type > __p(std::get_temporary_buffer< value_type >(_M_original_len));
            _M_buffer = __p.first;
            _M_len = __p.second;
            if (!__is_pod(_Tp) && _M_len > 0)
                std::uninitialized_fill_n(_M_buffer, _M_len, *__first);
        }
        catch (...)
        {
            std::return_temporary_buffer(_M_buffer);
            _M_buffer = 0;
            _M_len = 0;
            throw;
        }
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Tp >
    inline const _Tp & __median(const _Tp & __a, const _Tp & __b, const _Tp & __c)
    {
        if (__a < __b)
            if (__b < __c)
                return __b;
            else
                if (__a < __c)
                    return __c;
                else
                    return __a;
        else
            if (__a < __c)
                return __a;
            else
                if (__b < __c)
                    return __c;
                else
                    return __b;
    }
    template<typename _Tp, typename _Compare >
    inline const _Tp & __median(const _Tp & __a, const _Tp & __b, const _Tp & __c, _Compare __comp)
    {
        if (__comp(__a, __b))
            if (__comp(__b, __c))
                return __b;
            else
                if (__comp(__a, __c))
                    return __c;
                else
                    return __a;
        else
            if (__comp(__a, __c))
                return __a;
            else
                if (__comp(__b, __c))
                    return __c;
                else
                    return __b;
    }
    template<typename _InputIterator, typename _Tp >
    inline _InputIterator __find(_InputIterator __first, _InputIterator __last, const _Tp & __val, input_iterator_tag)
    {
        while (__first != __last && !(*__first == __val))
            ++__first;
        return __first;
    }
    template<typename _InputIterator, typename _Predicate >
    inline _InputIterator __find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred, input_iterator_tag)
    {
        while (__first != __last && !bool(__pred(*__first)))
            ++__first;
        return __first;
    }
    template<typename _RandomAccessIterator, typename _Tp >
    _RandomAccessIterator __find(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp & __val, random_access_iterator_tag)
    {
        typename iterator_traits< _RandomAccessIterator >::difference_type __trip_count = (__last - __first) >> 2;
        for (;
            __trip_count > 0;
            --__trip_count)
        {
            if (*__first == __val)
                return __first;
            ++__first;
            if (*__first == __val)
                return __first;
            ++__first;
            if (*__first == __val)
                return __first;
            ++__first;
            if (*__first == __val)
                return __first;
            ++__first;
        }
        switch (__last - __first)
        {
            case 3 : 
            if (*__first == __val)
                return __first;
            ++__first;
            case 2 : 
            if (*__first == __val)
                return __first;
            ++__first;
            case 1 : 
            if (*__first == __val)
                return __first;
            ++__first;
            case 0 : 
            default : 
            return __last;
        }
    }
    template<typename _RandomAccessIterator, typename _Predicate >
    _RandomAccessIterator __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, random_access_iterator_tag)
    {
        typename iterator_traits< _RandomAccessIterator >::difference_type __trip_count = (__last - __first) >> 2;
        for (;
            __trip_count > 0;
            --__trip_count)
        {
            if (__pred(*__first))
                return __first;
            ++__first;
            if (__pred(*__first))
                return __first;
            ++__first;
            if (__pred(*__first))
                return __first;
            ++__first;
            if (__pred(*__first))
                return __first;
            ++__first;
        }
        switch (__last - __first)
        {
            case 3 : 
            if (__pred(*__first))
                return __first;
            ++__first;
            case 2 : 
            if (__pred(*__first))
                return __first;
            ++__first;
            case 1 : 
            if (__pred(*__first))
                return __first;
            ++__first;
            case 0 : 
            default : 
            return __last;
        }
    }
    template<typename _ForwardIterator, typename _Integer, typename _Tp >
    _ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp & __val, std::forward_iterator_tag)
    {
        __first = std::find(__first, __last, __val);
        while (__first != __last)
        {
            typename iterator_traits< _ForwardIterator >::difference_type __n = __count;
            _ForwardIterator __i = __first;
            ++__i;
            while (__i != __last && __n != 1 && *__i == __val)
            {
                ++__i;
                --__n;
            }
            if (__n == 1)
                return __first;
            if (__i == __last)
                return __last;
            __first = std::find(++__i, __last, __val);
        }
        return __last;
    }
    template<typename _RandomAccessIter, typename _Integer, typename _Tp >
    _RandomAccessIter __search_n(_RandomAccessIter __first, _RandomAccessIter __last, _Integer __count, const _Tp & __val, std::random_access_iterator_tag)
    {
        typedef typename std::iterator_traits< _RandomAccessIter >::difference_type _DistanceType;
        _DistanceType __tailSize = __last - __first;
        const _DistanceType __pattSize = __count;
        if (__tailSize < __pattSize)
            return __last;
        const _DistanceType __skipOffset = __pattSize - 1;
        _RandomAccessIter __lookAhead = __first + __skipOffset;
        __tailSize -= __pattSize;
        while (1)
        {
            while (!(*__lookAhead == __val))
            {
                if (__tailSize < __pattSize)
                    return __last;
                __lookAhead += __pattSize;
                __tailSize -= __pattSize;
            }
            _DistanceType __remainder = __skipOffset;
            for (_RandomAccessIter __backTrack = __lookAhead - 1;
                *__backTrack == __val;
                --__backTrack)
            {
                if (--__remainder == 0)
                    return (__lookAhead - __skipOffset);
            }
            if (__remainder > __tailSize)
                return __last;
            __lookAhead += __remainder;
            __tailSize -= __remainder;
        }
    }
    template<typename _ForwardIterator, typename _Integer, typename _Tp, typename _BinaryPredicate >
    _ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp & __val, _BinaryPredicate __binary_pred, std::forward_iterator_tag)
    {
        while (__first != __last && !bool(__binary_pred(*__first, __val)))
            ++__first;
        while (__first != __last)
        {
            typename iterator_traits< _ForwardIterator >::difference_type __n = __count;
            _ForwardIterator __i = __first;
            ++__i;
            while (__i != __last && __n != 1 && bool(__binary_pred(*__i, __val)))
            {
                ++__i;
                --__n;
            }
            if (__n == 1)
                return __first;
            if (__i == __last)
                return __last;
            __first = ++__i;
            while (__first != __last && !bool(__binary_pred(*__first, __val)))
                ++__first;
        }
        return __last;
    }
    template<typename _RandomAccessIter, typename _Integer, typename _Tp, typename _BinaryPredicate >
    _RandomAccessIter __search_n(_RandomAccessIter __first, _RandomAccessIter __last, _Integer __count, const _Tp & __val, _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
    {
        typedef typename std::iterator_traits< _RandomAccessIter >::difference_type _DistanceType;
        _DistanceType __tailSize = __last - __first;
        const _DistanceType __pattSize = __count;
        if (__tailSize < __pattSize)
            return __last;
        const _DistanceType __skipOffset = __pattSize - 1;
        _RandomAccessIter __lookAhead = __first + __skipOffset;
        __tailSize -= __pattSize;
        while (1)
        {
            while (!bool(__binary_pred(*__lookAhead, __val)))
            {
                if (__tailSize < __pattSize)
                    return __last;
                __lookAhead += __pattSize;
                __tailSize -= __pattSize;
            }
            _DistanceType __remainder = __skipOffset;
            for (_RandomAccessIter __backTrack = __lookAhead - 1;
                __binary_pred(*__backTrack, __val);
                --__backTrack)
            {
                if (--__remainder == 0)
                    return (__lookAhead - __skipOffset);
            }
            if (__remainder > __tailSize)
                return __last;
            __lookAhead += __remainder;
            __tailSize -= __remainder;
        }
    }
    template<typename _ForwardIterator1, typename _ForwardIterator2 >
    _ForwardIterator1 __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, forward_iterator_tag, forward_iterator_tag)
    {
        if (__first2 == __last2)
            return __last1;
        else
        {
            _ForwardIterator1 __result = __last1;
            while (1)
            {
                _ForwardIterator1 __new_result = std::search(__first1, __last1, __first2, __last2);
                if (__new_result == __last1)
                    return __result;
                else
                {
                    __result = __new_result;
                    __first1 = __new_result;
                    ++__first1;
                }
            }
        }
    }
    template<typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate >
    _ForwardIterator1 __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, forward_iterator_tag, forward_iterator_tag, _BinaryPredicate __comp)
    {
        if (__first2 == __last2)
            return __last1;
        else
        {
            _ForwardIterator1 __result = __last1;
            while (1)
            {
                _ForwardIterator1 __new_result = std::search(__first1, __last1, __first2, __last2, __comp);
                if (__new_result == __last1)
                    return __result;
                else
                {
                    __result = __new_result;
                    __first1 = __new_result;
                    ++__first1;
                }
            }
        }
    }
    template<typename _BidirectionalIterator1, typename _BidirectionalIterator2 >
    _BidirectionalIterator1 __find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, bidirectional_iterator_tag, bidirectional_iterator_tag)
    {
        typedef reverse_iterator< _BidirectionalIterator1 > _RevIterator1;
        typedef reverse_iterator< _BidirectionalIterator2 > _RevIterator2;
        _RevIterator1 __rlast1(__first1);
        _RevIterator2 __rlast2(__first2);
        _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1, _RevIterator2(__last2), __rlast2);
        if (__rresult == __rlast1)
            return __last1;
        else
        {
            _BidirectionalIterator1 __result = __rresult.base();
            std::advance(__result, -std::distance(__first2, __last2));
            return __result;
        }
    }
    template<typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _BinaryPredicate >
    _BidirectionalIterator1 __find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, bidirectional_iterator_tag, bidirectional_iterator_tag, _BinaryPredicate __comp)
    {
        typedef reverse_iterator< _BidirectionalIterator1 > _RevIterator1;
        typedef reverse_iterator< _BidirectionalIterator2 > _RevIterator2;
        _RevIterator1 __rlast1(__first1);
        _RevIterator2 __rlast2(__first2);
        _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1, _RevIterator2(__last2), __rlast2, __comp);
        if (__rresult == __rlast1)
            return __last1;
        else
        {
            _BidirectionalIterator1 __result = __rresult.base();
            std::advance(__result, -std::distance(__first2, __last2));
            return __result;
        }
    }
    template<typename _ForwardIterator1, typename _ForwardIterator2 >
    inline _ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
        ;
        ;
        return std::__find_end(__first1, __last1, __first2, __last2, std::__iterator_category(__first1), std::__iterator_category(__first2));
    }
    template<typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate >
    inline _ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __comp)
    {
        ;
        ;
        return std::__find_end(__first1, __last1, __first2, __last2, std::__iterator_category(__first1), std::__iterator_category(__first2), __comp);
    }
    template<typename _InputIterator, typename _OutputIterator, typename _Tp >
    _OutputIterator remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp & __value)
    {
        ;
        for (;
            __first != __last;
            ++__first)
        if (!(*__first == __value))
        {
            *__result = *__first;
            ++__result;
        }
        return __result;
    }
    template<typename _InputIterator, typename _OutputIterator, typename _Predicate >
    _OutputIterator remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
    {
        ;
        for (;
            __first != __last;
            ++__first)
        if (!bool(__pred(*__first)))
        {
            *__result = *__first;
            ++__result;
        }
        return __result;
    }
    template<typename _ForwardIterator, typename _Tp >
    _ForwardIterator remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __value)
    {
        ;
        __first = std::find(__first, __last, __value);
        if (__first == __last)
            return __first;
        _ForwardIterator __result = __first;
        ++__first;
        for (;
            __first != __last;
            ++__first)
        if (!(*__first == __value))
        {
            *__result = (*__first);
            ++__result;
        }
        return __result;
    }
    template<typename _ForwardIterator, typename _Predicate >
    _ForwardIterator remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
    {
        ;
        __first = std::find_if(__first, __last, __pred);
        if (__first == __last)
            return __first;
        _ForwardIterator __result = __first;
        ++__first;
        for (;
            __first != __last;
            ++__first)
        if (!bool(__pred(*__first)))
        {
            *__result = (*__first);
            ++__result;
        }
        return __result;
    }
    template<typename _ForwardIterator >
    _ForwardIterator unique(_ForwardIterator __first, _ForwardIterator __last)
    {
        ;
        __first = std::adjacent_find(__first, __last);
        if (__first == __last)
            return __last;
        _ForwardIterator __dest = __first;
        ++__first;
        while (++__first != __last)
            if (!(*__dest == *__first))
                *++__dest = (*__first);
        return ++__dest;
    }
    template<typename _ForwardIterator, typename _BinaryPredicate >
    _ForwardIterator unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)
    {
        ;
        __first = std::adjacent_find(__first, __last, __binary_pred);
        if (__first == __last)
            return __last;
        _ForwardIterator __dest = __first;
        ++__first;
        while (++__first != __last)
            if (!bool(__binary_pred(*__dest, *__first)))
                *++__dest = (*__first);
        return ++__dest;
    }
    template<typename _ForwardIterator, typename _OutputIterator >
    _OutputIterator __unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, forward_iterator_tag, output_iterator_tag)
    {
        _ForwardIterator __next = __first;
        *__result = *__first;
        while (++__next != __last)
            if (!(*__first == *__next))
            {
                __first = __next;
                *++__result = *__first;
            }
        return ++__result;
    }
    template<typename _InputIterator, typename _OutputIterator >
    _OutputIterator __unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, input_iterator_tag, output_iterator_tag)
    {
        typename iterator_traits< _InputIterator >::value_type __value = *__first;
        *__result = __value;
        while (++__first != __last)
            if (!(__value == *__first))
            {
                __value = *__first;
                *++__result = __value;
            }
        return ++__result;
    }
    template<typename _InputIterator, typename _ForwardIterator >
    _ForwardIterator __unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, input_iterator_tag, forward_iterator_tag)
    {
        *__result = *__first;
        while (++__first != __last)
            if (!(*__result == *__first))
                *++__result = *__first;
        return ++__result;
    }
    template<typename _ForwardIterator, typename _OutputIterator, typename _BinaryPredicate >
    _OutputIterator __unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred, forward_iterator_tag, output_iterator_tag)
    {
        _ForwardIterator __next = __first;
        *__result = *__first;
        while (++__next != __last)
            if (!bool(__binary_pred(*__first, *__next)))
            {
                __first = __next;
                *++__result = *__first;
            }
        return ++__result;
    }
    template<typename _InputIterator, typename _OutputIterator, typename _BinaryPredicate >
    _OutputIterator __unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred, input_iterator_tag, output_iterator_tag)
    {
        typename iterator_traits< _InputIterator >::value_type __value = *__first;
        *__result = __value;
        while (++__first != __last)
            if (!bool(__binary_pred(__value, *__first)))
            {
                __value = *__first;
                *++__result = __value;
            }
        return ++__result;
    }
    template<typename _InputIterator, typename _ForwardIterator, typename _BinaryPredicate >
    _ForwardIterator __unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __binary_pred, input_iterator_tag, forward_iterator_tag)
    {
        *__result = *__first;
        while (++__first != __last)
            if (!bool(__binary_pred(*__result, *__first)))
                *++__result = *__first;
        return ++__result;
    }
    template<typename _BidirectionalIterator >
    void __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)
    {
        while (true)
            if (__first == __last || __first == --__last)
                return;
            else
            {
                std::iter_swap(__first, __last);
                ++__first;
            }
    }
    template<typename _RandomAccessIterator >
    void __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)
    {
        if (__first == __last)
            return;
        --__last;
        while (__first < __last)
        {
            std::iter_swap(__first, __last);
            ++__first;
            --__last;
        }
    }
    template<typename _BidirectionalIterator >
    inline void reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {
        ;
        std::__reverse(__first, __last, std::__iterator_category(__first));
    }
    template<typename _BidirectionalIterator, typename _OutputIterator >
    _OutputIterator reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
    {
        ;
        while (__first != __last)
        {
            --__last;
            *__result = *__last;
            ++__result;
        }
        return __result;
    }
    template<typename _EuclideanRingElement >
    _EuclideanRingElement __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
        while (__n != 0)
        {
            _EuclideanRingElement __t = __m % __n;
            __m = __n;
            __n = __t;
        }
        return __m;
    }
    template<typename _ForwardIterator >
    void __rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, forward_iterator_tag)
    {
        if (__first == __middle || __last == __middle)
            return;
        _ForwardIterator __first2 = __middle;
        do
        {
            std::iter_swap(__first, __first2);
            ++__first;
            ++__first2;
            if (__first == __middle)
                __middle = __first2;
        }
        while (__first2 != __last);
        __first2 = __middle;
        while (__first2 != __last)
        {
            std::iter_swap(__first, __first2);
            ++__first;
            ++__first2;
            if (__first == __middle)
                __middle = __first2;
            else
                if (__first2 == __last)
                    __first2 = __middle;
        }
    }
    template<typename _BidirectionalIterator >
    void __rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, bidirectional_iterator_tag)
    {
        if (__first == __middle || __last == __middle)
            return;
        std::__reverse(__first, __middle, bidirectional_iterator_tag());
        std::__reverse(__middle, __last, bidirectional_iterator_tag());
        while (__first != __middle && __middle != __last)
        {
            std::iter_swap(__first, --__last);
            ++__first;
        }
        if (__first == __middle)
            std::__reverse(__middle, __last, bidirectional_iterator_tag());
        else
            std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }
    template<typename _RandomAccessIterator >
    void __rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, random_access_iterator_tag)
    {
        if (__first == __middle || __last == __middle)
            return;
        typedef typename iterator_traits< _RandomAccessIterator >::difference_type _Distance;
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        const _Distance __n = __last - __first;
        const _Distance __k = __middle - __first;
        const _Distance __l = __n - __k;
        if (__k == __l)
        {
            std::swap_ranges(__first, __middle, __middle);
            return;
        }
        const _Distance __d = std::__gcd(__n, __k);
        for (_Distance __i = 0;
            __i < __d;
            __i++)
        {
            _ValueType __tmp = (*__first);
            _RandomAccessIterator __p = __first;
            if (__k < __l)
            {
                for (_Distance __j = 0;
                    __j < __l / __d;
                    __j++)
                {
                    if (__p > __first + __l)
                    {
                        *__p = (*(__p - __l));
                        __p -= __l;
                    }
                    *__p = (*(__p + __k));
                    __p += __k;
                }
            }
            else
            {
                for (_Distance __j = 0;
                    __j < __k / __d - 1;
                    __j++)
                {
                    if (__p < __last - __k)
                    {
                        *__p = (*(__p + __k));
                        __p += __k;
                    }
                    *__p = (*(__p - __l));
                    __p -= __l;
                }
            }
            *__p = (__tmp);
            ++__first;
        }
    }
    template<typename _ForwardIterator >
    inline void rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
    {
        ;
        ;
        typedef typename iterator_traits< _ForwardIterator >::iterator_category _IterType;
        std::__rotate(__first, __middle, __last, _IterType());
    }
    template<typename _ForwardIterator, typename _OutputIterator >
    _OutputIterator rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
    {
        ;
        ;
        return std::copy(__first, __middle, std::copy(__middle, __last, __result));
    }
    template<typename _ForwardIterator, typename _Predicate >
    _ForwardIterator __partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)
    {
        if (__first == __last)
            return __first;
        while (__pred(*__first))
            if (++__first == __last)
                return __first;
        _ForwardIterator __next = __first;
        while (++__next != __last)
            if (__pred(*__next))
            {
                std::iter_swap(__first, __next);
                ++__first;
            }
        return __first;
    }
    template<typename _BidirectionalIterator, typename _Predicate >
    _BidirectionalIterator __partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred, bidirectional_iterator_tag)
    {
        while (true)
        {
            while (true)
                if (__first == __last)
                    return __first;
                else
                    if (__pred(*__first))
                        ++__first;
                    else
                        break;
            --__last;
            while (true)
                if (__first == __last)
                    return __first;
                else
                    if (!bool(__pred(*__last)))
                        --__last;
                    else
                        break;
            std::iter_swap(__first, __last);
            ++__first;
        }
    }
    template<typename _ForwardIterator, typename _Predicate, typename _Distance >
    _ForwardIterator __inplace_stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, _Distance __len)
    {
        if (__len == 1)
            return __pred(*__first) ? __last : __first;
        _ForwardIterator __middle = __first;
        std::advance(__middle, __len / 2);
        _ForwardIterator __begin = std::__inplace_stable_partition(__first, __middle, __pred, __len / 2);
        _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last, __pred, __len - __len / 2);
        std::rotate(__begin, __middle, __end);
        std::advance(__begin, std::distance(__middle, __end));
        return __begin;
    }
    template<typename _ForwardIterator, typename _Pointer, typename _Predicate, typename _Distance >
    _ForwardIterator __stable_partition_adaptive(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, _Distance __len, _Pointer __buffer, _Distance __buffer_size)
    {
        if (__len <= __buffer_size)
        {
            _ForwardIterator __result1 = __first;
            _Pointer __result2 = __buffer;
            for (;
                __first != __last;
                ++__first)
            if (__pred(*__first))
            {
                *__result1 = *__first;
                ++__result1;
            }
            else
            {
                *__result2 = *__first;
                ++__result2;
            }
            std::copy(__buffer, __result2, __result1);
            return __result1;
        }
        else
        {
            _ForwardIterator __middle = __first;
            std::advance(__middle, __len / 2);
            _ForwardIterator __begin = std::__stable_partition_adaptive(__first, __middle, __pred, __len / 2, __buffer, __buffer_size);
            _ForwardIterator __end = std::__stable_partition_adaptive(__middle, __last, __pred, __len - __len / 2, __buffer, __buffer_size);
            std::rotate(__begin, __middle, __end);
            std::advance(__begin, std::distance(__middle, __end));
            return __begin;
        }
    }
    template<typename _ForwardIterator, typename _Predicate >
    _ForwardIterator stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
    {
        ;
        if (__first == __last)
            return __first;
        else
        {
            typedef typename iterator_traits< _ForwardIterator >::value_type _ValueType;
            typedef typename iterator_traits< _ForwardIterator >::difference_type _DistanceType;
            _Temporary_buffer< _ForwardIterator, _ValueType > __buf(__first, __last);
            if (__buf.size() > 0)
                return std::__stable_partition_adaptive(__first, __last, __pred, _DistanceType(__buf.requested_size()), __buf.begin(), _DistanceType(__buf.size()));
            else
                return std::__inplace_stable_partition(__first, __last, __pred, _DistanceType(__buf.requested_size()));
        }
    }
    template<typename _RandomAccessIterator >
    void __heap_select(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
    {
        std::make_heap(__first, __middle);
        for (_RandomAccessIterator __i = __middle;
            __i < __last;
            ++__i)
        if (*__i < *__first)
            std::__pop_heap(__first, __middle, __i);
    }
    template<typename _RandomAccessIterator, typename _Compare >
    void __heap_select(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)
    {
        std::make_heap(__first, __middle, __comp);
        for (_RandomAccessIterator __i = __middle;
            __i < __last;
            ++__i)
        if (__comp(*__i, *__first))
            std::__pop_heap(__first, __middle, __i, __comp);
    }
    template<typename _InputIterator, typename _RandomAccessIterator >
    _RandomAccessIterator partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
    {
        typedef typename iterator_traits< _InputIterator >::value_type _InputValueType;
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _OutputValueType;
        typedef typename iterator_traits< _RandomAccessIterator >::difference_type _DistanceType;
        ;
        ;
        if (__result_first == __result_last)
            return __result_last;
        _RandomAccessIterator __result_real_last = __result_first;
        while (__first != __last && __result_real_last != __result_last)
        {
            *__result_real_last = *__first;
            ++__result_real_last;
            ++__first;
        }
        std::make_heap(__result_first, __result_real_last);
        while (__first != __last)
        {
            if (*__first < *__result_first)
                std::__adjust_heap(__result_first, _DistanceType(0), _DistanceType(__result_real_last - __result_first), _InputValueType(*__first));
            ++__first;
        }
        std::sort_heap(__result_first, __result_real_last);
        return __result_real_last;
    }
    template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare >
    _RandomAccessIterator partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
    {
        typedef typename iterator_traits< _InputIterator >::value_type _InputValueType;
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _OutputValueType;
        typedef typename iterator_traits< _RandomAccessIterator >::difference_type _DistanceType;
        ;
        ;
        if (__result_first == __result_last)
            return __result_last;
        _RandomAccessIterator __result_real_last = __result_first;
        while (__first != __last && __result_real_last != __result_last)
        {
            *__result_real_last = *__first;
            ++__result_real_last;
            ++__first;
        }
        std::make_heap(__result_first, __result_real_last, __comp);
        while (__first != __last)
        {
            if (__comp(*__first, *__result_first))
                std::__adjust_heap(__result_first, _DistanceType(0), _DistanceType(__result_real_last - __result_first), _InputValueType(*__first), __comp);
            ++__first;
        }
        std::sort_heap(__result_first, __result_real_last, __comp);
        return __result_real_last;
    }
    template<typename _RandomAccessIterator, typename _Tp >
    void __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val)
    {
        _RandomAccessIterator __next = __last;
        --__next;
        while (__val < *__next)
        {
            *__last = *__next;
            __last = __next;
            --__next;
        }
        *__last = __val;
    }
    template<typename _RandomAccessIterator, typename _Tp, typename _Compare >
    void __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val, _Compare __comp)
    {
        _RandomAccessIterator __next = __last;
        --__next;
        while (__comp(__val, *__next))
        {
            *__last = *__next;
            __last = __next;
            --__next;
        }
        *__last = __val;
    }
    template<typename _RandomAccessIterator >
    void __insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
        if (__first == __last)
            return;
        for (_RandomAccessIterator __i = __first + 1;
            __i != __last;
            ++__i)
        {
            typename iterator_traits< _RandomAccessIterator >::value_type __val = *__i;
            if (__val < *__first)
            {
                std::copy_backward(__first, __i, __i + 1);
                *__first = __val;
            }
            else
                std::__unguarded_linear_insert(__i, __val);
        }
    }
    template<typename _RandomAccessIterator, typename _Compare >
    void __insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
    {
        if (__first == __last)
            return;
        for (_RandomAccessIterator __i = __first + 1;
            __i != __last;
            ++__i)
        {
            typename iterator_traits< _RandomAccessIterator >::value_type __val = *__i;
            if (__comp(__val, *__first))
            {
                std::copy_backward(__first, __i, __i + 1);
                *__first = __val;
            }
            else
                std::__unguarded_linear_insert(__i, __val, __comp);
        }
    }
    template<typename _RandomAccessIterator >
    inline void __unguarded_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        for (_RandomAccessIterator __i = __first;
            __i != __last;
            ++__i)
        std::__unguarded_linear_insert(__i, _ValueType(*__i));
    }
    template<typename _RandomAccessIterator, typename _Compare >
    inline void __unguarded_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        for (_RandomAccessIterator __i = __first;
            __i != __last;
            ++__i)
        std::__unguarded_linear_insert(__i, _ValueType(*__i), __comp);
    }
    enum 
    {
        _S_threshold = 16
    };
    template<typename _RandomAccessIterator >
    void __final_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
        if (__last - __first > int(_S_threshold))
        {
            std::__insertion_sort(__first, __first + int(_S_threshold));
            std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
        }
        else
            std::__insertion_sort(__first, __last);
    }
    template<typename _RandomAccessIterator, typename _Compare >
    void __final_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
    {
        if (__last - __first > int(_S_threshold))
        {
            std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
            std::__unguarded_insertion_sort(__first + int(_S_threshold), __last, __comp);
        }
        else
            std::__insertion_sort(__first, __last, __comp);
    }
    template<typename _RandomAccessIterator, typename _Tp >
    _RandomAccessIterator __unguarded_partition(_RandomAccessIterator __first, _RandomAccessIterator __last, _Tp __pivot)
    {
        while (true)
        {
            while (*__first < __pivot)
                ++__first;
            --__last;
            while (__pivot < *__last)
                --__last;
            if (!(__first < __last))
                return __first;
            std::iter_swap(__first, __last);
            ++__first;
        }
    }
    template<typename _RandomAccessIterator, typename _Tp, typename _Compare >
    _RandomAccessIterator __unguarded_partition(_RandomAccessIterator __first, _RandomAccessIterator __last, _Tp __pivot, _Compare __comp)
    {
        while (true)
        {
            while (__comp(*__first, __pivot))
                ++__first;
            --__last;
            while (__comp(__pivot, *__last))
                --__last;
            if (!(__first < __last))
                return __first;
            std::iter_swap(__first, __last);
            ++__first;
        }
    }
    template<typename _RandomAccessIterator, typename _Size >
    void __introsort_loop(_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        while (__last - __first > int(_S_threshold))
        {
            if (__depth_limit == 0)
            {
                std::partial_sort(__first, __last, __last);
                return;
            }
            --__depth_limit;
            _RandomAccessIterator __cut = std::__unguarded_partition(__first, __last, _ValueType(std::__median(*__first, *(__first + (__last - __first) / 2), *(__last - 1))));
            std::__introsort_loop(__cut, __last, __depth_limit);
            __last = __cut;
        }
    }
    template<typename _RandomAccessIterator, typename _Size, typename _Compare >
    void __introsort_loop(_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        while (__last - __first > int(_S_threshold))
        {
            if (__depth_limit == 0)
            {
                std::partial_sort(__first, __last, __last, __comp);
                return;
            }
            --__depth_limit;
            _RandomAccessIterator __cut = std::__unguarded_partition(__first, __last, _ValueType(std::__median(*__first, *(__first + (__last - __first) / 2), *(__last - 1), __comp)), __comp);
            std::__introsort_loop(__cut, __last, __depth_limit, __comp);
            __last = __cut;
        }
    }
    template<typename _Size >
    inline _Size __lg(_Size __n)
    {
        _Size __k;
        for (__k = 0;
            __n != 0;
            __n >>= 1)
        ++__k;
        return __k - 1;
    }
    inline int __lg(int __n)
    {
        return sizeof(int) * 8 - 1 - __builtin_clz(__n);
    }
    inline long __lg(long __n)
    {
        return sizeof(long) * 8 - 1 - __builtin_clzl(__n);
    }
    inline long long __lg(long long __n)
    {
        return sizeof(long long) * 8 - 1 - __builtin_clzll(__n);
    }
    template<typename _RandomAccessIterator, typename _Size >
    void __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Size __depth_limit)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        while (__last - __first > 3)
        {
            if (__depth_limit == 0)
            {
                std::__heap_select(__first, __nth + 1, __last);
                std::iter_swap(__first, __nth);
                return;
            }
            --__depth_limit;
            _RandomAccessIterator __cut = std::__unguarded_partition(__first, __last, _ValueType(std::__median(*__first, *(__first + (__last - __first) / 2), *(__last - 1))));
            if (__cut <= __nth)
                __first = __cut;
            else
                __last = __cut;
        }
        std::__insertion_sort(__first, __last);
    }
    template<typename _RandomAccessIterator, typename _Size, typename _Compare >
    void __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        while (__last - __first > 3)
        {
            if (__depth_limit == 0)
            {
                std::__heap_select(__first, __nth + 1, __last, __comp);
                std::iter_swap(__first, __nth);
                return;
            }
            --__depth_limit;
            _RandomAccessIterator __cut = std::__unguarded_partition(__first, __last, _ValueType(std::__median(*__first, *(__first + (__last - __first) / 2), *(__last - 1), __comp)), __comp);
            if (__cut <= __nth)
                __first = __cut;
            else
                __last = __cut;
        }
        std::__insertion_sort(__first, __last, __comp);
    }
    template<typename _ForwardIterator, typename _Tp >
    _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __val)
    {
        typedef typename iterator_traits< _ForwardIterator >::value_type _ValueType;
        typedef typename iterator_traits< _ForwardIterator >::difference_type _DistanceType;
        ;
        _DistanceType __len = std::distance(__first, __last);
        _DistanceType __half;
        _ForwardIterator __middle;
        while (__len > 0)
        {
            __half = __len >> 1;
            __middle = __first;
            std::advance(__middle, __half);
            if (*__middle < __val)
            {
                __first = __middle;
                ++__first;
                __len = __len - __half - 1;
            }
            else
                __len = __half;
        }
        return __first;
    }
    template<typename _ForwardIterator, typename _Tp, typename _Compare >
    _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __val, _Compare __comp)
    {
        typedef typename iterator_traits< _ForwardIterator >::value_type _ValueType;
        typedef typename iterator_traits< _ForwardIterator >::difference_type _DistanceType;
        ;
        _DistanceType __len = std::distance(__first, __last);
        _DistanceType __half;
        _ForwardIterator __middle;
        while (__len > 0)
        {
            __half = __len >> 1;
            __middle = __first;
            std::advance(__middle, __half);
            if (__comp(*__middle, __val))
            {
                __first = __middle;
                ++__first;
                __len = __len - __half - 1;
            }
            else
                __len = __half;
        }
        return __first;
    }
    template<typename _ForwardIterator, typename _Tp >
    _ForwardIterator upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __val)
    {
        typedef typename iterator_traits< _ForwardIterator >::value_type _ValueType;
        typedef typename iterator_traits< _ForwardIterator >::difference_type _DistanceType;
        ;
        _DistanceType __len = std::distance(__first, __last);
        _DistanceType __half;
        _ForwardIterator __middle;
        while (__len > 0)
        {
            __half = __len >> 1;
            __middle = __first;
            std::advance(__middle, __half);
            if (__val < *__middle)
                __len = __half;
            else
            {
                __first = __middle;
                ++__first;
                __len = __len - __half - 1;
            }
        }
        return __first;
    }
    template<typename _ForwardIterator, typename _Tp, typename _Compare >
    _ForwardIterator upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __val, _Compare __comp)
    {
        typedef typename iterator_traits< _ForwardIterator >::value_type _ValueType;
        typedef typename iterator_traits< _ForwardIterator >::difference_type _DistanceType;
        ;
        _DistanceType __len = std::distance(__first, __last);
        _DistanceType __half;
        _ForwardIterator __middle;
        while (__len > 0)
        {
            __half = __len >> 1;
            __middle = __first;
            std::advance(__middle, __half);
            if (__comp(__val, *__middle))
                __len = __half;
            else
            {
                __first = __middle;
                ++__first;
                __len = __len - __half - 1;
            }
        }
        return __first;
    }
    template<typename _ForwardIterator, typename _Tp >
    pair< _ForwardIterator, _ForwardIterator > equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __val)
    {
        typedef typename iterator_traits< _ForwardIterator >::value_type _ValueType;
        typedef typename iterator_traits< _ForwardIterator >::difference_type _DistanceType;
        ;
        ;
        _DistanceType __len = std::distance(__first, __last);
        _DistanceType __half;
        _ForwardIterator __middle, __left, __right;
        while (__len > 0)
        {
            __half = __len >> 1;
            __middle = __first;
            std::advance(__middle, __half);
            if (*__middle < __val)
            {
                __first = __middle;
                ++__first;
                __len = __len - __half - 1;
            }
            else
                if (__val < *__middle)
                    __len = __half;
                else
                {
                    __left = std::lower_bound(__first, __middle, __val);
                    std::advance(__first, __len);
                    __right = std::upper_bound(++__middle, __first, __val);
                    return pair< _ForwardIterator, _ForwardIterator >(__left, __right);
                }
        }
        return pair< _ForwardIterator, _ForwardIterator >(__first, __first);
    }
    template<typename _ForwardIterator, typename _Tp, typename _Compare >
    pair< _ForwardIterator, _ForwardIterator > equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __val, _Compare __comp)
    {
        typedef typename iterator_traits< _ForwardIterator >::value_type _ValueType;
        typedef typename iterator_traits< _ForwardIterator >::difference_type _DistanceType;
        ;
        ;
        _DistanceType __len = std::distance(__first, __last);
        _DistanceType __half;
        _ForwardIterator __middle, __left, __right;
        while (__len > 0)
        {
            __half = __len >> 1;
            __middle = __first;
            std::advance(__middle, __half);
            if (__comp(*__middle, __val))
            {
                __first = __middle;
                ++__first;
                __len = __len - __half - 1;
            }
            else
                if (__comp(__val, *__middle))
                    __len = __half;
                else
                {
                    __left = std::lower_bound(__first, __middle, __val, __comp);
                    std::advance(__first, __len);
                    __right = std::upper_bound(++__middle, __first, __val, __comp);
                    return pair< _ForwardIterator, _ForwardIterator >(__left, __right);
                }
        }
        return pair< _ForwardIterator, _ForwardIterator >(__first, __first);
    }
    template<typename _ForwardIterator, typename _Tp >
    bool binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __val)
    {
        typedef typename iterator_traits< _ForwardIterator >::value_type _ValueType;
        ;
        ;
        _ForwardIterator __i = std::lower_bound(__first, __last, __val);
        return __i != __last && !(__val < *__i);
    }
    template<typename _ForwardIterator, typename _Tp, typename _Compare >
    bool binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __val, _Compare __comp)
    {
        typedef typename iterator_traits< _ForwardIterator >::value_type _ValueType;
        ;
        ;
        _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
        return __i != __last && !bool(__comp(__val, *__i));
    }
    template<typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _BidirectionalIterator3 >
    _BidirectionalIterator3 __merge_backward(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BidirectionalIterator3 __result)
    {
        if (__first1 == __last1)
            return std::copy_backward(__first2, __last2, __result);
        if (__first2 == __last2)
            return std::copy_backward(__first1, __last1, __result);
        --__last1;
        --__last2;
        while (true)
        {
            if (*__last2 < *__last1)
            {
                *--__result = *__last1;
                if (__first1 == __last1)
                    return std::copy_backward(__first2, ++__last2, __result);
                --__last1;
            }
            else
            {
                *--__result = *__last2;
                if (__first2 == __last2)
                    return std::copy_backward(__first1, ++__last1, __result);
                --__last2;
            }
        }
    }
    template<typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _BidirectionalIterator3, typename _Compare >
    _BidirectionalIterator3 __merge_backward(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BidirectionalIterator3 __result, _Compare __comp)
    {
        if (__first1 == __last1)
            return std::copy_backward(__first2, __last2, __result);
        if (__first2 == __last2)
            return std::copy_backward(__first1, __last1, __result);
        --__last1;
        --__last2;
        while (true)
        {
            if (__comp(*__last2, *__last1))
            {
                *--__result = *__last1;
                if (__first1 == __last1)
                    return std::copy_backward(__first2, ++__last2, __result);
                --__last1;
            }
            else
            {
                *--__result = *__last2;
                if (__first2 == __last2)
                    return std::copy_backward(__first1, ++__last1, __result);
                --__last2;
            }
        }
    }
    template<typename _BidirectionalIterator1, typename _BidirectionalIterator2, typename _Distance >
    _BidirectionalIterator1 __rotate_adaptive(_BidirectionalIterator1 __first, _BidirectionalIterator1 __middle, _BidirectionalIterator1 __last, _Distance __len1, _Distance __len2, _BidirectionalIterator2 __buffer, _Distance __buffer_size)
    {
        _BidirectionalIterator2 __buffer_end;
        if (__len1 > __len2 && __len2 <= __buffer_size)
        {
            __buffer_end = std::copy(__middle, __last, __buffer);
            std::copy_backward(__first, __middle, __last);
            return std::copy(__buffer, __buffer_end, __first);
        }
        else
            if (__len1 <= __buffer_size)
            {
                __buffer_end = std::copy(__first, __middle, __buffer);
                std::copy(__middle, __last, __first);
                return std::copy_backward(__buffer, __buffer_end, __last);
            }
            else
            {
                std::rotate(__first, __middle, __last);
                std::advance(__first, std::distance(__middle, __last));
                return __first;
            }
    }
    template<typename _BidirectionalIterator, typename _Distance, typename _Pointer >
    void __merge_adaptive(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size)
    {
        if (__len1 <= __len2 && __len1 <= __buffer_size)
        {
            _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
            std::merge(__buffer, __buffer_end, __middle, __last, __first);
        }
        else
            if (__len2 <= __buffer_size)
            {
                _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
                std::__merge_backward(__first, __middle, __buffer, __buffer_end, __last);
            }
            else
            {
                _BidirectionalIterator __first_cut = __first;
                _BidirectionalIterator __second_cut = __middle;
                _Distance __len11 = 0;
                _Distance __len22 = 0;
                if (__len1 > __len2)
                {
                    __len11 = __len1 / 2;
                    std::advance(__first_cut, __len11);
                    __second_cut = std::lower_bound(__middle, __last, *__first_cut);
                    __len22 = std::distance(__middle, __second_cut);
                }
                else
                {
                    __len22 = __len2 / 2;
                    std::advance(__second_cut, __len22);
                    __first_cut = std::upper_bound(__first, __middle, *__second_cut);
                    __len11 = std::distance(__first, __first_cut);
                }
                _BidirectionalIterator __new_middle = std::__rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11, __len22, __buffer, __buffer_size);
                std::__merge_adaptive(__first, __first_cut, __new_middle, __len11, __len22, __buffer, __buffer_size);
                std::__merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22, __buffer, __buffer_size);
            }
    }
    template<typename _BidirectionalIterator, typename _Distance, typename _Pointer, typename _Compare >
    void __merge_adaptive(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size, _Compare __comp)
    {
        if (__len1 <= __len2 && __len1 <= __buffer_size)
        {
            _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
            std::merge(__buffer, __buffer_end, __middle, __last, __first, __comp);
        }
        else
            if (__len2 <= __buffer_size)
            {
                _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
                std::__merge_backward(__first, __middle, __buffer, __buffer_end, __last, __comp);
            }
            else
            {
                _BidirectionalIterator __first_cut = __first;
                _BidirectionalIterator __second_cut = __middle;
                _Distance __len11 = 0;
                _Distance __len22 = 0;
                if (__len1 > __len2)
                {
                    __len11 = __len1 / 2;
                    std::advance(__first_cut, __len11);
                    __second_cut = std::lower_bound(__middle, __last, *__first_cut, __comp);
                    __len22 = std::distance(__middle, __second_cut);
                }
                else
                {
                    __len22 = __len2 / 2;
                    std::advance(__second_cut, __len22);
                    __first_cut = std::upper_bound(__first, __middle, *__second_cut, __comp);
                    __len11 = std::distance(__first, __first_cut);
                }
                _BidirectionalIterator __new_middle = std::__rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11, __len22, __buffer, __buffer_size);
                std::__merge_adaptive(__first, __first_cut, __new_middle, __len11, __len22, __buffer, __buffer_size, __comp);
                std::__merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22, __buffer, __buffer_size, __comp);
            }
    }
    template<typename _BidirectionalIterator, typename _Distance >
    void __merge_without_buffer(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2)
    {
        if (__len1 == 0 || __len2 == 0)
            return;
        if (__len1 + __len2 == 2)
        {
            if (*__middle < *__first)
                std::iter_swap(__first, __middle);
            return;
        }
        _BidirectionalIterator __first_cut = __first;
        _BidirectionalIterator __second_cut = __middle;
        _Distance __len11 = 0;
        _Distance __len22 = 0;
        if (__len1 > __len2)
        {
            __len11 = __len1 / 2;
            std::advance(__first_cut, __len11);
            __second_cut = std::lower_bound(__middle, __last, *__first_cut);
            __len22 = std::distance(__middle, __second_cut);
        }
        else
        {
            __len22 = __len2 / 2;
            std::advance(__second_cut, __len22);
            __first_cut = std::upper_bound(__first, __middle, *__second_cut);
            __len11 = std::distance(__first, __first_cut);
        }
        std::rotate(__first_cut, __middle, __second_cut);
        _BidirectionalIterator __new_middle = __first_cut;
        std::advance(__new_middle, std::distance(__middle, __second_cut));
        std::__merge_without_buffer(__first, __first_cut, __new_middle, __len11, __len22);
        std::__merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22);
    }
    template<typename _BidirectionalIterator, typename _Distance, typename _Compare >
    void __merge_without_buffer(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Compare __comp)
    {
        if (__len1 == 0 || __len2 == 0)
            return;
        if (__len1 + __len2 == 2)
        {
            if (__comp(*__middle, *__first))
                std::iter_swap(__first, __middle);
            return;
        }
        _BidirectionalIterator __first_cut = __first;
        _BidirectionalIterator __second_cut = __middle;
        _Distance __len11 = 0;
        _Distance __len22 = 0;
        if (__len1 > __len2)
        {
            __len11 = __len1 / 2;
            std::advance(__first_cut, __len11);
            __second_cut = std::lower_bound(__middle, __last, *__first_cut, __comp);
            __len22 = std::distance(__middle, __second_cut);
        }
        else
        {
            __len22 = __len2 / 2;
            std::advance(__second_cut, __len22);
            __first_cut = std::upper_bound(__first, __middle, *__second_cut, __comp);
            __len11 = std::distance(__first, __first_cut);
        }
        std::rotate(__first_cut, __middle, __second_cut);
        _BidirectionalIterator __new_middle = __first_cut;
        std::advance(__new_middle, std::distance(__middle, __second_cut));
        std::__merge_without_buffer(__first, __first_cut, __new_middle, __len11, __len22, __comp);
        std::__merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22, __comp);
    }
    template<typename _BidirectionalIterator >
    void inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
    {
        typedef typename iterator_traits< _BidirectionalIterator >::value_type _ValueType;
        typedef typename iterator_traits< _BidirectionalIterator >::difference_type _DistanceType;
        ;
        ;
        if (__first == __middle || __middle == __last)
            return;
        _DistanceType __len1 = std::distance(__first, __middle);
        _DistanceType __len2 = std::distance(__middle, __last);
        _Temporary_buffer< _BidirectionalIterator, _ValueType > __buf(__first, __last);
        if (__buf.begin() == 0)
            std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
        else
            std::__merge_adaptive(__first, __middle, __last, __len1, __len2, __buf.begin(), _DistanceType(__buf.size()));
    }
    template<typename _BidirectionalIterator, typename _Compare >
    void inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp)
    {
        typedef typename iterator_traits< _BidirectionalIterator >::value_type _ValueType;
        typedef typename iterator_traits< _BidirectionalIterator >::difference_type _DistanceType;
        ;
        ;
        if (__first == __middle || __middle == __last)
            return;
        const _DistanceType __len1 = std::distance(__first, __middle);
        const _DistanceType __len2 = std::distance(__middle, __last);
        _Temporary_buffer< _BidirectionalIterator, _ValueType > __buf(__first, __last);
        if (__buf.begin() == 0)
            std::__merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp);
        else
            std::__merge_adaptive(__first, __middle, __last, __len1, __len2, __buf.begin(), _DistanceType(__buf.size()), __comp);
    }
    template<typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _Distance >
    void __merge_sort_loop(_RandomAccessIterator1 __first, _RandomAccessIterator1 __last, _RandomAccessIterator2 __result, _Distance __step_size)
    {
        const _Distance __two_step = 2 * __step_size;
        while (__last - __first >= __two_step)
        {
            __result = std::merge(__first, __first + __step_size, __first + __step_size, __first + __two_step, __result);
            __first += __two_step;
        }
        __step_size = std::min(_Distance(__last - __first), __step_size);
        std::merge(__first, __first + __step_size, __first + __step_size, __last, __result);
    }
    template<typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename _Distance, typename _Compare >
    void __merge_sort_loop(_RandomAccessIterator1 __first, _RandomAccessIterator1 __last, _RandomAccessIterator2 __result, _Distance __step_size, _Compare __comp)
    {
        const _Distance __two_step = 2 * __step_size;
        while (__last - __first >= __two_step)
        {
            __result = std::merge(__first, __first + __step_size, __first + __step_size, __first + __two_step, __result, __comp);
            __first += __two_step;
        }
        __step_size = std::min(_Distance(__last - __first), __step_size);
        std::merge(__first, __first + __step_size, __first + __step_size, __last, __result, __comp);
    }
    template<typename _RandomAccessIterator, typename _Distance >
    void __chunk_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance __chunk_size)
    {
        while (__last - __first >= __chunk_size)
        {
            std::__insertion_sort(__first, __first + __chunk_size);
            __first += __chunk_size;
        }
        std::__insertion_sort(__first, __last);
    }
    template<typename _RandomAccessIterator, typename _Distance, typename _Compare >
    void __chunk_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance __chunk_size, _Compare __comp)
    {
        while (__last - __first >= __chunk_size)
        {
            std::__insertion_sort(__first, __first + __chunk_size, __comp);
            __first += __chunk_size;
        }
        std::__insertion_sort(__first, __last, __comp);
    }
    enum 
    {
        _S_chunk_size = 7
    };
    template<typename _RandomAccessIterator, typename _Pointer >
    void __merge_sort_with_buffer(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::difference_type _Distance;
        const _Distance __len = __last - __first;
        const _Pointer __buffer_last = __buffer + __len;
        _Distance __step_size = _S_chunk_size;
        std::__chunk_insertion_sort(__first, __last, __step_size);
        while (__step_size < __len)
        {
            std::__merge_sort_loop(__first, __last, __buffer, __step_size);
            __step_size *= 2;
            std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
            __step_size *= 2;
        }
    }
    template<typename _RandomAccessIterator, typename _Pointer, typename _Compare >
    void __merge_sort_with_buffer(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Compare __comp)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::difference_type _Distance;
        const _Distance __len = __last - __first;
        const _Pointer __buffer_last = __buffer + __len;
        _Distance __step_size = _S_chunk_size;
        std::__chunk_insertion_sort(__first, __last, __step_size, __comp);
        while (__step_size < __len)
        {
            std::__merge_sort_loop(__first, __last, __buffer, __step_size, __comp);
            __step_size *= 2;
            std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size, __comp);
            __step_size *= 2;
        }
    }
    template<typename _RandomAccessIterator, typename _Pointer, typename _Distance >
    void __stable_sort_adaptive(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Distance __buffer_size)
    {
        const _Distance __len = (__last - __first + 1) / 2;
        const _RandomAccessIterator __middle = __first + __len;
        if (__len > __buffer_size)
        {
            std::__stable_sort_adaptive(__first, __middle, __buffer, __buffer_size);
            std::__stable_sort_adaptive(__middle, __last, __buffer, __buffer_size);
        }
        else
        {
            std::__merge_sort_with_buffer(__first, __middle, __buffer);
            std::__merge_sort_with_buffer(__middle, __last, __buffer);
        }
        std::__merge_adaptive(__first, __middle, __last, _Distance(__middle - __first), _Distance(__last - __middle), __buffer, __buffer_size);
    }
    template<typename _RandomAccessIterator, typename _Pointer, typename _Distance, typename _Compare >
    void __stable_sort_adaptive(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Distance __buffer_size, _Compare __comp)
    {
        const _Distance __len = (__last - __first + 1) / 2;
        const _RandomAccessIterator __middle = __first + __len;
        if (__len > __buffer_size)
        {
            std::__stable_sort_adaptive(__first, __middle, __buffer, __buffer_size, __comp);
            std::__stable_sort_adaptive(__middle, __last, __buffer, __buffer_size, __comp);
        }
        else
        {
            std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
            std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
        }
        std::__merge_adaptive(__first, __middle, __last, _Distance(__middle - __first), _Distance(__last - __middle), __buffer, __buffer_size, __comp);
    }
    template<typename _RandomAccessIterator >
    void __inplace_stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
        if (__last - __first < 15)
        {
            std::__insertion_sort(__first, __last);
            return;
        }
        _RandomAccessIterator __middle = __first + (__last - __first) / 2;
        std::__inplace_stable_sort(__first, __middle);
        std::__inplace_stable_sort(__middle, __last);
        std::__merge_without_buffer(__first, __middle, __last, __middle - __first, __last - __middle);
    }
    template<typename _RandomAccessIterator, typename _Compare >
    void __inplace_stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
    {
        if (__last - __first < 15)
        {
            std::__insertion_sort(__first, __last, __comp);
            return;
        }
        _RandomAccessIterator __middle = __first + (__last - __first) / 2;
        std::__inplace_stable_sort(__first, __middle, __comp);
        std::__inplace_stable_sort(__middle, __last, __comp);
        std::__merge_without_buffer(__first, __middle, __last, __middle - __first, __last - __middle, __comp);
    }
    template<typename _InputIterator1, typename _InputIterator2 >
    bool includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)
    {
        typedef typename iterator_traits< _InputIterator1 >::value_type _ValueType1;
        typedef typename iterator_traits< _InputIterator2 >::value_type _ValueType2;
        ;
        ;
        while (__first1 != __last1 && __first2 != __last2)
            if (*__first2 < *__first1)
                return false;
            else
                if (*__first1 < *__first2)
                    ++__first1;
                else
                    ++__first1 , ++__first2;
        return __first2 == __last2;
    }
    template<typename _InputIterator1, typename _InputIterator2, typename _Compare >
    bool includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
    {
        typedef typename iterator_traits< _InputIterator1 >::value_type _ValueType1;
        typedef typename iterator_traits< _InputIterator2 >::value_type _ValueType2;
        ;
        ;
        while (__first1 != __last1 && __first2 != __last2)
            if (__comp(*__first2, *__first1))
                return false;
            else
                if (__comp(*__first1, *__first2))
                    ++__first1;
                else
                    ++__first1 , ++__first2;
        return __first2 == __last2;
    }
    template<typename _BidirectionalIterator >
    bool next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {
        ;
        if (__first == __last)
            return false;
        _BidirectionalIterator __i = __first;
        ++__i;
        if (__i == __last)
            return false;
        __i = __last;
        --__i;
        for (;
;
            )
        {
            _BidirectionalIterator __ii = __i;
            --__i;
            if (*__i < *__ii)
            {
                _BidirectionalIterator __j = __last;
                while (!(*__i < *--__j))
                {
                }
                std::iter_swap(__i, __j);
                std::reverse(__ii, __last);
                return true;
            }
            if (__i == __first)
            {
                std::reverse(__first, __last);
                return false;
            }
        }
    }
    template<typename _BidirectionalIterator, typename _Compare >
    bool next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
    {
        ;
        if (__first == __last)
            return false;
        _BidirectionalIterator __i = __first;
        ++__i;
        if (__i == __last)
            return false;
        __i = __last;
        --__i;
        for (;
;
            )
        {
            _BidirectionalIterator __ii = __i;
            --__i;
            if (__comp(*__i, *__ii))
            {
                _BidirectionalIterator __j = __last;
                while (!bool(__comp(*__i, *--__j)))
                {
                }
                std::iter_swap(__i, __j);
                std::reverse(__ii, __last);
                return true;
            }
            if (__i == __first)
            {
                std::reverse(__first, __last);
                return false;
            }
        }
    }
    template<typename _BidirectionalIterator >
    bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {
        ;
        if (__first == __last)
            return false;
        _BidirectionalIterator __i = __first;
        ++__i;
        if (__i == __last)
            return false;
        __i = __last;
        --__i;
        for (;
;
            )
        {
            _BidirectionalIterator __ii = __i;
            --__i;
            if (*__ii < *__i)
            {
                _BidirectionalIterator __j = __last;
                while (!(*--__j < *__i))
                {
                }
                std::iter_swap(__i, __j);
                std::reverse(__ii, __last);
                return true;
            }
            if (__i == __first)
            {
                std::reverse(__first, __last);
                return false;
            }
        }
    }
    template<typename _BidirectionalIterator, typename _Compare >
    bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
    {
        ;
        if (__first == __last)
            return false;
        _BidirectionalIterator __i = __first;
        ++__i;
        if (__i == __last)
            return false;
        __i = __last;
        --__i;
        for (;
;
            )
        {
            _BidirectionalIterator __ii = __i;
            --__i;
            if (__comp(*__ii, *__i))
            {
                _BidirectionalIterator __j = __last;
                while (!bool(__comp(*--__j, *__i)))
                {
                }
                std::iter_swap(__i, __j);
                std::reverse(__ii, __last);
                return true;
            }
            if (__i == __first)
            {
                std::reverse(__first, __last);
                return false;
            }
        }
    }
    template<typename _InputIterator, typename _OutputIterator, typename _Tp >
    _OutputIterator replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp & __old_value, const _Tp & __new_value)
    {
        ;
        for (;
            __first != __last;
            ++__first , ++__result)
        if (*__first == __old_value)
            *__result = __new_value;
        else
            *__result = *__first;
        return __result;
    }
    template<typename _InputIterator, typename _OutputIterator, typename _Predicate, typename _Tp >
    _OutputIterator replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred, const _Tp & __new_value)
    {
        ;
        for (;
            __first != __last;
            ++__first , ++__result)
        if (__pred(*__first))
            *__result = __new_value;
        else
            *__result = *__first;
        return __result;
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _InputIterator, typename _Function >
    _Function for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {
        ;
        for (;
            __first != __last;
            ++__first)
        __f(*__first);
        return __f;
    }
    template<typename _InputIterator, typename _Tp >
    inline _InputIterator find(_InputIterator __first, _InputIterator __last, const _Tp & __val)
    {
        ;
        return std::__find(__first, __last, __val, std::__iterator_category(__first));
    }
    template<typename _InputIterator, typename _Predicate >
    inline _InputIterator find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
        ;
        return std::__find_if(__first, __last, __pred, std::__iterator_category(__first));
    }
    template<typename _InputIterator, typename _ForwardIterator >
    _InputIterator find_first_of(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2)
    {
        ;
        ;
        for (;
            __first1 != __last1;
            ++__first1)
        for (_ForwardIterator __iter = __first2;
            __iter != __last2;
            ++__iter)
        if (*__first1 == *__iter)
            return __first1;
        return __last1;
    }
    template<typename _InputIterator, typename _ForwardIterator, typename _BinaryPredicate >
    _InputIterator find_first_of(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, _BinaryPredicate __comp)
    {
        ;
        ;
        for (;
            __first1 != __last1;
            ++__first1)
        for (_ForwardIterator __iter = __first2;
            __iter != __last2;
            ++__iter)
        if (__comp(*__first1, *__iter))
            return __first1;
        return __last1;
    }
    template<typename _ForwardIterator >
    _ForwardIterator adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {
        ;
        if (__first == __last)
            return __last;
        _ForwardIterator __next = __first;
        while (++__next != __last)
        {
            if (*__first == *__next)
                return __first;
            __first = __next;
        }
        return __last;
    }
    template<typename _ForwardIterator, typename _BinaryPredicate >
    _ForwardIterator adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)
    {
        ;
        if (__first == __last)
            return __last;
        _ForwardIterator __next = __first;
        while (++__next != __last)
        {
            if (__binary_pred(*__first, *__next))
                return __first;
            __first = __next;
        }
        return __last;
    }
    template<typename _InputIterator, typename _Tp >
    typename iterator_traits< _InputIterator >::difference_type count(_InputIterator __first, _InputIterator __last, const _Tp & __value)
    {
        ;
        typename iterator_traits< _InputIterator >::difference_type __n = 0;
        for (;
            __first != __last;
            ++__first)
        if (*__first == __value)
            ++__n;
        return __n;
    }
    template<typename _InputIterator, typename _Predicate >
    typename iterator_traits< _InputIterator >::difference_type count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
        ;
        typename iterator_traits< _InputIterator >::difference_type __n = 0;
        for (;
            __first != __last;
            ++__first)
        if (__pred(*__first))
            ++__n;
        return __n;
    }
    template<typename _ForwardIterator1, typename _ForwardIterator2 >
    _ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
        ;
        ;
        if (__first1 == __last1 || __first2 == __last2)
            return __first1;
        _ForwardIterator2 __p1(__first2);
        if (++__p1 == __last2)
            return std::find(__first1, __last1, *__first2);
        _ForwardIterator2 __p;
        _ForwardIterator1 __current = __first1;
        for (;
;
            )
        {
            __first1 = std::find(__first1, __last1, *__first2);
            if (__first1 == __last1)
                return __last1;
            __p = __p1;
            __current = __first1;
            if (++__current == __last1)
                return __last1;
            while (*__current == *__p)
            {
                if (++__p == __last2)
                    return __first1;
                if (++__current == __last1)
                    return __last1;
            }
            ++__first1;
        }
        return __first1;
    }
    template<typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate >
    _ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __predicate)
    {
        ;
        ;
        if (__first1 == __last1 || __first2 == __last2)
            return __first1;
        _ForwardIterator2 __p1(__first2);
        if (++__p1 == __last2)
        {
            while (__first1 != __last1 && !bool(__predicate(*__first1, *__first2)))
                ++__first1;
            return __first1;
        }
        _ForwardIterator2 __p;
        _ForwardIterator1 __current = __first1;
        for (;
;
            )
        {
            while (__first1 != __last1 && !bool(__predicate(*__first1, *__first2)))
                ++__first1;
            if (__first1 == __last1)
                return __last1;
            __p = __p1;
            __current = __first1;
            if (++__current == __last1)
                return __last1;
            while (__predicate(*__current, *__p))
            {
                if (++__p == __last2)
                    return __first1;
                if (++__current == __last1)
                    return __last1;
            }
            ++__first1;
        }
        return __first1;
    }
    template<typename _ForwardIterator, typename _Integer, typename _Tp >
    _ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp & __val)
    {
        ;
        if (__count <= 0)
            return __first;
        if (__count == 1)
            return std::find(__first, __last, __val);
        return std::__search_n(__first, __last, __count, __val, std::__iterator_category(__first));
    }
    template<typename _ForwardIterator, typename _Integer, typename _Tp, typename _BinaryPredicate >
    _ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp & __val, _BinaryPredicate __binary_pred)
    {
        ;
        if (__count <= 0)
            return __first;
        if (__count == 1)
        {
            while (__first != __last && !bool(__binary_pred(*__first, __val)))
                ++__first;
            return __first;
        }
        return std::__search_n(__first, __last, __count, __val, __binary_pred, std::__iterator_category(__first));
    }
    template<typename _InputIterator, typename _OutputIterator, typename _UnaryOperation >
    _OutputIterator transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __unary_op)
    {
        ;
        for (;
            __first != __last;
            ++__first , ++__result)
        *__result = __unary_op(*__first);
        return __result;
    }
    template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _BinaryOperation >
    _OutputIterator transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _OutputIterator __result, _BinaryOperation __binary_op)
    {
        ;
        for (;
            __first1 != __last1;
            ++__first1 , ++__first2 , ++__result)
        *__result = __binary_op(*__first1, *__first2);
        return __result;
    }
    template<typename _ForwardIterator, typename _Tp >
    void replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp & __old_value, const _Tp & __new_value)
    {
        ;
        for (;
            __first != __last;
            ++__first)
        if (*__first == __old_value)
            *__first = __new_value;
    }
    template<typename _ForwardIterator, typename _Predicate, typename _Tp >
    void replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp & __new_value)
    {
        ;
        for (;
            __first != __last;
            ++__first)
        if (__pred(*__first))
            *__first = __new_value;
    }
    template<typename _ForwardIterator, typename _Generator >
    void generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
    {
        ;
        for (;
            __first != __last;
            ++__first)
        *__first = __gen();
    }
    template<typename _OutputIterator, typename _Size, typename _Generator >
    _OutputIterator generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {
        for (;
            __n > 0;
            --__n , ++__first)
        *__first = __gen();
        return __first;
    }
    template<typename _InputIterator, typename _OutputIterator >
    inline _OutputIterator unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
    {
        ;
        if (__first == __last)
            return __result;
        return std::__unique_copy(__first, __last, __result, std::__iterator_category(__first), std::__iterator_category(__result));
    }
    template<typename _InputIterator, typename _OutputIterator, typename _BinaryPredicate >
    inline _OutputIterator unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred)
    {
        ;
        if (__first == __last)
            return __result;
        return std::__unique_copy(__first, __last, __result, __binary_pred, std::__iterator_category(__first), std::__iterator_category(__result));
    }
    template<typename _RandomAccessIterator >
    inline void random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
        ;
        if (__first != __last)
            for (_RandomAccessIterator __i = __first + 1;
                __i != __last;
                ++__i)
            std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
    template<typename _RandomAccessIterator, typename _RandomNumberGenerator >
    void random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomNumberGenerator & __rand)
    {
        ;
        if (__first == __last)
            return;
        for (_RandomAccessIterator __i = __first + 1;
            __i != __last;
            ++__i)
        std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }
    template<typename _ForwardIterator, typename _Predicate >
    inline _ForwardIterator partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
    {
        ;
        return std::__partition(__first, __last, __pred, std::__iterator_category(__first));
    }
    template<typename _RandomAccessIterator >
    inline void partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        ;
        ;
        std::__heap_select(__first, __middle, __last);
        std::sort_heap(__first, __middle);
    }
    template<typename _RandomAccessIterator, typename _Compare >
    inline void partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        ;
        ;
        std::__heap_select(__first, __middle, __last, __comp);
        std::sort_heap(__first, __middle, __comp);
    }
    template<typename _RandomAccessIterator >
    inline void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        ;
        ;
        if (__first == __last || __nth == __last)
            return;
        std::__introselect(__first, __nth, __last, std::__lg(__last - __first) * 2);
    }
    template<typename _RandomAccessIterator, typename _Compare >
    inline void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        ;
        ;
        if (__first == __last || __nth == __last)
            return;
        std::__introselect(__first, __nth, __last, std::__lg(__last - __first) * 2, __comp);
    }
    template<typename _RandomAccessIterator >
    inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        ;
        if (__first != __last)
        {
            std::__introsort_loop(__first, __last, std::__lg(__last - __first) * 2);
            std::__final_insertion_sort(__first, __last);
        }
    }
    template<typename _RandomAccessIterator, typename _Compare >
    inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        ;
        if (__first != __last)
        {
            std::__introsort_loop(__first, __last, std::__lg(__last - __first) * 2, __comp);
            std::__final_insertion_sort(__first, __last, __comp);
        }
    }
    template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
    _OutputIterator merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
    {
        typedef typename iterator_traits< _InputIterator1 >::value_type _ValueType1;
        typedef typename iterator_traits< _InputIterator2 >::value_type _ValueType2;
        ;
        ;
        while (__first1 != __last1 && __first2 != __last2)
        {
            if (*__first2 < *__first1)
            {
                *__result = *__first2;
                ++__first2;
            }
            else
            {
                *__result = *__first1;
                ++__first1;
            }
            ++__result;
        }
        return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
    }
    template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
    _OutputIterator merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
    {
        typedef typename iterator_traits< _InputIterator1 >::value_type _ValueType1;
        typedef typename iterator_traits< _InputIterator2 >::value_type _ValueType2;
        ;
        ;
        while (__first1 != __last1 && __first2 != __last2)
        {
            if (__comp(*__first2, *__first1))
            {
                *__result = *__first2;
                ++__first2;
            }
            else
            {
                *__result = *__first1;
                ++__first1;
            }
            ++__result;
        }
        return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
    }
    template<typename _RandomAccessIterator >
    inline void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        typedef typename iterator_traits< _RandomAccessIterator >::difference_type _DistanceType;
        ;
        _Temporary_buffer< _RandomAccessIterator, _ValueType > __buf(__first, __last);
        if (__buf.begin() == 0)
            std::__inplace_stable_sort(__first, __last);
        else
            std::__stable_sort_adaptive(__first, __last, __buf.begin(), _DistanceType(__buf.size()));
    }
    template<typename _RandomAccessIterator, typename _Compare >
    inline void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
    {
        typedef typename iterator_traits< _RandomAccessIterator >::value_type _ValueType;
        typedef typename iterator_traits< _RandomAccessIterator >::difference_type _DistanceType;
        ;
        _Temporary_buffer< _RandomAccessIterator, _ValueType > __buf(__first, __last);
        if (__buf.begin() == 0)
            std::__inplace_stable_sort(__first, __last, __comp);
        else
            std::__stable_sort_adaptive(__first, __last, __buf.begin(), _DistanceType(__buf.size()), __comp);
    }
    template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
    _OutputIterator set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
    {
        typedef typename iterator_traits< _InputIterator1 >::value_type _ValueType1;
        typedef typename iterator_traits< _InputIterator2 >::value_type _ValueType2;
        ;
        ;
        while (__first1 != __last1 && __first2 != __last2)
        {
            if (*__first1 < *__first2)
            {
                *__result = *__first1;
                ++__first1;
            }
            else
                if (*__first2 < *__first1)
                {
                    *__result = *__first2;
                    ++__first2;
                }
                else
                {
                    *__result = *__first1;
                    ++__first1;
                    ++__first2;
                }
            ++__result;
        }
        return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
    }
    template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
    _OutputIterator set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
    {
        typedef typename iterator_traits< _InputIterator1 >::value_type _ValueType1;
        typedef typename iterator_traits< _InputIterator2 >::value_type _ValueType2;
        ;
        ;
        while (__first1 != __last1 && __first2 != __last2)
        {
            if (__comp(*__first1, *__first2))
            {
                *__result = *__first1;
                ++__first1;
            }
            else
                if (__comp(*__first2, *__first1))
                {
                    *__result = *__first2;
                    ++__first2;
                }
                else
                {
                    *__result = *__first1;
                    ++__first1;
                    ++__first2;
                }
            ++__result;
        }
        return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
    }
    template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
    _OutputIterator set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
    {
        typedef typename iterator_traits< _InputIterator1 >::value_type _ValueType1;
        typedef typename iterator_traits< _InputIterator2 >::value_type _ValueType2;
        ;
        ;
        while (__first1 != __last1 && __first2 != __last2)
            if (*__first1 < *__first2)
                ++__first1;
            else
                if (*__first2 < *__first1)
                    ++__first2;
                else
                {
                    *__result = *__first1;
                    ++__first1;
                    ++__first2;
                    ++__result;
                }
        return __result;
    }
    template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
    _OutputIterator set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
    {
        typedef typename iterator_traits< _InputIterator1 >::value_type _ValueType1;
        typedef typename iterator_traits< _InputIterator2 >::value_type _ValueType2;
        ;
        ;
        while (__first1 != __last1 && __first2 != __last2)
            if (__comp(*__first1, *__first2))
                ++__first1;
            else
                if (__comp(*__first2, *__first1))
                    ++__first2;
                else
                {
                    *__result = *__first1;
                    ++__first1;
                    ++__first2;
                    ++__result;
                }
        return __result;
    }
    template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
    _OutputIterator set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
    {
        typedef typename iterator_traits< _InputIterator1 >::value_type _ValueType1;
        typedef typename iterator_traits< _InputIterator2 >::value_type _ValueType2;
        ;
        ;
        while (__first1 != __last1 && __first2 != __last2)
            if (*__first1 < *__first2)
            {
                *__result = *__first1;
                ++__first1;
                ++__result;
            }
            else
                if (*__first2 < *__first1)
                    ++__first2;
                else
                {
                    ++__first1;
                    ++__first2;
                }
        return std::copy(__first1, __last1, __result);
    }
    template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
    _OutputIterator set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
    {
        typedef typename iterator_traits< _InputIterator1 >::value_type _ValueType1;
        typedef typename iterator_traits< _InputIterator2 >::value_type _ValueType2;
        ;
        ;
        while (__first1 != __last1 && __first2 != __last2)
            if (__comp(*__first1, *__first2))
            {
                *__result = *__first1;
                ++__first1;
                ++__result;
            }
            else
                if (__comp(*__first2, *__first1))
                    ++__first2;
                else
                {
                    ++__first1;
                    ++__first2;
                }
        return std::copy(__first1, __last1, __result);
    }
    template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator >
    _OutputIterator set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
    {
        typedef typename iterator_traits< _InputIterator1 >::value_type _ValueType1;
        typedef typename iterator_traits< _InputIterator2 >::value_type _ValueType2;
        ;
        ;
        while (__first1 != __last1 && __first2 != __last2)
            if (*__first1 < *__first2)
            {
                *__result = *__first1;
                ++__first1;
                ++__result;
            }
            else
                if (*__first2 < *__first1)
                {
                    *__result = *__first2;
                    ++__first2;
                    ++__result;
                }
                else
                {
                    ++__first1;
                    ++__first2;
                }
        return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
    }
    template<typename _InputIterator1, typename _InputIterator2, typename _OutputIterator, typename _Compare >
    _OutputIterator set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
    {
        typedef typename iterator_traits< _InputIterator1 >::value_type _ValueType1;
        typedef typename iterator_traits< _InputIterator2 >::value_type _ValueType2;
        ;
        ;
        while (__first1 != __last1 && __first2 != __last2)
            if (__comp(*__first1, *__first2))
            {
                *__result = *__first1;
                ++__first1;
                ++__result;
            }
            else
                if (__comp(*__first2, *__first1))
                {
                    *__result = *__first2;
                    ++__first2;
                    ++__result;
                }
                else
                {
                    ++__first1;
                    ++__first2;
                }
        return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
    }
    template<typename _ForwardIterator >
    _ForwardIterator min_element(_ForwardIterator __first, _ForwardIterator __last)
    {
        ;
        if (__first == __last)
            return __first;
        _ForwardIterator __result = __first;
        while (++__first != __last)
            if (*__first < *__result)
                __result = __first;
        return __result;
    }
    template<typename _ForwardIterator, typename _Compare >
    _ForwardIterator min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
    {
        ;
        if (__first == __last)
            return __first;
        _ForwardIterator __result = __first;
        while (++__first != __last)
            if (__comp(*__first, *__result))
                __result = __first;
        return __result;
    }
    template<typename _ForwardIterator >
    _ForwardIterator max_element(_ForwardIterator __first, _ForwardIterator __last)
    {
        ;
        if (__first == __last)
            return __first;
        _ForwardIterator __result = __first;
        while (++__first != __last)
            if (*__result < *__first)
                __result = __first;
        return __result;
    }
    template<typename _ForwardIterator, typename _Compare >
    _ForwardIterator max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
    {
        ;
        if (__first == __last)
            return __first;
        _ForwardIterator __result = __first;
        while (++__first != __last)
            if (__comp(*__result, *__first))
                __result = __first;
        return __result;
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Alloc >
    class allocator;
    template<class _CharT >
    struct char_traits;
    template<typename _CharT, typename _Traits = char_traits< _CharT >, typename _Alloc = allocator< _CharT > >
    class basic_string;
    template<>
    struct char_traits< char >;
    typedef basic_string< char > string;
    template<>
    struct char_traits< wchar_t >;
    typedef basic_string< wchar_t > wstring;
}
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef struct _IO_FILE __FILE;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned int wint_t;
typedef struct 
{
        int __count;
        union 
        {
                unsigned int __wch;
                char __wchb[4];
        } __value;
} __mbstate_t;
typedef __mbstate_t mbstate_t;
extern "C"
{
    struct tm;
    extern wchar_t * wcscpy(wchar_t *__restrict __dest, __const wchar_t *__restrict __src) throw ();
    extern wchar_t * wcsncpy(wchar_t *__restrict __dest, __const wchar_t *__restrict __src, size_t __n) throw ();
    extern wchar_t * wcscat(wchar_t *__restrict __dest, __const wchar_t *__restrict __src) throw ();
    extern wchar_t * wcsncat(wchar_t *__restrict __dest, __const wchar_t *__restrict __src, size_t __n) throw ();
    extern int wcscmp(__const wchar_t * __s1, __const wchar_t * __s2) throw () __attribute__((__pure__));
    extern int wcsncmp(__const wchar_t * __s1, __const wchar_t * __s2, size_t __n) throw () __attribute__((__pure__));
    extern int wcscasecmp(__const wchar_t * __s1, __const wchar_t * __s2) throw ();
    extern int wcsncasecmp(__const wchar_t * __s1, __const wchar_t * __s2, size_t __n) throw ();
    extern int wcscasecmp_l(__const wchar_t * __s1, __const wchar_t * __s2, __locale_t __loc) throw ();
    extern int wcsncasecmp_l(__const wchar_t * __s1, __const wchar_t * __s2, size_t __n, __locale_t __loc) throw ();
    extern int wcscoll(__const wchar_t * __s1, __const wchar_t * __s2) throw ();
    extern size_t wcsxfrm(wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n) throw ();
    extern int wcscoll_l(__const wchar_t * __s1, __const wchar_t * __s2, __locale_t __loc) throw ();
    extern size_t wcsxfrm_l(wchar_t * __s1, __const wchar_t * __s2, size_t __n, __locale_t __loc) throw ();
    extern wchar_t * wcsdup(__const wchar_t * __s) throw () __attribute__((__malloc__));
    extern wchar_t * wcschr(__const wchar_t * __wcs, wchar_t __wc) throw () __attribute__((__pure__));
    extern wchar_t * wcsrchr(__const wchar_t * __wcs, wchar_t __wc) throw () __attribute__((__pure__));
    extern wchar_t * wcschrnul(__const wchar_t * __s, wchar_t __wc) throw () __attribute__((__pure__));
    extern size_t wcscspn(__const wchar_t * __wcs, __const wchar_t * __reject) throw () __attribute__((__pure__));
    extern size_t wcsspn(__const wchar_t * __wcs, __const wchar_t * __accept) throw () __attribute__((__pure__));
    extern wchar_t * wcspbrk(__const wchar_t * __wcs, __const wchar_t * __accept) throw () __attribute__((__pure__));
    extern wchar_t * wcsstr(__const wchar_t * __haystack, __const wchar_t * __needle) throw () __attribute__((__pure__));
    extern wchar_t * wcstok(wchar_t *__restrict __s, __const wchar_t *__restrict __delim, wchar_t * *__restrict __ptr) throw ();
    extern size_t wcslen(__const wchar_t * __s) throw () __attribute__((__pure__));
    extern wchar_t * wcswcs(__const wchar_t * __haystack, __const wchar_t * __needle) throw () __attribute__((__pure__));
    extern size_t wcsnlen(__const wchar_t * __s, size_t __maxlen) throw () __attribute__((__pure__));
    extern wchar_t * wmemchr(__const wchar_t * __s, wchar_t __c, size_t __n) throw () __attribute__((__pure__));
    extern int wmemcmp(__const wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n) throw () __attribute__((__pure__));
    extern wchar_t * wmemcpy(wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n) throw ();
    extern wchar_t * wmemmove(wchar_t * __s1, __const wchar_t * __s2, size_t __n) throw ();
    extern wchar_t * wmemset(wchar_t * __s, wchar_t __c, size_t __n) throw ();
    extern wchar_t * wmempcpy(wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n) throw ();
    extern wint_t btowc(int __c) throw ();
    extern int wctob(wint_t __c) throw ();
    extern int mbsinit(__const mbstate_t * __ps) throw () __attribute__((__pure__));
    extern size_t mbrtowc(wchar_t *__restrict __pwc, __const char *__restrict __s, size_t __n, mbstate_t * __p) throw ();
    extern size_t wcrtomb(char *__restrict __s, wchar_t __wc, mbstate_t *__restrict __ps) throw ();
    extern size_t __mbrlen(__const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw ();
    extern size_t mbrlen(__const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw ();
    extern size_t mbsrtowcs(wchar_t *__restrict __dst, __const char * *__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw ();
    extern size_t wcsrtombs(char *__restrict __dst, __const wchar_t * *__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw ();
    extern size_t mbsnrtowcs(wchar_t *__restrict __dst, __const char * *__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps) throw ();
    extern size_t wcsnrtombs(char *__restrict __dst, __const wchar_t * *__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps) throw ();
    extern int wcwidth(wchar_t __c) throw ();
    extern int wcswidth(__const wchar_t * __s, size_t __n) throw ();
    extern double wcstod(__const wchar_t *__restrict __nptr, wchar_t * *__restrict __endptr) throw ();
    extern float wcstof(__const wchar_t *__restrict __nptr, wchar_t * *__restrict __endptr) throw ();
    extern long double wcstold(__const wchar_t *__restrict __nptr, wchar_t * *__restrict __endptr) throw ();
    extern long int wcstol(__const wchar_t *__restrict __nptr, wchar_t * *__restrict __endptr, int __base) throw ();
    extern unsigned long int wcstoul(__const wchar_t *__restrict __nptr, wchar_t * *__restrict __endptr, int __base) throw ();
    __extension__
    extern long long int wcstoll(__const wchar_t *__restrict __nptr, wchar_t * *__restrict __endptr, int __base) throw ();
    __extension__
    extern unsigned long long int wcstoull(__const wchar_t *__restrict __nptr, wchar_t * *__restrict __endptr, int __base) throw ();
    __extension__
    extern long long int wcstoq(__const wchar_t *__restrict __nptr, wchar_t * *__restrict __endptr, int __base) throw ();
    __extension__
    extern unsigned long long int wcstouq(__const wchar_t *__restrict __nptr, wchar_t * *__restrict __endptr, int __base) throw ();
    extern long int wcstol_l(__const wchar_t *__restrict __nptr, wchar_t * *__restrict __endptr, int __base, __locale_t __loc) throw ();
    extern unsigned long int wcstoul_l(__const wchar_t *__restrict __nptr, wchar_t * *__restrict __endptr, int __base, __locale_t __loc) throw ();
    __extension__
    extern long long int wcstoll_l(__const wchar_t *__restrict __nptr, wchar_t * *__restrict __endptr, int __base, __locale_t __loc) throw ();
    __extension__
    extern unsigned long long int wcstoull_l(__const wchar_t *__restrict __nptr, wchar_t * *__restrict __endptr, int __base, __locale_t __loc) throw ();
    extern double wcstod_l(__const wchar_t *__restrict __nptr, wchar_t * *__restrict __endptr, __locale_t __loc) throw ();
    extern float wcstof_l(__const wchar_t *__restrict __nptr, wchar_t * *__restrict __endptr, __locale_t __loc) throw ();
    extern long double wcstold_l(__const wchar_t *__restrict __nptr, wchar_t * *__restrict __endptr, __locale_t __loc) throw ();
    extern wchar_t * wcpcpy(wchar_t * __dest, __const wchar_t * __src) throw ();
    extern wchar_t * wcpncpy(wchar_t * __dest, __const wchar_t * __src, size_t __n) throw ();
    extern __FILE * open_wmemstream(wchar_t * * __bufloc, size_t * __sizeloc) throw ();
    extern int fwide(__FILE * __fp, int __mode) throw ();
    extern int fwprintf(__FILE *__restrict __stream, __const wchar_t *__restrict __format, ...);
    extern int wprintf(__const wchar_t *__restrict __format, ...);
    extern int swprintf(wchar_t *__restrict __s, size_t __n, __const wchar_t *__restrict __format, ...) throw ();
    extern int vfwprintf(__FILE *__restrict __s, __const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vwprintf(__const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vswprintf(wchar_t *__restrict __s, size_t __n, __const wchar_t *__restrict __format, __gnuc_va_list __arg) throw ();
    extern int fwscanf(__FILE *__restrict __stream, __const wchar_t *__restrict __format, ...);
    extern int wscanf(__const wchar_t *__restrict __format, ...);
    extern int swscanf(__const wchar_t *__restrict __s, __const wchar_t *__restrict __format, ...) throw ();
    extern int vfwscanf(__FILE *__restrict __s, __const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vwscanf(__const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vswscanf(__const wchar_t *__restrict __s, __const wchar_t *__restrict __format, __gnuc_va_list __arg) throw ();
    extern wint_t fgetwc(__FILE * __stream);
    extern wint_t getwc(__FILE * __stream);
    extern wint_t getwchar(void);
    extern wint_t fputwc(wchar_t __wc, __FILE * __stream);
    extern wint_t putwc(wchar_t __wc, __FILE * __stream);
    extern wint_t putwchar(wchar_t __wc);
    extern wchar_t * fgetws(wchar_t *__restrict __ws, int __n, __FILE *__restrict __stream);
    extern int fputws(__const wchar_t *__restrict __ws, __FILE *__restrict __stream);
    extern wint_t ungetwc(wint_t __wc, __FILE * __stream);
    extern wint_t getwc_unlocked(__FILE * __stream);
    extern wint_t getwchar_unlocked(void);
    extern wint_t fgetwc_unlocked(__FILE * __stream);
    extern wint_t fputwc_unlocked(wchar_t __wc, __FILE * __stream);
    extern wint_t putwc_unlocked(wchar_t __wc, __FILE * __stream);
    extern wint_t putwchar_unlocked(wchar_t __wc);
    extern wchar_t * fgetws_unlocked(wchar_t *__restrict __ws, int __n, __FILE *__restrict __stream);
    extern int fputws_unlocked(__const wchar_t *__restrict __ws, __FILE *__restrict __stream);
    extern size_t wcsftime(wchar_t *__restrict __s, size_t __maxsize, __const wchar_t *__restrict __format, __const struct tm *__restrict __tp) throw ();
    extern size_t wcsftime_l(wchar_t *__restrict __s, size_t __maxsize, __const wchar_t *__restrict __format, __const struct tm *__restrict __tp, __locale_t __loc) throw ();
}
namespace std __attribute__((__visibility__("default"))) {
    using ::mbstate_t;
}
namespace std __attribute__((__visibility__("default"))) {
    using ::wint_t;
    using ::btowc;
    using ::fgetwc;
    using ::fgetws;
    using ::fputwc;
    using ::fputws;
    using ::fwide;
    using ::fwprintf;
    using ::fwscanf;
    using ::getwc;
    using ::getwchar;
    using ::mbrlen;
    using ::mbrtowc;
    using ::mbsinit;
    using ::mbsrtowcs;
    using ::putwc;
    using ::putwchar;
    using ::swprintf;
    using ::swscanf;
    using ::ungetwc;
    using ::vfwprintf;
    using ::vfwscanf;
    using ::vswprintf;
    using ::vswscanf;
    using ::vwprintf;
    using ::vwscanf;
    using ::wcrtomb;
    using ::wcscat;
    using ::wcscmp;
    using ::wcscoll;
    using ::wcscpy;
    using ::wcscspn;
    using ::wcsftime;
    using ::wcslen;
    using ::wcsncat;
    using ::wcsncmp;
    using ::wcsncpy;
    using ::wcsrtombs;
    using ::wcsspn;
    using ::wcstod;
    using ::wcstof;
    using ::wcstok;
    using ::wcstol;
    using ::wcstoul;
    using ::wcsxfrm;
    using ::wctob;
    using ::wmemcmp;
    using ::wmemcpy;
    using ::wmemmove;
    using ::wmemset;
    using ::wprintf;
    using ::wscanf;
    using ::wcschr;
    inline wchar_t * wcschr(wchar_t * __p, wchar_t __c)
    {
        return wcschr(const_cast<const wchar_t * >(__p), __c);
    }
    using ::wcspbrk;
    inline wchar_t * wcspbrk(wchar_t * __s1, const wchar_t * __s2)
    {
        return wcspbrk(const_cast<const wchar_t * >(__s1), __s2);
    }
    using ::wcsrchr;
    inline wchar_t * wcsrchr(wchar_t * __p, wchar_t __c)
    {
        return wcsrchr(const_cast<const wchar_t * >(__p), __c);
    }
    using ::wcsstr;
    inline wchar_t * wcsstr(wchar_t * __s1, const wchar_t * __s2)
    {
        return wcsstr(const_cast<const wchar_t * >(__s1), __s2);
    }
    using ::wmemchr;
    inline wchar_t * wmemchr(wchar_t * __p, wchar_t __c, size_t __n)
    {
        return wmemchr(const_cast<const wchar_t * >(__p), __c, __n);
    }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
    using ::wcstold;
    using ::wcstoll;
    using ::wcstoull;
}
namespace std __attribute__((__visibility__("default"))) {
    using ::__gnu_cxx::wcstold;
    using ::__gnu_cxx::wcstoll;
    using ::__gnu_cxx::wcstoull;
}
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long int uint64_t;
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
typedef long int int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long int uint_least64_t;
typedef signed char int_fast8_t;
typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
typedef long int intptr_t;
typedef unsigned long int uintptr_t;
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
namespace std __attribute__((__visibility__("default"))) {
    typedef int64_t streamoff;
    typedef ptrdiff_t streamsize;
    template<typename _StateT >
    class fpos
    {
        private :
            streamoff _M_off;
            _StateT _M_state;
        public :
            fpos()
                : _M_off(0), _M_state() 
            {
            }
            fpos(streamoff __off)
                : _M_off(__off), _M_state() 
            {
            }
            operator streamoff() const
            {
                return _M_off;
            }
            void state(_StateT __st)
            {
                _M_state = __st;
            }
            _StateT state() const
            {
                return _M_state;
            }
            fpos & operator +=(streamoff __off)
            {
                _M_off += __off;
                return *this;
            }
            fpos & operator -=(streamoff __off)
            {
                _M_off -= __off;
                return *this;
            }
            fpos operator +(streamoff __off) const
            {
                fpos __pos(*this);
                __pos += __off;
                return __pos;
            }
            fpos operator -(streamoff __off) const
            {
                fpos __pos(*this);
                __pos -= __off;
                return __pos;
            }
            streamoff operator -(const fpos & __other) const
            {
                return _M_off - __other._M_off;
            }
    };
    template<typename _StateT >
    inline bool operator ==(const fpos< _StateT > & __lhs, const fpos< _StateT > & __rhs)
    {
        return streamoff(__lhs) == streamoff(__rhs);
    }
    template<typename _StateT >
    inline bool operator !=(const fpos< _StateT > & __lhs, const fpos< _StateT > & __rhs)
    {
        return streamoff(__lhs) != streamoff(__rhs);
    }
    typedef fpos< mbstate_t > streampos;
    typedef fpos< mbstate_t > wstreampos;
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _CharT, typename _Traits = char_traits< _CharT > >
    class basic_ios;
    template<typename _CharT, typename _Traits = char_traits< _CharT > >
    class basic_streambuf;
    template<typename _CharT, typename _Traits = char_traits< _CharT > >
    class basic_istream;
    template<typename _CharT, typename _Traits = char_traits< _CharT > >
    class basic_ostream;
    template<typename _CharT, typename _Traits = char_traits< _CharT > >
    class basic_iostream;
    template<typename _CharT, typename _Traits = char_traits< _CharT >, typename _Alloc = allocator< _CharT > >
    class basic_stringbuf;
    template<typename _CharT, typename _Traits = char_traits< _CharT >, typename _Alloc = allocator< _CharT > >
    class basic_istringstream;
    template<typename _CharT, typename _Traits = char_traits< _CharT >, typename _Alloc = allocator< _CharT > >
    class basic_ostringstream;
    template<typename _CharT, typename _Traits = char_traits< _CharT >, typename _Alloc = allocator< _CharT > >
    class basic_stringstream;
    template<typename _CharT, typename _Traits = char_traits< _CharT > >
    class basic_filebuf;
    template<typename _CharT, typename _Traits = char_traits< _CharT > >
    class basic_ifstream;
    template<typename _CharT, typename _Traits = char_traits< _CharT > >
    class basic_ofstream;
    template<typename _CharT, typename _Traits = char_traits< _CharT > >
    class basic_fstream;
    template<typename _CharT, typename _Traits = char_traits< _CharT > >
    class istreambuf_iterator;
    template<typename _CharT, typename _Traits = char_traits< _CharT > >
    class ostreambuf_iterator;
    class ios_base;
    typedef basic_ios< char > ios;
    typedef basic_streambuf< char > streambuf;
    typedef basic_istream< char > istream;
    typedef basic_ostream< char > ostream;
    typedef basic_iostream< char > iostream;
    typedef basic_stringbuf< char > stringbuf;
    typedef basic_istringstream< char > istringstream;
    typedef basic_ostringstream< char > ostringstream;
    typedef basic_stringstream< char > stringstream;
    typedef basic_filebuf< char > filebuf;
    typedef basic_ifstream< char > ifstream;
    typedef basic_ofstream< char > ofstream;
    typedef basic_fstream< char > fstream;
    typedef basic_ios< wchar_t > wios;
    typedef basic_streambuf< wchar_t > wstreambuf;
    typedef basic_istream< wchar_t > wistream;
    typedef basic_ostream< wchar_t > wostream;
    typedef basic_iostream< wchar_t > wiostream;
    typedef basic_stringbuf< wchar_t > wstringbuf;
    typedef basic_istringstream< wchar_t > wistringstream;
    typedef basic_ostringstream< wchar_t > wostringstream;
    typedef basic_stringstream< wchar_t > wstringstream;
    typedef basic_filebuf< wchar_t > wfilebuf;
    typedef basic_ifstream< wchar_t > wifstream;
    typedef basic_ofstream< wchar_t > wofstream;
    typedef basic_fstream< wchar_t > wfstream;
}
extern "C"
{
    typedef struct 
    {
            __off_t __pos;
            __mbstate_t __state;
    } _G_fpos_t;
    typedef struct 
    {
            __off64_t __pos;
            __mbstate_t __state;
    } _G_fpos64_t;
    typedef int _G_int16_t __attribute__((__mode__(__HI__)));
    typedef int _G_int32_t __attribute__((__mode__(__SI__)));
    typedef unsigned int _G_uint16_t __attribute__((__mode__(__HI__)));
    typedef unsigned int _G_uint32_t __attribute__((__mode__(__SI__)));
    struct _IO_jump_t;
    struct _IO_FILE;
    typedef void _IO_lock_t;
    struct _IO_marker
    {
            struct _IO_marker * _next;
            struct _IO_FILE * _sbuf;
            int _pos;
    };
    enum __codecvt_result
    {
        __codecvt_ok, 
        __codecvt_partial, 
        __codecvt_error, 
        __codecvt_noconv
    };
    struct _IO_FILE
    {
            int _flags;
            char * _IO_read_ptr;
            char * _IO_read_end;
            char * _IO_read_base;
            char * _IO_write_base;
            char * _IO_write_ptr;
            char * _IO_write_end;
            char * _IO_buf_base;
            char * _IO_buf_end;
            char * _IO_save_base;
            char * _IO_backup_base;
            char * _IO_save_end;
            struct _IO_marker * _markers;
            struct _IO_FILE * _chain;
            int _fileno;
            int _flags2;
            __off_t _old_offset;
            unsigned short _cur_column;
            signed char _vtable_offset;
            char _shortbuf[1];
            _IO_lock_t * _lock;
            __off64_t _offset;
            void * __pad1;
            void * __pad2;
            void * __pad3;
            void * __pad4;
            size_t __pad5;
            int _mode;
            char _unused2[15 * sizeof(int) - 4 * sizeof(void *) - sizeof(size_t)];
    };
    struct _IO_FILE_plus;
    extern struct _IO_FILE_plus _IO_2_1_stdin_;
    extern struct _IO_FILE_plus _IO_2_1_stdout_;
    extern struct _IO_FILE_plus _IO_2_1_stderr_;
    typedef __ssize_t __io_read_fn(void * __cookie, char * __buf, size_t __nbytes);
    typedef __ssize_t __io_write_fn(void * __cookie, __const char * __buf, size_t __n);
    typedef int __io_seek_fn(void * __cookie, __off64_t * __pos, int __w);
    typedef int __io_close_fn(void * __cookie);
    typedef __io_read_fn cookie_read_function_t;
    typedef __io_write_fn cookie_write_function_t;
    typedef __io_seek_fn cookie_seek_function_t;
    typedef __io_close_fn cookie_close_function_t;
    typedef struct 
    {
            __io_read_fn * read;
            __io_write_fn * write;
            __io_seek_fn * seek;
            __io_close_fn * close;
    } _IO_cookie_io_functions_t;
    typedef _IO_cookie_io_functions_t cookie_io_functions_t;
    struct _IO_cookie_file;
    extern void _IO_cookie_init(struct _IO_cookie_file * __cfile, int __read_write, void * __cookie, _IO_cookie_io_functions_t __fns);
    extern "C"
    {
        extern int __underflow(_IO_FILE *);
        extern int __uflow(_IO_FILE *);
        extern int __overflow(_IO_FILE *, int);
        extern int _IO_getc(_IO_FILE * __fp);
        extern int _IO_putc(int __c, _IO_FILE * __fp);
        extern int _IO_feof(_IO_FILE * __fp) throw ();
        extern int _IO_ferror(_IO_FILE * __fp) throw ();
        extern int _IO_peekc_locked(_IO_FILE * __fp);
        extern void _IO_flockfile(_IO_FILE *) throw ();
        extern void _IO_funlockfile(_IO_FILE *) throw ();
        extern int _IO_ftrylockfile(_IO_FILE *) throw ();
        extern int _IO_vfscanf(_IO_FILE *__restrict, const char *__restrict, __gnuc_va_list, int *__restrict);
        extern int _IO_vfprintf(_IO_FILE *__restrict, const char *__restrict, __gnuc_va_list);
        extern __ssize_t _IO_padn(_IO_FILE *, int, __ssize_t);
        extern size_t _IO_sgetn(_IO_FILE *, void *, size_t);
        extern __off64_t _IO_seekoff(_IO_FILE *, __off64_t, int, int);
        extern __off64_t _IO_seekpos(_IO_FILE *, __off64_t, int);
        extern void _IO_free_backup_area(_IO_FILE *) throw ();
    }
    typedef __gnuc_va_list va_list;
    typedef _G_fpos_t fpos_t;
    typedef _G_fpos64_t fpos64_t;
    extern struct _IO_FILE * stdin;
    extern struct _IO_FILE * stdout;
    extern struct _IO_FILE * stderr;
    extern int remove(__const char * __filename) throw ();
    extern int rename(__const char * __old, __const char * __new) throw ();
    extern int renameat(int __oldfd, __const char * __old, int __newfd, __const char * __new) throw ();
    extern FILE * tmpfile(void);
    extern FILE * tmpfile64(void);
    extern char * tmpnam(char * __s) throw ();
    extern char * tmpnam_r(char * __s) throw ();
    extern char * tempnam(__const char * __dir, __const char * __pfx) throw () __attribute__((__malloc__));
    extern int fclose(FILE * __stream);
    extern int fflush(FILE * __stream);
    extern int fflush_unlocked(FILE * __stream);
    extern int fcloseall(void);
    extern FILE * fopen(__const char *__restrict __filename, __const char *__restrict __modes);
    extern FILE * freopen(__const char *__restrict __filename, __const char *__restrict __modes, FILE *__restrict __stream);
    extern FILE * fopen64(__const char *__restrict __filename, __const char *__restrict __modes);
    extern FILE * freopen64(__const char *__restrict __filename, __const char *__restrict __modes, FILE *__restrict __stream);
    extern FILE * fdopen(int __fd, __const char * __modes) throw ();
    extern FILE * fopencookie(void *__restrict __magic_cookie, __const char *__restrict __modes, _IO_cookie_io_functions_t __io_funcs) throw ();
    extern FILE * fmemopen(void * __s, size_t __len, __const char * __modes) throw ();
    extern FILE * open_memstream(char * * __bufloc, size_t * __sizeloc) throw ();
    extern void setbuf(FILE *__restrict __stream, char *__restrict __buf) throw ();
    extern int setvbuf(FILE *__restrict __stream, char *__restrict __buf, int __modes, size_t __n) throw ();
    extern void setbuffer(FILE *__restrict __stream, char *__restrict __buf, size_t __size) throw ();
    extern void setlinebuf(FILE * __stream) throw ();
    extern int fprintf(FILE *__restrict __stream, __const char *__restrict __format, ...);
    extern int printf(__const char *__restrict __format, ...);
    extern int sprintf(char *__restrict __s, __const char *__restrict __format, ...) throw ();
    extern int vfprintf(FILE *__restrict __s, __const char *__restrict __format, __gnuc_va_list __arg);
    extern int vprintf(__const char *__restrict __format, __gnuc_va_list __arg);
    extern int vsprintf(char *__restrict __s, __const char *__restrict __format, __gnuc_va_list __arg) throw ();
    extern int snprintf(char *__restrict __s, size_t __maxlen, __const char *__restrict __format, ...) throw () __attribute__((__format__(__printf__, 3, 4)));
    extern int vsnprintf(char *__restrict __s, size_t __maxlen, __const char *__restrict __format, __gnuc_va_list __arg) throw () __attribute__((__format__(__printf__, 3, 0)));
    extern int vasprintf(char * *__restrict __ptr, __const char *__restrict __f, __gnuc_va_list __arg) throw () __attribute__((__format__(__printf__, 2, 0)));
    extern int __asprintf(char * *__restrict __ptr, __const char *__restrict __fmt, ...) throw () __attribute__((__format__(__printf__, 2, 3)));
    extern int asprintf(char * *__restrict __ptr, __const char *__restrict __fmt, ...) throw () __attribute__((__format__(__printf__, 2, 3)));
    extern int vdprintf(int __fd, __const char *__restrict __fmt, __gnuc_va_list __arg) __attribute__((__format__(__printf__, 2, 0)));
    extern int dprintf(int __fd, __const char *__restrict __fmt, ...) __attribute__((__format__(__printf__, 2, 3)));
    extern int fscanf(FILE *__restrict __stream, __const char *__restrict __format, ...);
    extern int scanf(__const char *__restrict __format, ...);
    extern int sscanf(__const char *__restrict __s, __const char *__restrict __format, ...) throw ();
    extern int vfscanf(FILE *__restrict __s, __const char *__restrict __format, __gnuc_va_list __arg) __attribute__((__format__(__scanf__, 2, 0)));
    extern int vscanf(__const char *__restrict __format, __gnuc_va_list __arg) __attribute__((__format__(__scanf__, 1, 0)));
    extern int vsscanf(__const char *__restrict __s, __const char *__restrict __format, __gnuc_va_list __arg) throw () __attribute__((__format__(__scanf__, 2, 0)));
    extern int fgetc(FILE * __stream);
    extern int getc(FILE * __stream);
    extern int getchar(void);
    extern int getc_unlocked(FILE * __stream);
    extern int getchar_unlocked(void);
    extern int fgetc_unlocked(FILE * __stream);
    extern int fputc(int __c, FILE * __stream);
    extern int putc(int __c, FILE * __stream);
    extern int putchar(int __c);
    extern int fputc_unlocked(int __c, FILE * __stream);
    extern int putc_unlocked(int __c, FILE * __stream);
    extern int putchar_unlocked(int __c);
    extern int getw(FILE * __stream);
    extern int putw(int __w, FILE * __stream);
    extern char * fgets(char *__restrict __s, int __n, FILE *__restrict __stream);
    extern char * gets(char * __s);
    extern char * fgets_unlocked(char *__restrict __s, int __n, FILE *__restrict __stream);
    extern __ssize_t __getdelim(char * *__restrict __lineptr, size_t *__restrict __n, int __delimiter, FILE *__restrict __stream);
    extern __ssize_t getdelim(char * *__restrict __lineptr, size_t *__restrict __n, int __delimiter, FILE *__restrict __stream);
    extern __ssize_t getline(char * *__restrict __lineptr, size_t *__restrict __n, FILE *__restrict __stream);
    extern int fputs(__const char *__restrict __s, FILE *__restrict __stream);
    extern int puts(__const char * __s);
    extern int ungetc(int __c, FILE * __stream);
    extern size_t fread(void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern size_t fwrite(__const void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __s);
    extern int fputs_unlocked(__const char *__restrict __s, FILE *__restrict __stream);
    extern size_t fread_unlocked(void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern size_t fwrite_unlocked(__const void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern int fseek(FILE * __stream, long int __off, int __whence);
    extern long int ftell(FILE * __stream);
    extern void rewind(FILE * __stream);
    extern int fseeko(FILE * __stream, __off_t __off, int __whence);
    extern __off_t ftello(FILE * __stream);
    extern int fgetpos(FILE *__restrict __stream, fpos_t *__restrict __pos);
    extern int fsetpos(FILE * __stream, __const fpos_t * __pos);
    extern int fseeko64(FILE * __stream, __off64_t __off, int __whence);
    extern __off64_t ftello64(FILE * __stream);
    extern int fgetpos64(FILE *__restrict __stream, fpos64_t *__restrict __pos);
    extern int fsetpos64(FILE * __stream, __const fpos64_t * __pos);
    extern void clearerr(FILE * __stream) throw ();
    extern int feof(FILE * __stream) throw ();
    extern int ferror(FILE * __stream) throw ();
    extern void clearerr_unlocked(FILE * __stream) throw ();
    extern int feof_unlocked(FILE * __stream) throw ();
    extern int ferror_unlocked(FILE * __stream) throw ();
    extern void perror(__const char * __s);
    extern int sys_nerr;
    extern __const char *__const sys_errlist[];
    extern int _sys_nerr;
    extern __const char *__const _sys_errlist[];
    extern int fileno(FILE * __stream) throw ();
    extern int fileno_unlocked(FILE * __stream) throw ();
    extern FILE * popen(__const char * __command, __const char * __modes);
    extern int pclose(FILE * __stream);
    extern char * ctermid(char * __s) throw ();
    extern char * cuserid(char * __s);
    struct obstack;
    extern int obstack_printf(struct obstack *__restrict __obstack, __const char *__restrict __format, ...) throw () __attribute__((__format__(__printf__, 2, 3)));
    extern int obstack_vprintf(struct obstack *__restrict __obstack, __const char *__restrict __format, __gnuc_va_list __args) throw () __attribute__((__format__(__printf__, 2, 0)));
    extern void flockfile(FILE * __stream) throw ();
    extern int ftrylockfile(FILE * __stream) throw ();
    extern void funlockfile(FILE * __stream) throw ();
}
namespace std __attribute__((__visibility__("default"))) {
    using ::FILE;
    using ::fpos_t;
    using ::clearerr;
    using ::fclose;
    using ::feof;
    using ::ferror;
    using ::fflush;
    using ::fgetc;
    using ::fgetpos;
    using ::fgets;
    using ::fopen;
    using ::fprintf;
    using ::fputc;
    using ::fputs;
    using ::fread;
    using ::freopen;
    using ::fscanf;
    using ::fseek;
    using ::fsetpos;
    using ::ftell;
    using ::fwrite;
    using ::getc;
    using ::getchar;
    using ::gets;
    using ::perror;
    using ::printf;
    using ::putc;
    using ::putchar;
    using ::puts;
    using ::remove;
    using ::rename;
    using ::rewind;
    using ::scanf;
    using ::setbuf;
    using ::setvbuf;
    using ::sprintf;
    using ::sscanf;
    using ::tmpfile;
    using ::tmpnam;
    using ::ungetc;
    using ::vfprintf;
    using ::vprintf;
    using ::vsprintf;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
    using ::snprintf;
    using ::vfscanf;
    using ::vscanf;
    using ::vsnprintf;
    using ::vsscanf;
}
namespace std __attribute__((__visibility__("default"))) {
    using ::__gnu_cxx::snprintf;
    using ::__gnu_cxx::vfscanf;
    using ::__gnu_cxx::vscanf;
    using ::__gnu_cxx::vsnprintf;
    using ::__gnu_cxx::vsscanf;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
    template<typename _CharT >
    struct _Char_types
    {
            typedef unsigned long int_type;
            typedef std::streampos pos_type;
            typedef std::streamoff off_type;
            typedef std::mbstate_t state_type;
    };
    template<typename _CharT >
    struct char_traits
    {
            typedef _CharT char_type;
            typedef typename _Char_types< _CharT >::int_type int_type;
            typedef typename _Char_types< _CharT >::pos_type pos_type;
            typedef typename _Char_types< _CharT >::off_type off_type;
            typedef typename _Char_types< _CharT >::state_type state_type;
            static void assign(char_type & __c1, const char_type & __c2)
            {
                __c1 = __c2;
            }
            static bool eq(const char_type & __c1, const char_type & __c2)
            {
                return __c1 == __c2;
            }
            static bool lt(const char_type & __c1, const char_type & __c2)
            {
                return __c1 < __c2;
            }
            static int compare(const char_type * __s1, const char_type * __s2, std::size_t __n);
            static std::size_t length(const char_type * __s);
            static const char_type * find(const char_type * __s, std::size_t __n, const char_type & __a);
            static char_type * move(char_type * __s1, const char_type * __s2, std::size_t __n);
            static char_type * copy(char_type * __s1, const char_type * __s2, std::size_t __n);
            static char_type * assign(char_type * __s, std::size_t __n, char_type __a);
            static char_type to_char_type(const int_type & __c)
            {
                return static_cast<char_type >(__c);
            }
            static int_type to_int_type(const char_type & __c)
            {
                return static_cast<int_type >(__c);
            }
            static bool eq_int_type(const int_type & __c1, const int_type & __c2)
            {
                return __c1 == __c2;
            }
            static int_type eof()
            {
                return static_cast<int_type >((-1));
            }
            static int_type not_eof(const int_type & __c)
            {
                return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type());
            }
    };
    template<typename _CharT >
    int char_traits< _CharT >::compare(const char_type * __s1, const char_type * __s2, std::size_t __n)
    {
        for (std::size_t __i = 0;
            __i < __n;
            ++__i)
        if (lt(__s1[__i], __s2[__i]))
            return -1;
        else
            if (lt(__s2[__i], __s1[__i]))
                return 1;
        return 0;
    }
    template<typename _CharT >
    std::size_t char_traits< _CharT >::length(const char_type * __p)
    {
        std::size_t __i = 0;
        while (!eq(__p[__i], char_type()))
            ++__i;
        return __i;
    }
    template<typename _CharT >
    const typename char_traits< _CharT >::char_type * char_traits< _CharT >::find(const char_type * __s, std::size_t __n, const char_type & __a)
    {
        for (std::size_t __i = 0;
            __i < __n;
            ++__i)
        if (eq(__s[__i], __a))
            return __s + __i;
        return 0;
    }
    template<typename _CharT >
    typename char_traits< _CharT >::char_type * char_traits< _CharT >::move(char_type * __s1, const char_type * __s2, std::size_t __n)
    {
        return static_cast<_CharT * >(__builtin_memmove(__s1, __s2, __n * sizeof(char_type)));
    }
    template<typename _CharT >
    typename char_traits< _CharT >::char_type * char_traits< _CharT >::copy(char_type * __s1, const char_type * __s2, std::size_t __n)
    {
        std::copy(__s2, __s2 + __n, __s1);
        return __s1;
    }
    template<typename _CharT >
    typename char_traits< _CharT >::char_type * char_traits< _CharT >::assign(char_type * __s, std::size_t __n, char_type __a)
    {
        std::fill_n(__s, __n, __a);
        return __s;
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<class _CharT >
    struct char_traits : public __gnu_cxx::char_traits< _CharT >
    {
    };
    template<>
    struct char_traits< char >
    {
            typedef char char_type;
            typedef int int_type;
            typedef streampos pos_type;
            typedef streamoff off_type;
            typedef mbstate_t state_type;
            static void assign(char_type & __c1, const char_type & __c2)
            {
                __c1 = __c2;
            }
            static bool eq(const char_type & __c1, const char_type & __c2)
            {
                return __c1 == __c2;
            }
            static bool lt(const char_type & __c1, const char_type & __c2)
            {
                return __c1 < __c2;
            }
            static int compare(const char_type * __s1, const char_type * __s2, size_t __n)
            {
                return __builtin_memcmp(__s1, __s2, __n);
            }
            static size_t length(const char_type * __s)
            {
                return __builtin_strlen(__s);
            }
            static const char_type * find(const char_type * __s, size_t __n, const char_type & __a)
            {
                return static_cast<const char_type * >(__builtin_memchr(__s, __a, __n));
            }
            static char_type * move(char_type * __s1, const char_type * __s2, size_t __n)
            {
                return static_cast<char_type * >(__builtin_memmove(__s1, __s2, __n));
            }
            static char_type * copy(char_type * __s1, const char_type * __s2, size_t __n)
            {
                return static_cast<char_type * >(__builtin_memcpy(__s1, __s2, __n));
            }
            static char_type * assign(char_type * __s, size_t __n, char_type __a)
            {
                return static_cast<char_type * >(__builtin_memset(__s, __a, __n));
            }
            static char_type to_char_type(const int_type & __c)
            {
                return static_cast<char_type >(__c);
            }
            static int_type to_int_type(const char_type & __c)
            {
                return static_cast<int_type >(static_cast<unsigned char >(__c));
            }
            static bool eq_int_type(const int_type & __c1, const int_type & __c2)
            {
                return __c1 == __c2;
            }
            static int_type eof()
            {
                return static_cast<int_type >((-1));
            }
            static int_type not_eof(const int_type & __c)
            {
                return (__c == eof()) ? 0 : __c;
            }
    };
    template<>
    struct char_traits< wchar_t >
    {
            typedef wchar_t char_type;
            typedef wint_t int_type;
            typedef streamoff off_type;
            typedef wstreampos pos_type;
            typedef mbstate_t state_type;
            static void assign(char_type & __c1, const char_type & __c2)
            {
                __c1 = __c2;
            }
            static bool eq(const char_type & __c1, const char_type & __c2)
            {
                return __c1 == __c2;
            }
            static bool lt(const char_type & __c1, const char_type & __c2)
            {
                return __c1 < __c2;
            }
            static int compare(const char_type * __s1, const char_type * __s2, size_t __n)
            {
                return wmemcmp(__s1, __s2, __n);
            }
            static size_t length(const char_type * __s)
            {
                return wcslen(__s);
            }
            static const char_type * find(const char_type * __s, size_t __n, const char_type & __a)
            {
                return wmemchr(__s, __a, __n);
            }
            static char_type * move(char_type * __s1, const char_type * __s2, size_t __n)
            {
                return wmemmove(__s1, __s2, __n);
            }
            static char_type * copy(char_type * __s1, const char_type * __s2, size_t __n)
            {
                return wmemcpy(__s1, __s2, __n);
            }
            static char_type * assign(char_type * __s, size_t __n, char_type __a)
            {
                return wmemset(__s, __a, __n);
            }
            static char_type to_char_type(const int_type & __c)
            {
                return char_type(__c);
            }
            static int_type to_int_type(const char_type & __c)
            {
                return int_type(__c);
            }
            static bool eq_int_type(const int_type & __c1, const int_type & __c2)
            {
                return __c1 == __c2;
            }
            static int_type eof()
            {
                return static_cast<int_type >((0xffffffffu));
            }
            static int_type not_eof(const int_type & __c)
            {
                return eq_int_type(__c, eof()) ? 0 : __c;
            }
    };
}
enum 
{
    __LC_CTYPE = 0, 
    __LC_NUMERIC = 1, 
    __LC_TIME = 2, 
    __LC_COLLATE = 3, 
    __LC_MONETARY = 4, 
    __LC_MESSAGES = 5, 
    __LC_ALL = 6, 
    __LC_PAPER = 7, 
    __LC_NAME = 8, 
    __LC_ADDRESS = 9, 
    __LC_TELEPHONE = 10, 
    __LC_MEASUREMENT = 11, 
    __LC_IDENTIFICATION = 12
};
extern "C"
{
    struct lconv
    {
            char * decimal_point;
            char * thousands_sep;
            char * grouping;
            char * int_curr_symbol;
            char * currency_symbol;
            char * mon_decimal_point;
            char * mon_thousands_sep;
            char * mon_grouping;
            char * positive_sign;
            char * negative_sign;
            char int_frac_digits;
            char frac_digits;
            char p_cs_precedes;
            char p_sep_by_space;
            char n_cs_precedes;
            char n_sep_by_space;
            char p_sign_posn;
            char n_sign_posn;
            char int_p_cs_precedes;
            char int_p_sep_by_space;
            char int_n_cs_precedes;
            char int_n_sep_by_space;
            char int_p_sign_posn;
            char int_n_sign_posn;
    };
    extern char * setlocale(int __category, __const char * __locale) throw ();
    extern struct lconv * localeconv(void) throw ();
    typedef __locale_t locale_t;
    extern __locale_t newlocale(int __category_mask, __const char * __locale, __locale_t __base) throw ();
    extern __locale_t duplocale(__locale_t __dataset) throw ();
    extern void freelocale(__locale_t __dataset) throw ();
    extern __locale_t uselocale(__locale_t __dataset) throw ();
}
namespace std __attribute__((__visibility__("default"))) {
    using ::lconv;
    using ::setlocale;
    using ::localeconv;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
    extern "C"
    __typeof (uselocale) __uselocale;

}
namespace std __attribute__((__visibility__("default"))) {
    typedef __locale_t __c_locale;
    inline int __convert_from_v(const __c_locale & __cloc __attribute__((__unused__)), char * __out, const int __size __attribute__((__unused__)), const char * __fmt, ...)
    {
        __c_locale __old = __gnu_cxx::__uselocale(__cloc);
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);
        __builtin_va_end(__args);
        __gnu_cxx::__uselocale(__old);
        return __ret;
    }
}
extern "C"
{
    enum 
    {
        _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)), 
        _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)), 
        _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)), 
        _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)), 
        _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)), 
        _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)), 
        _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)), 
        _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)), 
        _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)), 
        _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)), 
        _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)), 
        _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
    };
    extern __const unsigned short int * * __ctype_b_loc(void) __attribute__((__const));
    extern __const __int32_t * * __ctype_tolower_loc(void) __attribute__((__const));
    extern __const __int32_t * * __ctype_toupper_loc(void) __attribute__((__const));
    extern int isalnum(int) throw ();
    extern int isalpha(int) throw ();
    extern int iscntrl(int) throw ();
    extern int isdigit(int) throw ();
    extern int islower(int) throw ();
    extern int isgraph(int) throw ();
    extern int isprint(int) throw ();
    extern int ispunct(int) throw ();
    extern int isspace(int) throw ();
    extern int isupper(int) throw ();
    extern int isxdigit(int) throw ();
    extern int tolower(int __c) throw ();
    extern int toupper(int __c) throw ();
    extern int isblank(int) throw ();
    extern int isctype(int __c, int __mask) throw ();
    extern int isascii(int __c) throw ();
    extern int toascii(int __c) throw ();
    extern int _toupper(int) throw ();
    extern int _tolower(int) throw ();
    extern int isalnum_l(int, __locale_t) throw ();
    extern int isalpha_l(int, __locale_t) throw ();
    extern int iscntrl_l(int, __locale_t) throw ();
    extern int isdigit_l(int, __locale_t) throw ();
    extern int islower_l(int, __locale_t) throw ();
    extern int isgraph_l(int, __locale_t) throw ();
    extern int isprint_l(int, __locale_t) throw ();
    extern int ispunct_l(int, __locale_t) throw ();
    extern int isspace_l(int, __locale_t) throw ();
    extern int isupper_l(int, __locale_t) throw ();
    extern int isxdigit_l(int, __locale_t) throw ();
    extern int isblank_l(int, __locale_t) throw ();
    extern int __tolower_l(int __c, __locale_t __l) throw ();
    extern int tolower_l(int __c, __locale_t __l) throw ();
    extern int __toupper_l(int __c, __locale_t __l) throw ();
    extern int toupper_l(int __c, __locale_t __l) throw ();
}
namespace std __attribute__((__visibility__("default"))) {
    using ::isalnum;
    using ::isalpha;
    using ::iscntrl;
    using ::isdigit;
    using ::isgraph;
    using ::islower;
    using ::isprint;
    using ::ispunct;
    using ::isspace;
    using ::isupper;
    using ::isxdigit;
    using ::tolower;
    using ::toupper;
}
namespace std __attribute__((__visibility__("default"))) {
    class locale;
    template<typename _Facet >
    bool has_facet(const locale &) throw ();
    template<typename _Facet >
    const _Facet & use_facet(const locale &);
    template<typename _CharT >
    bool isspace(_CharT, const locale &);
    template<typename _CharT >
    bool isprint(_CharT, const locale &);
    template<typename _CharT >
    bool iscntrl(_CharT, const locale &);
    template<typename _CharT >
    bool isupper(_CharT, const locale &);
    template<typename _CharT >
    bool islower(_CharT, const locale &);
    template<typename _CharT >
    bool isalpha(_CharT, const locale &);
    template<typename _CharT >
    bool isdigit(_CharT, const locale &);
    template<typename _CharT >
    bool ispunct(_CharT, const locale &);
    template<typename _CharT >
    bool isxdigit(_CharT, const locale &);
    template<typename _CharT >
    bool isalnum(_CharT, const locale &);
    template<typename _CharT >
    bool isgraph(_CharT, const locale &);
    template<typename _CharT >
    _CharT toupper(_CharT, const locale &);
    template<typename _CharT >
    _CharT tolower(_CharT, const locale &);
    class ctype_base;
    template<typename _CharT >
    class ctype;
    template<>
    class ctype< char >;
    template<>
    class ctype< wchar_t >;
    template<typename _CharT >
    class ctype_byname;
    class codecvt_base;
    template<typename _InternT, typename _ExternT, typename _StateT >
    class codecvt;
    template<>
    class codecvt< char, char, mbstate_t >;
    template<>
    class codecvt< wchar_t, char, mbstate_t >;
    template<typename _InternT, typename _ExternT, typename _StateT >
    class codecvt_byname;
    template<typename _CharT, typename _InIter = istreambuf_iterator< _CharT > >
    class num_get;
    template<typename _CharT, typename _OutIter = ostreambuf_iterator< _CharT > >
    class num_put;
    template<typename _CharT >
    class numpunct;
    template<typename _CharT >
    class numpunct_byname;
    template<typename _CharT >
    class collate;
    template<typename _CharT >
    class collate_byname;
    class time_base;
    template<typename _CharT, typename _InIter = istreambuf_iterator< _CharT > >
    class time_get;
    template<typename _CharT, typename _InIter = istreambuf_iterator< _CharT > >
    class time_get_byname;
    template<typename _CharT, typename _OutIter = ostreambuf_iterator< _CharT > >
    class time_put;
    template<typename _CharT, typename _OutIter = ostreambuf_iterator< _CharT > >
    class time_put_byname;
    class money_base;
    template<typename _CharT, typename _InIter = istreambuf_iterator< _CharT > >
    class money_get;
    template<typename _CharT, typename _OutIter = ostreambuf_iterator< _CharT > >
    class money_put;
    template<typename _CharT, bool _Intl = false >
    class moneypunct;
    template<typename _CharT, bool _Intl = false >
    class moneypunct_byname;
    class messages_base;
    template<typename _CharT >
    class messages;
    template<typename _CharT >
    class messages_byname;
}
#pragma GCC visibility push(default)
struct sched_param
{
        int __sched_priority;
};
extern "C"
{
    extern int clone(int (* __fn)(void * __arg), void * __child_stack, int __flags, void * __arg, ...) throw ();
    extern int unshare(int __flags) throw ();
    extern int sched_getcpu(void) throw ();
}
struct __sched_param
{
        int __sched_priority;
};
typedef unsigned long int __cpu_mask;
typedef struct 
{
        __cpu_mask __bits[1024 / (8 * sizeof(__cpu_mask))];
} cpu_set_t;
extern "C"
{
    extern int __sched_cpucount(size_t __setsize, const cpu_set_t * __setp) throw ();
    extern cpu_set_t * __sched_cpualloc(size_t __count) throw ();
    extern void __sched_cpufree(cpu_set_t * __set) throw ();
}
extern "C"
{
    extern int sched_setparam(__pid_t __pid, __const struct sched_param * __param) throw ();
    extern int sched_getparam(__pid_t __pid, struct sched_param * __param) throw ();
    extern int sched_setscheduler(__pid_t __pid, int __policy, __const struct sched_param * __param) throw ();
    extern int sched_getscheduler(__pid_t __pid) throw ();
    extern int sched_yield(void) throw ();
    extern int sched_get_priority_max(int __algorithm) throw ();
    extern int sched_get_priority_min(int __algorithm) throw ();
    extern int sched_rr_get_interval(__pid_t __pid, struct timespec * __t) throw ();
    extern int sched_setaffinity(__pid_t __pid, size_t __cpusetsize, __const cpu_set_t * __cpuset) throw ();
    extern int sched_getaffinity(__pid_t __pid, size_t __cpusetsize, cpu_set_t * __cpuset) throw ();
}
extern "C"
{
    struct tm
    {
            int tm_sec;
            int tm_min;
            int tm_hour;
            int tm_mday;
            int tm_mon;
            int tm_year;
            int tm_wday;
            int tm_yday;
            int tm_isdst;
            long int tm_gmtoff;
            __const char * tm_zone;
    };
    struct itimerspec
    {
            struct timespec it_interval;
            struct timespec it_value;
    };
    struct sigevent;
    extern clock_t clock(void) throw ();
    extern time_t time(time_t * __timer) throw ();
    extern double difftime(time_t __time1, time_t __time0) throw () __attribute__((__const__));
    extern time_t mktime(struct tm * __tp) throw ();
    extern size_t strftime(char *__restrict __s, size_t __maxsize, __const char *__restrict __format, __const struct tm *__restrict __tp) throw ();
    extern char * strptime(__const char *__restrict __s, __const char *__restrict __fmt, struct tm * __tp) throw ();
    extern size_t strftime_l(char *__restrict __s, size_t __maxsize, __const char *__restrict __format, __const struct tm *__restrict __tp, __locale_t __loc) throw ();
    extern char * strptime_l(__const char *__restrict __s, __const char *__restrict __fmt, struct tm * __tp, __locale_t __loc) throw ();
    extern struct tm * gmtime(__const time_t * __timer) throw ();
    extern struct tm * localtime(__const time_t * __timer) throw ();
    extern struct tm * gmtime_r(__const time_t *__restrict __timer, struct tm *__restrict __tp) throw ();
    extern struct tm * localtime_r(__const time_t *__restrict __timer, struct tm *__restrict __tp) throw ();
    extern char * asctime(__const struct tm * __tp) throw ();
    extern char * ctime(__const time_t * __timer) throw ();
    extern char * asctime_r(__const struct tm *__restrict __tp, char *__restrict __buf) throw ();
    extern char * ctime_r(__const time_t *__restrict __timer, char *__restrict __buf) throw ();
    extern char * __tzname[2];
    extern int __daylight;
    extern long int __timezone;
    extern char * tzname[2];
    extern void tzset(void) throw ();
    extern int daylight;
    extern long int timezone;
    extern int stime(__const time_t * __when) throw ();
    extern time_t timegm(struct tm * __tp) throw ();
    extern time_t timelocal(struct tm * __tp) throw ();
    extern int dysize(int __year) throw () __attribute__((__const__));
    extern int nanosleep(__const struct timespec * __requested_time, struct timespec * __remaining);
    extern int clock_getres(clockid_t __clock_id, struct timespec * __res) throw ();
    extern int clock_gettime(clockid_t __clock_id, struct timespec * __tp) throw ();
    extern int clock_settime(clockid_t __clock_id, __const struct timespec * __tp) throw ();
    extern int clock_nanosleep(clockid_t __clock_id, int __flags, __const struct timespec * __req, struct timespec * __rem);
    extern int clock_getcpuclockid(pid_t __pid, clockid_t * __clock_id) throw ();
    extern int timer_create(clockid_t __clock_id, struct sigevent *__restrict __evp, timer_t *__restrict __timerid) throw ();
    extern int timer_delete(timer_t __timerid) throw ();
    extern int timer_settime(timer_t __timerid, int __flags, __const struct itimerspec *__restrict __value, struct itimerspec *__restrict __ovalue) throw ();
    extern int timer_gettime(timer_t __timerid, struct itimerspec * __value) throw ();
    extern int timer_getoverrun(timer_t __timerid) throw ();
    extern int getdate_err;
    extern struct tm * getdate(__const char * __string);
    extern int getdate_r(__const char *__restrict __string, struct tm *__restrict __resbufp);
}
extern "C"
{
}
typedef long int __jmp_buf[8];
enum 
{
    PTHREAD_CREATE_JOINABLE, 
    PTHREAD_CREATE_DETACHED
};
enum 
{
    PTHREAD_MUTEX_TIMED_NP, 
    PTHREAD_MUTEX_RECURSIVE_NP, 
    PTHREAD_MUTEX_ERRORCHECK_NP, 
    PTHREAD_MUTEX_ADAPTIVE_NP, 
    PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP, 
    PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP, 
    PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP, 
    PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL, 
    PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP
};
enum 
{
    PTHREAD_MUTEX_STALLED_NP, 
    PTHREAD_MUTEX_ROBUST_NP
};
enum 
{
    PTHREAD_PRIO_NONE, 
    PTHREAD_PRIO_INHERIT, 
    PTHREAD_PRIO_PROTECT
};
enum 
{
    PTHREAD_RWLOCK_PREFER_READER_NP, 
    PTHREAD_RWLOCK_PREFER_WRITER_NP, 
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, 
    PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
enum 
{
    PTHREAD_INHERIT_SCHED, 
    PTHREAD_EXPLICIT_SCHED
};
enum 
{
    PTHREAD_SCOPE_SYSTEM, 
    PTHREAD_SCOPE_PROCESS
};
enum 
{
    PTHREAD_PROCESS_PRIVATE, 
    PTHREAD_PROCESS_SHARED
};
struct _pthread_cleanup_buffer
{
        void (* __routine)(void *);
        void * __arg;
        int __canceltype;
        struct _pthread_cleanup_buffer * __prev;
};
enum 
{
    PTHREAD_CANCEL_ENABLE, 
    PTHREAD_CANCEL_DISABLE
};
enum 
{
    PTHREAD_CANCEL_DEFERRED, 
    PTHREAD_CANCEL_ASYNCHRONOUS
};
extern "C"
{
    extern int pthread_create(pthread_t *__restrict __newthread, __const pthread_attr_t *__restrict __attr, void * (* __start_routine)(void *), void *__restrict __arg) throw () __attribute__((__nonnull__(1, 3)));
    extern void pthread_exit(void * __retval) __attribute__((__noreturn__));
    extern int pthread_join(pthread_t __th, void * * __thread_return);
    extern int pthread_tryjoin_np(pthread_t __th, void * * __thread_return) throw ();
    extern int pthread_timedjoin_np(pthread_t __th, void * * __thread_return, __const struct timespec * __abstime);
    extern int pthread_detach(pthread_t __th) throw ();
    extern pthread_t pthread_self(void) throw () __attribute__((__const__));
    extern int pthread_equal(pthread_t __thread1, pthread_t __thread2) throw ();
    extern int pthread_attr_init(pthread_attr_t * __attr) throw () __attribute__((__nonnull__(1)));
    extern int pthread_attr_destroy(pthread_attr_t * __attr) throw () __attribute__((__nonnull__(1)));
    extern int pthread_attr_getdetachstate(__const pthread_attr_t * __attr, int * __detachstate) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_attr_setdetachstate(pthread_attr_t * __attr, int __detachstate) throw () __attribute__((__nonnull__(1)));
    extern int pthread_attr_getguardsize(__const pthread_attr_t * __attr, size_t * __guardsize) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_attr_setguardsize(pthread_attr_t * __attr, size_t __guardsize) throw () __attribute__((__nonnull__(1)));
    extern int pthread_attr_getschedparam(__const pthread_attr_t *__restrict __attr, struct sched_param *__restrict __param) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_attr_setschedparam(pthread_attr_t *__restrict __attr, __const struct sched_param *__restrict __param) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_attr_getschedpolicy(__const pthread_attr_t *__restrict __attr, int *__restrict __policy) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_attr_setschedpolicy(pthread_attr_t * __attr, int __policy) throw () __attribute__((__nonnull__(1)));
    extern int pthread_attr_getinheritsched(__const pthread_attr_t *__restrict __attr, int *__restrict __inherit) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_attr_setinheritsched(pthread_attr_t * __attr, int __inherit) throw () __attribute__((__nonnull__(1)));
    extern int pthread_attr_getscope(__const pthread_attr_t *__restrict __attr, int *__restrict __scope) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_attr_setscope(pthread_attr_t * __attr, int __scope) throw () __attribute__((__nonnull__(1)));
    extern int pthread_attr_getstackaddr(__const pthread_attr_t *__restrict __attr, void * *__restrict __stackaddr) throw () __attribute__((__nonnull__(1, 2))) __attribute__((__deprecated__));
    extern int pthread_attr_setstackaddr(pthread_attr_t * __attr, void * __stackaddr) throw () __attribute__((__nonnull__(1))) __attribute__((__deprecated__));
    extern int pthread_attr_getstacksize(__const pthread_attr_t *__restrict __attr, size_t *__restrict __stacksize) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_attr_setstacksize(pthread_attr_t * __attr, size_t __stacksize) throw () __attribute__((__nonnull__(1)));
    extern int pthread_attr_getstack(__const pthread_attr_t *__restrict __attr, void * *__restrict __stackaddr, size_t *__restrict __stacksize) throw () __attribute__((__nonnull__(1, 2, 3)));
    extern int pthread_attr_setstack(pthread_attr_t * __attr, void * __stackaddr, size_t __stacksize) throw () __attribute__((__nonnull__(1)));
    extern int pthread_attr_setaffinity_np(pthread_attr_t * __attr, size_t __cpusetsize, __const cpu_set_t * __cpuset) throw () __attribute__((__nonnull__(1, 3)));
    extern int pthread_attr_getaffinity_np(__const pthread_attr_t * __attr, size_t __cpusetsize, cpu_set_t * __cpuset) throw () __attribute__((__nonnull__(1, 3)));
    extern int pthread_getattr_np(pthread_t __th, pthread_attr_t * __attr) throw () __attribute__((__nonnull__(2)));
    extern int pthread_setschedparam(pthread_t __target_thread, int __policy, __const struct sched_param * __param) throw () __attribute__((__nonnull__(3)));
    extern int pthread_getschedparam(pthread_t __target_thread, int *__restrict __policy, struct sched_param *__restrict __param) throw () __attribute__((__nonnull__(2, 3)));
    extern int pthread_setschedprio(pthread_t __target_thread, int __prio) throw ();
    extern int pthread_getconcurrency(void) throw ();
    extern int pthread_setconcurrency(int __level) throw ();
    extern int pthread_yield(void) throw ();
    extern int pthread_setaffinity_np(pthread_t __th, size_t __cpusetsize, __const cpu_set_t * __cpuset) throw () __attribute__((__nonnull__(3)));
    extern int pthread_getaffinity_np(pthread_t __th, size_t __cpusetsize, cpu_set_t * __cpuset) throw () __attribute__((__nonnull__(3)));
    extern int pthread_once(pthread_once_t * __once_control, void (* __init_routine)(void)) __attribute__((__nonnull__(1, 2)));
    extern int pthread_setcancelstate(int __state, int * __oldstate);
    extern int pthread_setcanceltype(int __type, int * __oldtype);
    extern int pthread_cancel(pthread_t __th);
    extern void pthread_testcancel(void);
    typedef struct 
    {
            struct 
            {
                    __jmp_buf __cancel_jmp_buf;
                    int __mask_was_saved;
            } __cancel_jmp_buf[1];
            void * __pad[4];
    } __pthread_unwind_buf_t __attribute__((__aligned__));
    struct __pthread_cleanup_frame
    {
            void (* __cancel_routine)(void *);
            void * __cancel_arg;
            int __do_it;
            int __cancel_type;
    };
    class __pthread_cleanup_class
    {
            void (* __cancel_routine)(void *);
            void * __cancel_arg;
            int __do_it;
            int __cancel_type;
        public :
            __pthread_cleanup_class(void (* __fct)(void *), void * __arg)
                : __cancel_routine(__fct), __cancel_arg(__arg), __do_it(1) 
            {
            }
            ~__pthread_cleanup_class()
            {
                if (__do_it)
                    __cancel_routine(__cancel_arg);
            }
            void __setdoit(int __newval)
            {
                __do_it = __newval;
            }
            void __defer()
            {
                pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &__cancel_type);
            }
            void __restore() const
            {
                pthread_setcanceltype(__cancel_type, 0);
            }
    };
    struct __jmp_buf_tag;
    extern int __sigsetjmp(struct __jmp_buf_tag * __env, int __savemask) throw ();
    extern int pthread_mutex_init(pthread_mutex_t * __mutex, __const pthread_mutexattr_t * __mutexattr) throw () __attribute__((__nonnull__(1)));
    extern int pthread_mutex_destroy(pthread_mutex_t * __mutex) throw () __attribute__((__nonnull__(1)));
    extern int pthread_mutex_trylock(pthread_mutex_t * __mutex) throw () __attribute__((__nonnull__(1)));
    extern int pthread_mutex_lock(pthread_mutex_t * __mutex) throw () __attribute__((__nonnull__(1)));
    extern int pthread_mutex_timedlock(pthread_mutex_t *__restrict __mutex, __const struct timespec *__restrict __abstime) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_mutex_unlock(pthread_mutex_t * __mutex) throw () __attribute__((__nonnull__(1)));
    extern int pthread_mutex_getprioceiling(__const pthread_mutex_t *__restrict __mutex, int *__restrict __prioceiling) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict __mutex, int __prioceiling, int *__restrict __old_ceiling) throw () __attribute__((__nonnull__(1, 3)));
    extern int pthread_mutex_consistent_np(pthread_mutex_t * __mutex) throw () __attribute__((__nonnull__(1)));
    extern int pthread_mutexattr_init(pthread_mutexattr_t * __attr) throw () __attribute__((__nonnull__(1)));
    extern int pthread_mutexattr_destroy(pthread_mutexattr_t * __attr) throw () __attribute__((__nonnull__(1)));
    extern int pthread_mutexattr_getpshared(__const pthread_mutexattr_t *__restrict __attr, int *__restrict __pshared) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_mutexattr_setpshared(pthread_mutexattr_t * __attr, int __pshared) throw () __attribute__((__nonnull__(1)));
    extern int pthread_mutexattr_gettype(__const pthread_mutexattr_t *__restrict __attr, int *__restrict __kind) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_mutexattr_settype(pthread_mutexattr_t * __attr, int __kind) throw () __attribute__((__nonnull__(1)));
    extern int pthread_mutexattr_getprotocol(__const pthread_mutexattr_t *__restrict __attr, int *__restrict __protocol) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t * __attr, int __protocol) throw () __attribute__((__nonnull__(1)));
    extern int pthread_mutexattr_getprioceiling(__const pthread_mutexattr_t *__restrict __attr, int *__restrict __prioceiling) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t * __attr, int __prioceiling) throw () __attribute__((__nonnull__(1)));
    extern int pthread_mutexattr_getrobust_np(__const pthread_mutexattr_t * __attr, int * __robustness) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_mutexattr_setrobust_np(pthread_mutexattr_t * __attr, int __robustness) throw () __attribute__((__nonnull__(1)));
    extern int pthread_rwlock_init(pthread_rwlock_t *__restrict __rwlock, __const pthread_rwlockattr_t *__restrict __attr) throw () __attribute__((__nonnull__(1)));
    extern int pthread_rwlock_destroy(pthread_rwlock_t * __rwlock) throw () __attribute__((__nonnull__(1)));
    extern int pthread_rwlock_rdlock(pthread_rwlock_t * __rwlock) throw () __attribute__((__nonnull__(1)));
    extern int pthread_rwlock_tryrdlock(pthread_rwlock_t * __rwlock) throw () __attribute__((__nonnull__(1)));
    extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict __rwlock, __const struct timespec *__restrict __abstime) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_rwlock_wrlock(pthread_rwlock_t * __rwlock) throw () __attribute__((__nonnull__(1)));
    extern int pthread_rwlock_trywrlock(pthread_rwlock_t * __rwlock) throw () __attribute__((__nonnull__(1)));
    extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict __rwlock, __const struct timespec *__restrict __abstime) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_rwlock_unlock(pthread_rwlock_t * __rwlock) throw () __attribute__((__nonnull__(1)));
    extern int pthread_rwlockattr_init(pthread_rwlockattr_t * __attr) throw () __attribute__((__nonnull__(1)));
    extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t * __attr) throw () __attribute__((__nonnull__(1)));
    extern int pthread_rwlockattr_getpshared(__const pthread_rwlockattr_t *__restrict __attr, int *__restrict __pshared) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t * __attr, int __pshared) throw () __attribute__((__nonnull__(1)));
    extern int pthread_rwlockattr_getkind_np(__const pthread_rwlockattr_t *__restrict __attr, int *__restrict __pref) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t * __attr, int __pref) throw () __attribute__((__nonnull__(1)));
    extern int pthread_cond_init(pthread_cond_t *__restrict __cond, __const pthread_condattr_t *__restrict __cond_attr) throw () __attribute__((__nonnull__(1)));
    extern int pthread_cond_destroy(pthread_cond_t * __cond) throw () __attribute__((__nonnull__(1)));
    extern int pthread_cond_signal(pthread_cond_t * __cond) throw () __attribute__((__nonnull__(1)));
    extern int pthread_cond_broadcast(pthread_cond_t * __cond) throw () __attribute__((__nonnull__(1)));
    extern int pthread_cond_wait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex) __attribute__((__nonnull__(1, 2)));
    extern int pthread_cond_timedwait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex, __const struct timespec *__restrict __abstime) __attribute__((__nonnull__(1, 2, 3)));
    extern int pthread_condattr_init(pthread_condattr_t * __attr) throw () __attribute__((__nonnull__(1)));
    extern int pthread_condattr_destroy(pthread_condattr_t * __attr) throw () __attribute__((__nonnull__(1)));
    extern int pthread_condattr_getpshared(__const pthread_condattr_t *__restrict __attr, int *__restrict __pshared) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_condattr_setpshared(pthread_condattr_t * __attr, int __pshared) throw () __attribute__((__nonnull__(1)));
    extern int pthread_condattr_getclock(__const pthread_condattr_t *__restrict __attr, __clockid_t *__restrict __clock_id) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_condattr_setclock(pthread_condattr_t * __attr, __clockid_t __clock_id) throw () __attribute__((__nonnull__(1)));
    extern int pthread_spin_init(pthread_spinlock_t * __lock, int __pshared) throw () __attribute__((__nonnull__(1)));
    extern int pthread_spin_destroy(pthread_spinlock_t * __lock) throw () __attribute__((__nonnull__(1)));
    extern int pthread_spin_lock(pthread_spinlock_t * __lock) throw () __attribute__((__nonnull__(1)));
    extern int pthread_spin_trylock(pthread_spinlock_t * __lock) throw () __attribute__((__nonnull__(1)));
    extern int pthread_spin_unlock(pthread_spinlock_t * __lock) throw () __attribute__((__nonnull__(1)));
    extern int pthread_barrier_init(pthread_barrier_t *__restrict __barrier, __const pthread_barrierattr_t *__restrict __attr, unsigned int __count) throw () __attribute__((__nonnull__(1)));
    extern int pthread_barrier_destroy(pthread_barrier_t * __barrier) throw () __attribute__((__nonnull__(1)));
    extern int pthread_barrier_wait(pthread_barrier_t * __barrier) throw () __attribute__((__nonnull__(1)));
    extern int pthread_barrierattr_init(pthread_barrierattr_t * __attr) throw () __attribute__((__nonnull__(1)));
    extern int pthread_barrierattr_destroy(pthread_barrierattr_t * __attr) throw () __attribute__((__nonnull__(1)));
    extern int pthread_barrierattr_getpshared(__const pthread_barrierattr_t *__restrict __attr, int *__restrict __pshared) throw () __attribute__((__nonnull__(1, 2)));
    extern int pthread_barrierattr_setpshared(pthread_barrierattr_t * __attr, int __pshared) throw () __attribute__((__nonnull__(1)));
    extern int pthread_key_create(pthread_key_t * __key, void (* __destr_function)(void *)) throw () __attribute__((__nonnull__(1)));
    extern int pthread_key_delete(pthread_key_t __key) throw ();
    extern void * pthread_getspecific(pthread_key_t __key) throw ();
    extern int pthread_setspecific(pthread_key_t __key, __const void * __pointer) throw ();
    extern int pthread_getcpuclockid(pthread_t __thread_id, __clockid_t * __clock_id) throw () __attribute__((__nonnull__(2)));
    extern int pthread_atfork(void (* __prepare)(void), void (* __parent)(void), void (* __child)(void)) throw ();
}
extern "C"
{
    typedef __socklen_t socklen_t;
    extern int access(__const char * __name, int __type) throw () __attribute__((__nonnull__(1)));
    extern int euidaccess(__const char * __name, int __type) throw () __attribute__((__nonnull__(1)));
    extern int eaccess(__const char * __name, int __type) throw () __attribute__((__nonnull__(1)));
    extern int faccessat(int __fd, __const char * __file, int __type, int __flag) throw () __attribute__((__nonnull__(2)));
    extern __off_t lseek(int __fd, __off_t __offset, int __whence) throw ();
    extern __off64_t lseek64(int __fd, __off64_t __offset, int __whence) throw ();
    extern int close(int __fd);
    extern ssize_t read(int __fd, void * __buf, size_t __nbytes);
    extern ssize_t write(int __fd, __const void * __buf, size_t __n);
    extern ssize_t pread(int __fd, void * __buf, size_t __nbytes, __off_t __offset);
    extern ssize_t pwrite(int __fd, __const void * __buf, size_t __n, __off_t __offset);
    extern ssize_t pread64(int __fd, void * __buf, size_t __nbytes, __off64_t __offset);
    extern ssize_t pwrite64(int __fd, __const void * __buf, size_t __n, __off64_t __offset);
    extern int pipe(int __pipedes[2]) throw ();
    extern unsigned int alarm(unsigned int __seconds) throw ();
    extern unsigned int sleep(unsigned int __seconds);
    extern __useconds_t ualarm(__useconds_t __value, __useconds_t __interval) throw ();
    extern int usleep(__useconds_t __useconds);
    extern int pause(void);
    extern int chown(__const char * __file, __uid_t __owner, __gid_t __group) throw () __attribute__((__nonnull__(1)));
    extern int fchown(int __fd, __uid_t __owner, __gid_t __group) throw ();
    extern int lchown(__const char * __file, __uid_t __owner, __gid_t __group) throw () __attribute__((__nonnull__(1)));
    extern int fchownat(int __fd, __const char * __file, __uid_t __owner, __gid_t __group, int __flag) throw () __attribute__((__nonnull__(2)));
    extern int chdir(__const char * __path) throw () __attribute__((__nonnull__(1)));
    extern int fchdir(int __fd) throw ();
    extern char * getcwd(char * __buf, size_t __size) throw ();
    extern char * get_current_dir_name(void) throw ();
    extern char * getwd(char * __buf) throw () __attribute__((__nonnull__(1))) __attribute__((__deprecated__));
    extern int dup(int __fd) throw ();
    extern int dup2(int __fd, int __fd2) throw ();
    extern char * * __environ;
    extern char * * environ;
    extern int execve(__const char * __path, char *__const __argv[], char *__const __envp[]) throw () __attribute__((__nonnull__(1)));
    extern int fexecve(int __fd, char *__const __argv[], char *__const __envp[]) throw ();
    extern int execv(__const char * __path, char *__const __argv[]) throw () __attribute__((__nonnull__(1)));
    extern int execle(__const char * __path, __const char * __arg, ...) throw () __attribute__((__nonnull__(1)));
    extern int execl(__const char * __path, __const char * __arg, ...) throw () __attribute__((__nonnull__(1)));
    extern int execvp(__const char * __file, char *__const __argv[]) throw () __attribute__((__nonnull__(1)));
    extern int execlp(__const char * __file, __const char * __arg, ...) throw () __attribute__((__nonnull__(1)));
    extern int nice(int __inc) throw ();
    extern void _exit(int __status) __attribute__((__noreturn__));
    enum 
    {
        _PC_LINK_MAX, 
        _PC_MAX_CANON, 
        _PC_MAX_INPUT, 
        _PC_NAME_MAX, 
        _PC_PATH_MAX, 
        _PC_PIPE_BUF, 
        _PC_CHOWN_RESTRICTED, 
        _PC_NO_TRUNC, 
        _PC_VDISABLE, 
        _PC_SYNC_IO, 
        _PC_ASYNC_IO, 
        _PC_PRIO_IO, 
        _PC_SOCK_MAXBUF, 
        _PC_FILESIZEBITS, 
        _PC_REC_INCR_XFER_SIZE, 
        _PC_REC_MAX_XFER_SIZE, 
        _PC_REC_MIN_XFER_SIZE, 
        _PC_REC_XFER_ALIGN, 
        _PC_ALLOC_SIZE_MIN, 
        _PC_SYMLINK_MAX, 
        _PC_2_SYMLINKS
    };
    enum 
    {
        _SC_ARG_MAX, 
        _SC_CHILD_MAX, 
        _SC_CLK_TCK, 
        _SC_NGROUPS_MAX, 
        _SC_OPEN_MAX, 
        _SC_STREAM_MAX, 
        _SC_TZNAME_MAX, 
        _SC_JOB_CONTROL, 
        _SC_SAVED_IDS, 
        _SC_REALTIME_SIGNALS, 
        _SC_PRIORITY_SCHEDULING, 
        _SC_TIMERS, 
        _SC_ASYNCHRONOUS_IO, 
        _SC_PRIORITIZED_IO, 
        _SC_SYNCHRONIZED_IO, 
        _SC_FSYNC, 
        _SC_MAPPED_FILES, 
        _SC_MEMLOCK, 
        _SC_MEMLOCK_RANGE, 
        _SC_MEMORY_PROTECTION, 
        _SC_MESSAGE_PASSING, 
        _SC_SEMAPHORES, 
        _SC_SHARED_MEMORY_OBJECTS, 
        _SC_AIO_LISTIO_MAX, 
        _SC_AIO_MAX, 
        _SC_AIO_PRIO_DELTA_MAX, 
        _SC_DELAYTIMER_MAX, 
        _SC_MQ_OPEN_MAX, 
        _SC_MQ_PRIO_MAX, 
        _SC_VERSION, 
        _SC_PAGESIZE, 
        _SC_RTSIG_MAX, 
        _SC_SEM_NSEMS_MAX, 
        _SC_SEM_VALUE_MAX, 
        _SC_SIGQUEUE_MAX, 
        _SC_TIMER_MAX, 
        _SC_BC_BASE_MAX, 
        _SC_BC_DIM_MAX, 
        _SC_BC_SCALE_MAX, 
        _SC_BC_STRING_MAX, 
        _SC_COLL_WEIGHTS_MAX, 
        _SC_EQUIV_CLASS_MAX, 
        _SC_EXPR_NEST_MAX, 
        _SC_LINE_MAX, 
        _SC_RE_DUP_MAX, 
        _SC_CHARCLASS_NAME_MAX, 
        _SC_2_VERSION, 
        _SC_2_C_BIND, 
        _SC_2_C_DEV, 
        _SC_2_FORT_DEV, 
        _SC_2_FORT_RUN, 
        _SC_2_SW_DEV, 
        _SC_2_LOCALEDEF, 
        _SC_PII, 
        _SC_PII_XTI, 
        _SC_PII_SOCKET, 
        _SC_PII_INTERNET, 
        _SC_PII_OSI, 
        _SC_POLL, 
        _SC_SELECT, 
        _SC_UIO_MAXIOV, 
        _SC_IOV_MAX = _SC_UIO_MAXIOV, 
        _SC_PII_INTERNET_STREAM, 
        _SC_PII_INTERNET_DGRAM, 
        _SC_PII_OSI_COTS, 
        _SC_PII_OSI_CLTS, 
        _SC_PII_OSI_M, 
        _SC_T_IOV_MAX, 
        _SC_THREADS, 
        _SC_THREAD_SAFE_FUNCTIONS, 
        _SC_GETGR_R_SIZE_MAX, 
        _SC_GETPW_R_SIZE_MAX, 
        _SC_LOGIN_NAME_MAX, 
        _SC_TTY_NAME_MAX, 
        _SC_THREAD_DESTRUCTOR_ITERATIONS, 
        _SC_THREAD_KEYS_MAX, 
        _SC_THREAD_STACK_MIN, 
        _SC_THREAD_THREADS_MAX, 
        _SC_THREAD_ATTR_STACKADDR, 
        _SC_THREAD_ATTR_STACKSIZE, 
        _SC_THREAD_PRIORITY_SCHEDULING, 
        _SC_THREAD_PRIO_INHERIT, 
        _SC_THREAD_PRIO_PROTECT, 
        _SC_THREAD_PROCESS_SHARED, 
        _SC_NPROCESSORS_CONF, 
        _SC_NPROCESSORS_ONLN, 
        _SC_PHYS_PAGES, 
        _SC_AVPHYS_PAGES, 
        _SC_ATEXIT_MAX, 
        _SC_PASS_MAX, 
        _SC_XOPEN_VERSION, 
        _SC_XOPEN_XCU_VERSION, 
        _SC_XOPEN_UNIX, 
        _SC_XOPEN_CRYPT, 
        _SC_XOPEN_ENH_I18N, 
        _SC_XOPEN_SHM, 
        _SC_2_CHAR_TERM, 
        _SC_2_C_VERSION, 
        _SC_2_UPE, 
        _SC_XOPEN_XPG2, 
        _SC_XOPEN_XPG3, 
        _SC_XOPEN_XPG4, 
        _SC_CHAR_BIT, 
        _SC_CHAR_MAX, 
        _SC_CHAR_MIN, 
        _SC_INT_MAX, 
        _SC_INT_MIN, 
        _SC_LONG_BIT, 
        _SC_WORD_BIT, 
        _SC_MB_LEN_MAX, 
        _SC_NZERO, 
        _SC_SSIZE_MAX, 
        _SC_SCHAR_MAX, 
        _SC_SCHAR_MIN, 
        _SC_SHRT_MAX, 
        _SC_SHRT_MIN, 
        _SC_UCHAR_MAX, 
        _SC_UINT_MAX, 
        _SC_ULONG_MAX, 
        _SC_USHRT_MAX, 
        _SC_NL_ARGMAX, 
        _SC_NL_LANGMAX, 
        _SC_NL_MSGMAX, 
        _SC_NL_NMAX, 
        _SC_NL_SETMAX, 
        _SC_NL_TEXTMAX, 
        _SC_XBS5_ILP32_OFF32, 
        _SC_XBS5_ILP32_OFFBIG, 
        _SC_XBS5_LP64_OFF64, 
        _SC_XBS5_LPBIG_OFFBIG, 
        _SC_XOPEN_LEGACY, 
        _SC_XOPEN_REALTIME, 
        _SC_XOPEN_REALTIME_THREADS, 
        _SC_ADVISORY_INFO, 
        _SC_BARRIERS, 
        _SC_BASE, 
        _SC_C_LANG_SUPPORT, 
        _SC_C_LANG_SUPPORT_R, 
        _SC_CLOCK_SELECTION, 
        _SC_CPUTIME, 
        _SC_THREAD_CPUTIME, 
        _SC_DEVICE_IO, 
        _SC_DEVICE_SPECIFIC, 
        _SC_DEVICE_SPECIFIC_R, 
        _SC_FD_MGMT, 
        _SC_FIFO, 
        _SC_PIPE, 
        _SC_FILE_ATTRIBUTES, 
        _SC_FILE_LOCKING, 
        _SC_FILE_SYSTEM, 
        _SC_MONOTONIC_CLOCK, 
        _SC_MULTI_PROCESS, 
        _SC_SINGLE_PROCESS, 
        _SC_NETWORKING, 
        _SC_READER_WRITER_LOCKS, 
        _SC_SPIN_LOCKS, 
        _SC_REGEXP, 
        _SC_REGEX_VERSION, 
        _SC_SHELL, 
        _SC_SIGNALS, 
        _SC_SPAWN, 
        _SC_SPORADIC_SERVER, 
        _SC_THREAD_SPORADIC_SERVER, 
        _SC_SYSTEM_DATABASE, 
        _SC_SYSTEM_DATABASE_R, 
        _SC_TIMEOUTS, 
        _SC_TYPED_MEMORY_OBJECTS, 
        _SC_USER_GROUPS, 
        _SC_USER_GROUPS_R, 
        _SC_2_PBS, 
        _SC_2_PBS_ACCOUNTING, 
        _SC_2_PBS_LOCATE, 
        _SC_2_PBS_MESSAGE, 
        _SC_2_PBS_TRACK, 
        _SC_SYMLOOP_MAX, 
        _SC_STREAMS, 
        _SC_2_PBS_CHECKPOINT, 
        _SC_V6_ILP32_OFF32, 
        _SC_V6_ILP32_OFFBIG, 
        _SC_V6_LP64_OFF64, 
        _SC_V6_LPBIG_OFFBIG, 
        _SC_HOST_NAME_MAX, 
        _SC_TRACE, 
        _SC_TRACE_EVENT_FILTER, 
        _SC_TRACE_INHERIT, 
        _SC_TRACE_LOG, 
        _SC_LEVEL1_ICACHE_SIZE, 
        _SC_LEVEL1_ICACHE_ASSOC, 
        _SC_LEVEL1_ICACHE_LINESIZE, 
        _SC_LEVEL1_DCACHE_SIZE, 
        _SC_LEVEL1_DCACHE_ASSOC, 
        _SC_LEVEL1_DCACHE_LINESIZE, 
        _SC_LEVEL2_CACHE_SIZE, 
        _SC_LEVEL2_CACHE_ASSOC, 
        _SC_LEVEL2_CACHE_LINESIZE, 
        _SC_LEVEL3_CACHE_SIZE, 
        _SC_LEVEL3_CACHE_ASSOC, 
        _SC_LEVEL3_CACHE_LINESIZE, 
        _SC_LEVEL4_CACHE_SIZE, 
        _SC_LEVEL4_CACHE_ASSOC, 
        _SC_LEVEL4_CACHE_LINESIZE, 
        _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50, 
        _SC_RAW_SOCKETS
    };
    enum 
    {
        _CS_PATH, 
        _CS_V6_WIDTH_RESTRICTED_ENVS, 
        _CS_GNU_LIBC_VERSION, 
        _CS_GNU_LIBPTHREAD_VERSION, 
        _CS_LFS_CFLAGS = 1000, 
        _CS_LFS_LDFLAGS, 
        _CS_LFS_LIBS, 
        _CS_LFS_LINTFLAGS, 
        _CS_LFS64_CFLAGS, 
        _CS_LFS64_LDFLAGS, 
        _CS_LFS64_LIBS, 
        _CS_LFS64_LINTFLAGS, 
        _CS_XBS5_ILP32_OFF32_CFLAGS = 1100, 
        _CS_XBS5_ILP32_OFF32_LDFLAGS, 
        _CS_XBS5_ILP32_OFF32_LIBS, 
        _CS_XBS5_ILP32_OFF32_LINTFLAGS, 
        _CS_XBS5_ILP32_OFFBIG_CFLAGS, 
        _CS_XBS5_ILP32_OFFBIG_LDFLAGS, 
        _CS_XBS5_ILP32_OFFBIG_LIBS, 
        _CS_XBS5_ILP32_OFFBIG_LINTFLAGS, 
        _CS_XBS5_LP64_OFF64_CFLAGS, 
        _CS_XBS5_LP64_OFF64_LDFLAGS, 
        _CS_XBS5_LP64_OFF64_LIBS, 
        _CS_XBS5_LP64_OFF64_LINTFLAGS, 
        _CS_XBS5_LPBIG_OFFBIG_CFLAGS, 
        _CS_XBS5_LPBIG_OFFBIG_LDFLAGS, 
        _CS_XBS5_LPBIG_OFFBIG_LIBS, 
        _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS, 
        _CS_POSIX_V6_ILP32_OFF32_CFLAGS, 
        _CS_POSIX_V6_ILP32_OFF32_LDFLAGS, 
        _CS_POSIX_V6_ILP32_OFF32_LIBS, 
        _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS, 
        _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS, 
        _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS, 
        _CS_POSIX_V6_ILP32_OFFBIG_LIBS, 
        _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS, 
        _CS_POSIX_V6_LP64_OFF64_CFLAGS, 
        _CS_POSIX_V6_LP64_OFF64_LDFLAGS, 
        _CS_POSIX_V6_LP64_OFF64_LIBS, 
        _CS_POSIX_V6_LP64_OFF64_LINTFLAGS, 
        _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS, 
        _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS, 
        _CS_POSIX_V6_LPBIG_OFFBIG_LIBS, 
        _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS
    };
    extern long int pathconf(__const char * __path, int __name) throw () __attribute__((__nonnull__(1)));
    extern long int fpathconf(int __fd, int __name) throw ();
    extern long int sysconf(int __name) throw ();
    extern size_t confstr(int __name, char * __buf, size_t __len) throw ();
    extern __pid_t getpid(void) throw ();
    extern __pid_t getppid(void) throw ();
    extern __pid_t getpgrp(void) throw ();
    extern __pid_t __getpgid(__pid_t __pid) throw ();
    extern __pid_t getpgid(__pid_t __pid) throw ();
    extern int setpgid(__pid_t __pid, __pid_t __pgid) throw ();
    extern int setpgrp(void) throw ();
    extern __pid_t setsid(void) throw ();
    extern __pid_t getsid(__pid_t __pid) throw ();
    extern __uid_t getuid(void) throw ();
    extern __uid_t geteuid(void) throw ();
    extern __gid_t getgid(void) throw ();
    extern __gid_t getegid(void) throw ();
    extern int getgroups(int __size, __gid_t __list[]) throw ();
    extern int group_member(__gid_t __gid) throw ();
    extern int setuid(__uid_t __uid) throw ();
    extern int setreuid(__uid_t __ruid, __uid_t __euid) throw ();
    extern int seteuid(__uid_t __uid) throw ();
    extern int setgid(__gid_t __gid) throw ();
    extern int setregid(__gid_t __rgid, __gid_t __egid) throw ();
    extern int setegid(__gid_t __gid) throw ();
    extern int getresuid(__uid_t * __ruid, __uid_t * __euid, __uid_t * __suid) throw ();
    extern int getresgid(__gid_t * __rgid, __gid_t * __egid, __gid_t * __sgid) throw ();
    extern int setresuid(__uid_t __ruid, __uid_t __euid, __uid_t __suid) throw ();
    extern int setresgid(__gid_t __rgid, __gid_t __egid, __gid_t __sgid) throw ();
    extern __pid_t fork(void) throw ();
    extern __pid_t vfork(void) throw ();
    extern char * ttyname(int __fd) throw ();
    extern int ttyname_r(int __fd, char * __buf, size_t __buflen) throw () __attribute__((__nonnull__(2)));
    extern int isatty(int __fd) throw ();
    extern int ttyslot(void) throw ();
    extern int link(__const char * __from, __const char * __to) throw () __attribute__((__nonnull__(1, 2)));
    extern int linkat(int __fromfd, __const char * __from, int __tofd, __const char * __to, int __flags) throw () __attribute__((__nonnull__(2, 4)));
    extern int symlink(__const char * __from, __const char * __to) throw () __attribute__((__nonnull__(1, 2)));
    extern ssize_t readlink(__const char *__restrict __path, char *__restrict __buf, size_t __len) throw () __attribute__((__nonnull__(1, 2)));
    extern int symlinkat(__const char * __from, int __tofd, __const char * __to) throw () __attribute__((__nonnull__(1, 3)));
    extern ssize_t readlinkat(int __fd, __const char *__restrict __path, char *__restrict __buf, size_t __len) throw () __attribute__((__nonnull__(2, 3)));
    extern int unlink(__const char * __name) throw () __attribute__((__nonnull__(1)));
    extern int unlinkat(int __fd, __const char * __name, int __flag) throw () __attribute__((__nonnull__(2)));
    extern int rmdir(__const char * __path) throw () __attribute__((__nonnull__(1)));
    extern __pid_t tcgetpgrp(int __fd) throw ();
    extern int tcsetpgrp(int __fd, __pid_t __pgrp_id) throw ();
    extern char * getlogin(void);
    extern int getlogin_r(char * __name, size_t __name_len) __attribute__((__nonnull__(1)));
    extern int setlogin(__const char * __name) throw () __attribute__((__nonnull__(1)));
    extern "C"
    {
        extern char * optarg;
        extern int optind;
        extern int opterr;
        extern int optopt;
        extern int getopt(int ___argc, char *const * ___argv, const char * __shortopts) throw ();
    }
    extern int gethostname(char * __name, size_t __len) throw () __attribute__((__nonnull__(1)));
    extern int sethostname(__const char * __name, size_t __len) throw () __attribute__((__nonnull__(1)));
    extern int sethostid(long int __id) throw ();
    extern int getdomainname(char * __name, size_t __len) throw () __attribute__((__nonnull__(1)));
    extern int setdomainname(__const char * __name, size_t __len) throw () __attribute__((__nonnull__(1)));
    extern int vhangup(void) throw ();
    extern int revoke(__const char * __file) throw () __attribute__((__nonnull__(1)));
    extern int profil(unsigned short int * __sample_buffer, size_t __size, size_t __offset, unsigned int __scale) throw () __attribute__((__nonnull__(1)));
    extern int acct(__const char * __name) throw ();
    extern char * getusershell(void) throw ();
    extern void endusershell(void) throw ();
    extern void setusershell(void) throw ();
    extern int daemon(int __nochdir, int __noclose) throw ();
    extern int chroot(__const char * __path) throw () __attribute__((__nonnull__(1)));
    extern char * getpass(__const char * __prompt) __attribute__((__nonnull__(1)));
    extern int fsync(int __fd);
    extern long int gethostid(void);
    extern void sync(void) throw ();
    extern int getpagesize(void) throw () __attribute__((__const__));
    extern int getdtablesize(void) throw ();
    extern int truncate(__const char * __file, __off_t __length) throw () __attribute__((__nonnull__(1)));
    extern int truncate64(__const char * __file, __off64_t __length) throw () __attribute__((__nonnull__(1)));
    extern int ftruncate(int __fd, __off_t __length) throw ();
    extern int ftruncate64(int __fd, __off64_t __length) throw ();
    extern int brk(void * __addr) throw ();
    extern void * sbrk(intptr_t __delta) throw ();
    extern long int syscall(long int __sysno, ...) throw ();
    extern int lockf(int __fd, int __cmd, __off_t __len);
    extern int lockf64(int __fd, int __cmd, __off64_t __len);
    extern int fdatasync(int __fildes);
    extern char * crypt(__const char * __key, __const char * __salt) throw () __attribute__((__nonnull__(1, 2)));
    extern void encrypt(char * __block, int __edflag) throw () __attribute__((__nonnull__(1)));
    extern void swab(__const void *__restrict __from, void *__restrict __to, ssize_t __n) throw () __attribute__((__nonnull__(1, 2)));
    extern char * ctermid(char * __s) throw ();
}
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
static __typeof (pthread_once) __gthrw_pthread_once __attribute__((__weakref__("pthread_once")));
static __typeof (pthread_getspecific) __gthrw_pthread_getspecific __attribute__((__weakref__("pthread_getspecific")));
static __typeof (pthread_setspecific) __gthrw_pthread_setspecific __attribute__((__weakref__("pthread_setspecific")));
static __typeof (pthread_create) __gthrw_pthread_create __attribute__((__weakref__("pthread_create")));
static __typeof (pthread_cancel) __gthrw_pthread_cancel __attribute__((__weakref__("pthread_cancel")));
static __typeof (pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__((__weakref__("pthread_mutex_lock")));
static __typeof (pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__((__weakref__("pthread_mutex_trylock")));
static __typeof (pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__((__weakref__("pthread_mutex_unlock")));
static __typeof (pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__((__weakref__("pthread_mutex_init")));
static __typeof (pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__((__weakref__("pthread_cond_broadcast")));
static __typeof (pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__((__weakref__("pthread_cond_wait")));
static __typeof (pthread_key_create) __gthrw_pthread_key_create __attribute__((__weakref__("pthread_key_create")));
static __typeof (pthread_key_delete) __gthrw_pthread_key_delete __attribute__((__weakref__("pthread_key_delete")));
static __typeof (pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__((__weakref__("pthread_mutexattr_init")));
static __typeof (pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__((__weakref__("pthread_mutexattr_settype")));
static __typeof (pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__((__weakref__("pthread_mutexattr_destroy")));
static inline int __gthread_active_p(void)
{
    static void *const __gthread_active_ptr = __extension__ (void *) &__gthrw_pthread_cancel;
    return __gthread_active_ptr != 0;
}
static inline int __gthread_once(__gthread_once_t * once, void (* func)(void))
{
    if (__gthread_active_p())
        return __gthrw_pthread_once(once, func);
    else
        return -1;
}
static inline int __gthread_key_create(__gthread_key_t * key, void (* dtor)(void *))
{
    return __gthrw_pthread_key_create(key, dtor);
}
static inline int __gthread_key_delete(__gthread_key_t key)
{
    return __gthrw_pthread_key_delete(key);
}
static inline void * __gthread_getspecific(__gthread_key_t key)
{
    return __gthrw_pthread_getspecific(key);
}
static inline int __gthread_setspecific(__gthread_key_t key, const void * ptr)
{
    return __gthrw_pthread_setspecific(key, ptr);
}
static inline int __gthread_mutex_lock(__gthread_mutex_t * mutex)
{
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_lock(mutex);
    else
        return 0;
}
static inline int __gthread_mutex_trylock(__gthread_mutex_t * mutex)
{
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_trylock(mutex);
    else
        return 0;
}
static inline int __gthread_mutex_unlock(__gthread_mutex_t * mutex)
{
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_unlock(mutex);
    else
        return 0;
}
static inline int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t * mutex)
{
    return __gthread_mutex_lock(mutex);
}
static inline int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t * mutex)
{
    return __gthread_mutex_trylock(mutex);
}
static inline int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t * mutex)
{
    return __gthread_mutex_unlock(mutex);
}
static inline int __gthread_cond_broadcast(__gthread_cond_t * cond)
{
    return __gthrw_pthread_cond_broadcast(cond);
}
static inline int __gthread_cond_wait(__gthread_cond_t * cond, __gthread_mutex_t * mutex)
{
    return __gthrw_pthread_cond_wait(cond, mutex);
}
static inline int __gthread_cond_wait_recursive(__gthread_cond_t * cond, __gthread_recursive_mutex_t * mutex)
{
    return __gthread_cond_wait(cond, mutex);
}
#pragma GCC visibility pop
typedef int _Atomic_word;
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
    static inline _Atomic_word __exchange_and_add(volatile _Atomic_word * __mem, int __val)
    {
        return __sync_fetch_and_add(__mem, __val);
    }
    static inline void __atomic_add(volatile _Atomic_word * __mem, int __val)
    {
        __sync_fetch_and_add(__mem, __val);
    }
    static inline _Atomic_word __exchange_and_add_single(_Atomic_word * __mem, int __val)
    {
        _Atomic_word __result = *__mem;
        *__mem += __val;
        return __result;
    }
    static inline void __atomic_add_single(_Atomic_word * __mem, int __val)
    {
        *__mem += __val;
    }
    static inline _Atomic_word __attribute__((__unused__)) __exchange_and_add_dispatch(_Atomic_word * __mem, int __val)
    {
        if (__gthread_active_p())
            return __exchange_and_add(__mem, __val);
        else
            return __exchange_and_add_single(__mem, __val);
    }
    static inline void __attribute__((__unused__)) __atomic_add_dispatch(_Atomic_word * __mem, int __val)
    {
        if (__gthread_active_p())
            __atomic_add(__mem, __val);
        else
            __atomic_add_single(__mem, __val);
    }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
    using std::size_t;
    using std::ptrdiff_t;
    template<typename _Tp >
    class new_allocator
    {
        public :
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef _Tp * pointer;
            typedef const _Tp * const_pointer;
            typedef _Tp & reference;
            typedef const _Tp & const_reference;
            typedef _Tp value_type;
            template<typename _Tp1 >
            struct rebind
            {
                    typedef new_allocator< _Tp1 > other;
            };
            new_allocator() throw ()
            {
            }
            new_allocator(const new_allocator &) throw ()
            {
            }
            template<typename _Tp1 >
            new_allocator(const new_allocator< _Tp1 > &) throw ()
            {
            }
            ~new_allocator() throw ()
            {
            }
            pointer address(reference __x) const
            {
                return &__x;
            }
            const_pointer address(const_reference __x) const
            {
                return &__x;
            }
            pointer allocate(size_type __n, const void * = 0)
            {
                if (__builtin_expect(__n > this->max_size(), false))
                    std::__throw_bad_alloc();
                return static_cast<_Tp * >(::operator new(__n * sizeof(_Tp)));
            }
            void deallocate(pointer __p, size_type)
            {
                ::operator delete(__p);
            }
            size_type max_size() const throw ()
            {
                return size_t(-1) / sizeof(_Tp);
            }
            void construct(pointer __p, const _Tp & __val)
            {
                ::new ((void *) __p) _Tp (__val);
            }
            void destroy(pointer __p)
            {
                __p->~_Tp();
            }
    };
    template<typename _Tp >
    inline bool operator ==(const new_allocator< _Tp > &, const new_allocator< _Tp > &)
    {
        return true;
    }
    template<typename _Tp >
    inline bool operator !=(const new_allocator< _Tp > &, const new_allocator< _Tp > &)
    {
        return false;
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Tp >
    class allocator;
    template<>
    class allocator< void >
    {
        public :
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef void * pointer;
            typedef const void * const_pointer;
            typedef void value_type;
            template<typename _Tp1 >
            struct rebind
            {
                    typedef allocator< _Tp1 > other;
            };
    };
    template<typename _Tp >
    class allocator : public __gnu_cxx::new_allocator< _Tp >
    {
        public :
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef _Tp * pointer;
            typedef const _Tp * const_pointer;
            typedef _Tp & reference;
            typedef const _Tp & const_reference;
            typedef _Tp value_type;
            template<typename _Tp1 >
            struct rebind
            {
                    typedef allocator< _Tp1 > other;
            };
            allocator() throw ()
            {
            }
            allocator(const allocator & __a) throw ()
                : __gnu_cxx::new_allocator< _Tp >(__a) 
            {
            }
            template<typename _Tp1 >
            allocator(const allocator< _Tp1 > &) throw ()
            {
            }
            ~allocator() throw ()
            {
            }
    };
    template<typename _T1, typename _T2 >
    inline bool operator ==(const allocator< _T1 > &, const allocator< _T2 > &)
    {
        return true;
    }
    template<typename _Tp >
    inline bool operator ==(const allocator< _Tp > &, const allocator< _Tp > &)
    {
        return true;
    }
    template<typename _T1, typename _T2 >
    inline bool operator !=(const allocator< _T1 > &, const allocator< _T2 > &)
    {
        return false;
    }
    template<typename _Tp >
    inline bool operator !=(const allocator< _Tp > &, const allocator< _Tp > &)
    {
        return false;
    }
    extern template class allocator< char > ;
    extern template class allocator< wchar_t > ;
    template<typename _Alloc, bool = __is_empty(_Alloc) >
    struct __alloc_swap
    {
            static void _S_do_it(_Alloc &, _Alloc &)
            {
            }
    };
    template<typename _Alloc >
    struct __alloc_swap< _Alloc, false >
    {
            static void _S_do_it(_Alloc & __one, _Alloc & __two)
            {
                if (__one != __two)
                    swap(__one, __two);
            }
    };
    template<typename _Alloc, bool = __is_empty(_Alloc) >
    struct __alloc_neq
    {
            static bool _S_do_it(const _Alloc &, const _Alloc &)
            {
                return false;
            }
    };
    template<typename _Alloc >
    struct __alloc_neq< _Alloc, false >
    {
            static bool _S_do_it(const _Alloc & __one, const _Alloc & __two)
            {
                return __one != __two;
            }
    };
}
#pragma GCC visibility push(default)
namespace __cxxabiv1 {
    class __forced_unwind
    {
            virtual ~__forced_unwind() throw ();
            virtual void __pure_dummy() = 0;
    };
}
#pragma GCC visibility pop
namespace std __attribute__((__visibility__("default"))) {
    template<typename _CharT, typename _Traits >
    inline void __ostream_write(basic_ostream< _CharT, _Traits > & __out, const _CharT * __s, streamsize __n)
    {
        typedef basic_ostream< _CharT, _Traits > __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        const streamsize __put = __out.rdbuf()->sputn(__s, __n);
        if (__put != __n)
            __out.setstate(__ios_base::badbit);
    }
    template<typename _CharT, typename _Traits >
    inline void __ostream_fill(basic_ostream< _CharT, _Traits > & __out, streamsize __n)
    {
        typedef basic_ostream< _CharT, _Traits > __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        const _CharT __c = __out.fill();
        for (;
            __n > 0;
            --__n)
        {
            const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
            if (_Traits::eq_int_type(__put, _Traits::eof()))
            {
                __out.setstate(__ios_base::badbit);
                break;
            }
        }
    }
    template<typename _CharT, typename _Traits >
    basic_ostream< _CharT, _Traits > & __ostream_insert(basic_ostream< _CharT, _Traits > & __out, const _CharT * __s, streamsize __n)
    {
        typedef basic_ostream< _CharT, _Traits > __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        typename __ostream_type::sentry __cerb(__out);
        if (__cerb)
        {
            try
            {
                const streamsize __w = __out.width();
                if (__w > __n)
                {
                    const bool __left = ((__out.flags() & __ios_base::adjustfield) == __ios_base::left);
                    if (!__left)
                        __ostream_fill(__out, __w - __n);
                    if (__out.good())
                        __ostream_write(__out, __s, __n);
                    if (__left && __out.good())
                        __ostream_fill(__out, __w - __n);
                }
                else
                    __ostream_write(__out, __s, __n);
                __out.width(0);
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                __out._M_setstate(__ios_base::badbit);
                throw;
            }
            catch (...)
            {
                __out._M_setstate(__ios_base::badbit);
            }
        }
        return __out;
    }
    extern template ostream & __ostream_insert(ostream &, const char *, streamsize);
    extern template wostream & __ostream_insert(wostream &, const wchar_t *, streamsize);
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Arg, typename _Result >
    struct unary_function
    {
            typedef _Arg argument_type;
            typedef _Result result_type;
    };
    template<typename _Arg1, typename _Arg2, typename _Result >
    struct binary_function
    {
            typedef _Arg1 first_argument_type;
            typedef _Arg2 second_argument_type;
            typedef _Result result_type;
    };
    template<typename _Tp >
    struct plus : public binary_function< _Tp, _Tp, _Tp >
    {
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x + __y;
            }
    };
    template<typename _Tp >
    struct minus : public binary_function< _Tp, _Tp, _Tp >
    {
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x - __y;
            }
    };
    template<typename _Tp >
    struct multiplies : public binary_function< _Tp, _Tp, _Tp >
    {
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x * __y;
            }
    };
    template<typename _Tp >
    struct divides : public binary_function< _Tp, _Tp, _Tp >
    {
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x / __y;
            }
    };
    template<typename _Tp >
    struct modulus : public binary_function< _Tp, _Tp, _Tp >
    {
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x % __y;
            }
    };
    template<typename _Tp >
    struct negate : public unary_function< _Tp, _Tp >
    {
            _Tp operator ()(const _Tp & __x) const
            {
                return -__x;
            }
    };
    template<typename _Tp >
    struct equal_to : public binary_function< _Tp, _Tp, bool >
    {
            bool operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x == __y;
            }
    };
    template<typename _Tp >
    struct not_equal_to : public binary_function< _Tp, _Tp, bool >
    {
            bool operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x != __y;
            }
    };
    template<typename _Tp >
    struct greater : public binary_function< _Tp, _Tp, bool >
    {
            bool operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x > __y;
            }
    };
    template<typename _Tp >
    struct less : public binary_function< _Tp, _Tp, bool >
    {
            bool operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x < __y;
            }
    };
    template<typename _Tp >
    struct greater_equal : public binary_function< _Tp, _Tp, bool >
    {
            bool operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x >= __y;
            }
    };
    template<typename _Tp >
    struct less_equal : public binary_function< _Tp, _Tp, bool >
    {
            bool operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x <= __y;
            }
    };
    template<typename _Tp >
    struct logical_and : public binary_function< _Tp, _Tp, bool >
    {
            bool operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x && __y;
            }
    };
    template<typename _Tp >
    struct logical_or : public binary_function< _Tp, _Tp, bool >
    {
            bool operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x || __y;
            }
    };
    template<typename _Tp >
    struct logical_not : public unary_function< _Tp, bool >
    {
            bool operator ()(const _Tp & __x) const
            {
                return !__x;
            }
    };
    template<typename _Tp >
    struct bit_and : public binary_function< _Tp, _Tp, _Tp >
    {
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x & __y;
            }
    };
    template<typename _Tp >
    struct bit_or : public binary_function< _Tp, _Tp, _Tp >
    {
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x | __y;
            }
    };
    template<typename _Tp >
    struct bit_xor : public binary_function< _Tp, _Tp, _Tp >
    {
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x ^ __y;
            }
    };
    template<typename _Predicate >
    class unary_negate : public unary_function< typename _Predicate::argument_type, bool >
    {
        protected :
            _Predicate _M_pred;
        public :
            explicit unary_negate(const _Predicate & __x)
                : _M_pred(__x) 
            {
            }
            bool operator ()(const typename _Predicate::argument_type & __x) const
            {
                return !_M_pred(__x);
            }
    };
    template<typename _Predicate >
    inline unary_negate< _Predicate > not1(const _Predicate & __pred)
    {
        return unary_negate< _Predicate >(__pred);
    }
    template<typename _Predicate >
    class binary_negate : public binary_function< typename _Predicate::first_argument_type, typename _Predicate::second_argument_type, bool >
    {
        protected :
            _Predicate _M_pred;
        public :
            explicit binary_negate(const _Predicate & __x)
                : _M_pred(__x) 
            {
            }
            bool operator ()(const typename _Predicate::first_argument_type & __x, const typename _Predicate::second_argument_type & __y) const
            {
                return !_M_pred(__x, __y);
            }
    };
    template<typename _Predicate >
    inline binary_negate< _Predicate > not2(const _Predicate & __pred)
    {
        return binary_negate< _Predicate >(__pred);
    }
    template<typename _Arg, typename _Result >
    class pointer_to_unary_function : public unary_function< _Arg, _Result >
    {
        protected :
            _Result (* _M_ptr)(_Arg);
        public :
            pointer_to_unary_function()
            {
            }
            explicit pointer_to_unary_function(_Result (* __x)(_Arg))
                : _M_ptr(__x) 
            {
            }
            _Result operator ()(_Arg __x) const
            {
                return _M_ptr(__x);
            }
    };
    template<typename _Arg, typename _Result >
    inline pointer_to_unary_function< _Arg, _Result > ptr_fun(_Result (* __x)(_Arg))
    {
        return pointer_to_unary_function< _Arg, _Result >(__x);
    }
    template<typename _Arg1, typename _Arg2, typename _Result >
    class pointer_to_binary_function : public binary_function< _Arg1, _Arg2, _Result >
    {
        protected :
            _Result (* _M_ptr)(_Arg1, _Arg2);
        public :
            pointer_to_binary_function()
            {
            }
            explicit pointer_to_binary_function(_Result (* __x)(_Arg1, _Arg2))
                : _M_ptr(__x) 
            {
            }
            _Result operator ()(_Arg1 __x, _Arg2 __y) const
            {
                return _M_ptr(__x, __y);
            }
    };
    template<typename _Arg1, typename _Arg2, typename _Result >
    inline pointer_to_binary_function< _Arg1, _Arg2, _Result > ptr_fun(_Result (* __x)(_Arg1, _Arg2))
    {
        return pointer_to_binary_function< _Arg1, _Arg2, _Result >(__x);
    }
    template<typename _Tp >
    struct _Identity : public unary_function< _Tp, _Tp >
    {
            _Tp & operator ()(_Tp & __x) const
            {
                return __x;
            }
            const _Tp & operator ()(const _Tp & __x) const
            {
                return __x;
            }
    };
    template<typename _Pair >
    struct _Select1st : public unary_function< _Pair, typename _Pair::first_type >
    {
            typename _Pair::first_type & operator ()(_Pair & __x) const
            {
                return __x.first;
            }
            const typename _Pair::first_type & operator ()(const _Pair & __x) const
            {
                return __x.first;
            }
    };
    template<typename _Pair >
    struct _Select2nd : public unary_function< _Pair, typename _Pair::second_type >
    {
            typename _Pair::second_type & operator ()(_Pair & __x) const
            {
                return __x.second;
            }
            const typename _Pair::second_type & operator ()(const _Pair & __x) const
            {
                return __x.second;
            }
    };
    template<typename _Ret, typename _Tp >
    class mem_fun_t : public unary_function< _Tp *, _Ret >
    {
        public :
            explicit mem_fun_t(_Ret (_Tp:: * __pf)())
                : _M_f(__pf) 
            {
            }
            _Ret operator ()(_Tp * __p) const
            {
                return (__p ->* _M_f)();
            }
        private :
            _Ret (_Tp:: * _M_f)();
    };
    template<typename _Ret, typename _Tp >
    class const_mem_fun_t : public unary_function< const _Tp *, _Ret >
    {
        public :
            explicit const_mem_fun_t(_Ret (_Tp:: * __pf)() const)
                : _M_f(__pf) 
            {
            }
            _Ret operator ()(const _Tp * __p) const
            {
                return (__p ->* _M_f)();
            }
        private :
            _Ret (_Tp:: * _M_f)() const;
    };
    template<typename _Ret, typename _Tp >
    class mem_fun_ref_t : public unary_function< _Tp, _Ret >
    {
        public :
            explicit mem_fun_ref_t(_Ret (_Tp:: * __pf)())
                : _M_f(__pf) 
            {
            }
            _Ret operator ()(_Tp & __r) const
            {
                return (__r .* _M_f)();
            }
        private :
            _Ret (_Tp:: * _M_f)();
    };
    template<typename _Ret, typename _Tp >
    class const_mem_fun_ref_t : public unary_function< _Tp, _Ret >
    {
        public :
            explicit const_mem_fun_ref_t(_Ret (_Tp:: * __pf)() const)
                : _M_f(__pf) 
            {
            }
            _Ret operator ()(const _Tp & __r) const
            {
                return (__r .* _M_f)();
            }
        private :
            _Ret (_Tp:: * _M_f)() const;
    };
    template<typename _Ret, typename _Tp, typename _Arg >
    class mem_fun1_t : public binary_function< _Tp *, _Arg, _Ret >
    {
        public :
            explicit mem_fun1_t(_Ret (_Tp:: * __pf)(_Arg))
                : _M_f(__pf) 
            {
            }
            _Ret operator ()(_Tp * __p, _Arg __x) const
            {
                return (__p ->* _M_f)(__x);
            }
        private :
            _Ret (_Tp:: * _M_f)(_Arg);
    };
    template<typename _Ret, typename _Tp, typename _Arg >
    class const_mem_fun1_t : public binary_function< const _Tp *, _Arg, _Ret >
    {
        public :
            explicit const_mem_fun1_t(_Ret (_Tp:: * __pf)(_Arg) const)
                : _M_f(__pf) 
            {
            }
            _Ret operator ()(const _Tp * __p, _Arg __x) const
            {
                return (__p ->* _M_f)(__x);
            }
        private :
            _Ret (_Tp:: * _M_f)(_Arg) const;
    };
    template<typename _Ret, typename _Tp, typename _Arg >
    class mem_fun1_ref_t : public binary_function< _Tp, _Arg, _Ret >
    {
        public :
            explicit mem_fun1_ref_t(_Ret (_Tp:: * __pf)(_Arg))
                : _M_f(__pf) 
            {
            }
            _Ret operator ()(_Tp & __r, _Arg __x) const
            {
                return (__r .* _M_f)(__x);
            }
        private :
            _Ret (_Tp:: * _M_f)(_Arg);
    };
    template<typename _Ret, typename _Tp, typename _Arg >
    class const_mem_fun1_ref_t : public binary_function< _Tp, _Arg, _Ret >
    {
        public :
            explicit const_mem_fun1_ref_t(_Ret (_Tp:: * __pf)(_Arg) const)
                : _M_f(__pf) 
            {
            }
            _Ret operator ()(const _Tp & __r, _Arg __x) const
            {
                return (__r .* _M_f)(__x);
            }
        private :
            _Ret (_Tp:: * _M_f)(_Arg) const;
    };
    template<typename _Ret, typename _Tp >
    inline mem_fun_t< _Ret, _Tp > mem_fun(_Ret (_Tp:: * __f)())
    {
        return mem_fun_t< _Ret, _Tp >(__f);
    }
    template<typename _Ret, typename _Tp >
    inline const_mem_fun_t< _Ret, _Tp > mem_fun(_Ret (_Tp:: * __f)() const)
    {
        return const_mem_fun_t< _Ret, _Tp >(__f);
    }
    template<typename _Ret, typename _Tp >
    inline mem_fun_ref_t< _Ret, _Tp > mem_fun_ref(_Ret (_Tp:: * __f)())
    {
        return mem_fun_ref_t< _Ret, _Tp >(__f);
    }
    template<typename _Ret, typename _Tp >
    inline const_mem_fun_ref_t< _Ret, _Tp > mem_fun_ref(_Ret (_Tp:: * __f)() const)
    {
        return const_mem_fun_ref_t< _Ret, _Tp >(__f);
    }
    template<typename _Ret, typename _Tp, typename _Arg >
    inline mem_fun1_t< _Ret, _Tp, _Arg > mem_fun(_Ret (_Tp:: * __f)(_Arg))
    {
        return mem_fun1_t< _Ret, _Tp, _Arg >(__f);
    }
    template<typename _Ret, typename _Tp, typename _Arg >
    inline const_mem_fun1_t< _Ret, _Tp, _Arg > mem_fun(_Ret (_Tp:: * __f)(_Arg) const)
    {
        return const_mem_fun1_t< _Ret, _Tp, _Arg >(__f);
    }
    template<typename _Ret, typename _Tp, typename _Arg >
    inline mem_fun1_ref_t< _Ret, _Tp, _Arg > mem_fun_ref(_Ret (_Tp:: * __f)(_Arg))
    {
        return mem_fun1_ref_t< _Ret, _Tp, _Arg >(__f);
    }
    template<typename _Ret, typename _Tp, typename _Arg >
    inline const_mem_fun1_ref_t< _Ret, _Tp, _Arg > mem_fun_ref(_Ret (_Tp:: * __f)(_Arg) const)
    {
        return const_mem_fun1_ref_t< _Ret, _Tp, _Arg >(__f);
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Operation >
    class binder1st : public unary_function< typename _Operation::second_argument_type, typename _Operation::result_type >
    {
        protected :
            _Operation op;
            typename _Operation::first_argument_type value;
        public :
            binder1st(const _Operation & __x, const typename _Operation::first_argument_type & __y)
                : op(__x), value(__y) 
            {
            }
            typename _Operation::result_type operator ()(const typename _Operation::second_argument_type & __x) const
            {
                return op(value, __x);
            }
            typename _Operation::result_type operator ()(typename _Operation::second_argument_type & __x) const
            {
                return op(value, __x);
            }
    };
    template<typename _Operation, typename _Tp >
    inline binder1st< _Operation > bind1st(const _Operation & __fn, const _Tp & __x)
    {
        typedef typename _Operation::first_argument_type _Arg1_type;
        return binder1st< _Operation >(__fn, _Arg1_type(__x));
    }
    template<typename _Operation >
    class binder2nd : public unary_function< typename _Operation::first_argument_type, typename _Operation::result_type >
    {
        protected :
            _Operation op;
            typename _Operation::second_argument_type value;
        public :
            binder2nd(const _Operation & __x, const typename _Operation::second_argument_type & __y)
                : op(__x), value(__y) 
            {
            }
            typename _Operation::result_type operator ()(const typename _Operation::first_argument_type & __x) const
            {
                return op(__x, value);
            }
            typename _Operation::result_type operator ()(typename _Operation::first_argument_type & __x) const
            {
                return op(__x, value);
            }
    };
    template<typename _Operation, typename _Tp >
    inline binder2nd< _Operation > bind2nd(const _Operation & __fn, const _Tp & __x)
    {
        typedef typename _Operation::second_argument_type _Arg2_type;
        return binder2nd< _Operation >(__fn, _Arg2_type(__x));
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _CharT, typename _Traits, typename _Alloc >
    class basic_string
    {
            typedef typename _Alloc::template rebind< _CharT >::other _CharT_alloc_type;
        public :
            typedef _Traits traits_type;
            typedef typename _Traits::char_type value_type;
            typedef _Alloc allocator_type;
            typedef typename _CharT_alloc_type::size_type size_type;
            typedef typename _CharT_alloc_type::difference_type difference_type;
            typedef typename _CharT_alloc_type::reference reference;
            typedef typename _CharT_alloc_type::const_reference const_reference;
            typedef typename _CharT_alloc_type::pointer pointer;
            typedef typename _CharT_alloc_type::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator< pointer, basic_string > iterator;
            typedef __gnu_cxx::__normal_iterator< const_pointer, basic_string > const_iterator;
            typedef std::reverse_iterator< const_iterator > const_reverse_iterator;
            typedef std::reverse_iterator< iterator > reverse_iterator;
        private :
            struct _Rep_base
            {
                    size_type _M_length;
                    size_type _M_capacity;
                    _Atomic_word _M_refcount;
            };
            struct _Rep : _Rep_base
            {
                    typedef typename _Alloc::template rebind< char >::other _Raw_bytes_alloc;
                    static const size_type _S_max_size;
                    static const _CharT _S_terminal;
                    static size_type _S_empty_rep_storage[];
                    static _Rep & _S_empty_rep()
                    {
                        void * __p = reinterpret_cast<void * >(&_S_empty_rep_storage);
                        return *reinterpret_cast<_Rep * >(__p);
                    }
                    bool _M_is_leaked() const
                    {
                        return this->_M_refcount < 0;
                    }
                    bool _M_is_shared() const
                    {
                        return this->_M_refcount > 0;
                    }
                    void _M_set_leaked()
                    {
                        this->_M_refcount = -1;
                    }
                    void _M_set_sharable()
                    {
                        this->_M_refcount = 0;
                    }
                    void _M_set_length_and_sharable(size_type __n)
                    {
                        this->_M_set_sharable();
                        this->_M_length = __n;
                        traits_type::assign(this->_M_refdata()[__n], _S_terminal);
                    }
                    _CharT * _M_refdata() throw ()
                    {
                        return reinterpret_cast<_CharT * >(this + 1);
                    }
                    _CharT * _M_grab(const _Alloc & __alloc1, const _Alloc & __alloc2)
                    {
                        return (!_M_is_leaked() && __alloc1 == __alloc2) ? _M_refcopy() : _M_clone(__alloc1);
                    }
                    static _Rep * _S_create(size_type, size_type, const _Alloc &);
                    void _M_dispose(const _Alloc & __a)
                    {
                        if (__builtin_expect(this != &_S_empty_rep(), false))
                            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) <= 0)
                                _M_destroy(__a);
                    }
                    void _M_destroy(const _Alloc &) throw ();
                    _CharT * _M_refcopy() throw ()
                    {
                        if (__builtin_expect(this != &_S_empty_rep(), false))
                            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
                        return _M_refdata();
                    }
                    _CharT * _M_clone(const _Alloc &, size_type __res = 0);
            };
            struct _Alloc_hider : _Alloc
            {
                    _Alloc_hider(_CharT * __dat, const _Alloc & __a)
                        : _Alloc(__a), _M_p(__dat) 
                    {
                    }
                    _CharT * _M_p;
            };
        public :
            static const size_type npos = static_cast<size_type >(-1);
        private :
            mutable _Alloc_hider _M_dataplus;
            _CharT * _M_data() const
            {
                return _M_dataplus._M_p;
            }
            _CharT * _M_data(_CharT * __p)
            {
                return (_M_dataplus._M_p = __p);
            }
            _Rep * _M_rep() const
            {
                return &((reinterpret_cast<_Rep * >(_M_data()))[-1]);
            }
            iterator _M_ibegin() const
            {
                return iterator(_M_data());
            }
            iterator _M_iend() const
            {
                return iterator(_M_data() + this->size());
            }
            void _M_leak()
            {
                if (!_M_rep()->_M_is_leaked())
                    _M_leak_hard();
            }
            size_type _M_check(size_type __pos, const char * __s) const
            {
                if (__pos > this->size())
                    __throw_out_of_range((__s));
                return __pos;
            }
            void _M_check_length(size_type __n1, size_type __n2, const char * __s) const
            {
                if (this->max_size() - (this->size() - __n1) < __n2)
                    __throw_length_error((__s));
            }
            size_type _M_limit(size_type __pos, size_type __off) const
            {
                const bool __testoff = __off < this->size() - __pos;
                return __testoff ? __off : this->size() - __pos;
            }
            bool _M_disjunct(const _CharT * __s) const
            {
                return (less< const _CharT * >()(__s, _M_data()) || less< const _CharT * >()(_M_data() + this->size(), __s));
            }
            static void _M_copy(_CharT * __d, const _CharT * __s, size_type __n)
            {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static void _M_move(_CharT * __d, const _CharT * __s, size_type __n)
            {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::move(__d, __s, __n);
            }
            static void _M_assign(_CharT * __d, size_type __n, _CharT __c)
            {
                if (__n == 1)
                    traits_type::assign(*__d, __c);
                else
                    traits_type::assign(__d, __n, __c);
            }
            template<class _Iterator >
            static void _S_copy_chars(_CharT * __p, _Iterator __k1, _Iterator __k2)
            {
                for (;
                    __k1 != __k2;
                    ++__k1 , ++__p)
                traits_type::assign(*__p, *__k1);
            }
            static void _S_copy_chars(_CharT * __p, iterator __k1, iterator __k2)
            {
                _S_copy_chars(__p, __k1.base(), __k2.base());
            }
            static void _S_copy_chars(_CharT * __p, const_iterator __k1, const_iterator __k2)
            {
                _S_copy_chars(__p, __k1.base(), __k2.base());
            }
            static void _S_copy_chars(_CharT * __p, _CharT * __k1, _CharT * __k2)
            {
                _M_copy(__p, __k1, __k2 - __k1);
            }
            static void _S_copy_chars(_CharT * __p, const _CharT * __k1, const _CharT * __k2)
            {
                _M_copy(__p, __k1, __k2 - __k1);
            }
            static int _S_compare(size_type __n1, size_type __n2)
            {
                const difference_type __d = difference_type(__n1 - __n2);
                if (__d > __gnu_cxx::__numeric_traits< int >::__max)
                    return __gnu_cxx::__numeric_traits< int >::__max;
                else
                    if (__d < __gnu_cxx::__numeric_traits< int >::__min)
                        return __gnu_cxx::__numeric_traits< int >::__min;
                    else
                        return int(__d);
            }
            void _M_mutate(size_type __pos, size_type __len1, size_type __len2);
            void _M_leak_hard();
            static _Rep & _S_empty_rep()
            {
                return _Rep::_S_empty_rep();
            }
        public :
            inline basic_string();
            explicit basic_string(const _Alloc & __a);
            basic_string(const basic_string & __str);
            basic_string(const basic_string & __str, size_type __pos, size_type __n = npos);
            basic_string(const basic_string & __str, size_type __pos, size_type __n, const _Alloc & __a);
            basic_string(const _CharT * __s, size_type __n, const _Alloc & __a = _Alloc());
            basic_string(const _CharT * __s, const _Alloc & __a = _Alloc());
            basic_string(size_type __n, _CharT __c, const _Alloc & __a = _Alloc());
            template<class _InputIterator >
            basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc & __a = _Alloc());
            ~basic_string()
            {
                _M_rep()->_M_dispose(this->get_allocator());
            }
            basic_string & operator =(const basic_string & __str)
            {
                return this->assign(__str);
            }
            basic_string & operator =(const _CharT * __s)
            {
                return this->assign(__s);
            }
            basic_string & operator =(_CharT __c)
            {
                this->assign(1, __c);
                return *this;
            }
            iterator begin()
            {
                _M_leak();
                return iterator(_M_data());
            }
            const_iterator begin() const
            {
                return const_iterator(_M_data());
            }
            iterator end()
            {
                _M_leak();
                return iterator(_M_data() + this->size());
            }
            const_iterator end() const
            {
                return const_iterator(_M_data() + this->size());
            }
            reverse_iterator rbegin()
            {
                return reverse_iterator(this->end());
            }
            const_reverse_iterator rbegin() const
            {
                return const_reverse_iterator(this->end());
            }
            reverse_iterator rend()
            {
                return reverse_iterator(this->begin());
            }
            const_reverse_iterator rend() const
            {
                return const_reverse_iterator(this->begin());
            }
        public :
            size_type size() const
            {
                return _M_rep()->_M_length;
            }
            size_type length() const
            {
                return _M_rep()->_M_length;
            }
            size_type max_size() const
            {
                return _Rep::_S_max_size;
            }
            void resize(size_type __n, _CharT __c);
            void resize(size_type __n)
            {
                this->resize(__n, _CharT());
            }
            size_type capacity() const
            {
                return _M_rep()->_M_capacity;
            }
            void reserve(size_type __res_arg = 0);
            void clear()
            {
                _M_mutate(0, this->size(), 0);
            }
            bool empty() const
            {
                return this->size() == 0;
            }
            const_reference operator [](size_type __pos) const
            {
                ;
                return _M_data()[__pos];
            }
            reference operator [](size_type __pos)
            {
                ;
                ;
                _M_leak();
                return _M_data()[__pos];
            }
            const_reference at(size_type __n) const
            {
                if (__n >= this->size())
                    __throw_out_of_range(("basic_string::at"));
                return _M_data()[__n];
            }
            reference at(size_type __n)
            {
                if (__n >= size())
                    __throw_out_of_range(("basic_string::at"));
                _M_leak();
                return _M_data()[__n];
            }
            basic_string & operator +=(const basic_string & __str)
            {
                return this->append(__str);
            }
            basic_string & operator +=(const _CharT * __s)
            {
                return this->append(__s);
            }
            basic_string & operator +=(_CharT __c)
            {
                this->push_back(__c);
                return *this;
            }
            basic_string & append(const basic_string & __str);
            basic_string & append(const basic_string & __str, size_type __pos, size_type __n);
            basic_string & append(const _CharT * __s, size_type __n);
            basic_string & append(const _CharT * __s)
            {
                ;
                return this->append(__s, traits_type::length(__s));
            }
            basic_string & append(size_type __n, _CharT __c);
            template<class _InputIterator >
            basic_string & append(_InputIterator __first, _InputIterator __last)
            {
                return this->replace(_M_iend(), _M_iend(), __first, __last);
            }
            void push_back(_CharT __c)
            {
                const size_type __len = 1 + this->size();
                if (__len > this->capacity() || _M_rep()->_M_is_shared())
                    this->reserve(__len);
                traits_type::assign(_M_data()[this->size()], __c);
                _M_rep()->_M_set_length_and_sharable(__len);
            }
            basic_string & assign(const basic_string & __str);
            basic_string & assign(const basic_string & __str, size_type __pos, size_type __n)
            {
                return this->assign(__str._M_data() + __str._M_check(__pos, "basic_string::assign"), __str._M_limit(__pos, __n));
            }
            basic_string & assign(const _CharT * __s, size_type __n);
            basic_string & assign(const _CharT * __s)
            {
                ;
                return this->assign(__s, traits_type::length(__s));
            }
            basic_string & assign(size_type __n, _CharT __c)
            {
                return _M_replace_aux(size_type(0), this->size(), __n, __c);
            }
            template<class _InputIterator >
            basic_string & assign(_InputIterator __first, _InputIterator __last)
            {
                return this->replace(_M_ibegin(), _M_iend(), __first, __last);
            }
            void insert(iterator __p, size_type __n, _CharT __c)
            {
                this->replace(__p, __p, __n, __c);
            }
            template<class _InputIterator >
            void insert(iterator __p, _InputIterator __beg, _InputIterator __end)
            {
                this->replace(__p, __p, __beg, __end);
            }
            basic_string & insert(size_type __pos1, const basic_string & __str)
            {
                return this->insert(__pos1, __str, size_type(0), __str.size());
            }
            basic_string & insert(size_type __pos1, const basic_string & __str, size_type __pos2, size_type __n)
            {
                return this->insert(__pos1, __str._M_data() + __str._M_check(__pos2, "basic_string::insert"), __str._M_limit(__pos2, __n));
            }
            basic_string & insert(size_type __pos, const _CharT * __s, size_type __n);
            basic_string & insert(size_type __pos, const _CharT * __s)
            {
                ;
                return this->insert(__pos, __s, traits_type::length(__s));
            }
            basic_string & insert(size_type __pos, size_type __n, _CharT __c)
            {
                return _M_replace_aux(_M_check(__pos, "basic_string::insert"), size_type(0), __n, __c);
            }
            iterator insert(iterator __p, _CharT __c)
            {
                ;
                const size_type __pos = __p - _M_ibegin();
                _M_replace_aux(__pos, size_type(0), size_type(1), __c);
                _M_rep()->_M_set_leaked();
                return iterator(_M_data() + __pos);
            }
            basic_string & erase(size_type __pos = 0, size_type __n = npos)
            {
                _M_mutate(_M_check(__pos, "basic_string::erase"), _M_limit(__pos, __n), size_type(0));
                return *this;
            }
            iterator erase(iterator __position)
            {
                ;
                const size_type __pos = __position - _M_ibegin();
                _M_mutate(__pos, size_type(1), size_type(0));
                _M_rep()->_M_set_leaked();
                return iterator(_M_data() + __pos);
            }
            iterator erase(iterator __first, iterator __last)
            {
                ;
                const size_type __pos = __first - _M_ibegin();
                _M_mutate(__pos, __last - __first, size_type(0));
                _M_rep()->_M_set_leaked();
                return iterator(_M_data() + __pos);
            }
            basic_string & replace(size_type __pos, size_type __n, const basic_string & __str)
            {
                return this->replace(__pos, __n, __str._M_data(), __str.size());
            }
            basic_string & replace(size_type __pos1, size_type __n1, const basic_string & __str, size_type __pos2, size_type __n2)
            {
                return this->replace(__pos1, __n1, __str._M_data() + __str._M_check(__pos2, "basic_string::replace"), __str._M_limit(__pos2, __n2));
            }
            basic_string & replace(size_type __pos, size_type __n1, const _CharT * __s, size_type __n2);
            basic_string & replace(size_type __pos, size_type __n1, const _CharT * __s)
            {
                ;
                return this->replace(__pos, __n1, __s, traits_type::length(__s));
            }
            basic_string & replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
            {
                return _M_replace_aux(_M_check(__pos, "basic_string::replace"), _M_limit(__pos, __n1), __n2, __c);
            }
            basic_string & replace(iterator __i1, iterator __i2, const basic_string & __str)
            {
                return this->replace(__i1, __i2, __str._M_data(), __str.size());
            }
            basic_string & replace(iterator __i1, iterator __i2, const _CharT * __s, size_type __n)
            {
                ;
                return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
            }
            basic_string & replace(iterator __i1, iterator __i2, const _CharT * __s)
            {
                ;
                return this->replace(__i1, __i2, __s, traits_type::length(__s));
            }
            basic_string & replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
            {
                ;
                return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
            }
            template<class _InputIterator >
            basic_string & replace(iterator __i1, iterator __i2, _InputIterator __k1, _InputIterator __k2)
            {
                ;
                ;
                typedef typename std::__is_integer< _InputIterator >::__type _Integral;
                return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
            }
            basic_string & replace(iterator __i1, iterator __i2, _CharT * __k1, _CharT * __k2)
            {
                ;
                ;
                return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __k1, __k2 - __k1);
            }
            basic_string & replace(iterator __i1, iterator __i2, const _CharT * __k1, const _CharT * __k2)
            {
                ;
                ;
                return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __k1, __k2 - __k1);
            }
            basic_string & replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
            {
                ;
                ;
                return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __k1.base(), __k2 - __k1);
            }
            basic_string & replace(iterator __i1, iterator __i2, const_iterator __k1, const_iterator __k2)
            {
                ;
                ;
                return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __k1.base(), __k2 - __k1);
            }
        private :
            template<class _Integer >
            basic_string & _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n, _Integer __val, __true_type)
            {
                return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val);
            }
            template<class _InputIterator >
            basic_string & _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1, _InputIterator __k2, __false_type);
            basic_string & _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, _CharT __c);
            basic_string & _M_replace_safe(size_type __pos1, size_type __n1, const _CharT * __s, size_type __n2);
            template<class _InIterator >
            static _CharT * _S_construct_aux(_InIterator __beg, _InIterator __end, const _Alloc & __a, __false_type)
            {
                typedef typename iterator_traits< _InIterator >::iterator_category _Tag;
                return _S_construct(__beg, __end, __a, _Tag());
            }
            template<class _Integer >
            static _CharT * _S_construct_aux(_Integer __beg, _Integer __end, const _Alloc & __a, __true_type)
            {
                return _S_construct(static_cast<size_type >(__beg), __end, __a);
            }
            template<class _InIterator >
            static _CharT * _S_construct(_InIterator __beg, _InIterator __end, const _Alloc & __a)
            {
                typedef typename std::__is_integer< _InIterator >::__type _Integral;
                return _S_construct_aux(__beg, __end, __a, _Integral());
            }
            template<class _InIterator >
            static _CharT * _S_construct(_InIterator __beg, _InIterator __end, const _Alloc & __a, input_iterator_tag);
            template<class _FwdIterator >
            static _CharT * _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc & __a, forward_iterator_tag);
            static _CharT * _S_construct(size_type __req, _CharT __c, const _Alloc & __a);
        public :
            size_type copy(_CharT * __s, size_type __n, size_type __pos = 0) const;
            void swap(basic_string & __s);
            const _CharT * c_str() const
            {
                return _M_data();
            }
            const _CharT * data() const
            {
                return _M_data();
            }
            allocator_type get_allocator() const
            {
                return _M_dataplus;
            }
            size_type find(const _CharT * __s, size_type __pos, size_type __n) const;
            size_type find(const basic_string & __str, size_type __pos = 0) const
            {
                return this->find(__str.data(), __pos, __str.size());
            }
            size_type find(const _CharT * __s, size_type __pos = 0) const
            {
                ;
                return this->find(__s, __pos, traits_type::length(__s));
            }
            size_type find(_CharT __c, size_type __pos = 0) const;
            size_type rfind(const basic_string & __str, size_type __pos = npos) const
            {
                return this->rfind(__str.data(), __pos, __str.size());
            }
            size_type rfind(const _CharT * __s, size_type __pos, size_type __n) const;
            size_type rfind(const _CharT * __s, size_type __pos = npos) const
            {
                ;
                return this->rfind(__s, __pos, traits_type::length(__s));
            }
            size_type rfind(_CharT __c, size_type __pos = npos) const;
            size_type find_first_of(const basic_string & __str, size_type __pos = 0) const
            {
                return this->find_first_of(__str.data(), __pos, __str.size());
            }
            size_type find_first_of(const _CharT * __s, size_type __pos, size_type __n) const;
            size_type find_first_of(const _CharT * __s, size_type __pos = 0) const
            {
                ;
                return this->find_first_of(__s, __pos, traits_type::length(__s));
            }
            size_type find_first_of(_CharT __c, size_type __pos = 0) const
            {
                return this->find(__c, __pos);
            }
            size_type find_last_of(const basic_string & __str, size_type __pos = npos) const
            {
                return this->find_last_of(__str.data(), __pos, __str.size());
            }
            size_type find_last_of(const _CharT * __s, size_type __pos, size_type __n) const;
            size_type find_last_of(const _CharT * __s, size_type __pos = npos) const
            {
                ;
                return this->find_last_of(__s, __pos, traits_type::length(__s));
            }
            size_type find_last_of(_CharT __c, size_type __pos = npos) const
            {
                return this->rfind(__c, __pos);
            }
            size_type find_first_not_of(const basic_string & __str, size_type __pos = 0) const
            {
                return this->find_first_not_of(__str.data(), __pos, __str.size());
            }
            size_type find_first_not_of(const _CharT * __s, size_type __pos, size_type __n) const;
            size_type find_first_not_of(const _CharT * __s, size_type __pos = 0) const
            {
                ;
                return this->find_first_not_of(__s, __pos, traits_type::length(__s));
            }
            size_type find_first_not_of(_CharT __c, size_type __pos = 0) const;
            size_type find_last_not_of(const basic_string & __str, size_type __pos = npos) const
            {
                return this->find_last_not_of(__str.data(), __pos, __str.size());
            }
            size_type find_last_not_of(const _CharT * __s, size_type __pos, size_type __n) const;
            size_type find_last_not_of(const _CharT * __s, size_type __pos = npos) const
            {
                ;
                return this->find_last_not_of(__s, __pos, traits_type::length(__s));
            }
            size_type find_last_not_of(_CharT __c, size_type __pos = npos) const;
            basic_string substr(size_type __pos = 0, size_type __n = npos) const
            {
                return basic_string(*this, _M_check(__pos, "basic_string::substr"), __n);
            }
            int compare(const basic_string & __str) const
            {
                const size_type __size = this->size();
                const size_type __osize = __str.size();
                const size_type __len = std::min(__size, __osize);
                int __r = traits_type::compare(_M_data(), __str.data(), __len);
                if (!__r)
                    __r = _S_compare(__size, __osize);
                return __r;
            }
            int compare(size_type __pos, size_type __n, const basic_string & __str) const;
            int compare(size_type __pos1, size_type __n1, const basic_string & __str, size_type __pos2, size_type __n2) const;
            int compare(const _CharT * __s) const;
            int compare(size_type __pos, size_type __n1, const _CharT * __s) const;
            int compare(size_type __pos, size_type __n1, const _CharT * __s, size_type __n2) const;
    };
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline basic_string< _CharT, _Traits, _Alloc >::basic_string()
        : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) 
    {
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc > operator +(const basic_string< _CharT, _Traits, _Alloc > & __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)
    {
        basic_string< _CharT, _Traits, _Alloc > __str(__lhs);
        __str.append(__rhs);
        return __str;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc > operator +(const _CharT * __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs);
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc > operator +(_CharT __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs);
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline basic_string< _CharT, _Traits, _Alloc > operator +(const basic_string< _CharT, _Traits, _Alloc > & __lhs, const _CharT * __rhs)
    {
        basic_string< _CharT, _Traits, _Alloc > __str(__lhs);
        __str.append(__rhs);
        return __str;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline basic_string< _CharT, _Traits, _Alloc > operator +(const basic_string< _CharT, _Traits, _Alloc > & __lhs, _CharT __rhs)
    {
        typedef basic_string< _CharT, _Traits, _Alloc > __string_type;
        typedef typename __string_type::size_type __size_type;
        __string_type __str(__lhs);
        __str.append(__size_type(1), __rhs);
        return __str;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator ==(const basic_string< _CharT, _Traits, _Alloc > & __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)
    {
        return __lhs.compare(__rhs) == 0;
    }
    template<typename _CharT >
    inline typename __gnu_cxx::__enable_if< __is_char< _CharT >::__value, bool >::__type operator ==(const basic_string< _CharT > & __lhs, const basic_string< _CharT > & __rhs)
    {
        return (__lhs.size() == __rhs.size() && !std::char_traits< _CharT >::compare(__lhs.data(), __rhs.data(), __lhs.size()));
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator ==(const _CharT * __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)
    {
        return __rhs.compare(__lhs) == 0;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator ==(const basic_string< _CharT, _Traits, _Alloc > & __lhs, const _CharT * __rhs)
    {
        return __lhs.compare(__rhs) == 0;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator !=(const basic_string< _CharT, _Traits, _Alloc > & __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)
    {
        return !(__lhs == __rhs);
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator !=(const _CharT * __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)
    {
        return !(__lhs == __rhs);
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator !=(const basic_string< _CharT, _Traits, _Alloc > & __lhs, const _CharT * __rhs)
    {
        return !(__lhs == __rhs);
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator <(const basic_string< _CharT, _Traits, _Alloc > & __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)
    {
        return __lhs.compare(__rhs) < 0;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator <(const basic_string< _CharT, _Traits, _Alloc > & __lhs, const _CharT * __rhs)
    {
        return __lhs.compare(__rhs) < 0;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator <(const _CharT * __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)
    {
        return __rhs.compare(__lhs) > 0;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator >(const basic_string< _CharT, _Traits, _Alloc > & __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)
    {
        return __lhs.compare(__rhs) > 0;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator >(const basic_string< _CharT, _Traits, _Alloc > & __lhs, const _CharT * __rhs)
    {
        return __lhs.compare(__rhs) > 0;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator >(const _CharT * __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)
    {
        return __rhs.compare(__lhs) < 0;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator <=(const basic_string< _CharT, _Traits, _Alloc > & __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)
    {
        return __lhs.compare(__rhs) <= 0;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator <=(const basic_string< _CharT, _Traits, _Alloc > & __lhs, const _CharT * __rhs)
    {
        return __lhs.compare(__rhs) <= 0;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator <=(const _CharT * __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)
    {
        return __rhs.compare(__lhs) >= 0;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator >=(const basic_string< _CharT, _Traits, _Alloc > & __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)
    {
        return __lhs.compare(__rhs) >= 0;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator >=(const basic_string< _CharT, _Traits, _Alloc > & __lhs, const _CharT * __rhs)
    {
        return __lhs.compare(__rhs) >= 0;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline bool operator >=(const _CharT * __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)
    {
        return __rhs.compare(__lhs) <= 0;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline void swap(basic_string< _CharT, _Traits, _Alloc > & __lhs, basic_string< _CharT, _Traits, _Alloc > & __rhs)
    {
        __lhs.swap(__rhs);
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_istream< _CharT, _Traits > & operator >>(basic_istream< _CharT, _Traits > & __is, basic_string< _CharT, _Traits, _Alloc > & __str);
    template<>
    basic_istream< char > & operator >>(basic_istream< char > & __is, basic_string< char > & __str);
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline basic_ostream< _CharT, _Traits > & operator <<(basic_ostream< _CharT, _Traits > & __os, const basic_string< _CharT, _Traits, _Alloc > & __str)
    {
        return __ostream_insert(__os, __str.data(), __str.size());
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_istream< _CharT, _Traits > & getline(basic_istream< _CharT, _Traits > & __is, basic_string< _CharT, _Traits, _Alloc > & __str, _CharT __delim);
    template<typename _CharT, typename _Traits, typename _Alloc >
    inline basic_istream< _CharT, _Traits > & getline(basic_istream< _CharT, _Traits > & __is, basic_string< _CharT, _Traits, _Alloc > & __str)
    {
        return getline(__is, __str, __is.widen('\n'));
    }
    template<>
    basic_istream< char > & getline(basic_istream< char > & __in, basic_string< char > & __str, char __delim);
    template<>
    basic_istream< wchar_t > & getline(basic_istream< wchar_t > & __in, basic_string< wchar_t > & __str, wchar_t __delim);
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _CharT, typename _Traits, typename _Alloc >
    const typename basic_string< _CharT, _Traits, _Alloc >::size_type basic_string< _CharT, _Traits, _Alloc >::_Rep::_S_max_size = (((npos - sizeof(_Rep_base)) / sizeof(_CharT)) - 1) / 4;
    template<typename _CharT, typename _Traits, typename _Alloc >
    const _CharT basic_string< _CharT, _Traits, _Alloc >::_Rep::_S_terminal = _CharT();
    template<typename _CharT, typename _Traits, typename _Alloc >
    const typename basic_string< _CharT, _Traits, _Alloc >::size_type basic_string< _CharT, _Traits, _Alloc >::npos;
    template<typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string< _CharT, _Traits, _Alloc >::size_type basic_string< _CharT, _Traits, _Alloc >::_Rep::_S_empty_rep_storage[(sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) / sizeof(size_type)];
    template<typename _CharT, typename _Traits, typename _Alloc >
    template<typename _InIterator >
    _CharT * basic_string< _CharT, _Traits, _Alloc >::_S_construct(_InIterator __beg, _InIterator __end, const _Alloc & __a, input_iterator_tag)
    {
        if (__beg == __end && __a == _Alloc())
            return _S_empty_rep()._M_refdata();
        _CharT __buf[128];
        size_type __len = 0;
        while (__beg != __end && __len < sizeof (__buf) / sizeof(_CharT))
        {
            __buf[__len++] = *__beg;
            ++__beg;
        }
        _Rep * __r = _Rep::_S_create(__len, size_type(0), __a);
        _M_copy(__r->_M_refdata(), __buf, __len);
        try
        {
            while (__beg != __end)
            {
                if (__len == __r->_M_capacity)
                {
                    _Rep * __another = _Rep::_S_create(__len + 1, __len, __a);
                    _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
                    __r->_M_destroy(__a);
                    __r = __another;
                }
                __r->_M_refdata()[__len++] = *__beg;
                ++__beg;
            }
        }
        catch (...)
        {
            __r->_M_destroy(__a);
            throw;
        }
        __r->_M_set_length_and_sharable(__len);
        return __r->_M_refdata();
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    template<typename _InIterator >
    _CharT * basic_string< _CharT, _Traits, _Alloc >::_S_construct(_InIterator __beg, _InIterator __end, const _Alloc & __a, forward_iterator_tag)
    {
        if (__beg == __end && __a == _Alloc())
            return _S_empty_rep()._M_refdata();
        if (__builtin_expect(__gnu_cxx::__is_null_pointer(__beg) && __beg != __end, 0))
            __throw_logic_error(("basic_string::_S_construct NULL not valid"));
        const size_type __dnew = static_cast<size_type >(std::distance(__beg, __end));
        _Rep * __r = _Rep::_S_create(__dnew, size_type(0), __a);
        try
        {
            _S_copy_chars(__r->_M_refdata(), __beg, __end);
        }
        catch (...)
        {
            __r->_M_destroy(__a);
            throw;
        }
        __r->_M_set_length_and_sharable(__dnew);
        return __r->_M_refdata();
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    _CharT * basic_string< _CharT, _Traits, _Alloc >::_S_construct(size_type __n, _CharT __c, const _Alloc & __a)
    {
        if (__n == 0 && __a == _Alloc())
            return _S_empty_rep()._M_refdata();
        _Rep * __r = _Rep::_S_create(__n, size_type(0), __a);
        if (__n)
            _M_assign(__r->_M_refdata(), __n, __c);
        __r->_M_set_length_and_sharable(__n);
        return __r->_M_refdata();
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc >::basic_string(const basic_string & __str)
        : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()), __str.get_allocator()), __str.get_allocator()) 
    {
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc >::basic_string(const _Alloc & __a)
        : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a) 
    {
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc >::basic_string(const basic_string & __str, size_type __pos, size_type __n)
        : _M_dataplus(_S_construct(__str._M_data() + __str._M_check(__pos, "basic_string::basic_string"), __str._M_data() + __str._M_limit(__pos, __n) + __pos, _Alloc()), _Alloc()) 
    {
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc >::basic_string(const basic_string & __str, size_type __pos, size_type __n, const _Alloc & __a)
        : _M_dataplus(_S_construct(__str._M_data() + __str._M_check(__pos, "basic_string::basic_string"), __str._M_data() + __str._M_limit(__pos, __n) + __pos, __a), __a) 
    {
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc >::basic_string(const _CharT * __s, size_type __n, const _Alloc & __a)
        : _M_dataplus(_S_construct(__s, __s + __n, __a), __a) 
    {
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc >::basic_string(const _CharT * __s, const _Alloc & __a)
        : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) : __s + npos, __a), __a) 
    {
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc >::basic_string(size_type __n, _CharT __c, const _Alloc & __a)
        : _M_dataplus(_S_construct(__n, __c, __a), __a) 
    {
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    template<typename _InputIterator >
    basic_string< _CharT, _Traits, _Alloc >::basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc & __a)
        : _M_dataplus(_S_construct(__beg, __end, __a), __a) 
    {
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc > & basic_string< _CharT, _Traits, _Alloc >::assign(const basic_string & __str)
    {
        if (_M_rep() != __str._M_rep())
        {
            const allocator_type __a = this->get_allocator();
            _CharT * __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
            _M_rep()->_M_dispose(__a);
            _M_data(__tmp);
        }
        return *this;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc > & basic_string< _CharT, _Traits, _Alloc >::assign(const _CharT * __s, size_type __n)
    {
        ;
        _M_check_length(this->size(), __n, "basic_string::assign");
        if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
            return _M_replace_safe(size_type(0), this->size(), __s, __n);
        else
        {
            const size_type __pos = __s - _M_data();
            if (__pos >= __n)
                _M_copy(_M_data(), __s, __n);
            else
                if (__pos)
                    _M_move(_M_data(), __s, __n);
            _M_rep()->_M_set_length_and_sharable(__n);
            return *this;
        }
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc > & basic_string< _CharT, _Traits, _Alloc >::append(size_type __n, _CharT __c)
    {
        if (__n)
        {
            _M_check_length(size_type(0), __n, "basic_string::append");
            const size_type __len = __n + this->size();
            if (__len > this->capacity() || _M_rep()->_M_is_shared())
                this->reserve(__len);
            _M_assign(_M_data() + this->size(), __n, __c);
            _M_rep()->_M_set_length_and_sharable(__len);
        }
        return *this;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc > & basic_string< _CharT, _Traits, _Alloc >::append(const _CharT * __s, size_type __n)
    {
        ;
        if (__n)
        {
            _M_check_length(size_type(0), __n, "basic_string::append");
            const size_type __len = __n + this->size();
            if (__len > this->capacity() || _M_rep()->_M_is_shared())
            {
                if (_M_disjunct(__s))
                    this->reserve(__len);
                else
                {
                    const size_type __off = __s - _M_data();
                    this->reserve(__len);
                    __s = _M_data() + __off;
                }
            }
            _M_copy(_M_data() + this->size(), __s, __n);
            _M_rep()->_M_set_length_and_sharable(__len);
        }
        return *this;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc > & basic_string< _CharT, _Traits, _Alloc >::append(const basic_string & __str)
    {
        const size_type __size = __str.size();
        if (__size)
        {
            const size_type __len = __size + this->size();
            if (__len > this->capacity() || _M_rep()->_M_is_shared())
                this->reserve(__len);
            _M_copy(_M_data() + this->size(), __str._M_data(), __size);
            _M_rep()->_M_set_length_and_sharable(__len);
        }
        return *this;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc > & basic_string< _CharT, _Traits, _Alloc >::append(const basic_string & __str, size_type __pos, size_type __n)
    {
        __str._M_check(__pos, "basic_string::append");
        __n = __str._M_limit(__pos, __n);
        if (__n)
        {
            const size_type __len = __n + this->size();
            if (__len > this->capacity() || _M_rep()->_M_is_shared())
                this->reserve(__len);
            _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
            _M_rep()->_M_set_length_and_sharable(__len);
        }
        return *this;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc > & basic_string< _CharT, _Traits, _Alloc >::insert(size_type __pos, const _CharT * __s, size_type __n)
    {
        ;
        _M_check(__pos, "basic_string::insert");
        _M_check_length(size_type(0), __n, "basic_string::insert");
        if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
            return _M_replace_safe(__pos, size_type(0), __s, __n);
        else
        {
            const size_type __off = __s - _M_data();
            _M_mutate(__pos, 0, __n);
            __s = _M_data() + __off;
            _CharT * __p = _M_data() + __pos;
            if (__s + __n <= __p)
                _M_copy(__p, __s, __n);
            else
                if (__s >= __p)
                    _M_copy(__p, __s + __n, __n);
                else
                {
                    const size_type __nleft = __p - __s;
                    _M_copy(__p, __s, __nleft);
                    _M_copy(__p + __nleft, __p + __n, __n - __nleft);
                }
            return *this;
        }
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc > & basic_string< _CharT, _Traits, _Alloc >::replace(size_type __pos, size_type __n1, const _CharT * __s, size_type __n2)
    {
        ;
        _M_check(__pos, "basic_string::replace");
        __n1 = _M_limit(__pos, __n1);
        _M_check_length(__n1, __n2, "basic_string::replace");
        bool __left;
        if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
            return _M_replace_safe(__pos, __n1, __s, __n2);
        else
            if ((__left = __s + __n2 <= _M_data() + __pos) || _M_data() + __pos + __n1 <= __s)
            {
                size_type __off = __s - _M_data();
                __left ? __off : (__off += __n2 - __n1);
                _M_mutate(__pos, __n1, __n2);
                _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
                return *this;
            }
            else
            {
                const basic_string __tmp(__s, __n2);
                return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
            }
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    void basic_string< _CharT, _Traits, _Alloc >::_Rep::_M_destroy(const _Alloc & __a) throw ()
    {
        const size_type __size = sizeof(_Rep_base) + (this->_M_capacity + 1) * sizeof(_CharT);
        _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char * >(this), __size);
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    void basic_string< _CharT, _Traits, _Alloc >::_M_leak_hard()
    {
        if (_M_rep() == &_S_empty_rep())
            return;
        if (_M_rep()->_M_is_shared())
            _M_mutate(0, 0, 0);
        _M_rep()->_M_set_leaked();
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    void basic_string< _CharT, _Traits, _Alloc >::_M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
        const size_type __old_size = this->size();
        const size_type __new_size = __old_size + __len2 - __len1;
        const size_type __how_much = __old_size - __pos - __len1;
        if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
        {
            const allocator_type __a = get_allocator();
            _Rep * __r = _Rep::_S_create(__new_size, this->capacity(), __a);
            if (__pos)
                _M_copy(__r->_M_refdata(), _M_data(), __pos);
            if (__how_much)
                _M_copy(__r->_M_refdata() + __pos + __len2, _M_data() + __pos + __len1, __how_much);
            _M_rep()->_M_dispose(__a);
            _M_data(__r->_M_refdata());
        }
        else
            if (__how_much && __len1 != __len2)
            {
                _M_move(_M_data() + __pos + __len2, _M_data() + __pos + __len1, __how_much);
            }
        _M_rep()->_M_set_length_and_sharable(__new_size);
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    void basic_string< _CharT, _Traits, _Alloc >::reserve(size_type __res)
    {
        if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {
            if (__res < this->size())
                __res = this->size();
            const allocator_type __a = get_allocator();
            _CharT * __tmp = _M_rep()->_M_clone(__a, __res - this->size());
            _M_rep()->_M_dispose(__a);
            _M_data(__tmp);
        }
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    void basic_string< _CharT, _Traits, _Alloc >::swap(basic_string & __s)
    {
        if (_M_rep()->_M_is_leaked())
            _M_rep()->_M_set_sharable();
        if (__s._M_rep()->_M_is_leaked())
            __s._M_rep()->_M_set_sharable();
        if (this->get_allocator() == __s.get_allocator())
        {
            _CharT * __tmp = _M_data();
            _M_data(__s._M_data());
            __s._M_data(__tmp);
        }
        else
        {
            const basic_string __tmp1(_M_ibegin(), _M_iend(), __s.get_allocator());
            const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(), this->get_allocator());
            *this = __tmp2;
            __s = __tmp1;
        }
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string< _CharT, _Traits, _Alloc >::_Rep * basic_string< _CharT, _Traits, _Alloc >::_Rep::_S_create(size_type __capacity, size_type __old_capacity, const _Alloc & __alloc)
    {
        if (__capacity > _S_max_size)
            __throw_length_error(("basic_string::_S_create"));
        const size_type __pagesize = 4096;
        const size_type __malloc_header_size = 4 * sizeof(void *);
        if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
            __capacity = 2 * __old_capacity;
        size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
        const size_type __adj_size = __size + __malloc_header_size;
        if (__adj_size > __pagesize && __capacity > __old_capacity)
        {
            const size_type __extra = __pagesize - __adj_size % __pagesize;
            __capacity += __extra / sizeof(_CharT);
            if (__capacity > _S_max_size)
                __capacity = _S_max_size;
            __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
        }
        void * __place = _Raw_bytes_alloc(__alloc).allocate(__size);
        _Rep * __p = new (__place) _Rep;
        __p->_M_capacity = __capacity;
        __p->_M_set_sharable();
        return __p;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    _CharT * basic_string< _CharT, _Traits, _Alloc >::_Rep::_M_clone(const _Alloc & __alloc, size_type __res)
    {
        const size_type __requested_cap = this->_M_length + __res;
        _Rep * __r = _Rep::_S_create(__requested_cap, this->_M_capacity, __alloc);
        if (this->_M_length)
            _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);
        __r->_M_set_length_and_sharable(this->_M_length);
        return __r->_M_refdata();
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    void basic_string< _CharT, _Traits, _Alloc >::resize(size_type __n, _CharT __c)
    {
        const size_type __size = this->size();
        _M_check_length(__size, __n, "basic_string::resize");
        if (__size < __n)
            this->append(__n - __size, __c);
        else
            if (__n < __size)
                this->erase(__n);
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    template<typename _InputIterator >
    basic_string< _CharT, _Traits, _Alloc > & basic_string< _CharT, _Traits, _Alloc >::_M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1, _InputIterator __k2, __false_type)
    {
        const basic_string __s(__k1, __k2);
        const size_type __n1 = __i2 - __i1;
        _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
        return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(), __s.size());
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc > & basic_string< _CharT, _Traits, _Alloc >::_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, _CharT __c)
    {
        _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
        _M_mutate(__pos1, __n1, __n2);
        if (__n2)
            _M_assign(_M_data() + __pos1, __n2, __c);
        return *this;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc > & basic_string< _CharT, _Traits, _Alloc >::_M_replace_safe(size_type __pos1, size_type __n1, const _CharT * __s, size_type __n2)
    {
        _M_mutate(__pos1, __n1, __n2);
        if (__n2)
            _M_copy(_M_data() + __pos1, __s, __n2);
        return *this;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc > operator +(const _CharT * __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)
    {
        ;
        typedef basic_string< _CharT, _Traits, _Alloc > __string_type;
        typedef typename __string_type::size_type __size_type;
        const __size_type __len = _Traits::length(__lhs);
        __string_type __str;
        __str.reserve(__len + __rhs.size());
        __str.append(__lhs, __len);
        __str.append(__rhs);
        return __str;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_string< _CharT, _Traits, _Alloc > operator +(_CharT __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)
    {
        typedef basic_string< _CharT, _Traits, _Alloc > __string_type;
        typedef typename __string_type::size_type __size_type;
        __string_type __str;
        const __size_type __len = __rhs.size();
        __str.reserve(__len + 1);
        __str.append(__size_type(1), __lhs);
        __str.append(__rhs);
        return __str;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string< _CharT, _Traits, _Alloc >::size_type basic_string< _CharT, _Traits, _Alloc >::copy(_CharT * __s, size_type __n, size_type __pos) const
    {
        _M_check(__pos, "basic_string::copy");
        __n = _M_limit(__pos, __n);
        ;
        if (__n)
            _M_copy(__s, _M_data() + __pos, __n);
        return __n;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string< _CharT, _Traits, _Alloc >::size_type basic_string< _CharT, _Traits, _Alloc >::find(const _CharT * __s, size_type __pos, size_type __n) const
    {
        ;
        const size_type __size = this->size();
        const _CharT * __data = _M_data();
        if (__n == 0)
            return __pos <= __size ? __pos : npos;
        if (__n <= __size)
        {
            for (;
                __pos <= __size - __n;
                ++__pos)
            if (traits_type::eq(__data[__pos], __s[0]) && traits_type::compare(__data + __pos + 1, __s + 1, __n - 1) == 0)
                return __pos;
        }
        return npos;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string< _CharT, _Traits, _Alloc >::size_type basic_string< _CharT, _Traits, _Alloc >::find(_CharT __c, size_type __pos) const
    {
        size_type __ret = npos;
        const size_type __size = this->size();
        if (__pos < __size)
        {
            const _CharT * __data = _M_data();
            const size_type __n = __size - __pos;
            const _CharT * __p = traits_type::find(__data + __pos, __n, __c);
            if (__p)
                __ret = __p - __data;
        }
        return __ret;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string< _CharT, _Traits, _Alloc >::size_type basic_string< _CharT, _Traits, _Alloc >::rfind(const _CharT * __s, size_type __pos, size_type __n) const
    {
        ;
        const size_type __size = this->size();
        if (__n <= __size)
        {
            __pos = std::min(size_type(__size - __n), __pos);
            const _CharT * __data = _M_data();
            do
            {
                if (traits_type::compare(__data + __pos, __s, __n) == 0)
                    return __pos;
            }
            while (__pos-- > 0);
        }
        return npos;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string< _CharT, _Traits, _Alloc >::size_type basic_string< _CharT, _Traits, _Alloc >::rfind(_CharT __c, size_type __pos) const
    {
        size_type __size = this->size();
        if (__size)
        {
            if (--__size > __pos)
                __size = __pos;
            for (++__size;
                __size-- > 0;
                )
            if (traits_type::eq(_M_data()[__size], __c))
                return __size;
        }
        return npos;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string< _CharT, _Traits, _Alloc >::size_type basic_string< _CharT, _Traits, _Alloc >::find_first_of(const _CharT * __s, size_type __pos, size_type __n) const
    {
        ;
        for (;
            __n && __pos < this->size();
            ++__pos)
        {
            const _CharT * __p = traits_type::find(__s, __n, _M_data()[__pos]);
            if (__p)
                return __pos;
        }
        return npos;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string< _CharT, _Traits, _Alloc >::size_type basic_string< _CharT, _Traits, _Alloc >::find_last_of(const _CharT * __s, size_type __pos, size_type __n) const
    {
        ;
        size_type __size = this->size();
        if (__size && __n)
        {
            if (--__size > __pos)
                __size = __pos;
            do
            {
                if (traits_type::find(__s, __n, _M_data()[__size]))
                    return __size;
            }
            while (__size-- != 0);
        }
        return npos;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string< _CharT, _Traits, _Alloc >::size_type basic_string< _CharT, _Traits, _Alloc >::find_first_not_of(const _CharT * __s, size_type __pos, size_type __n) const
    {
        ;
        for (;
            __pos < this->size();
            ++__pos)
        if (!traits_type::find(__s, __n, _M_data()[__pos]))
            return __pos;
        return npos;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string< _CharT, _Traits, _Alloc >::size_type basic_string< _CharT, _Traits, _Alloc >::find_first_not_of(_CharT __c, size_type __pos) const
    {
        for (;
            __pos < this->size();
            ++__pos)
        if (!traits_type::eq(_M_data()[__pos], __c))
            return __pos;
        return npos;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string< _CharT, _Traits, _Alloc >::size_type basic_string< _CharT, _Traits, _Alloc >::find_last_not_of(const _CharT * __s, size_type __pos, size_type __n) const
    {
        ;
        size_type __size = this->size();
        if (__size)
        {
            if (--__size > __pos)
                __size = __pos;
            do
            {
                if (!traits_type::find(__s, __n, _M_data()[__size]))
                    return __size;
            }
            while (__size--);
        }
        return npos;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    typename basic_string< _CharT, _Traits, _Alloc >::size_type basic_string< _CharT, _Traits, _Alloc >::find_last_not_of(_CharT __c, size_type __pos) const
    {
        size_type __size = this->size();
        if (__size)
        {
            if (--__size > __pos)
                __size = __pos;
            do
            {
                if (!traits_type::eq(_M_data()[__size], __c))
                    return __size;
            }
            while (__size--);
        }
        return npos;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    int basic_string< _CharT, _Traits, _Alloc >::compare(size_type __pos, size_type __n, const basic_string & __str) const
    {
        _M_check(__pos, "basic_string::compare");
        __n = _M_limit(__pos, __n);
        const size_type __osize = __str.size();
        const size_type __len = std::min(__n, __osize);
        int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
        if (!__r)
            __r = _S_compare(__n, __osize);
        return __r;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    int basic_string< _CharT, _Traits, _Alloc >::compare(size_type __pos1, size_type __n1, const basic_string & __str, size_type __pos2, size_type __n2) const
    {
        _M_check(__pos1, "basic_string::compare");
        __str._M_check(__pos2, "basic_string::compare");
        __n1 = _M_limit(__pos1, __n1);
        __n2 = __str._M_limit(__pos2, __n2);
        const size_type __len = std::min(__n1, __n2);
        int __r = traits_type::compare(_M_data() + __pos1, __str.data() + __pos2, __len);
        if (!__r)
            __r = _S_compare(__n1, __n2);
        return __r;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    int basic_string< _CharT, _Traits, _Alloc >::compare(const _CharT * __s) const
    {
        ;
        const size_type __size = this->size();
        const size_type __osize = traits_type::length(__s);
        const size_type __len = std::min(__size, __osize);
        int __r = traits_type::compare(_M_data(), __s, __len);
        if (!__r)
            __r = _S_compare(__size, __osize);
        return __r;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    int basic_string< _CharT, _Traits, _Alloc >::compare(size_type __pos, size_type __n1, const _CharT * __s) const
    {
        ;
        _M_check(__pos, "basic_string::compare");
        __n1 = _M_limit(__pos, __n1);
        const size_type __osize = traits_type::length(__s);
        const size_type __len = std::min(__n1, __osize);
        int __r = traits_type::compare(_M_data() + __pos, __s, __len);
        if (!__r)
            __r = _S_compare(__n1, __osize);
        return __r;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    int basic_string< _CharT, _Traits, _Alloc >::compare(size_type __pos, size_type __n1, const _CharT * __s, size_type __n2) const
    {
        ;
        _M_check(__pos, "basic_string::compare");
        __n1 = _M_limit(__pos, __n1);
        const size_type __len = std::min(__n1, __n2);
        int __r = traits_type::compare(_M_data() + __pos, __s, __len);
        if (!__r)
            __r = _S_compare(__n1, __n2);
        return __r;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_istream< _CharT, _Traits > & operator >>(basic_istream< _CharT, _Traits > & __in, basic_string< _CharT, _Traits, _Alloc > & __str)
    {
        typedef basic_istream< _CharT, _Traits > __istream_type;
        typedef basic_string< _CharT, _Traits, _Alloc > __string_type;
        typedef typename __istream_type::ios_base __ios_base;
        typedef typename __istream_type::int_type __int_type;
        typedef typename __string_type::size_type __size_type;
        typedef ctype< _CharT > __ctype_type;
        typedef typename __ctype_type::ctype_base __ctype_base;
        __size_type __extracted = 0;
        typename __ios_base::iostate __err = __ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb)
        {
            try
            {
                __str.erase();
                _CharT __buf[128];
                __size_type __len = 0;
                const streamsize __w = __in.width();
                const __size_type __n = __w > 0 ? static_cast<__size_type >(__w) : __str.max_size();
                const __ctype_type & __ct = use_facet< __ctype_type >(__in.getloc());
                const __int_type __eof = _Traits::eof();
                __int_type __c = __in.rdbuf()->sgetc();
                while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) && !__ct.is(__ctype_base::space, _Traits::to_char_type(__c)))
                {
                    if (__len == sizeof (__buf) / sizeof(_CharT))
                    {
                        __str.append(__buf, sizeof (__buf) / sizeof(_CharT));
                        __len = 0;
                    }
                    __buf[__len++] = _Traits::to_char_type(__c);
                    ++__extracted;
                    __c = __in.rdbuf()->snextc();
                }
                __str.append(__buf, __len);
                if (_Traits::eq_int_type(__c, __eof))
                    __err |= __ios_base::eofbit;
                __in.width(0);
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                __in._M_setstate(__ios_base::badbit);
                throw;
            }
            catch (...)
            {
                __in._M_setstate(__ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= __ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    basic_istream< _CharT, _Traits > & getline(basic_istream< _CharT, _Traits > & __in, basic_string< _CharT, _Traits, _Alloc > & __str, _CharT __delim)
    {
        typedef basic_istream< _CharT, _Traits > __istream_type;
        typedef basic_string< _CharT, _Traits, _Alloc > __string_type;
        typedef typename __istream_type::ios_base __ios_base;
        typedef typename __istream_type::int_type __int_type;
        typedef typename __string_type::size_type __size_type;
        __size_type __extracted = 0;
        const __size_type __n = __str.max_size();
        typename __ios_base::iostate __err = __ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, true);
        if (__cerb)
        {
            try
            {
                __str.erase();
                const __int_type __idelim = _Traits::to_int_type(__delim);
                const __int_type __eof = _Traits::eof();
                __int_type __c = __in.rdbuf()->sgetc();
                while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) && !_Traits::eq_int_type(__c, __idelim))
                {
                    __str += _Traits::to_char_type(__c);
                    ++__extracted;
                    __c = __in.rdbuf()->snextc();
                }
                if (_Traits::eq_int_type(__c, __eof))
                    __err |= __ios_base::eofbit;
                else
                    if (_Traits::eq_int_type(__c, __idelim))
                    {
                        ++__extracted;
                        __in.rdbuf()->sbumpc();
                    }
                    else
                        __err |= __ios_base::failbit;
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                __in._M_setstate(__ios_base::badbit);
                throw;
            }
            catch (...)
            {
                __in._M_setstate(__ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= __ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }
    extern template class basic_string< char > ;
    extern template basic_istream< char > & operator >>(basic_istream< char > &, string &);
    extern template basic_ostream< char > & operator <<(basic_ostream< char > &, const string &);
    extern template basic_istream< char > & getline(basic_istream< char > &, string &, char);
    extern template basic_istream< char > & getline(basic_istream< char > &, string &);
    extern template class basic_string< wchar_t > ;
    extern template basic_istream< wchar_t > & operator >>(basic_istream< wchar_t > &, wstring &);
    extern template basic_ostream< wchar_t > & operator <<(basic_ostream< wchar_t > &, const wstring &);
    extern template basic_istream< wchar_t > & getline(basic_istream< wchar_t > &, wstring &, wchar_t);
    extern template basic_istream< wchar_t > & getline(basic_istream< wchar_t > &, wstring &);
}
namespace std __attribute__((__visibility__("default"))) {
    class locale
    {
        public :
            typedef int category;
            class facet;
            class id;
            class _Impl;
            friend class facet;
            friend class _Impl;
            template<typename _Facet >
            friend bool has_facet(const locale &) throw ();
            template<typename _Facet >
            friend const _Facet & use_facet(const locale &);
            template<typename _Cache >
            friend struct __use_cache;
            static const category none = 0;
            static const category ctype = 1L << 0;
            static const category numeric = 1L << 1;
            static const category collate = 1L << 2;
            static const category time = 1L << 3;
            static const category monetary = 1L << 4;
            static const category messages = 1L << 5;
            static const category all = (ctype | numeric | collate | time | monetary | messages);
            locale() throw ();
            locale(const locale & __other) throw ();
            explicit locale(const char * __s);
            locale(const locale & __base, const char * __s, category __cat);
            locale(const locale & __base, const locale & __add, category __cat);
            template<typename _Facet >
            locale(const locale & __other, _Facet * __f);
            ~locale() throw ();
            const locale & operator =(const locale & __other) throw ();
            template<typename _Facet >
            locale combine(const locale & __other) const;
            string name() const;
            bool operator ==(const locale & __other) const throw ();
            bool operator !=(const locale & __other) const throw ()
            {
                return !(this->operator ==(__other));
            }
            template<typename _Char, typename _Traits, typename _Alloc >
            bool operator ()(const basic_string< _Char, _Traits, _Alloc > & __s1, const basic_string< _Char, _Traits, _Alloc > & __s2) const;
            static locale global(const locale &);
            static const locale & classic();
        private :
            _Impl * _M_impl;
            static _Impl * _S_classic;
            static _Impl * _S_global;
            static const char *const *const _S_categories;
            enum 
            {
                _S_categories_size = 6 + 6
            };
            static __gthread_once_t _S_once;
            explicit locale(_Impl *) throw ();
            static void _S_initialize();
            static void _S_initialize_once();
            static category _S_normalize_category(category);
            void _M_coalesce(const locale & __base, const locale & __add, category __cat);
    };
    class locale::facet
    {
        private :
            friend class locale;
            friend class locale::_Impl;
            mutable _Atomic_word _M_refcount;
            static __c_locale _S_c_locale;
            static const char _S_c_name[2];
            static __gthread_once_t _S_once;
            static void _S_initialize_once();
        protected :
            explicit facet(size_t __refs = 0) throw ()
                : _M_refcount(__refs ? 1 : 0) 
            {
            }
            virtual ~facet();
            static void _S_create_c_locale(__c_locale & __cloc, const char * __s, __c_locale __old = 0);
            static __c_locale _S_clone_c_locale(__c_locale & __cloc);
            static void _S_destroy_c_locale(__c_locale & __cloc);
            static __c_locale _S_get_c_locale();
            static const char * _S_get_c_name();
        private :
            void _M_add_reference() const throw ()
            {
                __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1);
            }
            void _M_remove_reference() const throw ()
            {
                if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
                {
                    try
                    {
                        delete this;
                    }
                    catch (...)
                    {
                    }
                }
            }
            facet(const facet &);
            facet & operator =(const facet &);
    };
    class locale::id
    {
        private :
            friend class locale;
            friend class locale::_Impl;
            template<typename _Facet >
            friend const _Facet & use_facet(const locale &);
            template<typename _Facet >
            friend bool has_facet(const locale &) throw ();
            mutable size_t _M_index;
            static _Atomic_word _S_refcount;
            void operator =(const id &);
            id(const id &);
        public :
            id()
            {
            }
            size_t _M_id() const;
    };
    class locale::_Impl
    {
        public :
            friend class locale;
            friend class locale::facet;
            template<typename _Facet >
            friend bool has_facet(const locale &) throw ();
            template<typename _Facet >
            friend const _Facet & use_facet(const locale &);
            template<typename _Cache >
            friend struct __use_cache;
        private :
            _Atomic_word _M_refcount;
            const facet * * _M_facets;
            size_t _M_facets_size;
            const facet * * _M_caches;
            char * * _M_names;
            static const locale::id *const _S_id_ctype[];
            static const locale::id *const _S_id_numeric[];
            static const locale::id *const _S_id_collate[];
            static const locale::id *const _S_id_time[];
            static const locale::id *const _S_id_monetary[];
            static const locale::id *const _S_id_messages[];
            static const locale::id *const *const _S_facet_categories[];
            void _M_add_reference() throw ()
            {
                __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1);
            }
            void _M_remove_reference() throw ()
            {
                if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
                {
                    try
                    {
                        delete this;
                    }
                    catch (...)
                    {
                    }
                }
            }
            _Impl(const _Impl &, size_t);
            _Impl(const char *, size_t);
            _Impl(size_t) throw ();
            ~_Impl() throw ();
            _Impl(const _Impl &);
            void operator =(const _Impl &);
            bool _M_check_same_name()
            {
                bool __ret = true;
                if (_M_names[1])
                    for (size_t __i = 0;
                        __ret && __i < _S_categories_size - 1;
                        ++__i)
                    __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
                return __ret;
            }
            void _M_replace_categories(const _Impl *, category);
            void _M_replace_category(const _Impl *, const locale::id *const*);
            void _M_replace_facet(const _Impl *, const locale::id *);
            void _M_install_facet(const locale::id *, const facet *);
            template<typename _Facet >
            void _M_init_facet(_Facet * __facet)
            {
                _M_install_facet(&_Facet::id, __facet);
            }
            void _M_install_cache(const facet *, size_t);
    };
    template<typename _Facet >
    bool has_facet(const locale & __loc) throw ();
    template<typename _Facet >
    const _Facet & use_facet(const locale & __loc);
    template<typename _CharT >
    class collate : public locale::facet
    {
        public :
            typedef _CharT char_type;
            typedef basic_string< _CharT > string_type;
        protected :
            __c_locale _M_c_locale_collate;
        public :
            static locale::id id;
            explicit collate(size_t __refs = 0)
                : facet(__refs), _M_c_locale_collate(_S_get_c_locale()) 
            {
            }
            explicit collate(__c_locale __cloc, size_t __refs = 0)
                : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc)) 
            {
            }
            int compare(const _CharT * __lo1, const _CharT * __hi1, const _CharT * __lo2, const _CharT * __hi2) const
            {
                return this->do_compare(__lo1, __hi1, __lo2, __hi2);
            }
            string_type transform(const _CharT * __lo, const _CharT * __hi) const
            {
                return this->do_transform(__lo, __hi);
            }
            long hash(const _CharT * __lo, const _CharT * __hi) const
            {
                return this->do_hash(__lo, __hi);
            }
            int _M_compare(const _CharT *, const _CharT *) const;
            size_t _M_transform(_CharT *, const _CharT *, size_t) const;
        protected :
            virtual ~collate()
            {
                _S_destroy_c_locale(_M_c_locale_collate);
            }
            virtual int do_compare(const _CharT * __lo1, const _CharT * __hi1, const _CharT * __lo2, const _CharT * __hi2) const;
            virtual string_type do_transform(const _CharT * __lo, const _CharT * __hi) const;
            virtual long do_hash(const _CharT * __lo, const _CharT * __hi) const;
    };
    template<typename _CharT >
    locale::id collate< _CharT >::id;
    template<>
    int collate< char >::_M_compare(const char *, const char *) const;
    template<>
    size_t collate< char >::_M_transform(char *, const char *, size_t) const;
    template<>
    int collate< wchar_t >::_M_compare(const wchar_t *, const wchar_t *) const;
    template<>
    size_t collate< wchar_t >::_M_transform(wchar_t *, const wchar_t *, size_t) const;
    template<typename _CharT >
    class collate_byname : public collate< _CharT >
    {
        public :
            typedef _CharT char_type;
            typedef basic_string< _CharT > string_type;
            explicit collate_byname(const char * __s, size_t __refs = 0)
                : collate< _CharT >(__refs) 
            {
                if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0)
                {
                    this->_S_destroy_c_locale(this->_M_c_locale_collate);
                    this->_S_create_c_locale(this->_M_c_locale_collate, __s);
                }
            }
        protected :
            virtual ~collate_byname()
            {
            }
    };
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Facet >
    locale::locale(const locale & __other, _Facet * __f)
    {
        _M_impl = new _Impl (*__other._M_impl, 1);
        try
        {
            _M_impl->_M_install_facet(&_Facet::id, __f);
        }
        catch (...)
        {
            _M_impl->_M_remove_reference();
            throw;
        }
        delete[] _M_impl->_M_names[0];
        _M_impl->_M_names[0] = 0;
    }
    template<typename _Facet >
    locale locale::combine(const locale & __other) const
    {
        _Impl * __tmp = new _Impl (*_M_impl, 1);
        try
        {
            __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
        }
        catch (...)
        {
            __tmp->_M_remove_reference();
            throw;
        }
        return locale(__tmp);
    }
    template<typename _CharT, typename _Traits, typename _Alloc >
    bool locale::operator ()(const basic_string< _CharT, _Traits, _Alloc > & __s1, const basic_string< _CharT, _Traits, _Alloc > & __s2) const
    {
        typedef std::collate< _CharT > __collate_type;
        const __collate_type & __collate = use_facet< __collate_type >(*this);
        return (__collate.compare(__s1.data(), __s1.data() + __s1.length(), __s2.data(), __s2.data() + __s2.length()) < 0);
    }
    template<typename _Facet >
    bool has_facet(const locale & __loc) throw ()
    {
        const size_t __i = _Facet::id._M_id();
        const locale::facet * * __facets = __loc._M_impl->_M_facets;
        return (__i < __loc._M_impl->_M_facets_size && dynamic_cast<const _Facet * >(__facets[__i]));
    }
    template<typename _Facet >
    const _Facet & use_facet(const locale & __loc)
    {
        const size_t __i = _Facet::id._M_id();
        const locale::facet * * __facets = __loc._M_impl->_M_facets;
        if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
            __throw_bad_cast();
        return dynamic_cast<const _Facet & >(*__facets[__i]);
    }
    template<typename _CharT >
    int collate< _CharT >::_M_compare(const _CharT *, const _CharT *) const
    {
        return 0;
    }
    template<typename _CharT >
    size_t collate< _CharT >::_M_transform(_CharT *, const _CharT *, size_t) const
    {
        return 0;
    }
    template<typename _CharT >
    int collate< _CharT >::do_compare(const _CharT * __lo1, const _CharT * __hi1, const _CharT * __lo2, const _CharT * __hi2) const
    {
        const string_type __one(__lo1, __hi1);
        const string_type __two(__lo2, __hi2);
        const _CharT * __p = __one.c_str();
        const _CharT * __pend = __one.data() + __one.length();
        const _CharT * __q = __two.c_str();
        const _CharT * __qend = __two.data() + __two.length();
        for (;
;
            )
        {
            const int __res = _M_compare(__p, __q);
            if (__res)
                return __res;
            __p += char_traits< _CharT >::length(__p);
            __q += char_traits< _CharT >::length(__q);
            if (__p == __pend && __q == __qend)
                return 0;
            else
                if (__p == __pend)
                    return -1;
                else
                    if (__q == __qend)
                        return 1;
            __p++;
            __q++;
        }
    }
    template<typename _CharT >
    typename collate< _CharT >::string_type collate< _CharT >::do_transform(const _CharT * __lo, const _CharT * __hi) const
    {
        string_type __ret;
        const string_type __str(__lo, __hi);
        const _CharT * __p = __str.c_str();
        const _CharT * __pend = __str.data() + __str.length();
        size_t __len = (__hi - __lo) * 2;
        _CharT * __c = new _CharT [__len];
        try
        {
            for (;
;
                )
            {
                size_t __res = _M_transform(__c, __p, __len);
                if (__res >= __len)
                {
                    __len = __res + 1;
                    delete[] __c , __c = 0;
                    __c = new _CharT [__len];
                    __res = _M_transform(__c, __p, __len);
                }
                __ret.append(__c, __res);
                __p += char_traits< _CharT >::length(__p);
                if (__p == __pend)
                    break;
                __p++;
                __ret.push_back(_CharT());
            }
        }
        catch (...)
        {
            delete[] __c;
            throw;
        }
        delete[] __c;
        return __ret;
    }
    template<typename _CharT >
    long collate< _CharT >::do_hash(const _CharT * __lo, const _CharT * __hi) const
    {
        unsigned long __val = 0;
        for (;
            __lo < __hi;
            ++__lo)
        __val = *__lo + ((__val << 7) | (__val >> (__gnu_cxx::__numeric_traits< unsigned long >::__digits - 7)));
        return static_cast<long >(__val);
    }
    extern template class collate< char > ;
    extern template class collate_byname< char > ;
    extern template const collate< char > & use_facet< collate< char > >(const locale &);
    extern template bool has_facet< collate< char > >(const locale &);
    extern template class collate< wchar_t > ;
    extern template class collate_byname< wchar_t > ;
    extern template const collate< wchar_t > & use_facet< collate< wchar_t > >(const locale &);
    extern template bool has_facet< collate< wchar_t > >(const locale &);
}
namespace std __attribute__((__visibility__("default"))) {
    enum _Ios_Fmtflags
    {
        _S_boolalpha = 1L << 0, 
        _S_dec = 1L << 1, 
        _S_fixed = 1L << 2, 
        _S_hex = 1L << 3, 
        _S_internal = 1L << 4, 
        _S_left = 1L << 5, 
        _S_oct = 1L << 6, 
        _S_right = 1L << 7, 
        _S_scientific = 1L << 8, 
        _S_showbase = 1L << 9, 
        _S_showpoint = 1L << 10, 
        _S_showpos = 1L << 11, 
        _S_skipws = 1L << 12, 
        _S_unitbuf = 1L << 13, 
        _S_uppercase = 1L << 14, 
        _S_adjustfield = _S_left | _S_right | _S_internal, 
        _S_basefield = _S_dec | _S_oct | _S_hex, 
        _S_floatfield = _S_scientific | _S_fixed, 
        _S_ios_fmtflags_end = 1L << 16
    };
    inline _Ios_Fmtflags operator &(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
    {
        return _Ios_Fmtflags(static_cast<int >(__a) & static_cast<int >(__b));
    }
    inline _Ios_Fmtflags operator |(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
    {
        return _Ios_Fmtflags(static_cast<int >(__a) | static_cast<int >(__b));
    }
    inline _Ios_Fmtflags operator ^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
    {
        return _Ios_Fmtflags(static_cast<int >(__a) ^ static_cast<int >(__b));
    }
    inline _Ios_Fmtflags & operator |=(_Ios_Fmtflags & __a, _Ios_Fmtflags __b)
    {
        return __a = __a | __b;
    }
    inline _Ios_Fmtflags & operator &=(_Ios_Fmtflags & __a, _Ios_Fmtflags __b)
    {
        return __a = __a & __b;
    }
    inline _Ios_Fmtflags & operator ^=(_Ios_Fmtflags & __a, _Ios_Fmtflags __b)
    {
        return __a = __a ^ __b;
    }
    inline _Ios_Fmtflags operator ~(_Ios_Fmtflags __a)
    {
        return _Ios_Fmtflags(~static_cast<int >(__a));
    }
    enum _Ios_Openmode
    {
        _S_app = 1L << 0, 
        _S_ate = 1L << 1, 
        _S_bin = 1L << 2, 
        _S_in = 1L << 3, 
        _S_out = 1L << 4, 
        _S_trunc = 1L << 5, 
        _S_ios_openmode_end = 1L << 16
    };
    inline _Ios_Openmode operator &(_Ios_Openmode __a, _Ios_Openmode __b)
    {
        return _Ios_Openmode(static_cast<int >(__a) & static_cast<int >(__b));
    }
    inline _Ios_Openmode operator |(_Ios_Openmode __a, _Ios_Openmode __b)
    {
        return _Ios_Openmode(static_cast<int >(__a) | static_cast<int >(__b));
    }
    inline _Ios_Openmode operator ^(_Ios_Openmode __a, _Ios_Openmode __b)
    {
        return _Ios_Openmode(static_cast<int >(__a) ^ static_cast<int >(__b));
    }
    inline _Ios_Openmode & operator |=(_Ios_Openmode & __a, _Ios_Openmode __b)
    {
        return __a = __a | __b;
    }
    inline _Ios_Openmode & operator &=(_Ios_Openmode & __a, _Ios_Openmode __b)
    {
        return __a = __a & __b;
    }
    inline _Ios_Openmode & operator ^=(_Ios_Openmode & __a, _Ios_Openmode __b)
    {
        return __a = __a ^ __b;
    }
    inline _Ios_Openmode operator ~(_Ios_Openmode __a)
    {
        return _Ios_Openmode(~static_cast<int >(__a));
    }
    enum _Ios_Iostate
    {
        _S_goodbit = 0, 
        _S_badbit = 1L << 0, 
        _S_eofbit = 1L << 1, 
        _S_failbit = 1L << 2, 
        _S_ios_iostate_end = 1L << 16
    };
    inline _Ios_Iostate operator &(_Ios_Iostate __a, _Ios_Iostate __b)
    {
        return _Ios_Iostate(static_cast<int >(__a) & static_cast<int >(__b));
    }
    inline _Ios_Iostate operator |(_Ios_Iostate __a, _Ios_Iostate __b)
    {
        return _Ios_Iostate(static_cast<int >(__a) | static_cast<int >(__b));
    }
    inline _Ios_Iostate operator ^(_Ios_Iostate __a, _Ios_Iostate __b)
    {
        return _Ios_Iostate(static_cast<int >(__a) ^ static_cast<int >(__b));
    }
    inline _Ios_Iostate & operator |=(_Ios_Iostate & __a, _Ios_Iostate __b)
    {
        return __a = __a | __b;
    }
    inline _Ios_Iostate & operator &=(_Ios_Iostate & __a, _Ios_Iostate __b)
    {
        return __a = __a & __b;
    }
    inline _Ios_Iostate & operator ^=(_Ios_Iostate & __a, _Ios_Iostate __b)
    {
        return __a = __a ^ __b;
    }
    inline _Ios_Iostate operator ~(_Ios_Iostate __a)
    {
        return _Ios_Iostate(~static_cast<int >(__a));
    }
    enum _Ios_Seekdir
    {
        _S_beg = 0, 
        _S_cur = 1, 
        _S_end = 2, 
        _S_ios_seekdir_end = 1L << 16
    };
    class ios_base
    {
        public :
            class failure : public exception
            {
                public :
                    explicit failure(const string & __str) throw ();
                    virtual ~failure() throw ();
                    virtual const char * what() const throw ();
                private :
                    string _M_msg;
            };
            typedef _Ios_Fmtflags fmtflags;
            static const fmtflags boolalpha = _S_boolalpha;
            static const fmtflags dec = _S_dec;
            static const fmtflags fixed = _S_fixed;
            static const fmtflags hex = _S_hex;
            static const fmtflags internal = _S_internal;
            static const fmtflags left = _S_left;
            static const fmtflags oct = _S_oct;
            static const fmtflags right = _S_right;
            static const fmtflags scientific = _S_scientific;
            static const fmtflags showbase = _S_showbase;
            static const fmtflags showpoint = _S_showpoint;
            static const fmtflags showpos = _S_showpos;
            static const fmtflags skipws = _S_skipws;
            static const fmtflags unitbuf = _S_unitbuf;
            static const fmtflags uppercase = _S_uppercase;
            static const fmtflags adjustfield = _S_adjustfield;
            static const fmtflags basefield = _S_basefield;
            static const fmtflags floatfield = _S_floatfield;
            typedef _Ios_Iostate iostate;
            static const iostate badbit = _S_badbit;
            static const iostate eofbit = _S_eofbit;
            static const iostate failbit = _S_failbit;
            static const iostate goodbit = _S_goodbit;
            typedef _Ios_Openmode openmode;
            static const openmode app = _S_app;
            static const openmode ate = _S_ate;
            static const openmode binary = _S_bin;
            static const openmode in = _S_in;
            static const openmode out = _S_out;
            static const openmode trunc = _S_trunc;
            typedef _Ios_Seekdir seekdir;
            static const seekdir beg = _S_beg;
            static const seekdir cur = _S_cur;
            static const seekdir end = _S_end;
            typedef int io_state;
            typedef int open_mode;
            typedef int seek_dir;
            typedef std::streampos streampos;
            typedef std::streamoff streamoff;
            enum event
            {
                erase_event, 
                imbue_event, 
                copyfmt_event
            };
            typedef void (* event_callback)(event, ios_base &, int);
            void register_callback(event_callback __fn, int __index);
        protected :
            streamsize _M_precision;
            streamsize _M_width;
            fmtflags _M_flags;
            iostate _M_exception;
            iostate _M_streambuf_state;
            struct _Callback_list
            {
                    _Callback_list * _M_next;
                    ios_base::event_callback _M_fn;
                    int _M_index;
                    _Atomic_word _M_refcount;
                    _Callback_list(ios_base::event_callback __fn, int __index, _Callback_list * __cb)
                        : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) 
                    {
                    }
                    void _M_add_reference()
                    {
                        __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1);
                    }
                    int _M_remove_reference()
                    {
                        return __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
                    }
            };
            _Callback_list * _M_callbacks;
            void _M_call_callbacks(event __ev) throw ();
            void _M_dispose_callbacks(void);
            struct _Words
            {
                    void * _M_pword;
                    long _M_iword;
                    _Words()
                        : _M_pword(0), _M_iword(0) 
                    {
                    }
            };
            _Words _M_word_zero;
            enum 
            {
                _S_local_word_size = 8
            };
            _Words _M_local_word[_S_local_word_size];
            int _M_word_size;
            _Words * _M_word;
            _Words & _M_grow_words(int __index, bool __iword);
            locale _M_ios_locale;
            void _M_init();
        public :
            class Init
            {
                    friend class ios_base;
                public :
                    Init();
                    ~Init();
                private :
                    static _Atomic_word _S_refcount;
                    static bool _S_synced_with_stdio;
            };
            fmtflags flags() const
            {
                return _M_flags;
            }
            fmtflags flags(fmtflags __fmtfl)
            {
                fmtflags __old = _M_flags;
                _M_flags = __fmtfl;
                return __old;
            }
            fmtflags setf(fmtflags __fmtfl)
            {
                fmtflags __old = _M_flags;
                _M_flags |= __fmtfl;
                return __old;
            }
            fmtflags setf(fmtflags __fmtfl, fmtflags __mask)
            {
                fmtflags __old = _M_flags;
                _M_flags &= ~__mask;
                _M_flags |= (__fmtfl & __mask);
                return __old;
            }
            void unsetf(fmtflags __mask)
            {
                _M_flags &= ~__mask;
            }
            streamsize precision() const
            {
                return _M_precision;
            }
            streamsize precision(streamsize __prec)
            {
                streamsize __old = _M_precision;
                _M_precision = __prec;
                return __old;
            }
            streamsize width() const
            {
                return _M_width;
            }
            streamsize width(streamsize __wide)
            {
                streamsize __old = _M_width;
                _M_width = __wide;
                return __old;
            }
            static bool sync_with_stdio(bool __sync = true);
            locale imbue(const locale & __loc);
            locale getloc() const
            {
                return _M_ios_locale;
            }
            const locale & _M_getloc() const
            {
                return _M_ios_locale;
            }
            static int xalloc() throw ();
            long & iword(int __ix)
            {
                _Words & __word = (__ix < _M_word_size) ? _M_word[__ix] : _M_grow_words(__ix, true);
                return __word._M_iword;
            }
            void * & pword(int __ix)
            {
                _Words & __word = (__ix < _M_word_size) ? _M_word[__ix] : _M_grow_words(__ix, false);
                return __word._M_pword;
            }
            virtual ~ios_base();
        protected :
            ios_base();
        private :
            ios_base(const ios_base &);
            ios_base & operator =(const ios_base &);
    };
    inline ios_base & boolalpha(ios_base & __base)
    {
        __base.setf(ios_base::boolalpha);
        return __base;
    }
    inline ios_base & noboolalpha(ios_base & __base)
    {
        __base.unsetf(ios_base::boolalpha);
        return __base;
    }
    inline ios_base & showbase(ios_base & __base)
    {
        __base.setf(ios_base::showbase);
        return __base;
    }
    inline ios_base & noshowbase(ios_base & __base)
    {
        __base.unsetf(ios_base::showbase);
        return __base;
    }
    inline ios_base & showpoint(ios_base & __base)
    {
        __base.setf(ios_base::showpoint);
        return __base;
    }
    inline ios_base & noshowpoint(ios_base & __base)
    {
        __base.unsetf(ios_base::showpoint);
        return __base;
    }
    inline ios_base & showpos(ios_base & __base)
    {
        __base.setf(ios_base::showpos);
        return __base;
    }
    inline ios_base & noshowpos(ios_base & __base)
    {
        __base.unsetf(ios_base::showpos);
        return __base;
    }
    inline ios_base & skipws(ios_base & __base)
    {
        __base.setf(ios_base::skipws);
        return __base;
    }
    inline ios_base & noskipws(ios_base & __base)
    {
        __base.unsetf(ios_base::skipws);
        return __base;
    }
    inline ios_base & uppercase(ios_base & __base)
    {
        __base.setf(ios_base::uppercase);
        return __base;
    }
    inline ios_base & nouppercase(ios_base & __base)
    {
        __base.unsetf(ios_base::uppercase);
        return __base;
    }
    inline ios_base & unitbuf(ios_base & __base)
    {
        __base.setf(ios_base::unitbuf);
        return __base;
    }
    inline ios_base & nounitbuf(ios_base & __base)
    {
        __base.unsetf(ios_base::unitbuf);
        return __base;
    }
    inline ios_base & internal(ios_base & __base)
    {
        __base.setf(ios_base::internal, ios_base::adjustfield);
        return __base;
    }
    inline ios_base & left(ios_base & __base)
    {
        __base.setf(ios_base::left, ios_base::adjustfield);
        return __base;
    }
    inline ios_base & right(ios_base & __base)
    {
        __base.setf(ios_base::right, ios_base::adjustfield);
        return __base;
    }
    inline ios_base & dec(ios_base & __base)
    {
        __base.setf(ios_base::dec, ios_base::basefield);
        return __base;
    }
    inline ios_base & hex(ios_base & __base)
    {
        __base.setf(ios_base::hex, ios_base::basefield);
        return __base;
    }
    inline ios_base & oct(ios_base & __base)
    {
        __base.setf(ios_base::oct, ios_base::basefield);
        return __base;
    }
    inline ios_base & fixed(ios_base & __base)
    {
        __base.setf(ios_base::fixed, ios_base::floatfield);
        return __base;
    }
    inline ios_base & scientific(ios_base & __base)
    {
        __base.setf(ios_base::scientific, ios_base::floatfield);
        return __base;
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _CharT, typename _Traits >
    streamsize __copy_streambufs_eof(basic_streambuf< _CharT, _Traits > *, basic_streambuf< _CharT, _Traits > *, bool &);
    template<typename _CharT, typename _Traits >
    class basic_streambuf
    {
        public :
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            typedef basic_streambuf< char_type, traits_type > __streambuf_type;
            friend class basic_ios< char_type, traits_type >;
            friend class basic_istream< char_type, traits_type >;
            friend class basic_ostream< char_type, traits_type >;
            friend class istreambuf_iterator< char_type, traits_type >;
            friend class ostreambuf_iterator< char_type, traits_type >;
            friend streamsize __copy_streambufs_eof<  >(__streambuf_type *, __streambuf_type *, bool &);
            template<bool _IsMove, typename _CharT2 >
            friend typename __gnu_cxx::__enable_if< __is_char< _CharT2 >::__value, _CharT2 * >::__type __copy_move_a2(istreambuf_iterator< _CharT2 >, istreambuf_iterator< _CharT2 >, _CharT2 *);
            template<typename _CharT2 >
            friend typename __gnu_cxx::__enable_if< __is_char< _CharT2 >::__value, istreambuf_iterator< _CharT2 > >::__type find(istreambuf_iterator< _CharT2 >, istreambuf_iterator< _CharT2 >, const _CharT2 &);
            template<typename _CharT2, typename _Traits2 >
            friend basic_istream< _CharT2, _Traits2 > & operator >>(basic_istream< _CharT2, _Traits2 > &, _CharT2 *);
            template<typename _CharT2, typename _Traits2, typename _Alloc >
            friend basic_istream< _CharT2, _Traits2 > & operator >>(basic_istream< _CharT2, _Traits2 > &, basic_string< _CharT2, _Traits2, _Alloc > &);
            template<typename _CharT2, typename _Traits2, typename _Alloc >
            friend basic_istream< _CharT2, _Traits2 > & getline(basic_istream< _CharT2, _Traits2 > &, basic_string< _CharT2, _Traits2, _Alloc > &, _CharT2);
        protected :
            char_type * _M_in_beg;
            char_type * _M_in_cur;
            char_type * _M_in_end;
            char_type * _M_out_beg;
            char_type * _M_out_cur;
            char_type * _M_out_end;
            locale _M_buf_locale;
        public :
            virtual ~basic_streambuf()
            {
            }
            locale pubimbue(const locale & __loc)
            {
                locale __tmp(this->getloc());
                this->imbue(__loc);
                _M_buf_locale = __loc;
                return __tmp;
            }
            locale getloc() const
            {
                return _M_buf_locale;
            }
            __streambuf_type * pubsetbuf(char_type * __s, streamsize __n)
            {
                return this->setbuf(__s, __n);
            }
            pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode = ios_base::in | ios_base::out)
            {
                return this->seekoff(__off, __way, __mode);
            }
            pos_type pubseekpos(pos_type __sp, ios_base::openmode __mode = ios_base::in | ios_base::out)
            {
                return this->seekpos(__sp, __mode);
            }
            int pubsync()
            {
                return this->sync();
            }
            streamsize in_avail()
            {
                const streamsize __ret = this->egptr() - this->gptr();
                return __ret ? __ret : this->showmanyc();
            }
            int_type snextc()
            {
                int_type __ret = traits_type::eof();
                if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(), __ret), true))
                    __ret = this->sgetc();
                return __ret;
            }
            int_type sbumpc()
            {
                int_type __ret;
                if (__builtin_expect(this->gptr() < this->egptr(), true))
                {
                    __ret = traits_type::to_int_type(*this->gptr());
                    this->gbump(1);
                }
                else
                    __ret = this->uflow();
                return __ret;
            }
            int_type sgetc()
            {
                int_type __ret;
                if (__builtin_expect(this->gptr() < this->egptr(), true))
                    __ret = traits_type::to_int_type(*this->gptr());
                else
                    __ret = this->underflow();
                return __ret;
            }
            streamsize sgetn(char_type * __s, streamsize __n)
            {
                return this->xsgetn(__s, __n);
            }
            int_type sputbackc(char_type __c)
            {
                int_type __ret;
                const bool __testpos = this->eback() < this->gptr();
                if (__builtin_expect(!__testpos || !traits_type::eq(__c, this->gptr()[-1]), false))
                    __ret = this->pbackfail(traits_type::to_int_type(__c));
                else
                {
                    this->gbump(-1);
                    __ret = traits_type::to_int_type(*this->gptr());
                }
                return __ret;
            }
            int_type sungetc()
            {
                int_type __ret;
                if (__builtin_expect(this->eback() < this->gptr(), true))
                {
                    this->gbump(-1);
                    __ret = traits_type::to_int_type(*this->gptr());
                }
                else
                    __ret = this->pbackfail();
                return __ret;
            }
            int_type sputc(char_type __c)
            {
                int_type __ret;
                if (__builtin_expect(this->pptr() < this->epptr(), true))
                {
                    *this->pptr() = __c;
                    this->pbump(1);
                    __ret = traits_type::to_int_type(__c);
                }
                else
                    __ret = this->overflow(traits_type::to_int_type(__c));
                return __ret;
            }
            streamsize sputn(const char_type * __s, streamsize __n)
            {
                return this->xsputn(__s, __n);
            }
        protected :
            basic_streambuf()
                : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), _M_out_beg(0), _M_out_cur(0), _M_out_end(0), _M_buf_locale(locale()) 
            {
            }
            char_type * eback() const
            {
                return _M_in_beg;
            }
            char_type * gptr() const
            {
                return _M_in_cur;
            }
            char_type * egptr() const
            {
                return _M_in_end;
            }
            void gbump(int __n)
            {
                _M_in_cur += __n;
            }
            void setg(char_type * __gbeg, char_type * __gnext, char_type * __gend)
            {
                _M_in_beg = __gbeg;
                _M_in_cur = __gnext;
                _M_in_end = __gend;
            }
            char_type * pbase() const
            {
                return _M_out_beg;
            }
            char_type * pptr() const
            {
                return _M_out_cur;
            }
            char_type * epptr() const
            {
                return _M_out_end;
            }
            void pbump(int __n)
            {
                _M_out_cur += __n;
            }
            void setp(char_type * __pbeg, char_type * __pend)
            {
                _M_out_beg = _M_out_cur = __pbeg;
                _M_out_end = __pend;
            }
            virtual void imbue(const locale &)
            {
            }
            virtual basic_streambuf< char_type, _Traits > * setbuf(char_type *, streamsize)
            {
                return this;
            }
            virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out)
            {
                return pos_type(off_type(-1));
            }
            virtual pos_type seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out)
            {
                return pos_type(off_type(-1));
            }
            virtual int sync()
            {
                return 0;
            }
            virtual streamsize showmanyc()
            {
                return 0;
            }
            virtual streamsize xsgetn(char_type * __s, streamsize __n);
            virtual int_type underflow()
            {
                return traits_type::eof();
            }
            virtual int_type uflow()
            {
                int_type __ret = traits_type::eof();
                const bool __testeof = traits_type::eq_int_type(this->underflow(), __ret);
                if (!__testeof)
                {
                    __ret = traits_type::to_int_type(*this->gptr());
                    this->gbump(1);
                }
                return __ret;
            }
            virtual int_type pbackfail(int_type = traits_type::eof())
            {
                return traits_type::eof();
            }
            virtual streamsize xsputn(const char_type * __s, streamsize __n);
            virtual int_type overflow(int_type = traits_type::eof())
            {
                return traits_type::eof();
            }
        public :
            void stossc()
            {
                if (this->gptr() < this->egptr())
                    this->gbump(1);
                else
                    this->uflow();
            }
        private :
            basic_streambuf(const __streambuf_type & __sb)
                : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur), _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg), _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur), _M_buf_locale(__sb._M_buf_locale) 
            {
            }
            __streambuf_type & operator =(const __streambuf_type &)
            {
                return *this;
            }
            ;
    };
    template<>
    streamsize __copy_streambufs_eof(basic_streambuf< char > * __sbin, basic_streambuf< char > * __sbout, bool & __ineof);
    template<>
    streamsize __copy_streambufs_eof(basic_streambuf< wchar_t > * __sbin, basic_streambuf< wchar_t > * __sbout, bool & __ineof);
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _CharT, typename _Traits >
    streamsize basic_streambuf< _CharT, _Traits >::xsgetn(char_type * __s, streamsize __n)
    {
        streamsize __ret = 0;
        while (__ret < __n)
        {
            const streamsize __buf_len = this->egptr() - this->gptr();
            if (__buf_len)
            {
                const streamsize __remaining = __n - __ret;
                const streamsize __len = std::min(__buf_len, __remaining);
                traits_type::copy(__s, this->gptr(), __len);
                __ret += __len;
                __s += __len;
                this->gbump(__len);
            }
            if (__ret < __n)
            {
                const int_type __c = this->uflow();
                if (!traits_type::eq_int_type(__c, traits_type::eof()))
                {
                    traits_type::assign(*__s++, traits_type::to_char_type(__c));
                    ++__ret;
                }
                else
                    break;
            }
        }
        return __ret;
    }
    template<typename _CharT, typename _Traits >
    streamsize basic_streambuf< _CharT, _Traits >::xsputn(const char_type * __s, streamsize __n)
    {
        streamsize __ret = 0;
        while (__ret < __n)
        {
            const streamsize __buf_len = this->epptr() - this->pptr();
            if (__buf_len)
            {
                const streamsize __remaining = __n - __ret;
                const streamsize __len = std::min(__buf_len, __remaining);
                traits_type::copy(this->pptr(), __s, __len);
                __ret += __len;
                __s += __len;
                this->pbump(__len);
            }
            if (__ret < __n)
            {
                int_type __c = this->overflow(traits_type::to_int_type(*__s));
                if (!traits_type::eq_int_type(__c, traits_type::eof()))
                {
                    ++__ret;
                    ++__s;
                }
                else
                    break;
            }
        }
        return __ret;
    }
    template<typename _CharT, typename _Traits >
    streamsize __copy_streambufs_eof(basic_streambuf< _CharT, _Traits > * __sbin, basic_streambuf< _CharT, _Traits > * __sbout, bool & __ineof)
    {
        streamsize __ret = 0;
        __ineof = true;
        typename _Traits::int_type __c = __sbin->sgetc();
        while (!_Traits::eq_int_type(__c, _Traits::eof()))
        {
            __c = __sbout->sputc(_Traits::to_char_type(__c));
            if (_Traits::eq_int_type(__c, _Traits::eof()))
            {
                __ineof = false;
                break;
            }
            ++__ret;
            __c = __sbin->snextc();
        }
        return __ret;
    }
    template<typename _CharT, typename _Traits >
    inline streamsize __copy_streambufs(basic_streambuf< _CharT, _Traits > * __sbin, basic_streambuf< _CharT, _Traits > * __sbout)
    {
        bool __ineof;
        return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }
    extern template class basic_streambuf< char > ;
    extern template streamsize __copy_streambufs(basic_streambuf< char > *, basic_streambuf< char > *);
    extern template streamsize __copy_streambufs_eof(basic_streambuf< char > *, basic_streambuf< char > *, bool &);
    extern template class basic_streambuf< wchar_t > ;
    extern template streamsize __copy_streambufs(basic_streambuf< wchar_t > *, basic_streambuf< wchar_t > *);
    extern template streamsize __copy_streambufs_eof(basic_streambuf< wchar_t > *, basic_streambuf< wchar_t > *, bool &);
}
typedef unsigned long int wctype_t;
enum 
{
    __ISwupper = 0, 
    __ISwlower = 1, 
    __ISwalpha = 2, 
    __ISwdigit = 3, 
    __ISwxdigit = 4, 
    __ISwspace = 5, 
    __ISwprint = 6, 
    __ISwgraph = 7, 
    __ISwblank = 8, 
    __ISwcntrl = 9, 
    __ISwpunct = 10, 
    __ISwalnum = 11, 
    _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))), 
    _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))), 
    _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))), 
    _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))), 
    _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))), 
    _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))), 
    _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))), 
    _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))), 
    _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))), 
    _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))), 
    _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))), 
    _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};
extern "C"
{
    extern int iswalnum(wint_t __wc) throw ();
    extern int iswalpha(wint_t __wc) throw ();
    extern int iswcntrl(wint_t __wc) throw ();
    extern int iswdigit(wint_t __wc) throw ();
    extern int iswgraph(wint_t __wc) throw ();
    extern int iswlower(wint_t __wc) throw ();
    extern int iswprint(wint_t __wc) throw ();
    extern int iswpunct(wint_t __wc) throw ();
    extern int iswspace(wint_t __wc) throw ();
    extern int iswupper(wint_t __wc) throw ();
    extern int iswxdigit(wint_t __wc) throw ();
    extern int iswblank(wint_t __wc) throw ();
    extern wctype_t wctype(__const char * __property) throw ();
    extern int iswctype(wint_t __wc, wctype_t __desc) throw ();
    typedef __const __int32_t * wctrans_t;
    extern wint_t towlower(wint_t __wc) throw ();
    extern wint_t towupper(wint_t __wc) throw ();
}
extern "C"
{
    extern wctrans_t wctrans(__const char * __property) throw ();
    extern wint_t towctrans(wint_t __wc, wctrans_t __desc) throw ();
    extern int iswalnum_l(wint_t __wc, __locale_t __locale) throw ();
    extern int iswalpha_l(wint_t __wc, __locale_t __locale) throw ();
    extern int iswcntrl_l(wint_t __wc, __locale_t __locale) throw ();
    extern int iswdigit_l(wint_t __wc, __locale_t __locale) throw ();
    extern int iswgraph_l(wint_t __wc, __locale_t __locale) throw ();
    extern int iswlower_l(wint_t __wc, __locale_t __locale) throw ();
    extern int iswprint_l(wint_t __wc, __locale_t __locale) throw ();
    extern int iswpunct_l(wint_t __wc, __locale_t __locale) throw ();
    extern int iswspace_l(wint_t __wc, __locale_t __locale) throw ();
    extern int iswupper_l(wint_t __wc, __locale_t __locale) throw ();
    extern int iswxdigit_l(wint_t __wc, __locale_t __locale) throw ();
    extern int iswblank_l(wint_t __wc, __locale_t __locale) throw ();
    extern wctype_t wctype_l(__const char * __property, __locale_t __locale) throw ();
    extern int iswctype_l(wint_t __wc, wctype_t __desc, __locale_t __locale) throw ();
    extern wint_t towlower_l(wint_t __wc, __locale_t __locale) throw ();
    extern wint_t towupper_l(wint_t __wc, __locale_t __locale) throw ();
    extern wctrans_t wctrans_l(__const char * __property, __locale_t __locale) throw ();
    extern wint_t towctrans_l(wint_t __wc, wctrans_t __desc, __locale_t __locale) throw ();
}
namespace std __attribute__((__visibility__("default"))) {
    using ::wctrans_t;
    using ::wctype_t;
    using ::wint_t;
    using ::iswalnum;
    using ::iswalpha;
    using ::iswblank;
    using ::iswcntrl;
    using ::iswctype;
    using ::iswdigit;
    using ::iswgraph;
    using ::iswlower;
    using ::iswprint;
    using ::iswpunct;
    using ::iswspace;
    using ::iswupper;
    using ::iswxdigit;
    using ::towctrans;
    using ::towlower;
    using ::towupper;
    using ::wctrans;
    using ::wctype;
}
namespace std __attribute__((__visibility__("default"))) {
    struct ctype_base
    {
            typedef const int * __to_type;
            typedef unsigned short mask;
            static const mask upper = _ISupper;
            static const mask lower = _ISlower;
            static const mask alpha = _ISalpha;
            static const mask digit = _ISdigit;
            static const mask xdigit = _ISxdigit;
            static const mask space = _ISspace;
            static const mask print = _ISprint;
            static const mask graph = _ISalpha | _ISdigit | _ISpunct;
            static const mask cntrl = _IScntrl;
            static const mask punct = _ISpunct;
            static const mask alnum = _ISalpha | _ISdigit;
    };
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _CharT, typename _Traits >
    class istreambuf_iterator : public iterator< input_iterator_tag, _CharT, typename _Traits::off_type, _CharT *, _CharT & >
    {
        public :
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename _Traits::int_type int_type;
            typedef basic_streambuf< _CharT, _Traits > streambuf_type;
            typedef basic_istream< _CharT, _Traits > istream_type;
            template<typename _CharT2 >
            friend typename __gnu_cxx::__enable_if< __is_char< _CharT2 >::__value, ostreambuf_iterator< _CharT2 > >::__type copy(istreambuf_iterator< _CharT2 >, istreambuf_iterator< _CharT2 >, ostreambuf_iterator< _CharT2 >);
            template<bool _IsMove, typename _CharT2 >
            friend typename __gnu_cxx::__enable_if< __is_char< _CharT2 >::__value, _CharT2 * >::__type __copy_move_a2(istreambuf_iterator< _CharT2 >, istreambuf_iterator< _CharT2 >, _CharT2 *);
            template<typename _CharT2 >
            friend typename __gnu_cxx::__enable_if< __is_char< _CharT2 >::__value, istreambuf_iterator< _CharT2 > >::__type find(istreambuf_iterator< _CharT2 >, istreambuf_iterator< _CharT2 >, const _CharT2 &);
        private :
            mutable streambuf_type * _M_sbuf;
            mutable int_type _M_c;
        public :
            istreambuf_iterator() throw ()
                : _M_sbuf(0), _M_c(traits_type::eof()) 
            {
            }
            istreambuf_iterator(istream_type & __s) throw ()
                : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) 
            {
            }
            istreambuf_iterator(streambuf_type * __s) throw ()
                : _M_sbuf(__s), _M_c(traits_type::eof()) 
            {
            }
            char_type operator *() const
            {
                return traits_type::to_char_type(_M_get());
            }
            istreambuf_iterator & operator ++()
            {
                ;
                if (_M_sbuf)
                {
                    _M_sbuf->sbumpc();
                    _M_c = traits_type::eof();
                }
                return *this;
            }
            istreambuf_iterator operator ++(int)
            {
                ;
                istreambuf_iterator __old = *this;
                if (_M_sbuf)
                {
                    __old._M_c = _M_sbuf->sbumpc();
                    _M_c = traits_type::eof();
                }
                return __old;
            }
            bool equal(const istreambuf_iterator & __b) const
            {
                return _M_at_eof() == __b._M_at_eof();
            }
        private :
            int_type _M_get() const
            {
                const int_type __eof = traits_type::eof();
                int_type __ret = __eof;
                if (_M_sbuf)
                {
                    if (!traits_type::eq_int_type(_M_c, __eof))
                        __ret = _M_c;
                    else
                        if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()), __eof))
                            _M_c = __ret;
                        else
                            _M_sbuf = 0;
                }
                return __ret;
            }
            bool _M_at_eof() const
            {
                const int_type __eof = traits_type::eof();
                return traits_type::eq_int_type(_M_get(), __eof);
            }
    };
    template<typename _CharT, typename _Traits >
    inline bool operator ==(const istreambuf_iterator< _CharT, _Traits > & __a, const istreambuf_iterator< _CharT, _Traits > & __b)
    {
        return __a.equal(__b);
    }
    template<typename _CharT, typename _Traits >
    inline bool operator !=(const istreambuf_iterator< _CharT, _Traits > & __a, const istreambuf_iterator< _CharT, _Traits > & __b)
    {
        return !__a.equal(__b);
    }
    template<typename _CharT, typename _Traits >
    class ostreambuf_iterator : public iterator< output_iterator_tag, void, void, void, void >
    {
        public :
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef basic_streambuf< _CharT, _Traits > streambuf_type;
            typedef basic_ostream< _CharT, _Traits > ostream_type;
            template<typename _CharT2 >
            friend typename __gnu_cxx::__enable_if< __is_char< _CharT2 >::__value, ostreambuf_iterator< _CharT2 > >::__type copy(istreambuf_iterator< _CharT2 >, istreambuf_iterator< _CharT2 >, ostreambuf_iterator< _CharT2 >);
        private :
            streambuf_type * _M_sbuf;
            bool _M_failed;
        public :
            ostreambuf_iterator(ostream_type & __s) throw ()
                : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) 
            {
            }
            ostreambuf_iterator(streambuf_type * __s) throw ()
                : _M_sbuf(__s), _M_failed(!_M_sbuf) 
            {
            }
            ostreambuf_iterator & operator =(_CharT __c)
            {
                if (!_M_failed && _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
                    _M_failed = true;
                return *this;
            }
            ostreambuf_iterator & operator *()
            {
                return *this;
            }
            ostreambuf_iterator & operator ++(int)
            {
                return *this;
            }
            ostreambuf_iterator & operator ++()
            {
                return *this;
            }
            bool failed() const throw ()
            {
                return _M_failed;
            }
            ostreambuf_iterator & _M_put(const _CharT * __ws, streamsize __len)
            {
                if (__builtin_expect(!_M_failed, true) && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len, false))
                    _M_failed = true;
                return *this;
            }
    };
    template<typename _CharT >
    typename __gnu_cxx::__enable_if< __is_char< _CharT >::__value, ostreambuf_iterator< _CharT > >::__type copy(istreambuf_iterator< _CharT > __first, istreambuf_iterator< _CharT > __last, ostreambuf_iterator< _CharT > __result)
    {
        if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
        {
            bool __ineof;
            __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
            if (!__ineof)
                __result._M_failed = true;
        }
        return __result;
    }
    template<bool _IsMove, typename _CharT >
    typename __gnu_cxx::__enable_if< __is_char< _CharT >::__value, ostreambuf_iterator< _CharT > >::__type __copy_move_a2(_CharT * __first, _CharT * __last, ostreambuf_iterator< _CharT > __result)
    {
        const streamsize __num = __last - __first;
        if (__num > 0)
            __result._M_put(__first, __num);
        return __result;
    }
    template<bool _IsMove, typename _CharT >
    typename __gnu_cxx::__enable_if< __is_char< _CharT >::__value, ostreambuf_iterator< _CharT > >::__type __copy_move_a2(const _CharT * __first, const _CharT * __last, ostreambuf_iterator< _CharT > __result)
    {
        const streamsize __num = __last - __first;
        if (__num > 0)
            __result._M_put(__first, __num);
        return __result;
    }
    template<bool _IsMove, typename _CharT >
    typename __gnu_cxx::__enable_if< __is_char< _CharT >::__value, _CharT * >::__type __copy_move_a2(istreambuf_iterator< _CharT > __first, istreambuf_iterator< _CharT > __last, _CharT * __result)
    {
        typedef istreambuf_iterator< _CharT > __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        if (__first._M_sbuf && !__last._M_sbuf)
        {
            streambuf_type * __sb = __first._M_sbuf;
            int_type __c = __sb->sgetc();
            while (!traits_type::eq_int_type(__c, traits_type::eof()))
            {
                const streamsize __n = __sb->egptr() - __sb->gptr();
                if (__n > 1)
                {
                    traits_type::copy(__result, __sb->gptr(), __n);
                    __sb->gbump(__n);
                    __result += __n;
                    __c = __sb->underflow();
                }
                else
                {
                    *__result++ = traits_type::to_char_type(__c);
                    __c = __sb->snextc();
                }
            }
        }
        return __result;
    }
    template<typename _CharT >
    typename __gnu_cxx::__enable_if< __is_char< _CharT >::__value, istreambuf_iterator< _CharT > >::__type find(istreambuf_iterator< _CharT > __first, istreambuf_iterator< _CharT > __last, const _CharT & __val)
    {
        typedef istreambuf_iterator< _CharT > __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        if (__first._M_sbuf && !__last._M_sbuf)
        {
            const int_type __ival = traits_type::to_int_type(__val);
            streambuf_type * __sb = __first._M_sbuf;
            int_type __c = __sb->sgetc();
            while (!traits_type::eq_int_type(__c, traits_type::eof()) && !traits_type::eq_int_type(__c, __ival))
            {
                streamsize __n = __sb->egptr() - __sb->gptr();
                if (__n > 1)
                {
                    const _CharT * __p = traits_type::find(__sb->gptr(), __n, __val);
                    if (__p)
                        __n = __p - __sb->gptr();
                    __sb->gbump(__n);
                    __c = __sb->sgetc();
                }
                else
                    __c = __sb->snextc();
            }
            if (!traits_type::eq_int_type(__c, traits_type::eof()))
                __first._M_c = __c;
            else
                __first._M_sbuf = 0;
        }
        return __first;
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Tv >
    void __convert_to_v(const char * __in, _Tv & __out, ios_base::iostate & __err, const __c_locale & __cloc);
    template<>
    void __convert_to_v(const char *, float &, ios_base::iostate &, const __c_locale &);
    template<>
    void __convert_to_v(const char *, double &, ios_base::iostate &, const __c_locale &);
    template<>
    void __convert_to_v(const char *, long double &, ios_base::iostate &, const __c_locale &);
    template<typename _CharT, typename _Traits >
    struct __pad
    {
            static void _S_pad(ios_base & __io, _CharT __fill, _CharT * __news, const _CharT * __olds, const streamsize __newlen, const streamsize __oldlen);
    };
    template<typename _CharT >
    _CharT * __add_grouping(_CharT * __s, _CharT __sep, const char * __gbeg, size_t __gsize, const _CharT * __first, const _CharT * __last);
    template<typename _CharT >
    inline ostreambuf_iterator< _CharT > __write(ostreambuf_iterator< _CharT > __s, const _CharT * __ws, int __len)
    {
        __s._M_put(__ws, __len);
        return __s;
    }
    template<typename _CharT, typename _OutIter >
    inline _OutIter __write(_OutIter __s, const _CharT * __ws, int __len)
    {
        for (int __j = 0;
            __j < __len;
            __j++ , ++__s)
        *__s = __ws[__j];
        return __s;
    }
    template<typename _CharT >
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
        public :
            typedef _CharT char_type;
            bool is(mask __m, char_type __c) const
            {
                return this->do_is(__m, __c);
            }
            const char_type * is(const char_type * __lo, const char_type * __hi, mask * __vec) const
            {
                return this->do_is(__lo, __hi, __vec);
            }
            const char_type * scan_is(mask __m, const char_type * __lo, const char_type * __hi) const
            {
                return this->do_scan_is(__m, __lo, __hi);
            }
            const char_type * scan_not(mask __m, const char_type * __lo, const char_type * __hi) const
            {
                return this->do_scan_not(__m, __lo, __hi);
            }
            char_type toupper(char_type __c) const
            {
                return this->do_toupper(__c);
            }
            const char_type * toupper(char_type * __lo, const char_type * __hi) const
            {
                return this->do_toupper(__lo, __hi);
            }
            char_type tolower(char_type __c) const
            {
                return this->do_tolower(__c);
            }
            const char_type * tolower(char_type * __lo, const char_type * __hi) const
            {
                return this->do_tolower(__lo, __hi);
            }
            char_type widen(char __c) const
            {
                return this->do_widen(__c);
            }
            const char * widen(const char * __lo, const char * __hi, char_type * __to) const
            {
                return this->do_widen(__lo, __hi, __to);
            }
            char narrow(char_type __c, char __dfault) const
            {
                return this->do_narrow(__c, __dfault);
            }
            const char_type * narrow(const char_type * __lo, const char_type * __hi, char __dfault, char * __to) const
            {
                return this->do_narrow(__lo, __hi, __dfault, __to);
            }
        protected :
            explicit __ctype_abstract_base(size_t __refs = 0)
                : facet(__refs) 
            {
            }
            virtual ~__ctype_abstract_base()
            {
            }
            virtual bool do_is(mask __m, char_type __c) const = 0;
            virtual const char_type * do_is(const char_type * __lo, const char_type * __hi, mask * __vec) const = 0;
            virtual const char_type * do_scan_is(mask __m, const char_type * __lo, const char_type * __hi) const = 0;
            virtual const char_type * do_scan_not(mask __m, const char_type * __lo, const char_type * __hi) const = 0;
            virtual char_type do_toupper(char_type) const = 0;
            virtual const char_type * do_toupper(char_type * __lo, const char_type * __hi) const = 0;
            virtual char_type do_tolower(char_type) const = 0;
            virtual const char_type * do_tolower(char_type * __lo, const char_type * __hi) const = 0;
            virtual char_type do_widen(char) const = 0;
            virtual const char * do_widen(const char * __lo, const char * __hi, char_type * __dest) const = 0;
            virtual char do_narrow(char_type, char __dfault) const = 0;
            virtual const char_type * do_narrow(const char_type * __lo, const char_type * __hi, char __dfault, char * __dest) const = 0;
    };
    template<typename _CharT >
    class ctype : public __ctype_abstract_base< _CharT >
    {
        public :
            typedef _CharT char_type;
            typedef typename __ctype_abstract_base< _CharT >::mask mask;
            static locale::id id;
            explicit ctype(size_t __refs = 0)
                : __ctype_abstract_base< _CharT >(__refs) 
            {
            }
        protected :
            virtual ~ctype();
            virtual bool do_is(mask __m, char_type __c) const;
            virtual const char_type * do_is(const char_type * __lo, const char_type * __hi, mask * __vec) const;
            virtual const char_type * do_scan_is(mask __m, const char_type * __lo, const char_type * __hi) const;
            virtual const char_type * do_scan_not(mask __m, const char_type * __lo, const char_type * __hi) const;
            virtual char_type do_toupper(char_type __c) const;
            virtual const char_type * do_toupper(char_type * __lo, const char_type * __hi) const;
            virtual char_type do_tolower(char_type __c) const;
            virtual const char_type * do_tolower(char_type * __lo, const char_type * __hi) const;
            virtual char_type do_widen(char __c) const;
            virtual const char * do_widen(const char * __lo, const char * __hi, char_type * __dest) const;
            virtual char do_narrow(char_type, char __dfault) const;
            virtual const char_type * do_narrow(const char_type * __lo, const char_type * __hi, char __dfault, char * __dest) const;
    };
    template<typename _CharT >
    locale::id ctype< _CharT >::id;
    template<>
    class ctype< char > : public locale::facet, public ctype_base
    {
        public :
            typedef char char_type;
        protected :
            __c_locale _M_c_locale_ctype;
            bool _M_del;
            __to_type _M_toupper;
            __to_type _M_tolower;
            const mask * _M_table;
            mutable char _M_widen_ok;
            mutable char _M_widen[1 + static_cast<unsigned char >(-1)];
            mutable char _M_narrow[1 + static_cast<unsigned char >(-1)];
            mutable char _M_narrow_ok;
        public :
            static locale::id id;
            static const size_t table_size = 1 + static_cast<unsigned char >(-1);
            explicit ctype(const mask * __table = 0, bool __del = false, size_t __refs = 0);
            explicit ctype(__c_locale __cloc, const mask * __table = 0, bool __del = false, size_t __refs = 0);
            inline bool is(mask __m, char __c) const;
            inline const char * is(const char * __lo, const char * __hi, mask * __vec) const;
            inline const char * scan_is(mask __m, const char * __lo, const char * __hi) const;
            inline const char * scan_not(mask __m, const char * __lo, const char * __hi) const;
            char_type toupper(char_type __c) const
            {
                return this->do_toupper(__c);
            }
            const char_type * toupper(char_type * __lo, const char_type * __hi) const
            {
                return this->do_toupper(__lo, __hi);
            }
            char_type tolower(char_type __c) const
            {
                return this->do_tolower(__c);
            }
            const char_type * tolower(char_type * __lo, const char_type * __hi) const
            {
                return this->do_tolower(__lo, __hi);
            }
            char_type widen(char __c) const
            {
                if (_M_widen_ok)
                    return _M_widen[static_cast<unsigned char >(__c)];
                this->_M_widen_init();
                return this->do_widen(__c);
            }
            const char * widen(const char * __lo, const char * __hi, char_type * __to) const
            {
                if (_M_widen_ok == 1)
                {
                    __builtin_memcpy(__to, __lo, __hi - __lo);
                    return __hi;
                }
                if (!_M_widen_ok)
                    _M_widen_init();
                return this->do_widen(__lo, __hi, __to);
            }
            char narrow(char_type __c, char __dfault) const
            {
                if (_M_narrow[static_cast<unsigned char >(__c)])
                    return _M_narrow[static_cast<unsigned char >(__c)];
                const char __t = do_narrow(__c, __dfault);
                if (__t != __dfault)
                    _M_narrow[static_cast<unsigned char >(__c)] = __t;
                return __t;
            }
            const char_type * narrow(const char_type * __lo, const char_type * __hi, char __dfault, char * __to) const
            {
                if (__builtin_expect(_M_narrow_ok == 1, true))
                {
                    __builtin_memcpy(__to, __lo, __hi - __lo);
                    return __hi;
                }
                if (!_M_narrow_ok)
                    _M_narrow_init();
                return this->do_narrow(__lo, __hi, __dfault, __to);
            }
            const mask * table() const throw ()
            {
                return _M_table;
            }
            static const mask * classic_table() throw ();
        protected :
            virtual ~ctype();
            virtual char_type do_toupper(char_type) const;
            virtual const char_type * do_toupper(char_type * __lo, const char_type * __hi) const;
            virtual char_type do_tolower(char_type) const;
            virtual const char_type * do_tolower(char_type * __lo, const char_type * __hi) const;
            virtual char_type do_widen(char __c) const
            {
                return __c;
            }
            virtual const char * do_widen(const char * __lo, const char * __hi, char_type * __dest) const
            {
                __builtin_memcpy(__dest, __lo, __hi - __lo);
                return __hi;
            }
            virtual char do_narrow(char_type __c, char) const
            {
                return __c;
            }
            virtual const char_type * do_narrow(const char_type * __lo, const char_type * __hi, char, char * __dest) const
            {
                __builtin_memcpy(__dest, __lo, __hi - __lo);
                return __hi;
            }
        private :
            void _M_widen_init() const
            {
                char __tmp[sizeof (_M_widen)];
                for (size_t __i = 0;
                    __i < sizeof (_M_widen);
                    ++__i)
                __tmp[__i] = __i;
                do_widen(__tmp, __tmp + sizeof (__tmp), _M_widen);
                _M_widen_ok = 1;
                if (__builtin_memcmp(__tmp, _M_widen, sizeof (_M_widen)))
                    _M_widen_ok = 2;
            }
            void _M_narrow_init() const
            {
                char __tmp[sizeof (_M_narrow)];
                for (size_t __i = 0;
                    __i < sizeof (_M_narrow);
                    ++__i)
                __tmp[__i] = __i;
                do_narrow(__tmp, __tmp + sizeof (__tmp), 0, _M_narrow);
                _M_narrow_ok = 1;
                if (__builtin_memcmp(__tmp, _M_narrow, sizeof (_M_narrow)))
                    _M_narrow_ok = 2;
                else
                {
                    char __c;
                    do_narrow(__tmp, __tmp + 1, 1, &__c);
                    if (__c == 1)
                        _M_narrow_ok = 2;
                }
            }
    };
    template<>
    const ctype< char > & use_facet< ctype< char > >(const locale & __loc);
    template<>
    class ctype< wchar_t > : public __ctype_abstract_base< wchar_t >
    {
        public :
            typedef wchar_t char_type;
            typedef wctype_t __wmask_type;
        protected :
            __c_locale _M_c_locale_ctype;
            bool _M_narrow_ok;
            char _M_narrow[128];
            wint_t _M_widen[1 + static_cast<unsigned char >(-1)];
            mask _M_bit[16];
            __wmask_type _M_wmask[16];
        public :
            static locale::id id;
            explicit ctype(size_t __refs = 0);
            explicit ctype(__c_locale __cloc, size_t __refs = 0);
        protected :
            __wmask_type _M_convert_to_wmask(const mask __m) const;
            virtual ~ctype();
            virtual bool do_is(mask __m, char_type __c) const;
            virtual const char_type * do_is(const char_type * __lo, const char_type * __hi, mask * __vec) const;
            virtual const char_type * do_scan_is(mask __m, const char_type * __lo, const char_type * __hi) const;
            virtual const char_type * do_scan_not(mask __m, const char_type * __lo, const char_type * __hi) const;
            virtual char_type do_toupper(char_type) const;
            virtual const char_type * do_toupper(char_type * __lo, const char_type * __hi) const;
            virtual char_type do_tolower(char_type) const;
            virtual const char_type * do_tolower(char_type * __lo, const char_type * __hi) const;
            virtual char_type do_widen(char) const;
            virtual const char * do_widen(const char * __lo, const char * __hi, char_type * __dest) const;
            virtual char do_narrow(char_type, char __dfault) const;
            virtual const char_type * do_narrow(const char_type * __lo, const char_type * __hi, char __dfault, char * __dest) const;
            void _M_initialize_ctype();
    };
    template<>
    const ctype< wchar_t > & use_facet< ctype< wchar_t > >(const locale & __loc);
    template<typename _CharT >
    class ctype_byname : public ctype< _CharT >
    {
        public :
            typedef typename ctype< _CharT >::mask mask;
            explicit ctype_byname(const char * __s, size_t __refs = 0);
        protected :
            virtual ~ctype_byname()
            {
            }
            ;
    };
    template<>
    class ctype_byname< char > : public ctype< char >
    {
        public :
            explicit ctype_byname(const char * __s, size_t __refs = 0);
        protected :
            virtual ~ctype_byname();
    };
    template<>
    class ctype_byname< wchar_t > : public ctype< wchar_t >
    {
        public :
            explicit ctype_byname(const char * __s, size_t __refs = 0);
        protected :
            virtual ~ctype_byname();
    };
}
namespace std __attribute__((__visibility__("default"))) {
    bool ctype< char >::is(mask __m, char __c) const
    {
        return _M_table[static_cast<unsigned char >(__c)] & __m;
    }
    const char * ctype< char >::is(const char * __low, const char * __high, mask * __vec) const
    {
        while (__low < __high)
            *__vec++ = _M_table[static_cast<unsigned char >(*__low++)];
        return __high;
    }
    const char * ctype< char >::scan_is(mask __m, const char * __low, const char * __high) const
    {
        while (__low < __high && !(_M_table[static_cast<unsigned char >(*__low)] & __m))
            ++__low;
        return __low;
    }
    const char * ctype< char >::scan_not(mask __m, const char * __low, const char * __high) const
    {
        while (__low < __high && (_M_table[static_cast<unsigned char >(*__low)] & __m) != 0)
            ++__low;
        return __low;
    }
}
namespace std __attribute__((__visibility__("default"))) {
    class __num_base
    {
        public :
            enum 
            {
                _S_ominus, 
                _S_oplus, 
                _S_ox, 
                _S_oX, 
                _S_odigits, 
                _S_odigits_end = _S_odigits + 16, 
                _S_oudigits = _S_odigits_end, 
                _S_oudigits_end = _S_oudigits + 16, 
                _S_oe = _S_odigits + 14, 
                _S_oE = _S_oudigits + 14, 
                _S_oend = _S_oudigits_end
            };
            static const char * _S_atoms_out;
            static const char * _S_atoms_in;
            enum 
            {
                _S_iminus, 
                _S_iplus, 
                _S_ix, 
                _S_iX, 
                _S_izero, 
                _S_ie = _S_izero + 14, 
                _S_iE = _S_izero + 20, 
                _S_iend = 26
            };
            static void _S_format_float(const ios_base & __io, char * __fptr, char __mod);
    };
    template<typename _CharT >
    struct __numpunct_cache : public locale::facet
    {
            const char * _M_grouping;
            size_t _M_grouping_size;
            bool _M_use_grouping;
            const _CharT * _M_truename;
            size_t _M_truename_size;
            const _CharT * _M_falsename;
            size_t _M_falsename_size;
            _CharT _M_decimal_point;
            _CharT _M_thousands_sep;
            _CharT _M_atoms_out[__num_base::_S_oend];
            _CharT _M_atoms_in[__num_base::_S_iend];
            bool _M_allocated;
            __numpunct_cache(size_t __refs = 0)
                : facet(__refs), _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false), _M_truename(__null), _M_truename_size(0), _M_falsename(__null), _M_falsename_size(0), _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), _M_allocated(false) 
            {
            }
            ~__numpunct_cache();
            void _M_cache(const locale & __loc);
        private :
            __numpunct_cache & operator =(const __numpunct_cache &);
            explicit __numpunct_cache(const __numpunct_cache &);
    };
    template<typename _CharT >
    __numpunct_cache< _CharT >::~__numpunct_cache()
    {
        if (_M_allocated)
        {
            delete[] _M_grouping;
            delete[] _M_truename;
            delete[] _M_falsename;
        }
    }
    template<typename _CharT >
    class numpunct : public locale::facet
    {
        public :
            typedef _CharT char_type;
            typedef basic_string< _CharT > string_type;
            typedef __numpunct_cache< _CharT > __cache_type;
        protected :
            __cache_type * _M_data;
        public :
            static locale::id id;
            explicit numpunct(size_t __refs = 0)
                : facet(__refs), _M_data(__null) 
            {
                _M_initialize_numpunct();
            }
            explicit numpunct(__cache_type * __cache, size_t __refs = 0)
                : facet(__refs), _M_data(__cache) 
            {
                _M_initialize_numpunct();
            }
            explicit numpunct(__c_locale __cloc, size_t __refs = 0)
                : facet(__refs), _M_data(__null) 
            {
                _M_initialize_numpunct(__cloc);
            }
            char_type decimal_point() const
            {
                return this->do_decimal_point();
            }
            char_type thousands_sep() const
            {
                return this->do_thousands_sep();
            }
            string grouping() const
            {
                return this->do_grouping();
            }
            string_type truename() const
            {
                return this->do_truename();
            }
            string_type falsename() const
            {
                return this->do_falsename();
            }
        protected :
            virtual ~numpunct();
            virtual char_type do_decimal_point() const
            {
                return _M_data->_M_decimal_point;
            }
            virtual char_type do_thousands_sep() const
            {
                return _M_data->_M_thousands_sep;
            }
            virtual string do_grouping() const
            {
                return _M_data->_M_grouping;
            }
            virtual string_type do_truename() const
            {
                return _M_data->_M_truename;
            }
            virtual string_type do_falsename() const
            {
                return _M_data->_M_falsename;
            }
            void _M_initialize_numpunct(__c_locale __cloc = __null);
    };
    template<typename _CharT >
    locale::id numpunct< _CharT >::id;
    template<>
    numpunct< char >::~numpunct();
    template<>
    void numpunct< char >::_M_initialize_numpunct(__c_locale __cloc);
    template<>
    numpunct< wchar_t >::~numpunct();
    template<>
    void numpunct< wchar_t >::_M_initialize_numpunct(__c_locale __cloc);
    template<typename _CharT >
    class numpunct_byname : public numpunct< _CharT >
    {
        public :
            typedef _CharT char_type;
            typedef basic_string< _CharT > string_type;
            explicit numpunct_byname(const char * __s, size_t __refs = 0)
                : numpunct< _CharT >(__refs) 
            {
                if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0)
                {
                    __c_locale __tmp;
                    this->_S_create_c_locale(__tmp, __s);
                    this->_M_initialize_numpunct(__tmp);
                    this->_S_destroy_c_locale(__tmp);
                }
            }
        protected :
            virtual ~numpunct_byname()
            {
            }
    };
    template<typename _CharT, typename _InIter >
    class num_get : public locale::facet
    {
        public :
            typedef _CharT char_type;
            typedef _InIter iter_type;
            static locale::id id;
            explicit num_get(size_t __refs = 0)
                : facet(__refs) 
            {
            }
            iter_type get(iter_type __in, iter_type __end, ios_base & __io, ios_base::iostate & __err, bool & __v) const
            {
                return this->do_get(__in, __end, __io, __err, __v);
            }
            iter_type get(iter_type __in, iter_type __end, ios_base & __io, ios_base::iostate & __err, long & __v) const
            {
                return this->do_get(__in, __end, __io, __err, __v);
            }
            iter_type get(iter_type __in, iter_type __end, ios_base & __io, ios_base::iostate & __err, unsigned short & __v) const
            {
                return this->do_get(__in, __end, __io, __err, __v);
            }
            iter_type get(iter_type __in, iter_type __end, ios_base & __io, ios_base::iostate & __err, unsigned int & __v) const
            {
                return this->do_get(__in, __end, __io, __err, __v);
            }
            iter_type get(iter_type __in, iter_type __end, ios_base & __io, ios_base::iostate & __err, unsigned long & __v) const
            {
                return this->do_get(__in, __end, __io, __err, __v);
            }
            iter_type get(iter_type __in, iter_type __end, ios_base & __io, ios_base::iostate & __err, long long & __v) const
            {
                return this->do_get(__in, __end, __io, __err, __v);
            }
            iter_type get(iter_type __in, iter_type __end, ios_base & __io, ios_base::iostate & __err, unsigned long long & __v) const
            {
                return this->do_get(__in, __end, __io, __err, __v);
            }
            iter_type get(iter_type __in, iter_type __end, ios_base & __io, ios_base::iostate & __err, float & __v) const
            {
                return this->do_get(__in, __end, __io, __err, __v);
            }
            iter_type get(iter_type __in, iter_type __end, ios_base & __io, ios_base::iostate & __err, double & __v) const
            {
                return this->do_get(__in, __end, __io, __err, __v);
            }
            iter_type get(iter_type __in, iter_type __end, ios_base & __io, ios_base::iostate & __err, long double & __v) const
            {
                return this->do_get(__in, __end, __io, __err, __v);
            }
            iter_type get(iter_type __in, iter_type __end, ios_base & __io, ios_base::iostate & __err, void * & __v) const
            {
                return this->do_get(__in, __end, __io, __err, __v);
            }
        protected :
            virtual ~num_get()
            {
            }
            iter_type _M_extract_float(iter_type, iter_type, ios_base &, ios_base::iostate &, string & __xtrc) const;
            template<typename _ValueT >
            iter_type _M_extract_int(iter_type, iter_type, ios_base &, ios_base::iostate &, _ValueT & __v) const;
            template<typename _CharT2 >
            typename __gnu_cxx::__enable_if< __is_char< _CharT2 >::__value, int >::__type _M_find(const _CharT2 *, size_t __len, _CharT2 __c) const
            {
                int __ret = -1;
                if (__len <= 10)
                {
                    if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
                        __ret = __c - _CharT2('0');
                }
                else
                {
                    if (__c >= _CharT2('0') && __c <= _CharT2('9'))
                        __ret = __c - _CharT2('0');
                    else
                        if (__c >= _CharT2('a') && __c <= _CharT2('f'))
                            __ret = 10 + (__c - _CharT2('a'));
                        else
                            if (__c >= _CharT2('A') && __c <= _CharT2('F'))
                                __ret = 10 + (__c - _CharT2('A'));
                }
                return __ret;
            }
            template<typename _CharT2 >
            typename __gnu_cxx::__enable_if< !__is_char< _CharT2 >::__value, int >::__type _M_find(const _CharT2 * __zero, size_t __len, _CharT2 __c) const
            {
                int __ret = -1;
                const char_type * __q = char_traits< _CharT2 >::find(__zero, __len, __c);
                if (__q)
                {
                    __ret = __q - __zero;
                    if (__ret > 15)
                        __ret -= 6;
                }
                return __ret;
            }
            virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, bool &) const;
            virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, long &) const;
            virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate & __err, unsigned short &) const;
            virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate & __err, unsigned int &) const;
            virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate & __err, unsigned long &) const;
            virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate & __err, long long &) const;
            virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate & __err, unsigned long long &) const;
            virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate & __err, float &) const;
            virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate & __err, double &) const;
            virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate & __err, long double &) const;
            virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate & __err, void *&) const;
    };
    template<typename _CharT, typename _InIter >
    locale::id num_get< _CharT, _InIter >::id;
    template<typename _CharT, typename _OutIter >
    class num_put : public locale::facet
    {
        public :
            typedef _CharT char_type;
            typedef _OutIter iter_type;
            static locale::id id;
            explicit num_put(size_t __refs = 0)
                : facet(__refs) 
            {
            }
            iter_type put(iter_type __s, ios_base & __f, char_type __fill, bool __v) const
            {
                return this->do_put(__s, __f, __fill, __v);
            }
            iter_type put(iter_type __s, ios_base & __f, char_type __fill, long __v) const
            {
                return this->do_put(__s, __f, __fill, __v);
            }
            iter_type put(iter_type __s, ios_base & __f, char_type __fill, unsigned long __v) const
            {
                return this->do_put(__s, __f, __fill, __v);
            }
            iter_type put(iter_type __s, ios_base & __f, char_type __fill, long long __v) const
            {
                return this->do_put(__s, __f, __fill, __v);
            }
            iter_type put(iter_type __s, ios_base & __f, char_type __fill, unsigned long long __v) const
            {
                return this->do_put(__s, __f, __fill, __v);
            }
            iter_type put(iter_type __s, ios_base & __f, char_type __fill, double __v) const
            {
                return this->do_put(__s, __f, __fill, __v);
            }
            iter_type put(iter_type __s, ios_base & __f, char_type __fill, long double __v) const
            {
                return this->do_put(__s, __f, __fill, __v);
            }
            iter_type put(iter_type __s, ios_base & __f, char_type __fill, const void * __v) const
            {
                return this->do_put(__s, __f, __fill, __v);
            }
        protected :
            template<typename _ValueT >
            iter_type _M_insert_float(iter_type, ios_base & __io, char_type __fill, char __mod, _ValueT __v) const;
            void _M_group_float(const char * __grouping, size_t __grouping_size, char_type __sep, const char_type * __p, char_type * __new, char_type * __cs, int & __len) const;
            template<typename _ValueT >
            iter_type _M_insert_int(iter_type, ios_base & __io, char_type __fill, _ValueT __v) const;
            void _M_group_int(const char * __grouping, size_t __grouping_size, char_type __sep, ios_base & __io, char_type * __new, char_type * __cs, int & __len) const;
            void _M_pad(char_type __fill, streamsize __w, ios_base & __io, char_type * __new, const char_type * __cs, int & __len) const;
            virtual ~num_put()
            {
            }
            ;
            virtual iter_type do_put(iter_type, ios_base &, char_type __fill, bool __v) const;
            virtual iter_type do_put(iter_type, ios_base &, char_type __fill, long __v) const;
            virtual iter_type do_put(iter_type, ios_base &, char_type __fill, unsigned long) const;
            virtual iter_type do_put(iter_type, ios_base &, char_type __fill, long long __v) const;
            virtual iter_type do_put(iter_type, ios_base &, char_type __fill, unsigned long long) const;
            virtual iter_type do_put(iter_type, ios_base &, char_type __fill, double __v) const;
            virtual iter_type do_put(iter_type, ios_base &, char_type __fill, long double __v) const;
            virtual iter_type do_put(iter_type, ios_base &, char_type __fill, const void * __v) const;
    };
    template<typename _CharT, typename _OutIter >
    locale::id num_put< _CharT, _OutIter >::id;
    template<typename _CharT >
    inline bool isspace(_CharT __c, const locale & __loc)
    {
        return use_facet< ctype< _CharT > >(__loc).is(ctype_base::space, __c);
    }
    template<typename _CharT >
    inline bool isprint(_CharT __c, const locale & __loc)
    {
        return use_facet< ctype< _CharT > >(__loc).is(ctype_base::print, __c);
    }
    template<typename _CharT >
    inline bool iscntrl(_CharT __c, const locale & __loc)
    {
        return use_facet< ctype< _CharT > >(__loc).is(ctype_base::cntrl, __c);
    }
    template<typename _CharT >
    inline bool isupper(_CharT __c, const locale & __loc)
    {
        return use_facet< ctype< _CharT > >(__loc).is(ctype_base::upper, __c);
    }
    template<typename _CharT >
    inline bool islower(_CharT __c, const locale & __loc)
    {
        return use_facet< ctype< _CharT > >(__loc).is(ctype_base::lower, __c);
    }
    template<typename _CharT >
    inline bool isalpha(_CharT __c, const locale & __loc)
    {
        return use_facet< ctype< _CharT > >(__loc).is(ctype_base::alpha, __c);
    }
    template<typename _CharT >
    inline bool isdigit(_CharT __c, const locale & __loc)
    {
        return use_facet< ctype< _CharT > >(__loc).is(ctype_base::digit, __c);
    }
    template<typename _CharT >
    inline bool ispunct(_CharT __c, const locale & __loc)
    {
        return use_facet< ctype< _CharT > >(__loc).is(ctype_base::punct, __c);
    }
    template<typename _CharT >
    inline bool isxdigit(_CharT __c, const locale & __loc)
    {
        return use_facet< ctype< _CharT > >(__loc).is(ctype_base::xdigit, __c);
    }
    template<typename _CharT >
    inline bool isalnum(_CharT __c, const locale & __loc)
    {
        return use_facet< ctype< _CharT > >(__loc).is(ctype_base::alnum, __c);
    }
    template<typename _CharT >
    inline bool isgraph(_CharT __c, const locale & __loc)
    {
        return use_facet< ctype< _CharT > >(__loc).is(ctype_base::graph, __c);
    }
    template<typename _CharT >
    inline _CharT toupper(_CharT __c, const locale & __loc)
    {
        return use_facet< ctype< _CharT > >(__loc).toupper(__c);
    }
    template<typename _CharT >
    inline _CharT tolower(_CharT __c, const locale & __loc)
    {
        return use_facet< ctype< _CharT > >(__loc).tolower(__c);
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Facet >
    struct __use_cache
    {
            const _Facet * operator ()(const locale & __loc) const;
    };
    template<typename _CharT >
    struct __use_cache< __numpunct_cache< _CharT > >
    {
            const __numpunct_cache< _CharT > * operator ()(const locale & __loc) const
            {
                const size_t __i = numpunct< _CharT >::id._M_id();
                const locale::facet * * __caches = __loc._M_impl->_M_caches;
                if (!__caches[__i])
                {
                    __numpunct_cache< _CharT > * __tmp = __null;
                    try
                    {
                        __tmp = new __numpunct_cache< _CharT >;
                        __tmp->_M_cache(__loc);
                    }
                    catch (...)
                    {
                        delete __tmp;
                        throw;
                    }
                    __loc._M_impl->_M_install_cache(__tmp, __i);
                }
                return static_cast<const __numpunct_cache< _CharT > * >(__caches[__i]);
            }
    };
    template<typename _CharT >
    void __numpunct_cache< _CharT >::_M_cache(const locale & __loc)
    {
        _M_allocated = true;
        const numpunct< _CharT > & __np = use_facet< numpunct< _CharT > >(__loc);
        _M_grouping_size = __np.grouping().size();
        char * __grouping = new char [_M_grouping_size];
        __np.grouping().copy(__grouping, _M_grouping_size);
        _M_grouping = __grouping;
        _M_use_grouping = (_M_grouping_size && static_cast<signed char >(__np.grouping()[0]) > 0);
        _M_truename_size = __np.truename().size();
        _CharT * __truename = new _CharT [_M_truename_size];
        __np.truename().copy(__truename, _M_truename_size);
        _M_truename = __truename;
        _M_falsename_size = __np.falsename().size();
        _CharT * __falsename = new _CharT [_M_falsename_size];
        __np.falsename().copy(__falsename, _M_falsename_size);
        _M_falsename = __falsename;
        _M_decimal_point = __np.decimal_point();
        _M_thousands_sep = __np.thousands_sep();
        const ctype< _CharT > & __ct = use_facet< ctype< _CharT > >(__loc);
        __ct.widen(__num_base::_S_atoms_out, __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);
        __ct.widen(__num_base::_S_atoms_in, __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);
    }
    bool __verify_grouping(const char * __grouping, size_t __grouping_size, const string & __grouping_tmp);
    template<typename _CharT, typename _InIter >
    _InIter num_get< _CharT, _InIter >::_M_extract_float(_InIter __beg, _InIter __end, ios_base & __io, ios_base::iostate & __err, string & __xtrc) const
    {
        typedef char_traits< _CharT > __traits_type;
        typedef __numpunct_cache< _CharT > __cache_type;
        __use_cache< __cache_type > __uc;
        const locale & __loc = __io._M_getloc();
        const __cache_type * __lc = __uc(__loc);
        const _CharT * __lit = __lc->_M_atoms_in;
        char_type __c = char_type();
        bool __testeof = __beg == __end;
        if (!__testeof)
        {
            __c = *__beg;
            const bool __plus = __c == __lit[__num_base::_S_iplus];
            if ((__plus || __c == __lit[__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point))
            {
                __xtrc += __plus ? '+' : '-';
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        }
        bool __found_mantissa = false;
        int __sep_pos = 0;
        while (!__testeof)
        {
            if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
                break;
            else
                if (__c == __lit[__num_base::_S_izero])
                {
                    if (!__found_mantissa)
                    {
                        __xtrc += '0';
                        __found_mantissa = true;
                    }
                    ++__sep_pos;
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
                else
                    break;
        }
        bool __found_dec = false;
        bool __found_sci = false;
        string __found_grouping;
        if (__lc->_M_use_grouping)
            __found_grouping.reserve(32);
        const char_type * __lit_zero = __lit + __num_base::_S_izero;
        if (!__lc->_M_allocated)
            while (!__testeof)
            {
                const int __digit = _M_find(__lit_zero, 10, __c);
                if (__digit != -1)
                {
                    __xtrc += '0' + __digit;
                    __found_mantissa = true;
                }
                else
                    if (__c == __lc->_M_decimal_point && !__found_dec && !__found_sci)
                    {
                        __xtrc += '.';
                        __found_dec = true;
                    }
                    else
                        if ((__c == __lit[__num_base::_S_ie] || __c == __lit[__num_base::_S_iE]) && !__found_sci && __found_mantissa)
                        {
                            __xtrc += 'e';
                            __found_sci = true;
                            if (++__beg != __end)
                            {
                                __c = *__beg;
                                const bool __plus = __c == __lit[__num_base::_S_iplus];
                                if (__plus || __c == __lit[__num_base::_S_iminus])
                                    __xtrc += __plus ? '+' : '-';
                                else
                                    continue;
                            }
                            else
                            {
                                __testeof = true;
                                break;
                            }
                        }
                        else
                            break;
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        else
            while (!__testeof)
            {
                if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
                {
                    if (!__found_dec && !__found_sci)
                    {
                        if (__sep_pos)
                        {
                            __found_grouping += static_cast<char >(__sep_pos);
                            __sep_pos = 0;
                        }
                        else
                        {
                            __xtrc.clear();
                            break;
                        }
                    }
                    else
                        break;
                }
                else
                    if (__c == __lc->_M_decimal_point)
                    {
                        if (!__found_dec && !__found_sci)
                        {
                            if (__found_grouping.size())
                                __found_grouping += static_cast<char >(__sep_pos);
                            __xtrc += '.';
                            __found_dec = true;
                        }
                        else
                            break;
                    }
                    else
                    {
                        const char_type * __q = __traits_type::find(__lit_zero, 10, __c);
                        if (__q)
                        {
                            __xtrc += '0' + (__q - __lit_zero);
                            __found_mantissa = true;
                            ++__sep_pos;
                        }
                        else
                            if ((__c == __lit[__num_base::_S_ie] || __c == __lit[__num_base::_S_iE]) && !__found_sci && __found_mantissa)
                            {
                                if (__found_grouping.size() && !__found_dec)
                                    __found_grouping += static_cast<char >(__sep_pos);
                                __xtrc += 'e';
                                __found_sci = true;
                                if (++__beg != __end)
                                {
                                    __c = *__beg;
                                    const bool __plus = __c == __lit[__num_base::_S_iplus];
                                    if ((__plus || __c == __lit[__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point))
                                        __xtrc += __plus ? '+' : '-';
                                    else
                                        continue;
                                }
                                else
                                {
                                    __testeof = true;
                                    break;
                                }
                            }
                            else
                                break;
                    }
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        if (__found_grouping.size())
        {
            if (!__found_dec && !__found_sci)
                __found_grouping += static_cast<char >(__sep_pos);
            if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
                __err |= ios_base::failbit;
        }
        if (__testeof)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template<typename _CharT, typename _InIter >
    template<typename _ValueT >
    _InIter num_get< _CharT, _InIter >::_M_extract_int(_InIter __beg, _InIter __end, ios_base & __io, ios_base::iostate & __err, _ValueT & __v) const
    {
        typedef char_traits< _CharT > __traits_type;
        using __gnu_cxx::__add_unsigned;
        typedef typename __add_unsigned< _ValueT >::__type __unsigned_type;
        typedef __numpunct_cache< _CharT > __cache_type;
        __use_cache< __cache_type > __uc;
        const locale & __loc = __io._M_getloc();
        const __cache_type * __lc = __uc(__loc);
        const _CharT * __lit = __lc->_M_atoms_in;
        char_type __c = char_type();
        const ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;
        const bool __oct = __basefield == ios_base::oct;
        int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);
        bool __testeof = __beg == __end;
        bool __negative = false;
        if (!__testeof)
        {
            __c = *__beg;
            if (__gnu_cxx::__numeric_traits< _ValueT >::__is_signed)
                __negative = __c == __lit[__num_base::_S_iminus];
            if ((__negative || __c == __lit[__num_base::_S_iplus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point))
            {
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        }
        bool __found_zero = false;
        int __sep_pos = 0;
        while (!__testeof)
        {
            if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
                break;
            else
                if (__c == __lit[__num_base::_S_izero] && (!__found_zero || __base == 10))
                {
                    __found_zero = true;
                    ++__sep_pos;
                    if (__basefield == 0)
                        __base = 8;
                    if (__base == 8)
                        __sep_pos = 0;
                }
                else
                    if (__found_zero && (__c == __lit[__num_base::_S_ix] || __c == __lit[__num_base::_S_iX]))
                    {
                        if (__basefield == 0)
                            __base = 16;
                        if (__base == 16)
                        {
                            __found_zero = false;
                            __sep_pos = 0;
                        }
                        else
                            break;
                    }
                    else
                        break;
            if (++__beg != __end)
            {
                __c = *__beg;
                if (!__found_zero)
                    break;
            }
            else
                __testeof = true;
        }
        const size_t __len = (__base == 16 ? __num_base::_S_iend - __num_base::_S_izero : __base);
        string __found_grouping;
        if (__lc->_M_use_grouping)
            __found_grouping.reserve(32);
        bool __testfail = false;
        const __unsigned_type __max = __negative ? -__gnu_cxx::__numeric_traits< _ValueT >::__min : __gnu_cxx::__numeric_traits< _ValueT >::__max;
        const __unsigned_type __smax = __max / __base;
        __unsigned_type __result = 0;
        int __digit = 0;
        const char_type * __lit_zero = __lit + __num_base::_S_izero;
        if (!__lc->_M_allocated)
            while (!__testeof)
            {
                __digit = _M_find(__lit_zero, __len, __c);
                if (__digit == -1)
                    break;
                if (__result > __smax)
                    __testfail = true;
                else
                {
                    __result *= __base;
                    __testfail |= __result > __max - __digit;
                    __result += __digit;
                    ++__sep_pos;
                }
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        else
            while (!__testeof)
            {
                if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
                {
                    if (__sep_pos)
                    {
                        __found_grouping += static_cast<char >(__sep_pos);
                        __sep_pos = 0;
                    }
                    else
                    {
                        __testfail = true;
                        break;
                    }
                }
                else
                    if (__c == __lc->_M_decimal_point)
                        break;
                    else
                    {
                        const char_type * __q = __traits_type::find(__lit_zero, __len, __c);
                        if (!__q)
                            break;
                        __digit = __q - __lit_zero;
                        if (__digit > 15)
                            __digit -= 6;
                        if (__result > __smax)
                            __testfail = true;
                        else
                        {
                            __result *= __base;
                            __testfail |= __result > __max - __digit;
                            __result += __digit;
                            ++__sep_pos;
                        }
                    }
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        if (__found_grouping.size())
        {
            __found_grouping += static_cast<char >(__sep_pos);
            if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
                __err |= ios_base::failbit;
        }
        if (!__testfail && (__sep_pos || __found_zero || __found_grouping.size()))
            __v = __negative ? -__result : __result;
        else
            __err |= ios_base::failbit;
        if (__testeof)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template<typename _CharT, typename _InIter >
    _InIter num_get< _CharT, _InIter >::do_get(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, bool & __v) const
    {
        if (!(__io.flags() & ios_base::boolalpha))
        {
            long __l = -1;
            __beg = _M_extract_int(__beg, __end, __io, __err, __l);
            if (__l == 0 || __l == 1)
                __v = bool(__l);
            else
                __err |= ios_base::failbit;
        }
        else
        {
            typedef __numpunct_cache< _CharT > __cache_type;
            __use_cache< __cache_type > __uc;
            const locale & __loc = __io._M_getloc();
            const __cache_type * __lc = __uc(__loc);
            bool __testf = true;
            bool __testt = true;
            size_t __n;
            bool __testeof = __beg == __end;
            for (__n = 0;
                !__testeof;
                ++__n)
            {
                const char_type __c = *__beg;
                if (__testf)
                {
                    if (__n < __lc->_M_falsename_size)
                        __testf = __c == __lc->_M_falsename[__n];
                    else
                        break;
                }
                if (__testt)
                {
                    if (__n < __lc->_M_truename_size)
                        __testt = __c == __lc->_M_truename[__n];
                    else
                        break;
                }
                if (!__testf && !__testt)
                    break;
                if (++__beg == __end)
                    __testeof = true;
            }
            if (__testf && __n == __lc->_M_falsename_size)
                __v = false;
            else
                if (__testt && __n == __lc->_M_truename_size)
                    __v = true;
                else
                    __err |= ios_base::failbit;
            if (__testeof)
                __err |= ios_base::eofbit;
        }
        return __beg;
    }
    template<typename _CharT, typename _InIter >
    _InIter num_get< _CharT, _InIter >::do_get(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, long & __v) const
    {
        return _M_extract_int(__beg, __end, __io, __err, __v);
    }
    template<typename _CharT, typename _InIter >
    _InIter num_get< _CharT, _InIter >::do_get(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, unsigned short & __v) const
    {
        return _M_extract_int(__beg, __end, __io, __err, __v);
    }
    template<typename _CharT, typename _InIter >
    _InIter num_get< _CharT, _InIter >::do_get(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, unsigned int & __v) const
    {
        return _M_extract_int(__beg, __end, __io, __err, __v);
    }
    template<typename _CharT, typename _InIter >
    _InIter num_get< _CharT, _InIter >::do_get(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, unsigned long & __v) const
    {
        return _M_extract_int(__beg, __end, __io, __err, __v);
    }
    template<typename _CharT, typename _InIter >
    _InIter num_get< _CharT, _InIter >::do_get(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, long long & __v) const
    {
        return _M_extract_int(__beg, __end, __io, __err, __v);
    }
    template<typename _CharT, typename _InIter >
    _InIter num_get< _CharT, _InIter >::do_get(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, unsigned long long & __v) const
    {
        return _M_extract_int(__beg, __end, __io, __err, __v);
    }
    template<typename _CharT, typename _InIter >
    _InIter num_get< _CharT, _InIter >::do_get(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, float & __v) const
    {
        string __xtrc;
        __xtrc.reserve(32);
        __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        return __beg;
    }
    template<typename _CharT, typename _InIter >
    _InIter num_get< _CharT, _InIter >::do_get(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, double & __v) const
    {
        string __xtrc;
        __xtrc.reserve(32);
        __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        return __beg;
    }
    template<typename _CharT, typename _InIter >
    _InIter num_get< _CharT, _InIter >::do_get(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, long double & __v) const
    {
        string __xtrc;
        __xtrc.reserve(32);
        __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        return __beg;
    }
    template<typename _CharT, typename _InIter >
    _InIter num_get< _CharT, _InIter >::do_get(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, void * & __v) const
    {
        typedef ios_base::fmtflags fmtflags;
        const fmtflags __fmt = __io.flags();
        __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);
        typedef __gnu_cxx::__conditional_type< (sizeof(void *) <= sizeof(unsigned long)), unsigned long, unsigned long long >::__type _UIntPtrType;
        _UIntPtrType __ul;
        __beg = _M_extract_int(__beg, __end, __io, __err, __ul);
        __io.flags(__fmt);
        if (!(__err & ios_base::failbit))
            __v = reinterpret_cast<void * >(__ul);
        return __beg;
    }
    template<typename _CharT, typename _OutIter >
    void num_put< _CharT, _OutIter >::_M_pad(_CharT __fill, streamsize __w, ios_base & __io, _CharT * __new, const _CharT * __cs, int & __len) const
    {
        __pad< _CharT, char_traits< _CharT > >::_S_pad(__io, __fill, __new, __cs, __w, __len);
        __len = static_cast<int >(__w);
    }
    template<typename _CharT, typename _ValueT >
    int __int_to_char(_CharT * __bufend, _ValueT __v, const _CharT * __lit, ios_base::fmtflags __flags, bool __dec)
    {
        _CharT * __buf = __bufend;
        if (__builtin_expect(__dec, true))
        {
            do
            {
                *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
                __v /= 10;
            }
            while (__v != 0);
        }
        else
            if ((__flags & ios_base::basefield) == ios_base::oct)
            {
                do
                {
                    *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
                    __v >>= 3;
                }
                while (__v != 0);
            }
            else
            {
                const bool __uppercase = __flags & ios_base::uppercase;
                const int __case_offset = __uppercase ? __num_base::_S_oudigits : __num_base::_S_odigits;
                do
                {
                    *--__buf = __lit[(__v & 0xf) + __case_offset];
                    __v >>= 4;
                }
                while (__v != 0);
            }
        return __bufend - __buf;
    }
    template<typename _CharT, typename _OutIter >
    void num_put< _CharT, _OutIter >::_M_group_int(const char * __grouping, size_t __grouping_size, _CharT __sep, ios_base &, _CharT * __new, _CharT * __cs, int & __len) const
    {
        _CharT * __p = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __len);
        __len = __p - __new;
    }
    template<typename _CharT, typename _OutIter >
    template<typename _ValueT >
    _OutIter num_put< _CharT, _OutIter >::_M_insert_int(_OutIter __s, ios_base & __io, _CharT __fill, _ValueT __v) const
    {
        using __gnu_cxx::__add_unsigned;
        typedef typename __add_unsigned< _ValueT >::__type __unsigned_type;
        typedef __numpunct_cache< _CharT > __cache_type;
        __use_cache< __cache_type > __uc;
        const locale & __loc = __io._M_getloc();
        const __cache_type * __lc = __uc(__loc);
        const _CharT * __lit = __lc->_M_atoms_out;
        const ios_base::fmtflags __flags = __io.flags();
        const int __ilen = 5 * sizeof(_ValueT);
        _CharT * __cs = static_cast<_CharT * >(__builtin_alloca(sizeof(_CharT) * __ilen));
        const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
        const bool __dec = (__basefield != ios_base::oct && __basefield != ios_base::hex);
        const __unsigned_type __u = ((__v > 0 || !__dec) ? __unsigned_type(__v) : -__unsigned_type(__v));
        int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
        __cs += __ilen - __len;
        if (__lc->_M_use_grouping)
        {
            _CharT * __cs2 = static_cast<_CharT * >(__builtin_alloca(sizeof(_CharT) * (__len + 1) * 2));
            _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
            __cs = __cs2 + 2;
        }
        if (__builtin_expect(__dec, true))
        {
            if (__v >= 0)
            {
                if (bool(__flags & ios_base::showpos) && __gnu_cxx::__numeric_traits< _ValueT >::__is_signed)
                    *--__cs = __lit[__num_base::_S_oplus] , ++__len;
            }
            else
                *--__cs = __lit[__num_base::_S_ominus] , ++__len;
        }
        else
            if (bool(__flags & ios_base::showbase) && __v)
            {
                if (__basefield == ios_base::oct)
                    *--__cs = __lit[__num_base::_S_odigits] , ++__len;
                else
                {
                    const bool __uppercase = __flags & ios_base::uppercase;
                    *--__cs = __lit[__num_base::_S_ox + __uppercase];
                    *--__cs = __lit[__num_base::_S_odigits];
                    __len += 2;
                }
            }
        const streamsize __w = __io.width();
        if (__w > static_cast<streamsize >(__len))
        {
            _CharT * __cs3 = static_cast<_CharT * >(__builtin_alloca(sizeof(_CharT) * __w));
            _M_pad(__fill, __w, __io, __cs3, __cs, __len);
            __cs = __cs3;
        }
        __io.width(0);
        return std::__write(__s, __cs, __len);
    }
    template<typename _CharT, typename _OutIter >
    void num_put< _CharT, _OutIter >::_M_group_float(const char * __grouping, size_t __grouping_size, _CharT __sep, const _CharT * __p, _CharT * __new, _CharT * __cs, int & __len) const
    {
        const int __declen = __p ? __p - __cs : __len;
        _CharT * __p2 = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __declen);
        int __newlen = __p2 - __new;
        if (__p)
        {
            char_traits< _CharT >::copy(__p2, __p, __len - __declen);
            __newlen += __len - __declen;
        }
        __len = __newlen;
    }
    template<typename _CharT, typename _OutIter >
    template<typename _ValueT >
    _OutIter num_put< _CharT, _OutIter >::_M_insert_float(_OutIter __s, ios_base & __io, _CharT __fill, char __mod, _ValueT __v) const
    {
        typedef __numpunct_cache< _CharT > __cache_type;
        __use_cache< __cache_type > __uc;
        const locale & __loc = __io._M_getloc();
        const __cache_type * __lc = __uc(__loc);
        const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();
        const int __max_digits = __gnu_cxx::__numeric_traits< _ValueT >::__digits10;
        int __len;
        char __fbuf[16];
        __num_base::_S_format_float(__io, __fbuf, __mod);
        int __cs_size = __max_digits * 3;
        char * __cs = static_cast<char * >(__builtin_alloca(__cs_size));
        __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
        if (__len >= __cs_size)
        {
            __cs_size = __len + 1;
            __cs = static_cast<char * >(__builtin_alloca(__cs_size));
            __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
        }
        const ctype< _CharT > & __ctype = use_facet< ctype< _CharT > >(__loc);
        _CharT * __ws = static_cast<_CharT * >(__builtin_alloca(sizeof(_CharT) * __len));
        __ctype.widen(__cs, __cs + __len, __ws);
        _CharT * __wp = 0;
        const char * __p = char_traits< char >::find(__cs, __len, '.');
        if (__p)
        {
            __wp = __ws + (__p - __cs);
            *__wp = __lc->_M_decimal_point;
        }
        if (__lc->_M_use_grouping && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9' && __cs[1] >= '0' && __cs[2] >= '0')))
        {
            _CharT * __ws2 = static_cast<_CharT * >(__builtin_alloca(sizeof(_CharT) * __len * 2));
            streamsize __off = 0;
            if (__cs[0] == '-' || __cs[0] == '+')
            {
                __off = 1;
                __ws2[0] = __ws[0];
                __len -= 1;
            }
            _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __wp, __ws2 + __off, __ws + __off, __len);
            __len += __off;
            __ws = __ws2;
        }
        const streamsize __w = __io.width();
        if (__w > static_cast<streamsize >(__len))
        {
            _CharT * __ws3 = static_cast<_CharT * >(__builtin_alloca(sizeof(_CharT) * __w));
            _M_pad(__fill, __w, __io, __ws3, __ws, __len);
            __ws = __ws3;
        }
        __io.width(0);
        return std::__write(__s, __ws, __len);
    }
    template<typename _CharT, typename _OutIter >
    _OutIter num_put< _CharT, _OutIter >::do_put(iter_type __s, ios_base & __io, char_type __fill, bool __v) const
    {
        const ios_base::fmtflags __flags = __io.flags();
        if ((__flags & ios_base::boolalpha) == 0)
        {
            const long __l = __v;
            __s = _M_insert_int(__s, __io, __fill, __l);
        }
        else
        {
            typedef __numpunct_cache< _CharT > __cache_type;
            __use_cache< __cache_type > __uc;
            const locale & __loc = __io._M_getloc();
            const __cache_type * __lc = __uc(__loc);
            const _CharT * __name = __v ? __lc->_M_truename : __lc->_M_falsename;
            int __len = __v ? __lc->_M_truename_size : __lc->_M_falsename_size;
            const streamsize __w = __io.width();
            if (__w > static_cast<streamsize >(__len))
            {
                _CharT * __cs = static_cast<_CharT * >(__builtin_alloca(sizeof(_CharT) * __w));
                _M_pad(__fill, __w, __io, __cs, __name, __len);
                __name = __cs;
            }
            __io.width(0);
            __s = std::__write(__s, __name, __len);
        }
        return __s;
    }
    template<typename _CharT, typename _OutIter >
    _OutIter num_put< _CharT, _OutIter >::do_put(iter_type __s, ios_base & __io, char_type __fill, long __v) const
    {
        return _M_insert_int(__s, __io, __fill, __v);
    }
    template<typename _CharT, typename _OutIter >
    _OutIter num_put< _CharT, _OutIter >::do_put(iter_type __s, ios_base & __io, char_type __fill, unsigned long __v) const
    {
        return _M_insert_int(__s, __io, __fill, __v);
    }
    template<typename _CharT, typename _OutIter >
    _OutIter num_put< _CharT, _OutIter >::do_put(iter_type __s, ios_base & __io, char_type __fill, long long __v) const
    {
        return _M_insert_int(__s, __io, __fill, __v);
    }
    template<typename _CharT, typename _OutIter >
    _OutIter num_put< _CharT, _OutIter >::do_put(iter_type __s, ios_base & __io, char_type __fill, unsigned long long __v) const
    {
        return _M_insert_int(__s, __io, __fill, __v);
    }
    template<typename _CharT, typename _OutIter >
    _OutIter num_put< _CharT, _OutIter >::do_put(iter_type __s, ios_base & __io, char_type __fill, double __v) const
    {
        return _M_insert_float(__s, __io, __fill, char(), __v);
    }
    template<typename _CharT, typename _OutIter >
    _OutIter num_put< _CharT, _OutIter >::do_put(iter_type __s, ios_base & __io, char_type __fill, long double __v) const
    {
        return _M_insert_float(__s, __io, __fill, 'L', __v);
    }
    template<typename _CharT, typename _OutIter >
    _OutIter num_put< _CharT, _OutIter >::do_put(iter_type __s, ios_base & __io, char_type __fill, const void * __v) const
    {
        const ios_base::fmtflags __flags = __io.flags();
        const ios_base::fmtflags __fmt = ~(ios_base::basefield | ios_base::uppercase | ios_base::internal);
        __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));
        typedef __gnu_cxx::__conditional_type< (sizeof(const void *) <= sizeof(unsigned long)), unsigned long, unsigned long long >::__type _UIntPtrType;
        __s = _M_insert_int(__s, __io, __fill, reinterpret_cast<_UIntPtrType >(__v));
        __io.flags(__flags);
        return __s;
    }
    template<typename _CharT, typename _Traits >
    void __pad< _CharT, _Traits >::_S_pad(ios_base & __io, _CharT __fill, _CharT * __news, const _CharT * __olds, const streamsize __newlen, const streamsize __oldlen)
    {
        const size_t __plen = static_cast<size_t >(__newlen - __oldlen);
        const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;
        if (__adjust == ios_base::left)
        {
            _Traits::copy(__news, __olds, __oldlen);
            _Traits::assign(__news + __oldlen, __plen, __fill);
            return;
        }
        size_t __mod = 0;
        if (__adjust == ios_base::internal)
        {
            const locale & __loc = __io._M_getloc();
            const ctype< _CharT > & __ctype = use_facet< ctype< _CharT > >(__loc);
            if (__ctype.widen('-') == __olds[0] || __ctype.widen('+') == __olds[0])
            {
                __news[0] = __olds[0];
                __mod = 1;
                ++__news;
            }
            else
                if (__ctype.widen('0') == __olds[0] && __oldlen > 1 && (__ctype.widen('x') == __olds[1] || __ctype.widen('X') == __olds[1]))
                {
                    __news[0] = __olds[0];
                    __news[1] = __olds[1];
                    __mod = 2;
                    __news += 2;
                }
        }
        _Traits::assign(__news, __plen, __fill);
        _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }
    template<typename _CharT >
    _CharT * __add_grouping(_CharT * __s, _CharT __sep, const char * __gbeg, size_t __gsize, const _CharT * __first, const _CharT * __last)
    {
        size_t __idx = 0;
        size_t __ctr = 0;
        while (__last - __first > __gbeg[__idx] && static_cast<signed char >(__gbeg[__idx]) > 0)
        {
            __last -= __gbeg[__idx];
            __idx < __gsize - 1 ? ++__idx : ++__ctr;
        }
        while (__first != __last)
            *__s++ = *__first++;
        while (__ctr--)
        {
            *__s++ = __sep;
            for (char __i = __gbeg[__idx];
                __i > 0;
                --__i)
            *__s++ = *__first++;
        }
        while (__idx--)
        {
            *__s++ = __sep;
            for (char __i = __gbeg[__idx];
                __i > 0;
                --__i)
            *__s++ = *__first++;
        }
        return __s;
    }
    extern template class numpunct< char > ;
    extern template class numpunct_byname< char > ;
    extern template class num_get< char > ;
    extern template class num_put< char > ;
    extern template class ctype_byname< char > ;
    extern template const numpunct< char > & use_facet< numpunct< char > >(const locale &);
    extern template const num_put< char > & use_facet< num_put< char > >(const locale &);
    extern template const num_get< char > & use_facet< num_get< char > >(const locale &);
    extern template bool has_facet< ctype< char > >(const locale &);
    extern template bool has_facet< numpunct< char > >(const locale &);
    extern template bool has_facet< num_put< char > >(const locale &);
    extern template bool has_facet< num_get< char > >(const locale &);
    extern template class numpunct< wchar_t > ;
    extern template class numpunct_byname< wchar_t > ;
    extern template class num_get< wchar_t > ;
    extern template class num_put< wchar_t > ;
    extern template class ctype_byname< wchar_t > ;
    extern template const numpunct< wchar_t > & use_facet< numpunct< wchar_t > >(const locale &);
    extern template const num_put< wchar_t > & use_facet< num_put< wchar_t > >(const locale &);
    extern template const num_get< wchar_t > & use_facet< num_get< wchar_t > >(const locale &);
    extern template bool has_facet< ctype< wchar_t > >(const locale &);
    extern template bool has_facet< numpunct< wchar_t > >(const locale &);
    extern template bool has_facet< num_put< wchar_t > >(const locale &);
    extern template bool has_facet< num_get< wchar_t > >(const locale &);
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Facet >
    inline const _Facet & __check_facet(const _Facet * __f)
    {
        if (!__f)
            __throw_bad_cast();
        return *__f;
    }
    template<typename _CharT, typename _Traits >
    class basic_ios : public ios_base
    {
        public :
            typedef _CharT char_type;
            typedef typename _Traits::int_type int_type;
            typedef typename _Traits::pos_type pos_type;
            typedef typename _Traits::off_type off_type;
            typedef _Traits traits_type;
            typedef ctype< _CharT > __ctype_type;
            typedef num_put< _CharT, ostreambuf_iterator< _CharT, _Traits > > __num_put_type;
            typedef num_get< _CharT, istreambuf_iterator< _CharT, _Traits > > __num_get_type;
        protected :
            basic_ostream< _CharT, _Traits > * _M_tie;
            mutable char_type _M_fill;
            mutable bool _M_fill_init;
            basic_streambuf< _CharT, _Traits > * _M_streambuf;
            const __ctype_type * _M_ctype;
            const __num_put_type * _M_num_put;
            const __num_get_type * _M_num_get;
        public :
            operator void *() const
            {
                return this->fail() ? 0 : const_cast<basic_ios * >(this);
            }
            bool operator !() const
            {
                return this->fail();
            }
            iostate rdstate() const
            {
                return _M_streambuf_state;
            }
            void clear(iostate __state = goodbit);
            void setstate(iostate __state)
            {
                this->clear(this->rdstate() | __state);
            }
            void _M_setstate(iostate __state)
            {
                _M_streambuf_state |= __state;
                if (this->exceptions() & __state)
                    throw;
            }
            bool good() const
            {
                return this->rdstate() == 0;
            }
            bool eof() const
            {
                return (this->rdstate() & eofbit) != 0;
            }
            bool fail() const
            {
                return (this->rdstate() & (badbit | failbit)) != 0;
            }
            bool bad() const
            {
                return (this->rdstate() & badbit) != 0;
            }
            iostate exceptions() const
            {
                return _M_exception;
            }
            void exceptions(iostate __except)
            {
                _M_exception = __except;
                this->clear(_M_streambuf_state);
            }
            explicit basic_ios(basic_streambuf< _CharT, _Traits > * __sb)
                : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0) 
            {
                this->init(__sb);
            }
            virtual ~basic_ios()
            {
            }
            basic_ostream< _CharT, _Traits > * tie() const
            {
                return _M_tie;
            }
            basic_ostream< _CharT, _Traits > * tie(basic_ostream< _CharT, _Traits > * __tiestr)
            {
                basic_ostream< _CharT, _Traits > * __old = _M_tie;
                _M_tie = __tiestr;
                return __old;
            }
            basic_streambuf< _CharT, _Traits > * rdbuf() const
            {
                return _M_streambuf;
            }
            basic_streambuf< _CharT, _Traits > * rdbuf(basic_streambuf< _CharT, _Traits > * __sb);
            basic_ios & copyfmt(const basic_ios & __rhs);
            char_type fill() const
            {
                if (!_M_fill_init)
                {
                    _M_fill = this->widen(' ');
                    _M_fill_init = true;
                }
                return _M_fill;
            }
            char_type fill(char_type __ch)
            {
                char_type __old = this->fill();
                _M_fill = __ch;
                return __old;
            }
            locale imbue(const locale & __loc);
            char narrow(char_type __c, char __dfault) const
            {
                return __check_facet(_M_ctype).narrow(__c, __dfault);
            }
            char_type widen(char __c) const
            {
                return __check_facet(_M_ctype).widen(__c);
            }
        protected :
            basic_ios()
                : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0) 
            {
            }
            void init(basic_streambuf< _CharT, _Traits > * __sb);
            void _M_cache_locale(const locale & __loc);
    };
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _CharT, typename _Traits >
    void basic_ios< _CharT, _Traits >::clear(iostate __state)
    {
        if (this->rdbuf())
            _M_streambuf_state = __state;
        else
            _M_streambuf_state = __state | badbit;
        if (this->exceptions() & this->rdstate())
            __throw_ios_failure(("basic_ios::clear"));
    }
    template<typename _CharT, typename _Traits >
    basic_streambuf< _CharT, _Traits > * basic_ios< _CharT, _Traits >::rdbuf(basic_streambuf< _CharT, _Traits > * __sb)
    {
        basic_streambuf< _CharT, _Traits > * __old = _M_streambuf;
        _M_streambuf = __sb;
        this->clear();
        return __old;
    }
    template<typename _CharT, typename _Traits >
    basic_ios< _CharT, _Traits > & basic_ios< _CharT, _Traits >::copyfmt(const basic_ios & __rhs)
    {
        if (this != &__rhs)
        {
            _Words * __words = (__rhs._M_word_size <= _S_local_word_size) ? _M_local_word : new _Words [__rhs._M_word_size];
            _Callback_list * __cb = __rhs._M_callbacks;
            if (__cb)
                __cb->_M_add_reference();
            _M_call_callbacks(erase_event);
            if (_M_word != _M_local_word)
            {
                delete[] _M_word;
                _M_word = 0;
            }
            _M_dispose_callbacks();
            _M_callbacks = __cb;
            for (int __i = 0;
                __i < __rhs._M_word_size;
                ++__i)
            __words[__i] = __rhs._M_word[__i];
            _M_word = __words;
            _M_word_size = __rhs._M_word_size;
            this->flags(__rhs.flags());
            this->width(__rhs.width());
            this->precision(__rhs.precision());
            this->tie(__rhs.tie());
            this->fill(__rhs.fill());
            _M_ios_locale = __rhs.getloc();
            _M_cache_locale(_M_ios_locale);
            _M_call_callbacks(copyfmt_event);
            this->exceptions(__rhs.exceptions());
        }
        return *this;
    }
    template<typename _CharT, typename _Traits >
    locale basic_ios< _CharT, _Traits >::imbue(const locale & __loc)
    {
        locale __old(this->getloc());
        ios_base::imbue(__loc);
        _M_cache_locale(__loc);
        if (this->rdbuf() != 0)
            this->rdbuf()->pubimbue(__loc);
        return __old;
    }
    template<typename _CharT, typename _Traits >
    void basic_ios< _CharT, _Traits >::init(basic_streambuf< _CharT, _Traits > * __sb)
    {
        ios_base::_M_init();
        _M_cache_locale(_M_ios_locale);
        _M_fill = _CharT();
        _M_fill_init = false;
        _M_tie = 0;
        _M_exception = goodbit;
        _M_streambuf = __sb;
        _M_streambuf_state = __sb ? goodbit : badbit;
    }
    template<typename _CharT, typename _Traits >
    void basic_ios< _CharT, _Traits >::_M_cache_locale(const locale & __loc)
    {
        if (__builtin_expect(has_facet< __ctype_type >(__loc), true))
            _M_ctype = &use_facet< __ctype_type >(__loc);
        else
            _M_ctype = 0;
        if (__builtin_expect(has_facet< __num_put_type >(__loc), true))
            _M_num_put = &use_facet< __num_put_type >(__loc);
        else
            _M_num_put = 0;
        if (__builtin_expect(has_facet< __num_get_type >(__loc), true))
            _M_num_get = &use_facet< __num_get_type >(__loc);
        else
            _M_num_get = 0;
    }
    extern template class basic_ios< char > ;
    extern template class basic_ios< wchar_t > ;
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _CharT, typename _Traits >
    class basic_ostream : virtual public basic_ios< _CharT, _Traits >
    {
        public :
            typedef _CharT char_type;
            typedef typename _Traits::int_type int_type;
            typedef typename _Traits::pos_type pos_type;
            typedef typename _Traits::off_type off_type;
            typedef _Traits traits_type;
            typedef basic_streambuf< _CharT, _Traits > __streambuf_type;
            typedef basic_ios< _CharT, _Traits > __ios_type;
            typedef basic_ostream< _CharT, _Traits > __ostream_type;
            typedef num_put< _CharT, ostreambuf_iterator< _CharT, _Traits > > __num_put_type;
            typedef ctype< _CharT > __ctype_type;
            explicit basic_ostream(__streambuf_type * __sb)
            {
                this->init(__sb);
            }
            virtual ~basic_ostream()
            {
            }
            class sentry;
            friend class sentry;
            __ostream_type & operator <<(__ostream_type & (* __pf)(__ostream_type &))
            {
                return __pf(*this);
            }
            __ostream_type & operator <<(__ios_type & (* __pf)(__ios_type &))
            {
                __pf(*this);
                return *this;
            }
            __ostream_type & operator <<(ios_base & (* __pf)(ios_base &))
            {
                __pf(*this);
                return *this;
            }
            __ostream_type & operator <<(long __n)
            {
                return _M_insert(__n);
            }
            __ostream_type & operator <<(unsigned long __n)
            {
                return _M_insert(__n);
            }
            __ostream_type & operator <<(bool __n)
            {
                return _M_insert(__n);
            }
            __ostream_type & operator <<(short __n);
            __ostream_type & operator <<(unsigned short __n)
            {
                return _M_insert(static_cast<unsigned long >(__n));
            }
            __ostream_type & operator <<(int __n);
            __ostream_type & operator <<(unsigned int __n)
            {
                return _M_insert(static_cast<unsigned long >(__n));
            }
            __ostream_type & operator <<(long long __n)
            {
                return _M_insert(__n);
            }
            __ostream_type & operator <<(unsigned long long __n)
            {
                return _M_insert(__n);
            }
            __ostream_type & operator <<(double __f)
            {
                return _M_insert(__f);
            }
            __ostream_type & operator <<(float __f)
            {
                return _M_insert(static_cast<double >(__f));
            }
            __ostream_type & operator <<(long double __f)
            {
                return _M_insert(__f);
            }
            __ostream_type & operator <<(const void * __p)
            {
                return _M_insert(__p);
            }
            __ostream_type & operator <<(__streambuf_type * __sb);
            __ostream_type & put(char_type __c);
            void _M_write(const char_type * __s, streamsize __n)
            {
                const streamsize __put = this->rdbuf()->sputn(__s, __n);
                if (__put != __n)
                    this->setstate(ios_base::badbit);
            }
            __ostream_type & write(const char_type * __s, streamsize __n);
            __ostream_type & flush();
            pos_type tellp();
            __ostream_type & seekp(pos_type);
            __ostream_type & seekp(off_type, ios_base::seekdir);
        protected :
            basic_ostream()
            {
                this->init(0);
            }
            template<typename _ValueT >
            __ostream_type & _M_insert(_ValueT __v);
    };
    template<typename _CharT, typename _Traits >
    class basic_ostream< _CharT, _Traits >::sentry
    {
            bool _M_ok;
            basic_ostream< _CharT, _Traits > & _M_os;
        public :
            explicit sentry(basic_ostream< _CharT, _Traits > & __os);
            ~sentry()
            {
                if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
                {
                    if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
                        _M_os.setstate(ios_base::badbit);
                }
            }
            operator bool() const
            {
                return _M_ok;
            }
    };
    template<typename _CharT, typename _Traits >
    inline basic_ostream< _CharT, _Traits > & operator <<(basic_ostream< _CharT, _Traits > & __out, _CharT __c)
    {
        return __ostream_insert(__out, &__c, 1);
    }
    template<typename _CharT, typename _Traits >
    inline basic_ostream< _CharT, _Traits > & operator <<(basic_ostream< _CharT, _Traits > & __out, char __c)
    {
        return (__out << __out.widen(__c));
    }
    template<class _Traits >
    inline basic_ostream< char, _Traits > & operator <<(basic_ostream< char, _Traits > & __out, char __c)
    {
        return __ostream_insert(__out, &__c, 1);
    }
    template<class _Traits >
    inline basic_ostream< char, _Traits > & operator <<(basic_ostream< char, _Traits > & __out, signed char __c)
    {
        return (__out << static_cast<char >(__c));
    }
    template<class _Traits >
    inline basic_ostream< char, _Traits > & operator <<(basic_ostream< char, _Traits > & __out, unsigned char __c)
    {
        return (__out << static_cast<char >(__c));
    }
    template<typename _CharT, typename _Traits >
    inline basic_ostream< _CharT, _Traits > & operator <<(basic_ostream< _CharT, _Traits > & __out, const _CharT * __s)
    {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else
            __ostream_insert(__out, __s, static_cast<streamsize >(_Traits::length(__s)));
        return __out;
    }
    template<typename _CharT, typename _Traits >
    basic_ostream< _CharT, _Traits > & operator <<(basic_ostream< _CharT, _Traits > & __out, const char * __s);
    template<class _Traits >
    inline basic_ostream< char, _Traits > & operator <<(basic_ostream< char, _Traits > & __out, const char * __s)
    {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else
            __ostream_insert(__out, __s, static_cast<streamsize >(_Traits::length(__s)));
        return __out;
    }
    template<class _Traits >
    inline basic_ostream< char, _Traits > & operator <<(basic_ostream< char, _Traits > & __out, const signed char * __s)
    {
        return (__out << reinterpret_cast<const char * >(__s));
    }
    template<class _Traits >
    inline basic_ostream< char, _Traits > & operator <<(basic_ostream< char, _Traits > & __out, const unsigned char * __s)
    {
        return (__out << reinterpret_cast<const char * >(__s));
    }
    template<typename _CharT, typename _Traits >
    inline basic_ostream< _CharT, _Traits > & endl(basic_ostream< _CharT, _Traits > & __os)
    {
        return flush(__os.put(__os.widen('\n')));
    }
    template<typename _CharT, typename _Traits >
    inline basic_ostream< _CharT, _Traits > & ends(basic_ostream< _CharT, _Traits > & __os)
    {
        return __os.put(_CharT());
    }
    template<typename _CharT, typename _Traits >
    inline basic_ostream< _CharT, _Traits > & flush(basic_ostream< _CharT, _Traits > & __os)
    {
        return __os.flush();
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _CharT, typename _Traits >
    basic_ostream< _CharT, _Traits >::sentry::sentry(basic_ostream< _CharT, _Traits > & __os)
        : _M_ok(false), _M_os(__os) 
    {
        if (__os.tie() && __os.good())
            __os.tie()->flush();
        if (__os.good())
            _M_ok = true;
        else
            __os.setstate(ios_base::failbit);
    }
    template<typename _CharT, typename _Traits >
    template<typename _ValueT >
    basic_ostream< _CharT, _Traits > & basic_ostream< _CharT, _Traits >::_M_insert(_ValueT __v)
    {
        sentry __cerb(*this);
        if (__cerb)
        {
            ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
            try
            {
                const __num_put_type & __np = __check_facet(this->_M_num_put);
                if (__np.put(*this, *this, this->fill(), __v).failed())
                    __err |= ios_base::badbit;
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_ostream< _CharT, _Traits > & basic_ostream< _CharT, _Traits >::operator <<(short __n)
    {
        const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt == ios_base::oct || __fmt == ios_base::hex)
            return _M_insert(static_cast<long >(static_cast<unsigned short >(__n)));
        else
            return _M_insert(static_cast<long >(__n));
    }
    template<typename _CharT, typename _Traits >
    basic_ostream< _CharT, _Traits > & basic_ostream< _CharT, _Traits >::operator <<(int __n)
    {
        const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt == ios_base::oct || __fmt == ios_base::hex)
            return _M_insert(static_cast<long >(static_cast<unsigned int >(__n)));
        else
            return _M_insert(static_cast<long >(__n));
    }
    template<typename _CharT, typename _Traits >
    basic_ostream< _CharT, _Traits > & basic_ostream< _CharT, _Traits >::operator <<(__streambuf_type * __sbin)
    {
        ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
        sentry __cerb(*this);
        if (__cerb && __sbin)
        {
            try
            {
                if (!__copy_streambufs(__sbin, this->rdbuf()))
                    __err |= ios_base::failbit;
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::failbit);
            }
        }
        else
            if (!__sbin)
                __err |= ios_base::badbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_ostream< _CharT, _Traits > & basic_ostream< _CharT, _Traits >::put(char_type __c)
    {
        sentry __cerb(*this);
        if (__cerb)
        {
            ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
            try
            {
                const int_type __put = this->rdbuf()->sputc(__c);
                if (traits_type::eq_int_type(__put, traits_type::eof()))
                    __err |= ios_base::badbit;
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_ostream< _CharT, _Traits > & basic_ostream< _CharT, _Traits >::write(const _CharT * __s, streamsize __n)
    {
        sentry __cerb(*this);
        if (__cerb)
        {
            try
            {
                _M_write(__s, __n);
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
        }
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_ostream< _CharT, _Traits > & basic_ostream< _CharT, _Traits >::flush()
    {
        ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
        try
        {
            if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
                __err |= ios_base::badbit;
        }
        catch (__cxxabiv1::__forced_unwind &)
        {
            this->_M_setstate(ios_base::badbit);
            throw;
        }
        catch (...)
        {
            this->_M_setstate(ios_base::badbit);
        }
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template<typename _CharT, typename _Traits >
    typename basic_ostream< _CharT, _Traits >::pos_type basic_ostream< _CharT, _Traits >::tellp()
    {
        pos_type __ret = pos_type(-1);
        try
        {
            if (!this->fail())
                __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
        }
        catch (__cxxabiv1::__forced_unwind &)
        {
            this->_M_setstate(ios_base::badbit);
            throw;
        }
        catch (...)
        {
            this->_M_setstate(ios_base::badbit);
        }
        return __ret;
    }
    template<typename _CharT, typename _Traits >
    basic_ostream< _CharT, _Traits > & basic_ostream< _CharT, _Traits >::seekp(pos_type __pos)
    {
        ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
        try
        {
            if (!this->fail())
            {
                const pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::out);
                if (__p == pos_type(off_type(-1)))
                    __err |= ios_base::failbit;
            }
        }
        catch (__cxxabiv1::__forced_unwind &)
        {
            this->_M_setstate(ios_base::badbit);
            throw;
        }
        catch (...)
        {
            this->_M_setstate(ios_base::badbit);
        }
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_ostream< _CharT, _Traits > & basic_ostream< _CharT, _Traits >::seekp(off_type __off, ios_base::seekdir __dir)
    {
        ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
        try
        {
            if (!this->fail())
            {
                const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ios_base::out);
                if (__p == pos_type(off_type(-1)))
                    __err |= ios_base::failbit;
            }
        }
        catch (__cxxabiv1::__forced_unwind &)
        {
            this->_M_setstate(ios_base::badbit);
            throw;
        }
        catch (...)
        {
            this->_M_setstate(ios_base::badbit);
        }
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_ostream< _CharT, _Traits > & operator <<(basic_ostream< _CharT, _Traits > & __out, const char * __s)
    {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else
        {
            const size_t __clen = char_traits< char >::length(__s);
            try
            {
                struct __ptr_guard
                {
                        _CharT * __p;
                        __ptr_guard(_CharT * __ip)
                            : __p(__ip) 
                        {
                        }
                        ~__ptr_guard()
                        {
                            delete[] __p;
                        }
                        _CharT * __get()
                        {
                            return __p;
                        }
                } __pg(new _CharT [__clen]);
                _CharT * __ws = __pg.__get();
                for (size_t __i = 0;
                    __i < __clen;
                    ++__i)
                __ws[__i] = __out.widen(__s[__i]);
                __ostream_insert(__out, __ws, __clen);
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                __out._M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                __out._M_setstate(ios_base::badbit);
            }
        }
        return __out;
    }
    extern template class basic_ostream< char > ;
    extern template ostream & endl(ostream &);
    extern template ostream & ends(ostream &);
    extern template ostream & flush(ostream &);
    extern template ostream & operator <<(ostream &, char);
    extern template ostream & operator <<(ostream &, unsigned char);
    extern template ostream & operator <<(ostream &, signed char);
    extern template ostream & operator <<(ostream &, const char *);
    extern template ostream & operator <<(ostream &, const unsigned char *);
    extern template ostream & operator <<(ostream &, const signed char *);
    extern template ostream & ostream::_M_insert(long);
    extern template ostream & ostream::_M_insert(unsigned long);
    extern template ostream & ostream::_M_insert(bool);
    extern template ostream & ostream::_M_insert(long long);
    extern template ostream & ostream::_M_insert(unsigned long long);
    extern template ostream & ostream::_M_insert(double);
    extern template ostream & ostream::_M_insert(long double);
    extern template ostream & ostream::_M_insert(const void *);
    extern template class basic_ostream< wchar_t > ;
    extern template wostream & endl(wostream &);
    extern template wostream & ends(wostream &);
    extern template wostream & flush(wostream &);
    extern template wostream & operator <<(wostream &, wchar_t);
    extern template wostream & operator <<(wostream &, char);
    extern template wostream & operator <<(wostream &, const wchar_t *);
    extern template wostream & operator <<(wostream &, const char *);
    extern template wostream & wostream::_M_insert(long);
    extern template wostream & wostream::_M_insert(unsigned long);
    extern template wostream & wostream::_M_insert(bool);
    extern template wostream & wostream::_M_insert(long long);
    extern template wostream & wostream::_M_insert(unsigned long long);
    extern template wostream & wostream::_M_insert(double);
    extern template wostream & wostream::_M_insert(long double);
    extern template wostream & wostream::_M_insert(const void *);
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _CharT, typename _Traits >
    class basic_istream : virtual public basic_ios< _CharT, _Traits >
    {
        public :
            typedef _CharT char_type;
            typedef typename _Traits::int_type int_type;
            typedef typename _Traits::pos_type pos_type;
            typedef typename _Traits::off_type off_type;
            typedef _Traits traits_type;
            typedef basic_streambuf< _CharT, _Traits > __streambuf_type;
            typedef basic_ios< _CharT, _Traits > __ios_type;
            typedef basic_istream< _CharT, _Traits > __istream_type;
            typedef num_get< _CharT, istreambuf_iterator< _CharT, _Traits > > __num_get_type;
            typedef ctype< _CharT > __ctype_type;
        protected :
            streamsize _M_gcount;
        public :
            explicit basic_istream(__streambuf_type * __sb)
                : _M_gcount(streamsize(0)) 
            {
                this->init(__sb);
            }
            virtual ~basic_istream()
            {
                _M_gcount = streamsize(0);
            }
            class sentry;
            friend class sentry;
            __istream_type & operator >>(__istream_type & (* __pf)(__istream_type &))
            {
                return __pf(*this);
            }
            __istream_type & operator >>(__ios_type & (* __pf)(__ios_type &))
            {
                __pf(*this);
                return *this;
            }
            __istream_type & operator >>(ios_base & (* __pf)(ios_base &))
            {
                __pf(*this);
                return *this;
            }
            __istream_type & operator >>(bool & __n)
            {
                return _M_extract(__n);
            }
            __istream_type & operator >>(short & __n);
            __istream_type & operator >>(unsigned short & __n)
            {
                return _M_extract(__n);
            }
            __istream_type & operator >>(int & __n);
            __istream_type & operator >>(unsigned int & __n)
            {
                return _M_extract(__n);
            }
            __istream_type & operator >>(long & __n)
            {
                return _M_extract(__n);
            }
            __istream_type & operator >>(unsigned long & __n)
            {
                return _M_extract(__n);
            }
            __istream_type & operator >>(long long & __n)
            {
                return _M_extract(__n);
            }
            __istream_type & operator >>(unsigned long long & __n)
            {
                return _M_extract(__n);
            }
            __istream_type & operator >>(float & __f)
            {
                return _M_extract(__f);
            }
            __istream_type & operator >>(double & __f)
            {
                return _M_extract(__f);
            }
            __istream_type & operator >>(long double & __f)
            {
                return _M_extract(__f);
            }
            __istream_type & operator >>(void * & __p)
            {
                return _M_extract(__p);
            }
            __istream_type & operator >>(__streambuf_type * __sb);
            streamsize gcount() const
            {
                return _M_gcount;
            }
            int_type get();
            __istream_type & get(char_type & __c);
            __istream_type & get(char_type * __s, streamsize __n, char_type __delim);
            __istream_type & get(char_type * __s, streamsize __n)
            {
                return this->get(__s, __n, this->widen('\n'));
            }
            __istream_type & get(__streambuf_type & __sb, char_type __delim);
            __istream_type & get(__streambuf_type & __sb)
            {
                return this->get(__sb, this->widen('\n'));
            }
            __istream_type & getline(char_type * __s, streamsize __n, char_type __delim);
            __istream_type & getline(char_type * __s, streamsize __n)
            {
                return this->getline(__s, __n, this->widen('\n'));
            }
            __istream_type & ignore();
            __istream_type & ignore(streamsize __n);
            __istream_type & ignore(streamsize __n, int_type __delim);
            int_type peek();
            __istream_type & read(char_type * __s, streamsize __n);
            streamsize readsome(char_type * __s, streamsize __n);
            __istream_type & putback(char_type __c);
            __istream_type & unget();
            int sync();
            pos_type tellg();
            __istream_type & seekg(pos_type);
            __istream_type & seekg(off_type, ios_base::seekdir);
        protected :
            basic_istream()
                : _M_gcount(streamsize(0)) 
            {
                this->init(0);
            }
            template<typename _ValueT >
            __istream_type & _M_extract(_ValueT & __v);
    };
    template<>
    basic_istream< char > & basic_istream< char >::getline(char_type * __s, streamsize __n, char_type __delim);
    template<>
    basic_istream< char > & basic_istream< char >::ignore(streamsize __n);
    template<>
    basic_istream< char > & basic_istream< char >::ignore(streamsize __n, int_type __delim);
    template<>
    basic_istream< wchar_t > & basic_istream< wchar_t >::getline(char_type * __s, streamsize __n, char_type __delim);
    template<>
    basic_istream< wchar_t > & basic_istream< wchar_t >::ignore(streamsize __n);
    template<>
    basic_istream< wchar_t > & basic_istream< wchar_t >::ignore(streamsize __n, int_type __delim);
    template<typename _CharT, typename _Traits >
    class basic_istream< _CharT, _Traits >::sentry
    {
        public :
            typedef _Traits traits_type;
            typedef basic_streambuf< _CharT, _Traits > __streambuf_type;
            typedef basic_istream< _CharT, _Traits > __istream_type;
            typedef typename __istream_type::__ctype_type __ctype_type;
            typedef typename _Traits::int_type __int_type;
            explicit sentry(basic_istream< _CharT, _Traits > & __is, bool __noskipws = false);
            operator bool() const
            {
                return _M_ok;
            }
        private :
            bool _M_ok;
    };
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & operator >>(basic_istream< _CharT, _Traits > & __in, _CharT & __c);
    template<class _Traits >
    inline basic_istream< char, _Traits > & operator >>(basic_istream< char, _Traits > & __in, unsigned char & __c)
    {
        return (__in >> reinterpret_cast<char & >(__c));
    }
    template<class _Traits >
    inline basic_istream< char, _Traits > & operator >>(basic_istream< char, _Traits > & __in, signed char & __c)
    {
        return (__in >> reinterpret_cast<char & >(__c));
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & operator >>(basic_istream< _CharT, _Traits > & __in, _CharT * __s);
    template<>
    basic_istream< char > & operator >>(basic_istream< char > & __in, char * __s);
    template<class _Traits >
    inline basic_istream< char, _Traits > & operator >>(basic_istream< char, _Traits > & __in, unsigned char * __s)
    {
        return (__in >> reinterpret_cast<char * >(__s));
    }
    template<class _Traits >
    inline basic_istream< char, _Traits > & operator >>(basic_istream< char, _Traits > & __in, signed char * __s)
    {
        return (__in >> reinterpret_cast<char * >(__s));
    }
    template<typename _CharT, typename _Traits >
    class basic_iostream : public basic_istream< _CharT, _Traits >, public basic_ostream< _CharT, _Traits >
    {
        public :
            typedef _CharT char_type;
            typedef typename _Traits::int_type int_type;
            typedef typename _Traits::pos_type pos_type;
            typedef typename _Traits::off_type off_type;
            typedef _Traits traits_type;
            typedef basic_istream< _CharT, _Traits > __istream_type;
            typedef basic_ostream< _CharT, _Traits > __ostream_type;
            explicit basic_iostream(basic_streambuf< _CharT, _Traits > * __sb)
                : __istream_type(__sb), __ostream_type(__sb) 
            {
            }
            virtual ~basic_iostream()
            {
            }
        protected :
            basic_iostream()
                : __istream_type(), __ostream_type() 
            {
            }
    };
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & ws(basic_istream< _CharT, _Traits > & __is);
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits >::sentry::sentry(basic_istream< _CharT, _Traits > & __in, bool __noskip)
        : _M_ok(false) 
    {
        ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
        if (__in.good())
        {
            if (__in.tie())
                __in.tie()->flush();
            if (!__noskip && bool(__in.flags() & ios_base::skipws))
            {
                const __int_type __eof = traits_type::eof();
                __streambuf_type * __sb = __in.rdbuf();
                __int_type __c = __sb->sgetc();
                const __ctype_type & __ct = __check_facet(__in._M_ctype);
                while (!traits_type::eq_int_type(__c, __eof) && __ct.is(ctype_base::space, traits_type::to_char_type(__c)))
                    __c = __sb->snextc();
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
            }
        }
        if (__in.good() && __err == ios_base::goodbit)
            _M_ok = true;
        else
        {
            __err |= ios_base::failbit;
            __in.setstate(__err);
        }
    }
    template<typename _CharT, typename _Traits >
    template<typename _ValueT >
    basic_istream< _CharT, _Traits > & basic_istream< _CharT, _Traits >::_M_extract(_ValueT & __v)
    {
        sentry __cerb(*this, false);
        if (__cerb)
        {
            ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
            try
            {
                const __num_get_type & __ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __v);
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & basic_istream< _CharT, _Traits >::operator >>(short & __n)
    {
        long __l;
        _M_extract(__l);
        if (!this->fail())
        {
            if (__gnu_cxx::__numeric_traits< short >::__min <= __l && __l <= __gnu_cxx::__numeric_traits< short >::__max)
                __n = short(__l);
            else
                this->setstate(ios_base::failbit);
        }
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & basic_istream< _CharT, _Traits >::operator >>(int & __n)
    {
        long __l;
        _M_extract(__l);
        if (!this->fail())
        {
            if (__gnu_cxx::__numeric_traits< int >::__min <= __l && __l <= __gnu_cxx::__numeric_traits< int >::__max)
                __n = int(__l);
            else
                this->setstate(ios_base::failbit);
        }
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & basic_istream< _CharT, _Traits >::operator >>(__streambuf_type * __sbout)
    {
        ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
        sentry __cerb(*this, false);
        if (__cerb && __sbout)
        {
            try
            {
                bool __ineof;
                if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
                    __err |= ios_base::failbit;
                if (__ineof)
                    __err |= ios_base::eofbit;
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::failbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::failbit);
            }
        }
        else
            if (!__sbout)
                __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template<typename _CharT, typename _Traits >
    typename basic_istream< _CharT, _Traits >::int_type basic_istream< _CharT, _Traits >::get(void)
    {
        const int_type __eof = traits_type::eof();
        int_type __c = __eof;
        _M_gcount = 0;
        ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
        sentry __cerb(*this, true);
        if (__cerb)
        {
            try
            {
                __c = this->rdbuf()->sbumpc();
                if (!traits_type::eq_int_type(__c, __eof))
                    _M_gcount = 1;
                else
                    __err |= ios_base::eofbit;
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return __c;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & basic_istream< _CharT, _Traits >::get(char_type & __c)
    {
        _M_gcount = 0;
        ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
        sentry __cerb(*this, true);
        if (__cerb)
        {
            try
            {
                const int_type __cb = this->rdbuf()->sbumpc();
                if (!traits_type::eq_int_type(__cb, traits_type::eof()))
                {
                    _M_gcount = 1;
                    __c = traits_type::to_char_type(__cb);
                }
                else
                    __err |= ios_base::eofbit;
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & basic_istream< _CharT, _Traits >::get(char_type * __s, streamsize __n, char_type __delim)
    {
        _M_gcount = 0;
        ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
        sentry __cerb(*this, true);
        if (__cerb)
        {
            try
            {
                const int_type __idelim = traits_type::to_int_type(__delim);
                const int_type __eof = traits_type::eof();
                __streambuf_type * __sb = this->rdbuf();
                int_type __c = __sb->sgetc();
                while (_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim))
                {
                    *__s++ = traits_type::to_char_type(__c);
                    ++_M_gcount;
                    __c = __sb->snextc();
                }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (__n > 0)
            *__s = char_type();
        if (!_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & basic_istream< _CharT, _Traits >::get(__streambuf_type & __sb, char_type __delim)
    {
        _M_gcount = 0;
        ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
        sentry __cerb(*this, true);
        if (__cerb)
        {
            try
            {
                const int_type __idelim = traits_type::to_int_type(__delim);
                const int_type __eof = traits_type::eof();
                __streambuf_type * __this_sb = this->rdbuf();
                int_type __c = __this_sb->sgetc();
                char_type __c2 = traits_type::to_char_type(__c);
                while (!traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim) && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
                {
                    ++_M_gcount;
                    __c = __this_sb->snextc();
                    __c2 = traits_type::to_char_type(__c);
                }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & basic_istream< _CharT, _Traits >::getline(char_type * __s, streamsize __n, char_type __delim)
    {
        _M_gcount = 0;
        ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
        sentry __cerb(*this, true);
        if (__cerb)
        {
            try
            {
                const int_type __idelim = traits_type::to_int_type(__delim);
                const int_type __eof = traits_type::eof();
                __streambuf_type * __sb = this->rdbuf();
                int_type __c = __sb->sgetc();
                while (_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim))
                {
                    *__s++ = traits_type::to_char_type(__c);
                    __c = __sb->snextc();
                    ++_M_gcount;
                }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                else
                {
                    if (traits_type::eq_int_type(__c, __idelim))
                    {
                        __sb->sbumpc();
                        ++_M_gcount;
                    }
                    else
                        __err |= ios_base::failbit;
                }
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (__n > 0)
            *__s = char_type();
        if (!_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & basic_istream< _CharT, _Traits >::ignore(void)
    {
        _M_gcount = 0;
        sentry __cerb(*this, true);
        if (__cerb)
        {
            ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
            try
            {
                const int_type __eof = traits_type::eof();
                __streambuf_type * __sb = this->rdbuf();
                if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
                    __err |= ios_base::eofbit;
                else
                    _M_gcount = 1;
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & basic_istream< _CharT, _Traits >::ignore(streamsize __n)
    {
        _M_gcount = 0;
        sentry __cerb(*this, true);
        if (__cerb && __n > 0)
        {
            ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
            try
            {
                const int_type __eof = traits_type::eof();
                __streambuf_type * __sb = this->rdbuf();
                int_type __c = __sb->sgetc();
                bool __large_ignore = false;
                while (true)
                {
                    while (_M_gcount < __n && !traits_type::eq_int_type(__c, __eof))
                    {
                        ++_M_gcount;
                        __c = __sb->snextc();
                    }
                    if (__n == __gnu_cxx::__numeric_traits< streamsize >::__max && !traits_type::eq_int_type(__c, __eof))
                    {
                        _M_gcount = __gnu_cxx::__numeric_traits< streamsize >::__min;
                        __large_ignore = true;
                    }
                    else
                        break;
                }
                if (__large_ignore)
                    _M_gcount = __gnu_cxx::__numeric_traits< streamsize >::__max;
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & basic_istream< _CharT, _Traits >::ignore(streamsize __n, int_type __delim)
    {
        _M_gcount = 0;
        sentry __cerb(*this, true);
        if (__cerb && __n > 0)
        {
            ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
            try
            {
                const int_type __eof = traits_type::eof();
                __streambuf_type * __sb = this->rdbuf();
                int_type __c = __sb->sgetc();
                bool __large_ignore = false;
                while (true)
                {
                    while (_M_gcount < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __delim))
                    {
                        ++_M_gcount;
                        __c = __sb->snextc();
                    }
                    if (__n == __gnu_cxx::__numeric_traits< streamsize >::__max && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __delim))
                    {
                        _M_gcount = __gnu_cxx::__numeric_traits< streamsize >::__min;
                        __large_ignore = true;
                    }
                    else
                        break;
                }
                if (__large_ignore)
                    _M_gcount = __gnu_cxx::__numeric_traits< streamsize >::__max;
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                else
                    if (traits_type::eq_int_type(__c, __delim))
                    {
                        if (_M_gcount < __gnu_cxx::__numeric_traits< streamsize >::__max)
                            ++_M_gcount;
                        __sb->sbumpc();
                    }
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template<typename _CharT, typename _Traits >
    typename basic_istream< _CharT, _Traits >::int_type basic_istream< _CharT, _Traits >::peek(void)
    {
        int_type __c = traits_type::eof();
        _M_gcount = 0;
        sentry __cerb(*this, true);
        if (__cerb)
        {
            ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
            try
            {
                __c = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__c, traits_type::eof()))
                    __err |= ios_base::eofbit;
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return __c;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & basic_istream< _CharT, _Traits >::read(char_type * __s, streamsize __n)
    {
        _M_gcount = 0;
        sentry __cerb(*this, true);
        if (__cerb)
        {
            ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
            try
            {
                _M_gcount = this->rdbuf()->sgetn(__s, __n);
                if (_M_gcount != __n)
                    __err |= (ios_base::eofbit | ios_base::failbit);
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template<typename _CharT, typename _Traits >
    streamsize basic_istream< _CharT, _Traits >::readsome(char_type * __s, streamsize __n)
    {
        _M_gcount = 0;
        sentry __cerb(*this, true);
        if (__cerb)
        {
            ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
            try
            {
                const streamsize __num = this->rdbuf()->in_avail();
                if (__num > 0)
                    _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
                else
                    if (__num == -1)
                        __err |= ios_base::eofbit;
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return _M_gcount;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & basic_istream< _CharT, _Traits >::putback(char_type __c)
    {
        _M_gcount = 0;
        sentry __cerb(*this, true);
        if (__cerb)
        {
            ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
            try
            {
                const int_type __eof = traits_type::eof();
                __streambuf_type * __sb = this->rdbuf();
                if (!__sb || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
                    __err |= ios_base::badbit;
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & basic_istream< _CharT, _Traits >::unget(void)
    {
        _M_gcount = 0;
        sentry __cerb(*this, true);
        if (__cerb)
        {
            ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
            try
            {
                const int_type __eof = traits_type::eof();
                __streambuf_type * __sb = this->rdbuf();
                if (!__sb || traits_type::eq_int_type(__sb->sungetc(), __eof))
                    __err |= ios_base::badbit;
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template<typename _CharT, typename _Traits >
    int basic_istream< _CharT, _Traits >::sync(void)
    {
        int __ret = -1;
        sentry __cerb(*this, true);
        if (__cerb)
        {
            ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
            try
            {
                __streambuf_type * __sb = this->rdbuf();
                if (__sb)
                {
                    if (__sb->pubsync() == -1)
                        __err |= ios_base::badbit;
                    else
                        __ret = 0;
                }
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                this->_M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return __ret;
    }
    template<typename _CharT, typename _Traits >
    typename basic_istream< _CharT, _Traits >::pos_type basic_istream< _CharT, _Traits >::tellg(void)
    {
        pos_type __ret = pos_type(-1);
        try
        {
            if (!this->fail())
                __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
        }
        catch (__cxxabiv1::__forced_unwind &)
        {
            this->_M_setstate(ios_base::badbit);
            throw;
        }
        catch (...)
        {
            this->_M_setstate(ios_base::badbit);
        }
        return __ret;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & basic_istream< _CharT, _Traits >::seekg(pos_type __pos)
    {
        ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
        try
        {
            if (!this->fail())
            {
                const pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::in);
                if (__p == pos_type(off_type(-1)))
                    __err |= ios_base::failbit;
            }
        }
        catch (__cxxabiv1::__forced_unwind &)
        {
            this->_M_setstate(ios_base::badbit);
            throw;
        }
        catch (...)
        {
            this->_M_setstate(ios_base::badbit);
        }
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & basic_istream< _CharT, _Traits >::seekg(off_type __off, ios_base::seekdir __dir)
    {
        ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
        try
        {
            if (!this->fail())
            {
                const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ios_base::in);
                if (__p == pos_type(off_type(-1)))
                    __err |= ios_base::failbit;
            }
        }
        catch (__cxxabiv1::__forced_unwind &)
        {
            this->_M_setstate(ios_base::badbit);
            throw;
        }
        catch (...)
        {
            this->_M_setstate(ios_base::badbit);
        }
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & operator >>(basic_istream< _CharT, _Traits > & __in, _CharT & __c)
    {
        typedef basic_istream< _CharT, _Traits > __istream_type;
        typedef typename __istream_type::int_type __int_type;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb)
        {
            ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
            try
            {
                const __int_type __cb = __in.rdbuf()->sbumpc();
                if (!_Traits::eq_int_type(__cb, _Traits::eof()))
                    __c = _Traits::to_char_type(__cb);
                else
                    __err |= (ios_base::eofbit | ios_base::failbit);
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                __in._M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                __in._M_setstate(ios_base::badbit);
            }
            if (__err)
                __in.setstate(__err);
        }
        return __in;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & operator >>(basic_istream< _CharT, _Traits > & __in, _CharT * __s)
    {
        typedef basic_istream< _CharT, _Traits > __istream_type;
        typedef basic_streambuf< _CharT, _Traits > __streambuf_type;
        typedef typename _Traits::int_type int_type;
        typedef _CharT char_type;
        typedef ctype< _CharT > __ctype_type;
        streamsize __extracted = 0;
        ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb)
        {
            try
            {
                streamsize __num = __in.width();
                if (__num <= 0)
                    __num = __gnu_cxx::__numeric_traits< streamsize >::__max;
                const __ctype_type & __ct = use_facet< __ctype_type >(__in.getloc());
                const int_type __eof = _Traits::eof();
                __streambuf_type * __sb = __in.rdbuf();
                int_type __c = __sb->sgetc();
                while (__extracted < __num - 1 && !_Traits::eq_int_type(__c, __eof) && !__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
                {
                    *__s++ = _Traits::to_char_type(__c);
                    ++__extracted;
                    __c = __sb->snextc();
                }
                if (_Traits::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                *__s = char_type();
                __in.width(0);
            }
            catch (__cxxabiv1::__forced_unwind &)
            {
                __in._M_setstate(ios_base::badbit);
                throw;
            }
            catch (...)
            {
                __in._M_setstate(ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }
    template<typename _CharT, typename _Traits >
    basic_istream< _CharT, _Traits > & ws(basic_istream< _CharT, _Traits > & __in)
    {
        typedef basic_istream< _CharT, _Traits > __istream_type;
        typedef basic_streambuf< _CharT, _Traits > __streambuf_type;
        typedef typename __istream_type::int_type __int_type;
        typedef ctype< _CharT > __ctype_type;
        const __ctype_type & __ct = use_facet< __ctype_type >(__in.getloc());
        const __int_type __eof = _Traits::eof();
        __streambuf_type * __sb = __in.rdbuf();
        __int_type __c = __sb->sgetc();
        while (!_Traits::eq_int_type(__c, __eof) && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
            __c = __sb->snextc();
        if (_Traits::eq_int_type(__c, __eof))
            __in.setstate(ios_base::eofbit);
        return __in;
    }
    extern template class basic_istream< char > ;
    extern template istream & ws(istream &);
    extern template istream & operator >>(istream &, char &);
    extern template istream & operator >>(istream &, char *);
    extern template istream & operator >>(istream &, unsigned char &);
    extern template istream & operator >>(istream &, signed char &);
    extern template istream & operator >>(istream &, unsigned char *);
    extern template istream & operator >>(istream &, signed char *);
    extern template istream & istream::_M_extract(unsigned short &);
    extern template istream & istream::_M_extract(unsigned int &);
    extern template istream & istream::_M_extract(long &);
    extern template istream & istream::_M_extract(unsigned long &);
    extern template istream & istream::_M_extract(bool &);
    extern template istream & istream::_M_extract(long long &);
    extern template istream & istream::_M_extract(unsigned long long &);
    extern template istream & istream::_M_extract(float &);
    extern template istream & istream::_M_extract(double &);
    extern template istream & istream::_M_extract(long double &);
    extern template istream & istream::_M_extract(void *&);
    extern template class basic_iostream< char > ;
    extern template class basic_istream< wchar_t > ;
    extern template wistream & ws(wistream &);
    extern template wistream & operator >>(wistream &, wchar_t &);
    extern template wistream & operator >>(wistream &, wchar_t *);
    extern template wistream & wistream::_M_extract(unsigned short &);
    extern template wistream & wistream::_M_extract(unsigned int &);
    extern template wistream & wistream::_M_extract(long &);
    extern template wistream & wistream::_M_extract(unsigned long &);
    extern template wistream & wistream::_M_extract(bool &);
    extern template wistream & wistream::_M_extract(long long &);
    extern template wistream & wistream::_M_extract(unsigned long long &);
    extern template wistream & wistream::_M_extract(float &);
    extern template wistream & wistream::_M_extract(double &);
    extern template wistream & wistream::_M_extract(long double &);
    extern template wistream & wistream::_M_extract(void *&);
    extern template class basic_iostream< wchar_t > ;
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Tp, typename _CharT = char, typename _Traits = char_traits< _CharT >, typename _Dist = ptrdiff_t >
    class istream_iterator : public iterator< input_iterator_tag, _Tp, _Dist, const _Tp *, const _Tp & >
    {
        public :
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef basic_istream< _CharT, _Traits > istream_type;
        private :
            istream_type * _M_stream;
            _Tp _M_value;
            bool _M_ok;
        public :
            istream_iterator()
                : _M_stream(0), _M_value(), _M_ok(false) 
            {
            }
            istream_iterator(istream_type & __s)
                : _M_stream(&__s) 
            {
                _M_read();
            }
            istream_iterator(const istream_iterator & __obj)
                : _M_stream(__obj._M_stream), _M_value(__obj._M_value), _M_ok(__obj._M_ok) 
            {
            }
            const _Tp & operator *() const
            {
                ;
                return _M_value;
            }
            const _Tp * operator ->() const
            {
                return &(operator *());
            }
            istream_iterator & operator ++()
            {
                ;
                _M_read();
                return *this;
            }
            istream_iterator operator ++(int)
            {
                ;
                istream_iterator __tmp = *this;
                _M_read();
                return __tmp;
            }
            bool _M_equal(const istream_iterator & __x) const
            {
                return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream);
            }
        private :
            void _M_read()
            {
                _M_ok = (_M_stream && *_M_stream) ? true : false;
                if (_M_ok)
                {
                    *_M_stream >> _M_value;
                    _M_ok = *_M_stream ? true : false;
                }
            }
    };
    template<typename _Tp, typename _CharT, typename _Traits, typename _Dist >
    inline bool operator ==(const istream_iterator< _Tp, _CharT, _Traits, _Dist > & __x, const istream_iterator< _Tp, _CharT, _Traits, _Dist > & __y)
    {
        return __x._M_equal(__y);
    }
    template<class _Tp, class _CharT, class _Traits, class _Dist >
    inline bool operator !=(const istream_iterator< _Tp, _CharT, _Traits, _Dist > & __x, const istream_iterator< _Tp, _CharT, _Traits, _Dist > & __y)
    {
        return !__x._M_equal(__y);
    }
    template<typename _Tp, typename _CharT = char, typename _Traits = char_traits< _CharT > >
    class ostream_iterator : public iterator< output_iterator_tag, void, void, void, void >
    {
        public :
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef basic_ostream< _CharT, _Traits > ostream_type;
        private :
            ostream_type * _M_stream;
            const _CharT * _M_string;
        public :
            ostream_iterator(ostream_type & __s)
                : _M_stream(&__s), _M_string(0) 
            {
            }
            ostream_iterator(ostream_type & __s, const _CharT * __c)
                : _M_stream(&__s), _M_string(__c) 
            {
            }
            ostream_iterator(const ostream_iterator & __obj)
                : _M_stream(__obj._M_stream), _M_string(__obj._M_string) 
            {
            }
            ostream_iterator & operator =(const _Tp & __value)
            {
                ;
                *_M_stream << __value;
                if (_M_string)
                    *_M_stream << _M_string;
                return *this;
            }
            ostream_iterator & operator *()
            {
                return *this;
            }
            ostream_iterator & operator ++()
            {
                return *this;
            }
            ostream_iterator & operator ++(int)
            {
                return *this;
            }
    };
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Tp, typename _Alloc >
    struct _Vector_base
    {
            typedef typename _Alloc::template rebind< _Tp >::other _Tp_alloc_type;
            struct _Vector_impl : public _Tp_alloc_type
            {
                    _Tp * _M_start;
                    _Tp * _M_finish;
                    _Tp * _M_end_of_storage;
                    _Vector_impl()
                        : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0) 
                    {
                    }
                    _Vector_impl(_Tp_alloc_type const & __a)
                        : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0) 
                    {
                    }
            };
        public :
            typedef _Alloc allocator_type;
            _Tp_alloc_type & _M_get_Tp_allocator()
            {
                return *static_cast<_Tp_alloc_type * >(&this->_M_impl);
            }
            const _Tp_alloc_type & _M_get_Tp_allocator() const
            {
                return *static_cast<const _Tp_alloc_type * >(&this->_M_impl);
            }
            allocator_type get_allocator() const
            {
                return allocator_type(_M_get_Tp_allocator());
            }
            _Vector_base()
                : _M_impl() 
            {
            }
            _Vector_base(const allocator_type & __a)
                : _M_impl(__a) 
            {
            }
            _Vector_base(size_t __n, const allocator_type & __a)
                : _M_impl(__a) 
            {
                this->_M_impl._M_start = this->_M_allocate(__n);
                this->_M_impl._M_finish = this->_M_impl._M_start;
                this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
            }
            ~_Vector_base()
            {
                _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            }
        public :
            _Vector_impl _M_impl;
            _Tp * _M_allocate(size_t __n)
            {
                return __n != 0 ? _M_impl.allocate(__n) : 0;
            }
            void _M_deallocate(_Tp * __p, size_t __n)
            {
                if (__p)
                    _M_impl.deallocate(__p, __n);
            }
    };
    template<typename _Tp, typename _Alloc = std::allocator< _Tp > >
    class vector : protected _Vector_base< _Tp, _Alloc >
    {
            typedef typename _Alloc::value_type _Alloc_value_type;
            typedef _Vector_base< _Tp, _Alloc > _Base;
            typedef vector< _Tp, _Alloc > vector_type;
            typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
        public :
            typedef _Tp value_type;
            typedef typename _Tp_alloc_type::pointer pointer;
            typedef typename _Tp_alloc_type::const_pointer const_pointer;
            typedef typename _Tp_alloc_type::reference reference;
            typedef typename _Tp_alloc_type::const_reference const_reference;
            typedef __gnu_cxx::__normal_iterator< pointer, vector_type > iterator;
            typedef __gnu_cxx::__normal_iterator< const_pointer, vector_type > const_iterator;
            typedef std::reverse_iterator< const_iterator > const_reverse_iterator;
            typedef std::reverse_iterator< iterator > reverse_iterator;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef _Alloc allocator_type;
        protected :
            using _Base::_M_allocate;
            using _Base::_M_deallocate;
            using _Base::_M_impl;
            using _Base::_M_get_Tp_allocator;
        public :
            vector()
                : _Base() 
            {
            }
            explicit vector(const allocator_type & __a)
                : _Base(__a) 
            {
            }
            explicit vector(size_type __n, const value_type & __value = value_type(), const allocator_type & __a = allocator_type())
                : _Base(__n, __a) 
            {
                _M_fill_initialize(__n, __value);
            }
            vector(const vector & __x)
                : _Base(__x.size(), __x._M_get_Tp_allocator()) 
            {
                this->_M_impl._M_finish = std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
            }
            template<typename _InputIterator >
            vector(_InputIterator __first, _InputIterator __last, const allocator_type & __a = allocator_type())
                : _Base(__a) 
            {
                typedef typename std::__is_integer< _InputIterator >::__type _Integral;
                _M_initialize_dispatch(__first, __last, _Integral());
            }
            ~vector()
            {
                std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
            }
            vector & operator =(const vector & __x);
            void assign(size_type __n, const value_type & __val)
            {
                _M_fill_assign(__n, __val);
            }
            template<typename _InputIterator >
            void assign(_InputIterator __first, _InputIterator __last)
            {
                typedef typename std::__is_integer< _InputIterator >::__type _Integral;
                _M_assign_dispatch(__first, __last, _Integral());
            }
            using _Base::get_allocator;
            iterator begin()
            {
                return iterator(this->_M_impl._M_start);
            }
            const_iterator begin() const
            {
                return const_iterator(this->_M_impl._M_start);
            }
            iterator end()
            {
                return iterator(this->_M_impl._M_finish);
            }
            const_iterator end() const
            {
                return const_iterator(this->_M_impl._M_finish);
            }
            reverse_iterator rbegin()
            {
                return reverse_iterator(end());
            }
            const_reverse_iterator rbegin() const
            {
                return const_reverse_iterator(end());
            }
            reverse_iterator rend()
            {
                return reverse_iterator(begin());
            }
            const_reverse_iterator rend() const
            {
                return const_reverse_iterator(begin());
            }
            size_type size() const
            {
                return size_type(this->_M_impl._M_finish - this->_M_impl._M_start);
            }
            size_type max_size() const
            {
                return _M_get_Tp_allocator().max_size();
            }
            void resize(size_type __new_size, value_type __x = value_type())
            {
                if (__new_size < size())
                    _M_erase_at_end(this->_M_impl._M_start + __new_size);
                else
                    insert(end(), __new_size - size(), __x);
            }
            size_type capacity() const
            {
                return size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            }
            bool empty() const
            {
                return begin() == end();
            }
            void reserve(size_type __n);
            reference operator [](size_type __n)
            {
                return *(this->_M_impl._M_start + __n);
            }
            const_reference operator [](size_type __n) const
            {
                return *(this->_M_impl._M_start + __n);
            }
        protected :
            void _M_range_check(size_type __n) const
            {
                if (__n >= this->size())
                    __throw_out_of_range(("vector::_M_range_check"));
            }
        public :
            reference at(size_type __n)
            {
                _M_range_check(__n);
                return (*this)[__n];
            }
            const_reference at(size_type __n) const
            {
                _M_range_check(__n);
                return (*this)[__n];
            }
            reference front()
            {
                return *begin();
            }
            const_reference front() const
            {
                return *begin();
            }
            reference back()
            {
                return *(end() - 1);
            }
            const_reference back() const
            {
                return *(end() - 1);
            }
            pointer data()
            {
                return pointer(this->_M_impl._M_start);
            }
            const_pointer data() const
            {
                return const_pointer(this->_M_impl._M_start);
            }
            void push_back(const value_type & __x)
            {
                if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                {
                    this->_M_impl.construct(this->_M_impl._M_finish, __x);
                    ++this->_M_impl._M_finish;
                }
                else
                    _M_insert_aux(end(), __x);
            }
            void pop_back()
            {
                --this->_M_impl._M_finish;
                this->_M_impl.destroy(this->_M_impl._M_finish);
            }
            iterator insert(iterator __position, const value_type & __x);
            void insert(iterator __position, size_type __n, const value_type & __x)
            {
                _M_fill_insert(__position, __n, __x);
            }
            template<typename _InputIterator >
            void insert(iterator __position, _InputIterator __first, _InputIterator __last)
            {
                typedef typename std::__is_integer< _InputIterator >::__type _Integral;
                _M_insert_dispatch(__position, __first, __last, _Integral());
            }
            iterator erase(iterator __position);
            iterator erase(iterator __first, iterator __last);
            void swap(vector & __x)
            {
                std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
                std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
                std::swap(this->_M_impl._M_end_of_storage, __x._M_impl._M_end_of_storage);
                std::__alloc_swap< _Tp_alloc_type >::_S_do_it(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
            }
            void clear()
            {
                _M_erase_at_end(this->_M_impl._M_start);
            }
        protected :
            template<typename _ForwardIterator >
            pointer _M_allocate_and_copy(size_type __n, _ForwardIterator __first, _ForwardIterator __last)
            {
                pointer __result = this->_M_allocate(__n);
                try
                {
                    std::__uninitialized_copy_a(__first, __last, __result, _M_get_Tp_allocator());
                    return __result;
                }
                catch (...)
                {
                    _M_deallocate(__result, __n);
                    throw;
                }
            }
            template<typename _Integer >
            void _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
            {
                this->_M_impl._M_start = _M_allocate(static_cast<size_type >(__n));
                this->_M_impl._M_end_of_storage = this->_M_impl._M_start + static_cast<size_type >(__n);
                _M_fill_initialize(static_cast<size_type >(__n), __value);
            }
            template<typename _InputIterator >
            void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last, __false_type)
            {
                typedef typename std::iterator_traits< _InputIterator >::iterator_category _IterCategory;
                _M_range_initialize(__first, __last, _IterCategory());
            }
            template<typename _InputIterator >
            void _M_range_initialize(_InputIterator __first, _InputIterator __last, std::input_iterator_tag)
            {
                for (;
                    __first != __last;
                    ++__first)
                push_back(*__first);
            }
            template<typename _ForwardIterator >
            void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag)
            {
                const size_type __n = std::distance(__first, __last);
                this->_M_impl._M_start = this->_M_allocate(__n);
                this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                this->_M_impl._M_finish = std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
            }
            void _M_fill_initialize(size_type __n, const value_type & __value)
            {
                std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
                this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
            }
            template<typename _Integer >
            void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
            {
                _M_fill_assign(__n, __val);
            }
            template<typename _InputIterator >
            void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, __false_type)
            {
                typedef typename std::iterator_traits< _InputIterator >::iterator_category _IterCategory;
                _M_assign_aux(__first, __last, _IterCategory());
            }
            template<typename _InputIterator >
            void _M_assign_aux(_InputIterator __first, _InputIterator __last, std::input_iterator_tag);
            template<typename _ForwardIterator >
            void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag);
            void _M_fill_assign(size_type __n, const value_type & __val);
            template<typename _Integer >
            void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val, __true_type)
            {
                _M_fill_insert(__pos, __n, __val);
            }
            template<typename _InputIterator >
            void _M_insert_dispatch(iterator __pos, _InputIterator __first, _InputIterator __last, __false_type)
            {
                typedef typename std::iterator_traits< _InputIterator >::iterator_category _IterCategory;
                _M_range_insert(__pos, __first, __last, _IterCategory());
            }
            template<typename _InputIterator >
            void _M_range_insert(iterator __pos, _InputIterator __first, _InputIterator __last, std::input_iterator_tag);
            template<typename _ForwardIterator >
            void _M_range_insert(iterator __pos, _ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag);
            void _M_fill_insert(iterator __pos, size_type __n, const value_type & __x);
            void _M_insert_aux(iterator __position, const value_type & __x);
            size_type _M_check_len(size_type __n, const char * __s) const
            {
                if (max_size() - size() < __n)
                    __throw_length_error((__s));
                const size_type __len = size() + std::max(size(), __n);
                return (__len < size() || __len > max_size()) ? max_size() : __len;
            }
            void _M_erase_at_end(pointer __pos)
            {
                std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
                this->_M_impl._M_finish = __pos;
            }
    };
    template<typename _Tp, typename _Alloc >
    inline bool operator ==(const vector< _Tp, _Alloc > & __x, const vector< _Tp, _Alloc > & __y)
    {
        return (__x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin()));
    }
    template<typename _Tp, typename _Alloc >
    inline bool operator <(const vector< _Tp, _Alloc > & __x, const vector< _Tp, _Alloc > & __y)
    {
        return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
    }
    template<typename _Tp, typename _Alloc >
    inline bool operator !=(const vector< _Tp, _Alloc > & __x, const vector< _Tp, _Alloc > & __y)
    {
        return !(__x == __y);
    }
    template<typename _Tp, typename _Alloc >
    inline bool operator >(const vector< _Tp, _Alloc > & __x, const vector< _Tp, _Alloc > & __y)
    {
        return __y < __x;
    }
    template<typename _Tp, typename _Alloc >
    inline bool operator <=(const vector< _Tp, _Alloc > & __x, const vector< _Tp, _Alloc > & __y)
    {
        return !(__y < __x);
    }
    template<typename _Tp, typename _Alloc >
    inline bool operator >=(const vector< _Tp, _Alloc > & __x, const vector< _Tp, _Alloc > & __y)
    {
        return !(__x < __y);
    }
    template<typename _Tp, typename _Alloc >
    inline void swap(vector< _Tp, _Alloc > & __x, vector< _Tp, _Alloc > & __y)
    {
        __x.swap(__y);
    }
}
namespace std __attribute__((__visibility__("default"))) {
    typedef unsigned long _Bit_type;
    enum 
    {
        _S_word_bit = int(8 * sizeof(_Bit_type))
    };
    struct _Bit_reference
    {
            _Bit_type * _M_p;
            _Bit_type _M_mask;
            _Bit_reference(_Bit_type * __x, _Bit_type __y)
                : _M_p(__x), _M_mask(__y) 
            {
            }
            _Bit_reference()
                : _M_p(0), _M_mask(0) 
            {
            }
            operator bool() const
            {
                return !!(*_M_p & _M_mask);
            }
            _Bit_reference & operator =(bool __x)
            {
                if (__x)
                    *_M_p |= _M_mask;
                else
                    *_M_p &= ~_M_mask;
                return *this;
            }
            _Bit_reference & operator =(const _Bit_reference & __x)
            {
                return *this = bool(__x);
            }
            bool operator ==(const _Bit_reference & __x) const
            {
                return bool(*this) == bool(__x);
            }
            bool operator <(const _Bit_reference & __x) const
            {
                return !bool(*this) && bool(__x);
            }
            void flip()
            {
                *_M_p ^= _M_mask;
            }
    };
    struct _Bit_iterator_base : public std::iterator< std::random_access_iterator_tag, bool >
    {
            _Bit_type * _M_p;
            unsigned int _M_offset;
            _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
                : _M_p(__x), _M_offset(__y) 
            {
            }
            void _M_bump_up()
            {
                if (_M_offset++ == int(_S_word_bit) - 1)
                {
                    _M_offset = 0;
                    ++_M_p;
                }
            }
            void _M_bump_down()
            {
                if (_M_offset-- == 0)
                {
                    _M_offset = int(_S_word_bit) - 1;
                    --_M_p;
                }
            }
            void _M_incr(ptrdiff_t __i)
            {
                difference_type __n = __i + _M_offset;
                _M_p += __n / int(_S_word_bit);
                __n = __n % int(_S_word_bit);
                if (__n < 0)
                {
                    __n += int(_S_word_bit);
                    --_M_p;
                }
                _M_offset = static_cast<unsigned int >(__n);
            }
            bool operator ==(const _Bit_iterator_base & __i) const
            {
                return _M_p == __i._M_p && _M_offset == __i._M_offset;
            }
            bool operator <(const _Bit_iterator_base & __i) const
            {
                return _M_p < __i._M_p || (_M_p == __i._M_p && _M_offset < __i._M_offset);
            }
            bool operator !=(const _Bit_iterator_base & __i) const
            {
                return !(*this == __i);
            }
            bool operator >(const _Bit_iterator_base & __i) const
            {
                return __i < *this;
            }
            bool operator <=(const _Bit_iterator_base & __i) const
            {
                return !(__i < *this);
            }
            bool operator >=(const _Bit_iterator_base & __i) const
            {
                return !(*this < __i);
            }
    };
    inline ptrdiff_t operator -(const _Bit_iterator_base & __x, const _Bit_iterator_base & __y)
    {
        return (int(_S_word_bit) * (__x._M_p - __y._M_p) + __x._M_offset - __y._M_offset);
    }
    struct _Bit_iterator : public _Bit_iterator_base
    {
            typedef _Bit_reference reference;
            typedef _Bit_reference * pointer;
            typedef _Bit_iterator iterator;
            _Bit_iterator()
                : _Bit_iterator_base(0, 0) 
            {
            }
            _Bit_iterator(_Bit_type * __x, unsigned int __y)
                : _Bit_iterator_base(__x, __y) 
            {
            }
            reference operator *() const
            {
                return reference(_M_p, 1UL << _M_offset);
            }
            iterator & operator ++()
            {
                _M_bump_up();
                return *this;
            }
            iterator operator ++(int)
            {
                iterator __tmp = *this;
                _M_bump_up();
                return __tmp;
            }
            iterator & operator --()
            {
                _M_bump_down();
                return *this;
            }
            iterator operator --(int)
            {
                iterator __tmp = *this;
                _M_bump_down();
                return __tmp;
            }
            iterator & operator +=(difference_type __i)
            {
                _M_incr(__i);
                return *this;
            }
            iterator & operator -=(difference_type __i)
            {
                *this += -__i;
                return *this;
            }
            iterator operator +(difference_type __i) const
            {
                iterator __tmp = *this;
                return __tmp += __i;
            }
            iterator operator -(difference_type __i) const
            {
                iterator __tmp = *this;
                return __tmp -= __i;
            }
            reference operator [](difference_type __i) const
            {
                return *(*this + __i);
            }
    };
    inline _Bit_iterator operator +(ptrdiff_t __n, const _Bit_iterator & __x)
    {
        return __x + __n;
    }
    struct _Bit_const_iterator : public _Bit_iterator_base
    {
            typedef bool reference;
            typedef bool const_reference;
            typedef const bool * pointer;
            typedef _Bit_const_iterator const_iterator;
            _Bit_const_iterator()
                : _Bit_iterator_base(0, 0) 
            {
            }
            _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
                : _Bit_iterator_base(__x, __y) 
            {
            }
            _Bit_const_iterator(const _Bit_iterator & __x)
                : _Bit_iterator_base(__x._M_p, __x._M_offset) 
            {
            }
            const_reference operator *() const
            {
                return _Bit_reference(_M_p, 1UL << _M_offset);
            }
            const_iterator & operator ++()
            {
                _M_bump_up();
                return *this;
            }
            const_iterator operator ++(int)
            {
                const_iterator __tmp = *this;
                _M_bump_up();
                return __tmp;
            }
            const_iterator & operator --()
            {
                _M_bump_down();
                return *this;
            }
            const_iterator operator --(int)
            {
                const_iterator __tmp = *this;
                _M_bump_down();
                return __tmp;
            }
            const_iterator & operator +=(difference_type __i)
            {
                _M_incr(__i);
                return *this;
            }
            const_iterator & operator -=(difference_type __i)
            {
                *this += -__i;
                return *this;
            }
            const_iterator operator +(difference_type __i) const
            {
                const_iterator __tmp = *this;
                return __tmp += __i;
            }
            const_iterator operator -(difference_type __i) const
            {
                const_iterator __tmp = *this;
                return __tmp -= __i;
            }
            const_reference operator [](difference_type __i) const
            {
                return *(*this + __i);
            }
    };
    inline _Bit_const_iterator operator +(ptrdiff_t __n, const _Bit_const_iterator & __x)
    {
        return __x + __n;
    }
    inline void __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
    {
        for (;
            __first != __last;
            ++__first)
        *__first = __x;
    }
    inline void fill(_Bit_iterator __first, _Bit_iterator __last, const bool & __x)
    {
        if (__first._M_p != __last._M_p)
        {
            std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
            __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
            __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
        }
        else
            __fill_bvector(__first, __last, __x);
    }
    template<typename _Alloc >
    struct _Bvector_base
    {
            typedef typename _Alloc::template rebind< _Bit_type >::other _Bit_alloc_type;
            struct _Bvector_impl : public _Bit_alloc_type
            {
                    _Bit_iterator _M_start;
                    _Bit_iterator _M_finish;
                    _Bit_type * _M_end_of_storage;
                    _Bvector_impl()
                        : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0) 
                    {
                    }
                    _Bvector_impl(const _Bit_alloc_type & __a)
                        : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0) 
                    {
                    }
            };
        public :
            typedef _Alloc allocator_type;
            _Bit_alloc_type & _M_get_Bit_allocator()
            {
                return *static_cast<_Bit_alloc_type * >(&this->_M_impl);
            }
            const _Bit_alloc_type & _M_get_Bit_allocator() const
            {
                return *static_cast<const _Bit_alloc_type * >(&this->_M_impl);
            }
            allocator_type get_allocator() const
            {
                return allocator_type(_M_get_Bit_allocator());
            }
            _Bvector_base()
                : _M_impl() 
            {
            }
            _Bvector_base(const allocator_type & __a)
                : _M_impl(__a) 
            {
            }
            ~_Bvector_base()
            {
                this->_M_deallocate();
            }
        protected :
            _Bvector_impl _M_impl;
            _Bit_type * _M_allocate(size_t __n)
            {
                return _M_impl.allocate((__n + int(_S_word_bit) - 1) / int(_S_word_bit));
            }
            void _M_deallocate()
            {
                if (_M_impl._M_start._M_p)
                    _M_impl.deallocate(_M_impl._M_start._M_p, _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
            }
    };
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Alloc >
    class vector< bool, _Alloc > : protected _Bvector_base< _Alloc >
    {
            typedef _Bvector_base< _Alloc > _Base;
        public :
            typedef bool value_type;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef _Bit_reference reference;
            typedef bool const_reference;
            typedef _Bit_reference * pointer;
            typedef const bool * const_pointer;
            typedef _Bit_iterator iterator;
            typedef _Bit_const_iterator const_iterator;
            typedef std::reverse_iterator< const_iterator > const_reverse_iterator;
            typedef std::reverse_iterator< iterator > reverse_iterator;
            typedef _Alloc allocator_type;
            allocator_type get_allocator() const
            {
                return _Base::get_allocator();
            }
        protected :
            using _Base::_M_allocate;
            using _Base::_M_deallocate;
            using _Base::_M_get_Bit_allocator;
        public :
            vector()
                : _Base() 
            {
            }
            explicit vector(const allocator_type & __a)
                : _Base(__a) 
            {
            }
            explicit vector(size_type __n, const bool & __value = bool(), const allocator_type & __a = allocator_type())
                : _Base(__a) 
            {
                _M_initialize(__n);
                std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, __value ? ~0 : 0);
            }
            vector(const vector & __x)
                : _Base(__x._M_get_Bit_allocator()) 
            {
                _M_initialize(__x.size());
                _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
            }
            template<typename _InputIterator >
            vector(_InputIterator __first, _InputIterator __last, const allocator_type & __a = allocator_type())
                : _Base(__a) 
            {
                typedef typename std::__is_integer< _InputIterator >::__type _Integral;
                _M_initialize_dispatch(__first, __last, _Integral());
            }
            ~vector()
            {
            }
            vector & operator =(const vector & __x)
            {
                if (&__x == this)
                    return *this;
                if (__x.size() > capacity())
                {
                    this->_M_deallocate();
                    _M_initialize(__x.size());
                }
                this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(), begin());
                return *this;
            }
            void assign(size_type __n, const bool & __x)
            {
                _M_fill_assign(__n, __x);
            }
            template<typename _InputIterator >
            void assign(_InputIterator __first, _InputIterator __last)
            {
                typedef typename std::__is_integer< _InputIterator >::__type _Integral;
                _M_assign_dispatch(__first, __last, _Integral());
            }
            iterator begin()
            {
                return this->_M_impl._M_start;
            }
            const_iterator begin() const
            {
                return this->_M_impl._M_start;
            }
            iterator end()
            {
                return this->_M_impl._M_finish;
            }
            const_iterator end() const
            {
                return this->_M_impl._M_finish;
            }
            reverse_iterator rbegin()
            {
                return reverse_iterator(end());
            }
            const_reverse_iterator rbegin() const
            {
                return const_reverse_iterator(end());
            }
            reverse_iterator rend()
            {
                return reverse_iterator(begin());
            }
            const_reverse_iterator rend() const
            {
                return const_reverse_iterator(begin());
            }
            size_type size() const
            {
                return size_type(end() - begin());
            }
            size_type max_size() const
            {
                const size_type __isize = __gnu_cxx::__numeric_traits< difference_type >::__max - int(_S_word_bit) + 1;
                const size_type __asize = _M_get_Bit_allocator().max_size();
                return (__asize <= __isize / int(_S_word_bit) ? __asize * int(_S_word_bit) : __isize);
            }
            size_type capacity() const
            {
                return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0) - begin());
            }
            bool empty() const
            {
                return begin() == end();
            }
            reference operator [](size_type __n)
            {
                return *iterator(this->_M_impl._M_start._M_p + __n / int(_S_word_bit), __n % int(_S_word_bit));
            }
            const_reference operator [](size_type __n) const
            {
                return *const_iterator(this->_M_impl._M_start._M_p + __n / int(_S_word_bit), __n % int(_S_word_bit));
            }
        protected :
            void _M_range_check(size_type __n) const
            {
                if (__n >= this->size())
                    __throw_out_of_range(("vector<bool>::_M_range_check"));
            }
        public :
            reference at(size_type __n)
            {
                _M_range_check(__n);
                return (*this)[__n];
            }
            const_reference at(size_type __n) const
            {
                _M_range_check(__n);
                return (*this)[__n];
            }
            void reserve(size_type __n);
            reference front()
            {
                return *begin();
            }
            const_reference front() const
            {
                return *begin();
            }
            reference back()
            {
                return *(end() - 1);
            }
            const_reference back() const
            {
                return *(end() - 1);
            }
            void data()
            {
            }
            void push_back(bool __x)
            {
                if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
                    *this->_M_impl._M_finish++ = __x;
                else
                    _M_insert_aux(end(), __x);
            }
            void swap(vector & __x)
            {
                std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
                std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
                std::swap(this->_M_impl._M_end_of_storage, __x._M_impl._M_end_of_storage);
                std::__alloc_swap< typename _Base::_Bit_alloc_type >::_S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
            }
            static void swap(reference __x, reference __y)
            {
                bool __tmp = __x;
                __x = __y;
                __y = __tmp;
            }
            iterator insert(iterator __position, const bool & __x = bool())
            {
                const difference_type __n = __position - begin();
                if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage && __position == end())
                    *this->_M_impl._M_finish++ = __x;
                else
                    _M_insert_aux(__position, __x);
                return begin() + __n;
            }
            template<typename _InputIterator >
            void insert(iterator __position, _InputIterator __first, _InputIterator __last)
            {
                typedef typename std::__is_integer< _InputIterator >::__type _Integral;
                _M_insert_dispatch(__position, __first, __last, _Integral());
            }
            void insert(iterator __position, size_type __n, const bool & __x)
            {
                _M_fill_insert(__position, __n, __x);
            }
            void pop_back()
            {
                --this->_M_impl._M_finish;
            }
            iterator erase(iterator __position)
            {
                if (__position + 1 != end())
                    std::copy(__position + 1, end(), __position);
                --this->_M_impl._M_finish;
                return __position;
            }
            iterator erase(iterator __first, iterator __last)
            {
                _M_erase_at_end(std::copy(__last, end(), __first));
                return __first;
            }
            void resize(size_type __new_size, bool __x = bool())
            {
                if (__new_size < size())
                    _M_erase_at_end(begin() + difference_type(__new_size));
                else
                    insert(end(), __new_size - size(), __x);
            }
            void flip()
            {
                for (_Bit_type * __p = this->_M_impl._M_start._M_p;
                    __p != this->_M_impl._M_end_of_storage;
                    ++__p)
                *__p = ~*__p;
            }
            void clear()
            {
                _M_erase_at_end(begin());
            }
        protected :
            iterator _M_copy_aligned(const_iterator __first, const_iterator __last, iterator __result)
            {
                _Bit_type * __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
                return std::copy(const_iterator(__last._M_p, 0), __last, iterator(__q, 0));
            }
            void _M_initialize(size_type __n)
            {
                _Bit_type * __q = this->_M_allocate(__n);
                this->_M_impl._M_end_of_storage = (__q + ((__n + int(_S_word_bit) - 1) / int(_S_word_bit)));
                this->_M_impl._M_start = iterator(__q, 0);
                this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
            }
            template<typename _Integer >
            void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
            {
                _M_initialize(static_cast<size_type >(__n));
                std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
            }
            template<typename _InputIterator >
            void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last, __false_type)
            {
                _M_initialize_range(__first, __last, std::__iterator_category(__first));
            }
            template<typename _InputIterator >
            void _M_initialize_range(_InputIterator __first, _InputIterator __last, std::input_iterator_tag)
            {
                for (;
                    __first != __last;
                    ++__first)
                push_back(*__first);
            }
            template<typename _ForwardIterator >
            void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag)
            {
                const size_type __n = std::distance(__first, __last);
                _M_initialize(__n);
                std::copy(__first, __last, this->_M_impl._M_start);
            }
            template<typename _Integer >
            void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
            {
                _M_fill_assign(__n, __val);
            }
            template<class _InputIterator >
            void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, __false_type)
            {
                _M_assign_aux(__first, __last, std::__iterator_category(__first));
            }
            void _M_fill_assign(size_t __n, bool __x)
            {
                if (__n > size())
                {
                    std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
                    insert(end(), __n - size(), __x);
                }
                else
                {
                    _M_erase_at_end(begin() + __n);
                    std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
                }
            }
            template<typename _InputIterator >
            void _M_assign_aux(_InputIterator __first, _InputIterator __last, std::input_iterator_tag)
            {
                iterator __cur = begin();
                for (;
                    __first != __last && __cur != end();
                    ++__cur , ++__first)
                *__cur = *__first;
                if (__first == __last)
                    _M_erase_at_end(__cur);
                else
                    insert(end(), __first, __last);
            }
            template<typename _ForwardIterator >
            void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag)
            {
                const size_type __len = std::distance(__first, __last);
                if (__len < size())
                    _M_erase_at_end(std::copy(__first, __last, begin()));
                else
                {
                    _ForwardIterator __mid = __first;
                    std::advance(__mid, size());
                    std::copy(__first, __mid, begin());
                    insert(end(), __mid, __last);
                }
            }
            template<typename _Integer >
            void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x, __true_type)
            {
                _M_fill_insert(__pos, __n, __x);
            }
            template<typename _InputIterator >
            void _M_insert_dispatch(iterator __pos, _InputIterator __first, _InputIterator __last, __false_type)
            {
                _M_insert_range(__pos, __first, __last, std::__iterator_category(__first));
            }
            void _M_fill_insert(iterator __position, size_type __n, bool __x);
            template<typename _InputIterator >
            void _M_insert_range(iterator __pos, _InputIterator __first, _InputIterator __last, std::input_iterator_tag)
            {
                for (;
                    __first != __last;
                    ++__first)
                {
                    __pos = insert(__pos, *__first);
                    ++__pos;
                }
            }
            template<typename _ForwardIterator >
            void _M_insert_range(iterator __position, _ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag);
            void _M_insert_aux(iterator __position, bool __x);
            size_type _M_check_len(size_type __n, const char * __s) const
            {
                if (max_size() - size() < __n)
                    __throw_length_error((__s));
                const size_type __len = size() + std::max(size(), __n);
                return (__len < size() || __len > max_size()) ? max_size() : __len;
            }
            void _M_erase_at_end(iterator __pos)
            {
                this->_M_impl._M_finish = __pos;
            }
    };
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Tp, typename _Alloc >
    void vector< _Tp, _Alloc >::reserve(size_type __n)
    {
        if (__n > this->max_size())
            __throw_length_error(("vector::reserve"));
        if (this->capacity() < __n)
        {
            const size_type __old_size = size();
            pointer __tmp = _M_allocate_and_copy(__n, (this->_M_impl._M_start), (this->_M_impl._M_finish));
            std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
            _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            this->_M_impl._M_start = __tmp;
            this->_M_impl._M_finish = __tmp + __old_size;
            this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
        }
    }
    template<typename _Tp, typename _Alloc >
    typename vector< _Tp, _Alloc >::iterator vector< _Tp, _Alloc >::insert(iterator __position, const value_type & __x)
    {
        const size_type __n = __position - begin();
        if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage && __position == end())
        {
            this->_M_impl.construct(this->_M_impl._M_finish, __x);
            ++this->_M_impl._M_finish;
        }
        else
        {
            _M_insert_aux(__position, __x);
        }
        return iterator(this->_M_impl._M_start + __n);
    }
    template<typename _Tp, typename _Alloc >
    typename vector< _Tp, _Alloc >::iterator vector< _Tp, _Alloc >::erase(iterator __position)
    {
        if (__position + 1 != end())
            std::copy(__position + 1, end(), __position);
        --this->_M_impl._M_finish;
        this->_M_impl.destroy(this->_M_impl._M_finish);
        return __position;
    }
    template<typename _Tp, typename _Alloc >
    typename vector< _Tp, _Alloc >::iterator vector< _Tp, _Alloc >::erase(iterator __first, iterator __last)
    {
        if (__last != end())
            std::copy(__last, end(), __first);
        _M_erase_at_end(__first.base() + (end() - __last));
        return __first;
    }
    template<typename _Tp, typename _Alloc >
    vector< _Tp, _Alloc > & vector< _Tp, _Alloc >::operator =(const vector< _Tp, _Alloc > & __x)
    {
        if (&__x != this)
        {
            const size_type __xlen = __x.size();
            if (__xlen > capacity())
            {
                pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());
                std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
                _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
                this->_M_impl._M_start = __tmp;
                this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
            }
            else
                if (size() >= __xlen)
                {
                    std::_Destroy(std::copy(__x.begin(), __x.end(), begin()), end(), _M_get_Tp_allocator());
                }
                else
                {
                    std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(), this->_M_impl._M_start);
                    std::__uninitialized_copy_a(__x._M_impl._M_start + size(), __x._M_impl._M_finish, this->_M_impl._M_finish, _M_get_Tp_allocator());
                }
            this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
        }
        return *this;
    }
    template<typename _Tp, typename _Alloc >
    void vector< _Tp, _Alloc >::_M_fill_assign(size_t __n, const value_type & __val)
    {
        if (__n > capacity())
        {
            vector __tmp(__n, __val, _M_get_Tp_allocator());
            __tmp.swap(*this);
        }
        else
            if (__n > size())
            {
                std::fill(begin(), end(), __val);
                std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - size(), __val, _M_get_Tp_allocator());
                this->_M_impl._M_finish += __n - size();
            }
            else
                _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }
    template<typename _Tp, typename _Alloc >
    template<typename _InputIterator >
    void vector< _Tp, _Alloc >::_M_assign_aux(_InputIterator __first, _InputIterator __last, std::input_iterator_tag)
    {
        pointer __cur(this->_M_impl._M_start);
        for (;
            __first != __last && __cur != this->_M_impl._M_finish;
            ++__cur , ++__first)
        *__cur = *__first;
        if (__first == __last)
            _M_erase_at_end(__cur);
        else
            insert(end(), __first, __last);
    }
    template<typename _Tp, typename _Alloc >
    template<typename _ForwardIterator >
    void vector< _Tp, _Alloc >::_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag)
    {
        const size_type __len = std::distance(__first, __last);
        if (__len > capacity())
        {
            pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
            std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
            _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            this->_M_impl._M_start = __tmp;
            this->_M_impl._M_finish = this->_M_impl._M_start + __len;
            this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
        }
        else
            if (size() >= __len)
                _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
            else
            {
                _ForwardIterator __mid = __first;
                std::advance(__mid, size());
                std::copy(__first, __mid, this->_M_impl._M_start);
                this->_M_impl._M_finish = std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
            }
    }
    template<typename _Tp, typename _Alloc >
    void vector< _Tp, _Alloc >::_M_insert_aux(iterator __position, const _Tp & __x)
    {
        if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
        {
            this->_M_impl.construct(this->_M_impl._M_finish, (*(this->_M_impl._M_finish - 1)));
            ++this->_M_impl._M_finish;
            _Tp __x_copy = __x;
            std::copy_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1);
            *__position = __x_copy;
        }
        else
        {
            const size_type __len = _M_check_len(size_type(1), "vector::_M_insert_aux");
            pointer __new_start(this->_M_allocate(__len));
            pointer __new_finish(__new_start);
            try
            {
                __new_finish = std::__uninitialized_move_a(this->_M_impl._M_start, __position.base(), __new_start, _M_get_Tp_allocator());
                this->_M_impl.construct(__new_finish, __x);
                ++__new_finish;
                __new_finish = std::__uninitialized_move_a(__position.base(), this->_M_impl._M_finish, __new_finish, _M_get_Tp_allocator());
            }
            catch (...)
            {
                std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                _M_deallocate(__new_start, __len);
                throw;
            }
            std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
            _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            this->_M_impl._M_start = __new_start;
            this->_M_impl._M_finish = __new_finish;
            this->_M_impl._M_end_of_storage = __new_start + __len;
        }
    }
    template<typename _Tp, typename _Alloc >
    void vector< _Tp, _Alloc >::_M_fill_insert(iterator __position, size_type __n, const value_type & __x)
    {
        if (__n != 0)
        {
            if (size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish) >= __n)
            {
                value_type __x_copy = __x;
                const size_type __elems_after = end() - __position;
                pointer __old_finish(this->_M_impl._M_finish);
                if (__elems_after > __n)
                {
                    std::__uninitialized_move_a(this->_M_impl._M_finish - __n, this->_M_impl._M_finish, this->_M_impl._M_finish, _M_get_Tp_allocator());
                    this->_M_impl._M_finish += __n;
                    std::copy_backward(__position.base(), __old_finish - __n, __old_finish);
                    std::fill(__position.base(), __position.base() + __n, __x_copy);
                }
                else
                {
                    std::__uninitialized_fill_n_a(this->_M_impl._M_finish, __n - __elems_after, __x_copy, _M_get_Tp_allocator());
                    this->_M_impl._M_finish += __n - __elems_after;
                    std::__uninitialized_move_a(__position.base(), __old_finish, this->_M_impl._M_finish, _M_get_Tp_allocator());
                    this->_M_impl._M_finish += __elems_after;
                    std::fill(__position.base(), __old_finish, __x_copy);
                }
            }
            else
            {
                const size_type __len = _M_check_len(__n, "vector::_M_fill_insert");
                pointer __new_start(this->_M_allocate(__len));
                pointer __new_finish(__new_start);
                try
                {
                    __new_finish = std::__uninitialized_move_a(this->_M_impl._M_start, __position.base(), __new_start, _M_get_Tp_allocator());
                    std::__uninitialized_fill_n_a(__new_finish, __n, __x, _M_get_Tp_allocator());
                    __new_finish += __n;
                    __new_finish = std::__uninitialized_move_a(__position.base(), this->_M_impl._M_finish, __new_finish, _M_get_Tp_allocator());
                }
                catch (...)
                {
                    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                    _M_deallocate(__new_start, __len);
                    throw;
                }
                std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
                _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
                this->_M_impl._M_start = __new_start;
                this->_M_impl._M_finish = __new_finish;
                this->_M_impl._M_end_of_storage = __new_start + __len;
            }
        }
    }
    template<typename _Tp, typename _Alloc >
    template<typename _InputIterator >
    void vector< _Tp, _Alloc >::_M_range_insert(iterator __pos, _InputIterator __first, _InputIterator __last, std::input_iterator_tag)
    {
        for (;
            __first != __last;
            ++__first)
        {
            __pos = insert(__pos, *__first);
            ++__pos;
        }
    }
    template<typename _Tp, typename _Alloc >
    template<typename _ForwardIterator >
    void vector< _Tp, _Alloc >::_M_range_insert(iterator __position, _ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag)
    {
        if (__first != __last)
        {
            const size_type __n = std::distance(__first, __last);
            if (size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish) >= __n)
            {
                const size_type __elems_after = end() - __position;
                pointer __old_finish(this->_M_impl._M_finish);
                if (__elems_after > __n)
                {
                    std::__uninitialized_move_a(this->_M_impl._M_finish - __n, this->_M_impl._M_finish, this->_M_impl._M_finish, _M_get_Tp_allocator());
                    this->_M_impl._M_finish += __n;
                    std::copy_backward(__position.base(), __old_finish - __n, __old_finish);
                    std::copy(__first, __last, __position);
                }
                else
                {
                    _ForwardIterator __mid = __first;
                    std::advance(__mid, __elems_after);
                    std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
                    this->_M_impl._M_finish += __n - __elems_after;
                    std::__uninitialized_move_a(__position.base(), __old_finish, this->_M_impl._M_finish, _M_get_Tp_allocator());
                    this->_M_impl._M_finish += __elems_after;
                    std::copy(__first, __mid, __position);
                }
            }
            else
            {
                const size_type __len = _M_check_len(__n, "vector::_M_range_insert");
                pointer __new_start(this->_M_allocate(__len));
                pointer __new_finish(__new_start);
                try
                {
                    __new_finish = std::__uninitialized_move_a(this->_M_impl._M_start, __position.base(), __new_start, _M_get_Tp_allocator());
                    __new_finish = std::__uninitialized_copy_a(__first, __last, __new_finish, _M_get_Tp_allocator());
                    __new_finish = std::__uninitialized_move_a(__position.base(), this->_M_impl._M_finish, __new_finish, _M_get_Tp_allocator());
                }
                catch (...)
                {
                    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                    _M_deallocate(__new_start, __len);
                    throw;
                }
                std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, _M_get_Tp_allocator());
                _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
                this->_M_impl._M_start = __new_start;
                this->_M_impl._M_finish = __new_finish;
                this->_M_impl._M_end_of_storage = __new_start + __len;
            }
        }
    }
    template<typename _Alloc >
    void vector< bool, _Alloc >::reserve(size_type __n)
    {
        if (__n > this->max_size())
            __throw_length_error(("vector::reserve"));
        if (this->capacity() < __n)
        {
            _Bit_type * __q = this->_M_allocate(__n);
            this->_M_impl._M_finish = _M_copy_aligned(begin(), end(), iterator(__q, 0));
            this->_M_deallocate();
            this->_M_impl._M_start = iterator(__q, 0);
            this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1) / int(_S_word_bit));
        }
    }
    template<typename _Alloc >
    void vector< bool, _Alloc >::_M_fill_insert(iterator __position, size_type __n, bool __x)
    {
        if (__n == 0)
            return;
        if (capacity() - size() >= __n)
        {
            std::copy_backward(__position, end(), this->_M_impl._M_finish + difference_type(__n));
            std::fill(__position, __position + difference_type(__n), __x);
            this->_M_impl._M_finish += difference_type(__n);
        }
        else
        {
            const size_type __len = _M_check_len(__n, "vector<bool>::_M_fill_insert");
            _Bit_type * __q = this->_M_allocate(__len);
            iterator __i = _M_copy_aligned(begin(), __position, iterator(__q, 0));
            std::fill(__i, __i + difference_type(__n), __x);
            this->_M_impl._M_finish = std::copy(__position, end(), __i + difference_type(__n));
            this->_M_deallocate();
            this->_M_impl._M_end_of_storage = (__q + ((__len + int(_S_word_bit) - 1) / int(_S_word_bit)));
            this->_M_impl._M_start = iterator(__q, 0);
        }
    }
    template<typename _Alloc >
    template<typename _ForwardIterator >
    void vector< bool, _Alloc >::_M_insert_range(iterator __position, _ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag)
    {
        if (__first != __last)
        {
            size_type __n = std::distance(__first, __last);
            if (capacity() - size() >= __n)
            {
                std::copy_backward(__position, end(), this->_M_impl._M_finish + difference_type(__n));
                std::copy(__first, __last, __position);
                this->_M_impl._M_finish += difference_type(__n);
            }
            else
            {
                const size_type __len = _M_check_len(__n, "vector<bool>::_M_insert_range");
                _Bit_type * __q = this->_M_allocate(__len);
                iterator __i = _M_copy_aligned(begin(), __position, iterator(__q, 0));
                __i = std::copy(__first, __last, __i);
                this->_M_impl._M_finish = std::copy(__position, end(), __i);
                this->_M_deallocate();
                this->_M_impl._M_end_of_storage = (__q + ((__len + int(_S_word_bit) - 1) / int(_S_word_bit)));
                this->_M_impl._M_start = iterator(__q, 0);
            }
        }
    }
    template<typename _Alloc >
    void vector< bool, _Alloc >::_M_insert_aux(iterator __position, bool __x)
    {
        if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        {
            std::copy_backward(__position, this->_M_impl._M_finish, this->_M_impl._M_finish + 1);
            *__position = __x;
            ++this->_M_impl._M_finish;
        }
        else
        {
            const size_type __len = _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
            _Bit_type * __q = this->_M_allocate(__len);
            iterator __i = _M_copy_aligned(begin(), __position, iterator(__q, 0));
            *__i++ = __x;
            this->_M_impl._M_finish = std::copy(__position, end(), __i);
            this->_M_deallocate();
            this->_M_impl._M_end_of_storage = (__q + ((__len + int(_S_word_bit) - 1) / int(_S_word_bit)));
            this->_M_impl._M_start = iterator(__q, 0);
        }
    }
}
namespace std __attribute__((__visibility__("default"))) {
    inline size_t __deque_buf_size(size_t __size)
    {
        return __size < 512 ? size_t(512 / __size) : size_t(1);
    }
    template<typename _Tp, typename _Ref, typename _Ptr >
    struct _Deque_iterator
    {
            typedef _Deque_iterator< _Tp, _Tp &, _Tp * > iterator;
            typedef _Deque_iterator< _Tp, const _Tp &, const _Tp * > const_iterator;
            static size_t _S_buffer_size()
            {
                return __deque_buf_size(sizeof(_Tp));
            }
            typedef std::random_access_iterator_tag iterator_category;
            typedef _Tp value_type;
            typedef _Ptr pointer;
            typedef _Ref reference;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef _Tp * * _Map_pointer;
            typedef _Deque_iterator _Self;
            _Tp * _M_cur;
            _Tp * _M_first;
            _Tp * _M_last;
            _Map_pointer _M_node;
            _Deque_iterator(_Tp * __x, _Map_pointer __y)
                : _M_cur(__x), _M_first(*__y), _M_last(*__y + _S_buffer_size()), _M_node(__y) 
            {
            }
            _Deque_iterator()
                : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) 
            {
            }
            _Deque_iterator(const iterator & __x)
                : _M_cur(__x._M_cur), _M_first(__x._M_first), _M_last(__x._M_last), _M_node(__x._M_node) 
            {
            }
            reference operator *() const
            {
                return *_M_cur;
            }
            pointer operator ->() const
            {
                return _M_cur;
            }
            _Self & operator ++()
            {
                ++_M_cur;
                if (_M_cur == _M_last)
                {
                    _M_set_node(_M_node + 1);
                    _M_cur = _M_first;
                }
                return *this;
            }
            _Self operator ++(int)
            {
                _Self __tmp = *this;
                ++*this;
                return __tmp;
            }
            _Self & operator --()
            {
                if (_M_cur == _M_first)
                {
                    _M_set_node(_M_node - 1);
                    _M_cur = _M_last;
                }
                --_M_cur;
                return *this;
            }
            _Self operator --(int)
            {
                _Self __tmp = *this;
                --*this;
                return __tmp;
            }
            _Self & operator +=(difference_type __n)
            {
                const difference_type __offset = __n + (_M_cur - _M_first);
                if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
                    _M_cur += __n;
                else
                {
                    const difference_type __node_offset = __offset > 0 ? __offset / difference_type(_S_buffer_size()) : -difference_type((-__offset - 1) / _S_buffer_size()) - 1;
                    _M_set_node(_M_node + __node_offset);
                    _M_cur = _M_first + (__offset - __node_offset * difference_type(_S_buffer_size()));
                }
                return *this;
            }
            _Self operator +(difference_type __n) const
            {
                _Self __tmp = *this;
                return __tmp += __n;
            }
            _Self & operator -=(difference_type __n)
            {
                return *this += -__n;
            }
            _Self operator -(difference_type __n) const
            {
                _Self __tmp = *this;
                return __tmp -= __n;
            }
            reference operator [](difference_type __n) const
            {
                return *(*this + __n);
            }
            void _M_set_node(_Map_pointer __new_node)
            {
                _M_node = __new_node;
                _M_first = *__new_node;
                _M_last = _M_first + difference_type(_S_buffer_size());
            }
    };
    template<typename _Tp, typename _Ref, typename _Ptr >
    inline bool operator ==(const _Deque_iterator< _Tp, _Ref, _Ptr > & __x, const _Deque_iterator< _Tp, _Ref, _Ptr > & __y)
    {
        return __x._M_cur == __y._M_cur;
    }
    template<typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
    inline bool operator ==(const _Deque_iterator< _Tp, _RefL, _PtrL > & __x, const _Deque_iterator< _Tp, _RefR, _PtrR > & __y)
    {
        return __x._M_cur == __y._M_cur;
    }
    template<typename _Tp, typename _Ref, typename _Ptr >
    inline bool operator !=(const _Deque_iterator< _Tp, _Ref, _Ptr > & __x, const _Deque_iterator< _Tp, _Ref, _Ptr > & __y)
    {
        return !(__x == __y);
    }
    template<typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
    inline bool operator !=(const _Deque_iterator< _Tp, _RefL, _PtrL > & __x, const _Deque_iterator< _Tp, _RefR, _PtrR > & __y)
    {
        return !(__x == __y);
    }
    template<typename _Tp, typename _Ref, typename _Ptr >
    inline bool operator <(const _Deque_iterator< _Tp, _Ref, _Ptr > & __x, const _Deque_iterator< _Tp, _Ref, _Ptr > & __y)
    {
        return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur) : (__x._M_node < __y._M_node);
    }
    template<typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
    inline bool operator <(const _Deque_iterator< _Tp, _RefL, _PtrL > & __x, const _Deque_iterator< _Tp, _RefR, _PtrR > & __y)
    {
        return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur) : (__x._M_node < __y._M_node);
    }
    template<typename _Tp, typename _Ref, typename _Ptr >
    inline bool operator >(const _Deque_iterator< _Tp, _Ref, _Ptr > & __x, const _Deque_iterator< _Tp, _Ref, _Ptr > & __y)
    {
        return __y < __x;
    }
    template<typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
    inline bool operator >(const _Deque_iterator< _Tp, _RefL, _PtrL > & __x, const _Deque_iterator< _Tp, _RefR, _PtrR > & __y)
    {
        return __y < __x;
    }
    template<typename _Tp, typename _Ref, typename _Ptr >
    inline bool operator <=(const _Deque_iterator< _Tp, _Ref, _Ptr > & __x, const _Deque_iterator< _Tp, _Ref, _Ptr > & __y)
    {
        return !(__y < __x);
    }
    template<typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
    inline bool operator <=(const _Deque_iterator< _Tp, _RefL, _PtrL > & __x, const _Deque_iterator< _Tp, _RefR, _PtrR > & __y)
    {
        return !(__y < __x);
    }
    template<typename _Tp, typename _Ref, typename _Ptr >
    inline bool operator >=(const _Deque_iterator< _Tp, _Ref, _Ptr > & __x, const _Deque_iterator< _Tp, _Ref, _Ptr > & __y)
    {
        return !(__x < __y);
    }
    template<typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
    inline bool operator >=(const _Deque_iterator< _Tp, _RefL, _PtrL > & __x, const _Deque_iterator< _Tp, _RefR, _PtrR > & __y)
    {
        return !(__x < __y);
    }
    template<typename _Tp, typename _Ref, typename _Ptr >
    inline typename _Deque_iterator< _Tp, _Ref, _Ptr >::difference_type operator -(const _Deque_iterator< _Tp, _Ref, _Ptr > & __x, const _Deque_iterator< _Tp, _Ref, _Ptr > & __y)
    {
        return typename _Deque_iterator< _Tp, _Ref, _Ptr >::difference_type(_Deque_iterator< _Tp, _Ref, _Ptr >::_S_buffer_size()) * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first) + (__y._M_last - __y._M_cur);
    }
    template<typename _Tp, typename _RefL, typename _PtrL, typename _RefR, typename _PtrR >
    inline typename _Deque_iterator< _Tp, _RefL, _PtrL >::difference_type operator -(const _Deque_iterator< _Tp, _RefL, _PtrL > & __x, const _Deque_iterator< _Tp, _RefR, _PtrR > & __y)
    {
        return typename _Deque_iterator< _Tp, _RefL, _PtrL >::difference_type(_Deque_iterator< _Tp, _RefL, _PtrL >::_S_buffer_size()) * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first) + (__y._M_last - __y._M_cur);
    }
    template<typename _Tp, typename _Ref, typename _Ptr >
    inline _Deque_iterator< _Tp, _Ref, _Ptr > operator +(ptrdiff_t __n, const _Deque_iterator< _Tp, _Ref, _Ptr > & __x)
    {
        return __x + __n;
    }
    template<typename _Tp >
    void fill(const _Deque_iterator< _Tp, _Tp &, _Tp * > & __first, const _Deque_iterator< _Tp, _Tp &, _Tp * > & __last, const _Tp & __value);
    template<typename _Tp, typename _Alloc >
    class _Deque_base
    {
        public :
            typedef _Alloc allocator_type;
            allocator_type get_allocator() const
            {
                return allocator_type(_M_get_Tp_allocator());
            }
            typedef _Deque_iterator< _Tp, _Tp &, _Tp * > iterator;
            typedef _Deque_iterator< _Tp, const _Tp &, const _Tp * > const_iterator;
            _Deque_base()
                : _M_impl() 
            {
                _M_initialize_map(0);
            }
            _Deque_base(const allocator_type & __a, size_t __num_elements)
                : _M_impl(__a) 
            {
                _M_initialize_map(__num_elements);
            }
            _Deque_base(const allocator_type & __a)
                : _M_impl(__a) 
            {
            }
            ~_Deque_base();
        protected :
            typedef typename _Alloc::template rebind< _Tp * >::other _Map_alloc_type;
            typedef typename _Alloc::template rebind< _Tp >::other _Tp_alloc_type;
            struct _Deque_impl : public _Tp_alloc_type
            {
                    _Tp * * _M_map;
                    size_t _M_map_size;
                    iterator _M_start;
                    iterator _M_finish;
                    _Deque_impl()
                        : _Tp_alloc_type(), _M_map(0), _M_map_size(0), _M_start(), _M_finish() 
                    {
                    }
                    _Deque_impl(const _Tp_alloc_type & __a)
                        : _Tp_alloc_type(__a), _M_map(0), _M_map_size(0), _M_start(), _M_finish() 
                    {
                    }
            };
            _Tp_alloc_type & _M_get_Tp_allocator()
            {
                return *static_cast<_Tp_alloc_type * >(&this->_M_impl);
            }
            const _Tp_alloc_type & _M_get_Tp_allocator() const
            {
                return *static_cast<const _Tp_alloc_type * >(&this->_M_impl);
            }
            _Map_alloc_type _M_get_map_allocator() const
            {
                return _Map_alloc_type(_M_get_Tp_allocator());
            }
            _Tp * _M_allocate_node()
            {
                return _M_impl._Tp_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));
            }
            void _M_deallocate_node(_Tp * __p)
            {
                _M_impl._Tp_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));
            }
            _Tp * * _M_allocate_map(size_t __n)
            {
                return _M_get_map_allocator().allocate(__n);
            }
            void _M_deallocate_map(_Tp * * __p, size_t __n)
            {
                _M_get_map_allocator().deallocate(__p, __n);
            }
        protected :
            void _M_initialize_map(size_t);
            void _M_create_nodes(_Tp * * __nstart, _Tp * * __nfinish);
            void _M_destroy_nodes(_Tp * * __nstart, _Tp * * __nfinish);
            enum 
            {
                _S_initial_map_size = 8
            };
            _Deque_impl _M_impl;
    };
    template<typename _Tp, typename _Alloc >
    _Deque_base< _Tp, _Alloc >::~_Deque_base()
    {
        if (this->_M_impl._M_map)
        {
            _M_destroy_nodes(this->_M_impl._M_start._M_node, this->_M_impl._M_finish._M_node + 1);
            _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
        }
    }
    template<typename _Tp, typename _Alloc >
    void _Deque_base< _Tp, _Alloc >::_M_initialize_map(size_t __num_elements)
    {
        const size_t __num_nodes = (__num_elements / __deque_buf_size(sizeof(_Tp)) + 1);
        this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size, size_t(__num_nodes + 2));
        this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);
        _Tp * * __nstart = (this->_M_impl._M_map + (this->_M_impl._M_map_size - __num_nodes) / 2);
        _Tp * * __nfinish = __nstart + __num_nodes;
        try
        {
            _M_create_nodes(__nstart, __nfinish);
        }
        catch (...)
        {
            _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
            this->_M_impl._M_map = 0;
            this->_M_impl._M_map_size = 0;
            throw;
        }
        this->_M_impl._M_start._M_set_node(__nstart);
        this->_M_impl._M_finish._M_set_node(__nfinish - 1);
        this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
        this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first + __num_elements % __deque_buf_size(sizeof(_Tp)));
    }
    template<typename _Tp, typename _Alloc >
    void _Deque_base< _Tp, _Alloc >::_M_create_nodes(_Tp * * __nstart, _Tp * * __nfinish)
    {
        _Tp * * __cur;
        try
        {
            for (__cur = __nstart;
                __cur < __nfinish;
                ++__cur)
            *__cur = this->_M_allocate_node();
        }
        catch (...)
        {
            _M_destroy_nodes(__nstart, __cur);
            throw;
        }
    }
    template<typename _Tp, typename _Alloc >
    void _Deque_base< _Tp, _Alloc >::_M_destroy_nodes(_Tp * * __nstart, _Tp * * __nfinish)
    {
        for (_Tp * * __n = __nstart;
            __n < __nfinish;
            ++__n)
        _M_deallocate_node(*__n);
    }
    template<typename _Tp, typename _Alloc = std::allocator< _Tp > >
    class deque : protected _Deque_base< _Tp, _Alloc >
    {
            typedef typename _Alloc::value_type _Alloc_value_type;
            typedef _Deque_base< _Tp, _Alloc > _Base;
            typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
        public :
            typedef _Tp value_type;
            typedef typename _Tp_alloc_type::pointer pointer;
            typedef typename _Tp_alloc_type::const_pointer const_pointer;
            typedef typename _Tp_alloc_type::reference reference;
            typedef typename _Tp_alloc_type::const_reference const_reference;
            typedef typename _Base::iterator iterator;
            typedef typename _Base::const_iterator const_iterator;
            typedef std::reverse_iterator< const_iterator > const_reverse_iterator;
            typedef std::reverse_iterator< iterator > reverse_iterator;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef _Alloc allocator_type;
        protected :
            typedef pointer * _Map_pointer;
            static size_t _S_buffer_size()
            {
                return __deque_buf_size(sizeof(_Tp));
            }
            using _Base::_M_initialize_map;
            using _Base::_M_create_nodes;
            using _Base::_M_destroy_nodes;
            using _Base::_M_allocate_node;
            using _Base::_M_deallocate_node;
            using _Base::_M_allocate_map;
            using _Base::_M_deallocate_map;
            using _Base::_M_get_Tp_allocator;
            using _Base::_M_impl;
        public :
            deque()
                : _Base() 
            {
            }
            explicit deque(const allocator_type & __a)
                : _Base(__a, 0) 
            {
            }
            explicit deque(size_type __n, const value_type & __value = value_type(), const allocator_type & __a = allocator_type())
                : _Base(__a, __n) 
            {
                _M_fill_initialize(__value);
            }
            deque(const deque & __x)
                : _Base(__x._M_get_Tp_allocator(), __x.size()) 
            {
                std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start, _M_get_Tp_allocator());
            }
            template<typename _InputIterator >
            deque(_InputIterator __first, _InputIterator __last, const allocator_type & __a = allocator_type())
                : _Base(__a) 
            {
                typedef typename std::__is_integer< _InputIterator >::__type _Integral;
                _M_initialize_dispatch(__first, __last, _Integral());
            }
            ~deque()
            {
                _M_destroy_data(begin(), end(), _M_get_Tp_allocator());
            }
            deque & operator =(const deque & __x);
            void assign(size_type __n, const value_type & __val)
            {
                _M_fill_assign(__n, __val);
            }
            template<typename _InputIterator >
            void assign(_InputIterator __first, _InputIterator __last)
            {
                typedef typename std::__is_integer< _InputIterator >::__type _Integral;
                _M_assign_dispatch(__first, __last, _Integral());
            }
            allocator_type get_allocator() const
            {
                return _Base::get_allocator();
            }
            iterator begin()
            {
                return this->_M_impl._M_start;
            }
            const_iterator begin() const
            {
                return this->_M_impl._M_start;
            }
            iterator end()
            {
                return this->_M_impl._M_finish;
            }
            const_iterator end() const
            {
                return this->_M_impl._M_finish;
            }
            reverse_iterator rbegin()
            {
                return reverse_iterator(this->_M_impl._M_finish);
            }
            const_reverse_iterator rbegin() const
            {
                return const_reverse_iterator(this->_M_impl._M_finish);
            }
            reverse_iterator rend()
            {
                return reverse_iterator(this->_M_impl._M_start);
            }
            const_reverse_iterator rend() const
            {
                return const_reverse_iterator(this->_M_impl._M_start);
            }
            size_type size() const
            {
                return this->_M_impl._M_finish - this->_M_impl._M_start;
            }
            size_type max_size() const
            {
                return _M_get_Tp_allocator().max_size();
            }
            void resize(size_type __new_size, value_type __x = value_type())
            {
                const size_type __len = size();
                if (__new_size < __len)
                    _M_erase_at_end(this->_M_impl._M_start + difference_type(__new_size));
                else
                    insert(this->_M_impl._M_finish, __new_size - __len, __x);
            }
            bool empty() const
            {
                return this->_M_impl._M_finish == this->_M_impl._M_start;
            }
            reference operator [](size_type __n)
            {
                return this->_M_impl._M_start[difference_type(__n)];
            }
            const_reference operator [](size_type __n) const
            {
                return this->_M_impl._M_start[difference_type(__n)];
            }
        protected :
            void _M_range_check(size_type __n) const
            {
                if (__n >= this->size())
                    __throw_out_of_range(("deque::_M_range_check"));
            }
        public :
            reference at(size_type __n)
            {
                _M_range_check(__n);
                return (*this)[__n];
            }
            const_reference at(size_type __n) const
            {
                _M_range_check(__n);
                return (*this)[__n];
            }
            reference front()
            {
                return *begin();
            }
            const_reference front() const
            {
                return *begin();
            }
            reference back()
            {
                iterator __tmp = end();
                --__tmp;
                return *__tmp;
            }
            const_reference back() const
            {
                const_iterator __tmp = end();
                --__tmp;
                return *__tmp;
            }
            void push_front(const value_type & __x)
            {
                if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
                {
                    this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1, __x);
                    --this->_M_impl._M_start._M_cur;
                }
                else
                    _M_push_front_aux(__x);
            }
            void push_back(const value_type & __x)
            {
                if (this->_M_impl._M_finish._M_cur != this->_M_impl._M_finish._M_last - 1)
                {
                    this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);
                    ++this->_M_impl._M_finish._M_cur;
                }
                else
                    _M_push_back_aux(__x);
            }
            void pop_front()
            {
                if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_last - 1)
                {
                    this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
                    ++this->_M_impl._M_start._M_cur;
                }
                else
                    _M_pop_front_aux();
            }
            void pop_back()
            {
                if (this->_M_impl._M_finish._M_cur != this->_M_impl._M_finish._M_first)
                {
                    --this->_M_impl._M_finish._M_cur;
                    this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
                }
                else
                    _M_pop_back_aux();
            }
            iterator insert(iterator __position, const value_type & __x);
            void insert(iterator __position, size_type __n, const value_type & __x)
            {
                _M_fill_insert(__position, __n, __x);
            }
            template<typename _InputIterator >
            void insert(iterator __position, _InputIterator __first, _InputIterator __last)
            {
                typedef typename std::__is_integer< _InputIterator >::__type _Integral;
                _M_insert_dispatch(__position, __first, __last, _Integral());
            }
            iterator erase(iterator __position);
            iterator erase(iterator __first, iterator __last);
            void swap(deque & __x)
            {
                std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
                std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
                std::swap(this->_M_impl._M_map, __x._M_impl._M_map);
                std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);
                std::__alloc_swap< _Tp_alloc_type >::_S_do_it(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
            }
            void clear()
            {
                _M_erase_at_end(begin());
            }
        protected :
            template<typename _Integer >
            void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
            {
                _M_initialize_map(static_cast<size_type >(__n));
                _M_fill_initialize(__x);
            }
            template<typename _InputIterator >
            void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last, __false_type)
            {
                typedef typename std::iterator_traits< _InputIterator >::iterator_category _IterCategory;
                _M_range_initialize(__first, __last, _IterCategory());
            }
            template<typename _InputIterator >
            void _M_range_initialize(_InputIterator __first, _InputIterator __last, std::input_iterator_tag);
            template<typename _ForwardIterator >
            void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag);
            void _M_fill_initialize(const value_type & __value);
            template<typename _Integer >
            void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
            {
                _M_fill_assign(__n, __val);
            }
            template<typename _InputIterator >
            void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, __false_type)
            {
                typedef typename std::iterator_traits< _InputIterator >::iterator_category _IterCategory;
                _M_assign_aux(__first, __last, _IterCategory());
            }
            template<typename _InputIterator >
            void _M_assign_aux(_InputIterator __first, _InputIterator __last, std::input_iterator_tag);
            template<typename _ForwardIterator >
            void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag)
            {
                const size_type __len = std::distance(__first, __last);
                if (__len > size())
                {
                    _ForwardIterator __mid = __first;
                    std::advance(__mid, size());
                    std::copy(__first, __mid, begin());
                    insert(end(), __mid, __last);
                }
                else
                    _M_erase_at_end(std::copy(__first, __last, begin()));
            }
            void _M_fill_assign(size_type __n, const value_type & __val)
            {
                if (__n > size())
                {
                    std::fill(begin(), end(), __val);
                    insert(end(), __n - size(), __val);
                }
                else
                {
                    _M_erase_at_end(begin() + difference_type(__n));
                    std::fill(begin(), end(), __val);
                }
            }
            void _M_push_back_aux(const value_type &);
            void _M_push_front_aux(const value_type &);
            void _M_pop_back_aux();
            void _M_pop_front_aux();
            template<typename _Integer >
            void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x, __true_type)
            {
                _M_fill_insert(__pos, __n, __x);
            }
            template<typename _InputIterator >
            void _M_insert_dispatch(iterator __pos, _InputIterator __first, _InputIterator __last, __false_type)
            {
                typedef typename std::iterator_traits< _InputIterator >::iterator_category _IterCategory;
                _M_range_insert_aux(__pos, __first, __last, _IterCategory());
            }
            template<typename _InputIterator >
            void _M_range_insert_aux(iterator __pos, _InputIterator __first, _InputIterator __last, std::input_iterator_tag);
            template<typename _ForwardIterator >
            void _M_range_insert_aux(iterator __pos, _ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag);
            void _M_fill_insert(iterator __pos, size_type __n, const value_type & __x);
            iterator _M_insert_aux(iterator __pos, const value_type & __x);
            void _M_insert_aux(iterator __pos, size_type __n, const value_type & __x);
            template<typename _ForwardIterator >
            void _M_insert_aux(iterator __pos, _ForwardIterator __first, _ForwardIterator __last, size_type __n);
            void _M_destroy_data_aux(iterator __first, iterator __last);
            template<typename _Alloc1 >
            void _M_destroy_data(iterator __first, iterator __last, const _Alloc1 &)
            {
                _M_destroy_data_aux(__first, __last);
            }
            void _M_destroy_data(iterator __first, iterator __last, const std::allocator< _Tp > &)
            {
                if (!__has_trivial_destructor(value_type))
                    _M_destroy_data_aux(__first, __last);
            }
            void _M_erase_at_begin(iterator __pos)
            {
                _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
                _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
                this->_M_impl._M_start = __pos;
            }
            void _M_erase_at_end(iterator __pos)
            {
                _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
                _M_destroy_nodes(__pos._M_node + 1, this->_M_impl._M_finish._M_node + 1);
                this->_M_impl._M_finish = __pos;
            }
            iterator _M_reserve_elements_at_front(size_type __n)
            {
                const size_type __vacancies = this->_M_impl._M_start._M_cur - this->_M_impl._M_start._M_first;
                if (__n > __vacancies)
                    _M_new_elements_at_front(__n - __vacancies);
                return this->_M_impl._M_start - difference_type(__n);
            }
            iterator _M_reserve_elements_at_back(size_type __n)
            {
                const size_type __vacancies = (this->_M_impl._M_finish._M_last - this->_M_impl._M_finish._M_cur) - 1;
                if (__n > __vacancies)
                    _M_new_elements_at_back(__n - __vacancies);
                return this->_M_impl._M_finish + difference_type(__n);
            }
            void _M_new_elements_at_front(size_type __new_elements);
            void _M_new_elements_at_back(size_type __new_elements);
            void _M_reserve_map_at_back(size_type __nodes_to_add = 1)
            {
                if (__nodes_to_add + 1 > this->_M_impl._M_map_size - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
                    _M_reallocate_map(__nodes_to_add, false);
            }
            void _M_reserve_map_at_front(size_type __nodes_to_add = 1)
            {
                if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node - this->_M_impl._M_map))
                    _M_reallocate_map(__nodes_to_add, true);
            }
            void _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);
    };
    template<typename _Tp, typename _Alloc >
    inline bool operator ==(const deque< _Tp, _Alloc > & __x, const deque< _Tp, _Alloc > & __y)
    {
        return __x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
    }
    template<typename _Tp, typename _Alloc >
    inline bool operator <(const deque< _Tp, _Alloc > & __x, const deque< _Tp, _Alloc > & __y)
    {
        return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
    }
    template<typename _Tp, typename _Alloc >
    inline bool operator !=(const deque< _Tp, _Alloc > & __x, const deque< _Tp, _Alloc > & __y)
    {
        return !(__x == __y);
    }
    template<typename _Tp, typename _Alloc >
    inline bool operator >(const deque< _Tp, _Alloc > & __x, const deque< _Tp, _Alloc > & __y)
    {
        return __y < __x;
    }
    template<typename _Tp, typename _Alloc >
    inline bool operator <=(const deque< _Tp, _Alloc > & __x, const deque< _Tp, _Alloc > & __y)
    {
        return !(__y < __x);
    }
    template<typename _Tp, typename _Alloc >
    inline bool operator >=(const deque< _Tp, _Alloc > & __x, const deque< _Tp, _Alloc > & __y)
    {
        return !(__x < __y);
    }
    template<typename _Tp, typename _Alloc >
    inline void swap(deque< _Tp, _Alloc > & __x, deque< _Tp, _Alloc > & __y)
    {
        __x.swap(__y);
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Tp, typename _Alloc >
    deque< _Tp, _Alloc > & deque< _Tp, _Alloc >::operator =(const deque & __x)
    {
        const size_type __len = size();
        if (&__x != this)
        {
            if (__len >= __x.size())
                _M_erase_at_end(std::copy(__x.begin(), __x.end(), this->_M_impl._M_start));
            else
            {
                const_iterator __mid = __x.begin() + difference_type(__len);
                std::copy(__x.begin(), __mid, this->_M_impl._M_start);
                insert(this->_M_impl._M_finish, __mid, __x.end());
            }
        }
        return *this;
    }
    template<typename _Tp, typename _Alloc >
    typename deque< _Tp, _Alloc >::iterator deque< _Tp, _Alloc >::insert(iterator __position, const value_type & __x)
    {
        if (__position._M_cur == this->_M_impl._M_start._M_cur)
        {
            push_front(__x);
            return this->_M_impl._M_start;
        }
        else
            if (__position._M_cur == this->_M_impl._M_finish._M_cur)
            {
                push_back(__x);
                iterator __tmp = this->_M_impl._M_finish;
                --__tmp;
                return __tmp;
            }
            else
                return _M_insert_aux(__position, __x);
    }
    template<typename _Tp, typename _Alloc >
    typename deque< _Tp, _Alloc >::iterator deque< _Tp, _Alloc >::erase(iterator __position)
    {
        iterator __next = __position;
        ++__next;
        const difference_type __index = __position - begin();
        if (static_cast<size_type >(__index) < (size() >> 1))
        {
            if (__position != begin())
                std::copy_backward(begin(), __position, __next);
            pop_front();
        }
        else
        {
            if (__next != end())
                std::copy(__next, end(), __position);
            pop_back();
        }
        return begin() + __index;
    }
    template<typename _Tp, typename _Alloc >
    typename deque< _Tp, _Alloc >::iterator deque< _Tp, _Alloc >::erase(iterator __first, iterator __last)
    {
        if (__first == begin() && __last == end())
        {
            clear();
            return end();
        }
        else
        {
            const difference_type __n = __last - __first;
            const difference_type __elems_before = __first - begin();
            if (static_cast<size_type >(__elems_before) <= (size() - __n) / 2)
            {
                if (__first != begin())
                    std::copy_backward(begin(), __first, __last);
                _M_erase_at_begin(begin() + __n);
            }
            else
            {
                if (__last != end())
                    std::copy(__last, end(), __first);
                _M_erase_at_end(end() - __n);
            }
            return begin() + __elems_before;
        }
    }
    template<typename _Tp, class _Alloc >
    template<typename _InputIterator >
    void deque< _Tp, _Alloc >::_M_assign_aux(_InputIterator __first, _InputIterator __last, std::input_iterator_tag)
    {
        iterator __cur = begin();
        for (;
            __first != __last && __cur != end();
            ++__cur , ++__first)
        *__cur = *__first;
        if (__first == __last)
            _M_erase_at_end(__cur);
        else
            insert(end(), __first, __last);
    }
    template<typename _Tp, typename _Alloc >
    void deque< _Tp, _Alloc >::_M_fill_insert(iterator __pos, size_type __n, const value_type & __x)
    {
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
        {
            iterator __new_start = _M_reserve_elements_at_front(__n);
            try
            {
                std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start, __x, _M_get_Tp_allocator());
                this->_M_impl._M_start = __new_start;
            }
            catch (...)
            {
                _M_destroy_nodes(__new_start._M_node, this->_M_impl._M_start._M_node);
                throw;
            }
        }
        else
            if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
            {
                iterator __new_finish = _M_reserve_elements_at_back(__n);
                try
                {
                    std::__uninitialized_fill_a(this->_M_impl._M_finish, __new_finish, __x, _M_get_Tp_allocator());
                    this->_M_impl._M_finish = __new_finish;
                }
                catch (...)
                {
                    _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1, __new_finish._M_node + 1);
                    throw;
                }
            }
            else
                _M_insert_aux(__pos, __n, __x);
    }
    template<typename _Tp, typename _Alloc >
    void deque< _Tp, _Alloc >::_M_fill_initialize(const value_type & __value)
    {
        _Map_pointer __cur;
        try
        {
            for (__cur = this->_M_impl._M_start._M_node;
                __cur < this->_M_impl._M_finish._M_node;
                ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(), __value, _M_get_Tp_allocator());
            std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first, this->_M_impl._M_finish._M_cur, __value, _M_get_Tp_allocator());
        }
        catch (...)
        {
            std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur), _M_get_Tp_allocator());
            throw;
        }
    }
    template<typename _Tp, typename _Alloc >
    template<typename _InputIterator >
    void deque< _Tp, _Alloc >::_M_range_initialize(_InputIterator __first, _InputIterator __last, std::input_iterator_tag)
    {
        this->_M_initialize_map(0);
        try
        {
            for (;
                __first != __last;
                ++__first)
            push_back(*__first);
        }
        catch (...)
        {
            clear();
            throw;
        }
    }
    template<typename _Tp, typename _Alloc >
    template<typename _ForwardIterator >
    void deque< _Tp, _Alloc >::_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag)
    {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);
        _Map_pointer __cur_node;
        try
        {
            for (__cur_node = this->_M_impl._M_start._M_node;
                __cur_node < this->_M_impl._M_finish._M_node;
                ++__cur_node)
            {
                _ForwardIterator __mid = __first;
                std::advance(__mid, _S_buffer_size());
                std::__uninitialized_copy_a(__first, __mid, *__cur_node, _M_get_Tp_allocator());
                __first = __mid;
            }
            std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_finish._M_first, _M_get_Tp_allocator());
        }
        catch (...)
        {
            std::_Destroy(this->_M_impl._M_start, iterator(*__cur_node, __cur_node), _M_get_Tp_allocator());
            throw;
        }
    }
    template<typename _Tp, typename _Alloc >
    void deque< _Tp, _Alloc >::_M_push_back_aux(const value_type & __t)
    {
        _M_reserve_map_at_back();
        *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
        try
        {
            this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t);
            this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node + 1);
            this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
        }
        catch (...)
        {
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
            throw;
        }
    }
    template<typename _Tp, typename _Alloc >
    void deque< _Tp, _Alloc >::_M_push_front_aux(const value_type & __t)
    {
        _M_reserve_map_at_front();
        *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
        try
        {
            this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node - 1);
            this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;
            this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t);
        }
        catch (...)
        {
            ++this->_M_impl._M_start;
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
            throw;
        }
    }
    template<typename _Tp, typename _Alloc >
    void deque< _Tp, _Alloc >::_M_pop_back_aux()
    {
        _M_deallocate_node(this->_M_impl._M_finish._M_first);
        this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
        this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
        this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
    }
    template<typename _Tp, typename _Alloc >
    void deque< _Tp, _Alloc >::_M_pop_front_aux()
    {
        this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
        _M_deallocate_node(this->_M_impl._M_start._M_first);
        this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
        this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }
    template<typename _Tp, typename _Alloc >
    template<typename _InputIterator >
    void deque< _Tp, _Alloc >::_M_range_insert_aux(iterator __pos, _InputIterator __first, _InputIterator __last, std::input_iterator_tag)
    {
        std::copy(__first, __last, std::inserter(*this, __pos));
    }
    template<typename _Tp, typename _Alloc >
    template<typename _ForwardIterator >
    void deque< _Tp, _Alloc >::_M_range_insert_aux(iterator __pos, _ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag)
    {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
        {
            iterator __new_start = _M_reserve_elements_at_front(__n);
            try
            {
                std::__uninitialized_copy_a(__first, __last, __new_start, _M_get_Tp_allocator());
                this->_M_impl._M_start = __new_start;
            }
            catch (...)
            {
                _M_destroy_nodes(__new_start._M_node, this->_M_impl._M_start._M_node);
                throw;
            }
        }
        else
            if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
            {
                iterator __new_finish = _M_reserve_elements_at_back(__n);
                try
                {
                    std::__uninitialized_copy_a(__first, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
                    this->_M_impl._M_finish = __new_finish;
                }
                catch (...)
                {
                    _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1, __new_finish._M_node + 1);
                    throw;
                }
            }
            else
                _M_insert_aux(__pos, __first, __last, __n);
    }
    template<typename _Tp, typename _Alloc >
    typename deque< _Tp, _Alloc >::iterator deque< _Tp, _Alloc >::_M_insert_aux(iterator __pos, const value_type & __x)
    {
        value_type __x_copy = __x;
        difference_type __index = __pos - this->_M_impl._M_start;
        if (static_cast<size_type >(__index) < size() / 2)
        {
            push_front((front()));
            iterator __front1 = this->_M_impl._M_start;
            ++__front1;
            iterator __front2 = __front1;
            ++__front2;
            __pos = this->_M_impl._M_start + __index;
            iterator __pos1 = __pos;
            ++__pos1;
            std::copy(__front2, __pos1, __front1);
        }
        else
        {
            push_back((back()));
            iterator __back1 = this->_M_impl._M_finish;
            --__back1;
            iterator __back2 = __back1;
            --__back2;
            __pos = this->_M_impl._M_start + __index;
            std::copy_backward(__pos, __back2, __back1);
        }
        *__pos = (__x_copy);
        return __pos;
    }
    template<typename _Tp, typename _Alloc >
    void deque< _Tp, _Alloc >::_M_insert_aux(iterator __pos, size_type __n, const value_type & __x)
    {
        const difference_type __elems_before = __pos - this->_M_impl._M_start;
        const size_type __length = this->size();
        value_type __x_copy = __x;
        if (__elems_before < difference_type(__length / 2))
        {
            iterator __new_start = _M_reserve_elements_at_front(__n);
            iterator __old_start = this->_M_impl._M_start;
            __pos = this->_M_impl._M_start + __elems_before;
            try
            {
                if (__elems_before >= difference_type(__n))
                {
                    iterator __start_n = (this->_M_impl._M_start + difference_type(__n));
                    std::__uninitialized_move_a(this->_M_impl._M_start, __start_n, __new_start, _M_get_Tp_allocator());
                    this->_M_impl._M_start = __new_start;
                    std::copy(__start_n, __pos, __old_start);
                    std::fill(__pos - difference_type(__n), __pos, __x_copy);
                }
                else
                {
                    std::__uninitialized_move_fill(this->_M_impl._M_start, __pos, __new_start, this->_M_impl._M_start, __x_copy, _M_get_Tp_allocator());
                    this->_M_impl._M_start = __new_start;
                    std::fill(__old_start, __pos, __x_copy);
                }
            }
            catch (...)
            {
                _M_destroy_nodes(__new_start._M_node, this->_M_impl._M_start._M_node);
                throw;
            }
        }
        else
        {
            iterator __new_finish = _M_reserve_elements_at_back(__n);
            iterator __old_finish = this->_M_impl._M_finish;
            const difference_type __elems_after = difference_type(__length) - __elems_before;
            __pos = this->_M_impl._M_finish - __elems_after;
            try
            {
                if (__elems_after > difference_type(__n))
                {
                    iterator __finish_n = (this->_M_impl._M_finish - difference_type(__n));
                    std::__uninitialized_move_a(__finish_n, this->_M_impl._M_finish, this->_M_impl._M_finish, _M_get_Tp_allocator());
                    this->_M_impl._M_finish = __new_finish;
                    std::copy_backward(__pos, __finish_n, __old_finish);
                    std::fill(__pos, __pos + difference_type(__n), __x_copy);
                }
                else
                {
                    std::__uninitialized_fill_move(this->_M_impl._M_finish, __pos + difference_type(__n), __x_copy, __pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
                    this->_M_impl._M_finish = __new_finish;
                    std::fill(__pos, __old_finish, __x_copy);
                }
            }
            catch (...)
            {
                _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1, __new_finish._M_node + 1);
                throw;
            }
        }
    }
    template<typename _Tp, typename _Alloc >
    template<typename _ForwardIterator >
    void deque< _Tp, _Alloc >::_M_insert_aux(iterator __pos, _ForwardIterator __first, _ForwardIterator __last, size_type __n)
    {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type >(__elemsbefore) < __length / 2)
        {
            iterator __new_start = _M_reserve_elements_at_front(__n);
            iterator __old_start = this->_M_impl._M_start;
            __pos = this->_M_impl._M_start + __elemsbefore;
            try
            {
                if (__elemsbefore >= difference_type(__n))
                {
                    iterator __start_n = (this->_M_impl._M_start + difference_type(__n));
                    std::__uninitialized_move_a(this->_M_impl._M_start, __start_n, __new_start, _M_get_Tp_allocator());
                    this->_M_impl._M_start = __new_start;
                    std::copy(__start_n, __pos, __old_start);
                    std::copy(__first, __last, __pos - difference_type(__n));
                }
                else
                {
                    _ForwardIterator __mid = __first;
                    std::advance(__mid, difference_type(__n) - __elemsbefore);
                    std::__uninitialized_move_copy(this->_M_impl._M_start, __pos, __first, __mid, __new_start, _M_get_Tp_allocator());
                    this->_M_impl._M_start = __new_start;
                    std::copy(__mid, __last, __old_start);
                }
            }
            catch (...)
            {
                _M_destroy_nodes(__new_start._M_node, this->_M_impl._M_start._M_node);
                throw;
            }
        }
        else
        {
            iterator __new_finish = _M_reserve_elements_at_back(__n);
            iterator __old_finish = this->_M_impl._M_finish;
            const difference_type __elemsafter = difference_type(__length) - __elemsbefore;
            __pos = this->_M_impl._M_finish - __elemsafter;
            try
            {
                if (__elemsafter > difference_type(__n))
                {
                    iterator __finish_n = (this->_M_impl._M_finish - difference_type(__n));
                    std::__uninitialized_move_a(__finish_n, this->_M_impl._M_finish, this->_M_impl._M_finish, _M_get_Tp_allocator());
                    this->_M_impl._M_finish = __new_finish;
                    std::copy_backward(__pos, __finish_n, __old_finish);
                    std::copy(__first, __last, __pos);
                }
                else
                {
                    _ForwardIterator __mid = __first;
                    std::advance(__mid, __elemsafter);
                    std::__uninitialized_copy_move(__mid, __last, __pos, this->_M_impl._M_finish, this->_M_impl._M_finish, _M_get_Tp_allocator());
                    this->_M_impl._M_finish = __new_finish;
                    std::copy(__first, __mid, __pos);
                }
            }
            catch (...)
            {
                _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1, __new_finish._M_node + 1);
                throw;
            }
        }
    }
    template<typename _Tp, typename _Alloc >
    void deque< _Tp, _Alloc >::_M_destroy_data_aux(iterator __first, iterator __last)
    {
        for (_Map_pointer __node = __first._M_node + 1;
            __node < __last._M_node;
            ++__node)
        std::_Destroy(*__node, *__node + _S_buffer_size(), _M_get_Tp_allocator());
        if (__first._M_node != __last._M_node)
        {
            std::_Destroy(__first._M_cur, __first._M_last, _M_get_Tp_allocator());
            std::_Destroy(__last._M_first, __last._M_cur, _M_get_Tp_allocator());
        }
        else
            std::_Destroy(__first._M_cur, __last._M_cur, _M_get_Tp_allocator());
    }
    template<typename _Tp, typename _Alloc >
    void deque< _Tp, _Alloc >::_M_new_elements_at_front(size_type __new_elems)
    {
        if (this->max_size() - this->size() < __new_elems)
            __throw_length_error(("deque::_M_new_elements_at_front"));
        const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1) / _S_buffer_size());
        _M_reserve_map_at_front(__new_nodes);
        size_type __i;
        try
        {
            for (__i = 1;
                __i <= __new_nodes;
                ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
        catch (...)
        {
            for (size_type __j = 1;
                __j < __i;
                ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
            throw;
        }
    }
    template<typename _Tp, typename _Alloc >
    void deque< _Tp, _Alloc >::_M_new_elements_at_back(size_type __new_elems)
    {
        if (this->max_size() - this->size() < __new_elems)
            __throw_length_error(("deque::_M_new_elements_at_back"));
        const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1) / _S_buffer_size());
        _M_reserve_map_at_back(__new_nodes);
        size_type __i;
        try
        {
            for (__i = 1;
                __i <= __new_nodes;
                ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
        catch (...)
        {
            for (size_type __j = 1;
                __j < __i;
                ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
            throw;
        }
    }
    template<typename _Tp, typename _Alloc >
    void deque< _Tp, _Alloc >::_M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
        const size_type __old_num_nodes = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
        const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;
        _Map_pointer __new_nstart;
        if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
        {
            __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size - __new_num_nodes) / 2 + (__add_at_front ? __nodes_to_add : 0);
            if (__new_nstart < this->_M_impl._M_start._M_node)
                std::copy(this->_M_impl._M_start._M_node, this->_M_impl._M_finish._M_node + 1, __new_nstart);
            else
                std::copy_backward(this->_M_impl._M_start._M_node, this->_M_impl._M_finish._M_node + 1, __new_nstart + __old_num_nodes);
        }
        else
        {
            size_type __new_map_size = this->_M_impl._M_map_size + std::max(this->_M_impl._M_map_size, __nodes_to_add) + 2;
            _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
            __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2 + (__add_at_front ? __nodes_to_add : 0);
            std::copy(this->_M_impl._M_start._M_node, this->_M_impl._M_finish._M_node + 1, __new_nstart);
            _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
            this->_M_impl._M_map = __new_map;
            this->_M_impl._M_map_size = __new_map_size;
        }
        this->_M_impl._M_start._M_set_node(__new_nstart);
        this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }
    template<typename _Tp >
    void fill(const _Deque_iterator< _Tp, _Tp &, _Tp * > & __first, const _Deque_iterator< _Tp, _Tp &, _Tp * > & __last, const _Tp & __value)
    {
        typedef typename _Deque_iterator< _Tp, _Tp &, _Tp * >::_Self _Self;
        for (typename _Self::_Map_pointer __node = __first._M_node + 1;
            __node < __last._M_node;
            ++__node)
        std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);
        if (__first._M_node != __last._M_node)
        {
            std::fill(__first._M_cur, __first._M_last, __value);
            std::fill(__last._M_first, __last._M_cur, __value);
        }
        else
            std::fill(__first._M_cur, __last._M_cur, __value);
    }
}
namespace std __attribute__((__visibility__("default"))) {
    struct _List_node_base
    {
            _List_node_base * _M_next;
            _List_node_base * _M_prev;
            static void swap(_List_node_base & __x, _List_node_base & __y);
            void transfer(_List_node_base *const __first, _List_node_base *const __last);
            void reverse();
            void hook(_List_node_base *const __position);
            void unhook();
    };
    template<typename _Tp >
    struct _List_node : public _List_node_base
    {
            _Tp _M_data;
    };
    template<typename _Tp >
    struct _List_iterator
    {
            typedef _List_iterator< _Tp > _Self;
            typedef _List_node< _Tp > _Node;
            typedef ptrdiff_t difference_type;
            typedef std::bidirectional_iterator_tag iterator_category;
            typedef _Tp value_type;
            typedef _Tp * pointer;
            typedef _Tp & reference;
            _List_iterator()
                : _M_node() 
            {
            }
            explicit _List_iterator(_List_node_base * __x)
                : _M_node(__x) 
            {
            }
            reference operator *() const
            {
                return static_cast<_Node * >(_M_node)->_M_data;
            }
            pointer operator ->() const
            {
                return &static_cast<_Node * >(_M_node)->_M_data;
            }
            _Self & operator ++()
            {
                _M_node = _M_node->_M_next;
                return *this;
            }
            _Self operator ++(int)
            {
                _Self __tmp = *this;
                _M_node = _M_node->_M_next;
                return __tmp;
            }
            _Self & operator --()
            {
                _M_node = _M_node->_M_prev;
                return *this;
            }
            _Self operator --(int)
            {
                _Self __tmp = *this;
                _M_node = _M_node->_M_prev;
                return __tmp;
            }
            bool operator ==(const _Self & __x) const
            {
                return _M_node == __x._M_node;
            }
            bool operator !=(const _Self & __x) const
            {
                return _M_node != __x._M_node;
            }
            _List_node_base * _M_node;
    };
    template<typename _Tp >
    struct _List_const_iterator
    {
            typedef _List_const_iterator< _Tp > _Self;
            typedef const _List_node< _Tp > _Node;
            typedef _List_iterator< _Tp > iterator;
            typedef ptrdiff_t difference_type;
            typedef std::bidirectional_iterator_tag iterator_category;
            typedef _Tp value_type;
            typedef const _Tp * pointer;
            typedef const _Tp & reference;
            _List_const_iterator()
                : _M_node() 
            {
            }
            explicit _List_const_iterator(const _List_node_base * __x)
                : _M_node(__x) 
            {
            }
            _List_const_iterator(const iterator & __x)
                : _M_node(__x._M_node) 
            {
            }
            reference operator *() const
            {
                return static_cast<_Node * >(_M_node)->_M_data;
            }
            pointer operator ->() const
            {
                return &static_cast<_Node * >(_M_node)->_M_data;
            }
            _Self & operator ++()
            {
                _M_node = _M_node->_M_next;
                return *this;
            }
            _Self operator ++(int)
            {
                _Self __tmp = *this;
                _M_node = _M_node->_M_next;
                return __tmp;
            }
            _Self & operator --()
            {
                _M_node = _M_node->_M_prev;
                return *this;
            }
            _Self operator --(int)
            {
                _Self __tmp = *this;
                _M_node = _M_node->_M_prev;
                return __tmp;
            }
            bool operator ==(const _Self & __x) const
            {
                return _M_node == __x._M_node;
            }
            bool operator !=(const _Self & __x) const
            {
                return _M_node != __x._M_node;
            }
            const _List_node_base * _M_node;
    };
    template<typename _Val >
    inline bool operator ==(const _List_iterator< _Val > & __x, const _List_const_iterator< _Val > & __y)
    {
        return __x._M_node == __y._M_node;
    }
    template<typename _Val >
    inline bool operator !=(const _List_iterator< _Val > & __x, const _List_const_iterator< _Val > & __y)
    {
        return __x._M_node != __y._M_node;
    }
    template<typename _Tp, typename _Alloc >
    class _List_base
    {
        protected :
            typedef typename _Alloc::template rebind< _List_node< _Tp > >::other _Node_alloc_type;
            typedef typename _Alloc::template rebind< _Tp >::other _Tp_alloc_type;
            struct _List_impl : public _Node_alloc_type
            {
                    _List_node_base _M_node;
                    _List_impl()
                        : _Node_alloc_type(), _M_node() 
                    {
                    }
                    _List_impl(const _Node_alloc_type & __a)
                        : _Node_alloc_type(__a), _M_node() 
                    {
                    }
            };
            _List_impl _M_impl;
            _List_node< _Tp > * _M_get_node()
            {
                return _M_impl._Node_alloc_type::allocate(1);
            }
            void _M_put_node(_List_node< _Tp > * __p)
            {
                _M_impl._Node_alloc_type::deallocate(__p, 1);
            }
        public :
            typedef _Alloc allocator_type;
            _Node_alloc_type & _M_get_Node_allocator()
            {
                return *static_cast<_Node_alloc_type * >(&this->_M_impl);
            }
            const _Node_alloc_type & _M_get_Node_allocator() const
            {
                return *static_cast<const _Node_alloc_type * >(&this->_M_impl);
            }
            _Tp_alloc_type _M_get_Tp_allocator() const
            {
                return _Tp_alloc_type(_M_get_Node_allocator());
            }
            allocator_type get_allocator() const
            {
                return allocator_type(_M_get_Node_allocator());
            }
            _List_base()
                : _M_impl() 
            {
                _M_init();
            }
            _List_base(const allocator_type & __a)
                : _M_impl(__a) 
            {
                _M_init();
            }
            ~_List_base()
            {
                _M_clear();
            }
            void _M_clear();
            void _M_init()
            {
                this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
                this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
            }
    };
    template<typename _Tp, typename _Alloc = std::allocator< _Tp > >
    class list : protected _List_base< _Tp, _Alloc >
    {
            typedef typename _Alloc::value_type _Alloc_value_type;
            typedef _List_base< _Tp, _Alloc > _Base;
            typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
        public :
            typedef _Tp value_type;
            typedef typename _Tp_alloc_type::pointer pointer;
            typedef typename _Tp_alloc_type::const_pointer const_pointer;
            typedef typename _Tp_alloc_type::reference reference;
            typedef typename _Tp_alloc_type::const_reference const_reference;
            typedef _List_iterator< _Tp > iterator;
            typedef _List_const_iterator< _Tp > const_iterator;
            typedef std::reverse_iterator< const_iterator > const_reverse_iterator;
            typedef std::reverse_iterator< iterator > reverse_iterator;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef _Alloc allocator_type;
        protected :
            typedef _List_node< _Tp > _Node;
            using _Base::_M_impl;
            using _Base::_M_put_node;
            using _Base::_M_get_node;
            using _Base::_M_get_Tp_allocator;
            using _Base::_M_get_Node_allocator;
            _Node * _M_create_node(const value_type & __x)
            {
                _Node * __p = this->_M_get_node();
                try
                {
                    _M_get_Tp_allocator().construct(&__p->_M_data, __x);
                }
                catch (...)
                {
                    _M_put_node(__p);
                    throw;
                }
                return __p;
            }
        public :
            list()
                : _Base() 
            {
            }
            explicit list(const allocator_type & __a)
                : _Base(__a) 
            {
            }
            explicit list(size_type __n, const value_type & __value = value_type(), const allocator_type & __a = allocator_type())
                : _Base(__a) 
            {
                _M_fill_initialize(__n, __value);
            }
            list(const list & __x)
                : _Base(__x._M_get_Node_allocator()) 
            {
                _M_initialize_dispatch(__x.begin(), __x.end(), __false_type());
            }
            template<typename _InputIterator >
            list(_InputIterator __first, _InputIterator __last, const allocator_type & __a = allocator_type())
                : _Base(__a) 
            {
                typedef typename std::__is_integer< _InputIterator >::__type _Integral;
                _M_initialize_dispatch(__first, __last, _Integral());
            }
            list & operator =(const list & __x);
            void assign(size_type __n, const value_type & __val)
            {
                _M_fill_assign(__n, __val);
            }
            template<typename _InputIterator >
            void assign(_InputIterator __first, _InputIterator __last)
            {
                typedef typename std::__is_integer< _InputIterator >::__type _Integral;
                _M_assign_dispatch(__first, __last, _Integral());
            }
            allocator_type get_allocator() const
            {
                return _Base::get_allocator();
            }
            iterator begin()
            {
                return iterator(this->_M_impl._M_node._M_next);
            }
            const_iterator begin() const
            {
                return const_iterator(this->_M_impl._M_node._M_next);
            }
            iterator end()
            {
                return iterator(&this->_M_impl._M_node);
            }
            const_iterator end() const
            {
                return const_iterator(&this->_M_impl._M_node);
            }
            reverse_iterator rbegin()
            {
                return reverse_iterator(end());
            }
            const_reverse_iterator rbegin() const
            {
                return const_reverse_iterator(end());
            }
            reverse_iterator rend()
            {
                return reverse_iterator(begin());
            }
            const_reverse_iterator rend() const
            {
                return const_reverse_iterator(begin());
            }
            bool empty() const
            {
                return this->_M_impl._M_node._M_next == &this->_M_impl._M_node;
            }
            size_type size() const
            {
                return std::distance(begin(), end());
            }
            size_type max_size() const
            {
                return _M_get_Tp_allocator().max_size();
            }
            void resize(size_type __new_size, value_type __x = value_type());
            reference front()
            {
                return *begin();
            }
            const_reference front() const
            {
                return *begin();
            }
            reference back()
            {
                iterator __tmp = end();
                --__tmp;
                return *__tmp;
            }
            const_reference back() const
            {
                const_iterator __tmp = end();
                --__tmp;
                return *__tmp;
            }
            void push_front(const value_type & __x)
            {
                this->_M_insert(begin(), __x);
            }
            void pop_front()
            {
                this->_M_erase(begin());
            }
            void push_back(const value_type & __x)
            {
                this->_M_insert(end(), __x);
            }
            void pop_back()
            {
                this->_M_erase(iterator(this->_M_impl._M_node._M_prev));
            }
            iterator insert(iterator __position, const value_type & __x);
            void insert(iterator __position, size_type __n, const value_type & __x)
            {
                list __tmp(__n, __x, _M_get_Node_allocator());
                splice(__position, __tmp);
            }
            template<typename _InputIterator >
            void insert(iterator __position, _InputIterator __first, _InputIterator __last)
            {
                list __tmp(__first, __last, _M_get_Node_allocator());
                splice(__position, __tmp);
            }
            iterator erase(iterator __position);
            iterator erase(iterator __first, iterator __last)
            {
                while (__first != __last)
                    __first = erase(__first);
                return __last;
            }
            void swap(list & __x)
            {
                _List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node);
                std::__alloc_swap< typename _Base::_Node_alloc_type >::_S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());
            }
            void clear()
            {
                _Base::_M_clear();
                _Base::_M_init();
            }
            void splice(iterator __position, list & __x)
            {
                if (!__x.empty())
                {
                    _M_check_equal_allocators(__x);
                    this->_M_transfer(__position, __x.begin(), __x.end());
                }
            }
            void splice(iterator __position, list & __x, iterator __i)
            {
                iterator __j = __i;
                ++__j;
                if (__position == __i || __position == __j)
                    return;
                if (this != &__x)
                    _M_check_equal_allocators(__x);
                this->_M_transfer(__position, __i, __j);
            }
            void splice(iterator __position, list & __x, iterator __first, iterator __last)
            {
                if (__first != __last)
                {
                    if (this != &__x)
                        _M_check_equal_allocators(__x);
                    this->_M_transfer(__position, __first, __last);
                }
            }
            void remove(const _Tp & __value);
            template<typename _Predicate >
            void remove_if(_Predicate);
            void unique();
            template<typename _BinaryPredicate >
            void unique(_BinaryPredicate);
            void merge(list & __x);
            template<typename _StrictWeakOrdering >
            void merge(list &, _StrictWeakOrdering);
            void reverse()
            {
                this->_M_impl._M_node.reverse();
            }
            void sort();
            template<typename _StrictWeakOrdering >
            void sort(_StrictWeakOrdering);
        protected :
            template<typename _Integer >
            void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
            {
                _M_fill_initialize(static_cast<size_type >(__n), __x);
            }
            template<typename _InputIterator >
            void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last, __false_type)
            {
                for (;
                    __first != __last;
                    ++__first)
                push_back(*__first);
            }
            void _M_fill_initialize(size_type __n, const value_type & __x)
            {
                for (;
                    __n > 0;
                    --__n)
                push_back(__x);
            }
            template<typename _Integer >
            void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
            {
                _M_fill_assign(__n, __val);
            }
            template<typename _InputIterator >
            void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, __false_type);
            void _M_fill_assign(size_type __n, const value_type & __val);
            void _M_transfer(iterator __position, iterator __first, iterator __last)
            {
                __position._M_node->transfer(__first._M_node, __last._M_node);
            }
            void _M_insert(iterator __position, const value_type & __x)
            {
                _Node * __tmp = _M_create_node(__x);
                __tmp->hook(__position._M_node);
            }
            void _M_erase(iterator __position)
            {
                __position._M_node->unhook();
                _Node * __n = static_cast<_Node * >(__position._M_node);
                _M_get_Tp_allocator().destroy(&__n->_M_data);
                _M_put_node(__n);
            }
            void _M_check_equal_allocators(list & __x)
            {
                if (std::__alloc_neq< typename _Base::_Node_alloc_type >::_S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))
                    __throw_runtime_error(("list::_M_check_equal_allocators"));
            }
    };
    template<typename _Tp, typename _Alloc >
    inline bool operator ==(const list< _Tp, _Alloc > & __x, const list< _Tp, _Alloc > & __y)
    {
        typedef typename list< _Tp, _Alloc >::const_iterator const_iterator;
        const_iterator __end1 = __x.end();
        const_iterator __end2 = __y.end();
        const_iterator __i1 = __x.begin();
        const_iterator __i2 = __y.begin();
        while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
        {
            ++__i1;
            ++__i2;
        }
        return __i1 == __end1 && __i2 == __end2;
    }
    template<typename _Tp, typename _Alloc >
    inline bool operator <(const list< _Tp, _Alloc > & __x, const list< _Tp, _Alloc > & __y)
    {
        return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
    }
    template<typename _Tp, typename _Alloc >
    inline bool operator !=(const list< _Tp, _Alloc > & __x, const list< _Tp, _Alloc > & __y)
    {
        return !(__x == __y);
    }
    template<typename _Tp, typename _Alloc >
    inline bool operator >(const list< _Tp, _Alloc > & __x, const list< _Tp, _Alloc > & __y)
    {
        return __y < __x;
    }
    template<typename _Tp, typename _Alloc >
    inline bool operator <=(const list< _Tp, _Alloc > & __x, const list< _Tp, _Alloc > & __y)
    {
        return !(__y < __x);
    }
    template<typename _Tp, typename _Alloc >
    inline bool operator >=(const list< _Tp, _Alloc > & __x, const list< _Tp, _Alloc > & __y)
    {
        return !(__x < __y);
    }
    template<typename _Tp, typename _Alloc >
    inline void swap(list< _Tp, _Alloc > & __x, list< _Tp, _Alloc > & __y)
    {
        __x.swap(__y);
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Tp, typename _Alloc >
    void _List_base< _Tp, _Alloc >::_M_clear()
    {
        typedef _List_node< _Tp > _Node;
        _Node * __cur = static_cast<_Node * >(this->_M_impl._M_node._M_next);
        while (__cur != &this->_M_impl._M_node)
        {
            _Node * __tmp = __cur;
            __cur = static_cast<_Node * >(__cur->_M_next);
            _M_get_Tp_allocator().destroy(&__tmp->_M_data);
            _M_put_node(__tmp);
        }
    }
    template<typename _Tp, typename _Alloc >
    typename list< _Tp, _Alloc >::iterator list< _Tp, _Alloc >::insert(iterator __position, const value_type & __x)
    {
        _Node * __tmp = _M_create_node(__x);
        __tmp->hook(__position._M_node);
        return iterator(__tmp);
    }
    template<typename _Tp, typename _Alloc >
    typename list< _Tp, _Alloc >::iterator list< _Tp, _Alloc >::erase(iterator __position)
    {
        iterator __ret = iterator(__position._M_node->_M_next);
        _M_erase(__position);
        return __ret;
    }
    template<typename _Tp, typename _Alloc >
    void list< _Tp, _Alloc >::resize(size_type __new_size, value_type __x)
    {
        iterator __i = begin();
        size_type __len = 0;
        for (;
            __i != end() && __len < __new_size;
            ++__i , ++__len)
        ;
        if (__len == __new_size)
            erase(__i, end());
        else
            insert(end(), __new_size - __len, __x);
    }
    template<typename _Tp, typename _Alloc >
    list< _Tp, _Alloc > & list< _Tp, _Alloc >::operator =(const list & __x)
    {
        if (this != &__x)
        {
            iterator __first1 = begin();
            iterator __last1 = end();
            const_iterator __first2 = __x.begin();
            const_iterator __last2 = __x.end();
            for (;
                __first1 != __last1 && __first2 != __last2;
                ++__first1 , ++__first2)
            *__first1 = *__first2;
            if (__first2 == __last2)
                erase(__first1, __last1);
            else
                insert(__last1, __first2, __last2);
        }
        return *this;
    }
    template<typename _Tp, typename _Alloc >
    void list< _Tp, _Alloc >::_M_fill_assign(size_type __n, const value_type & __val)
    {
        iterator __i = begin();
        for (;
            __i != end() && __n > 0;
            ++__i , --__n)
        *__i = __val;
        if (__n > 0)
            insert(end(), __n, __val);
        else
            erase(__i, end());
    }
    template<typename _Tp, typename _Alloc >
    template<typename _InputIterator >
    void list< _Tp, _Alloc >::_M_assign_dispatch(_InputIterator __first2, _InputIterator __last2, __false_type)
    {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (;
            __first1 != __last1 && __first2 != __last2;
            ++__first1 , ++__first2)
        *__first1 = *__first2;
        if (__first2 == __last2)
            erase(__first1, __last1);
        else
            insert(__last1, __first2, __last2);
    }
    template<typename _Tp, typename _Alloc >
    void list< _Tp, _Alloc >::remove(const value_type & __value)
    {
        iterator __first = begin();
        iterator __last = end();
        iterator __extra = __last;
        while (__first != __last)
        {
            iterator __next = __first;
            ++__next;
            if (*__first == __value)
            {
                if (&*__first != &__value)
                    _M_erase(__first);
                else
                    __extra = __first;
            }
            __first = __next;
        }
        if (__extra != __last)
            _M_erase(__extra);
    }
    template<typename _Tp, typename _Alloc >
    void list< _Tp, _Alloc >::unique()
    {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
            return;
        iterator __next = __first;
        while (++__next != __last)
        {
            if (*__first == *__next)
                _M_erase(__next);
            else
                __first = __next;
            __next = __first;
        }
    }
    template<typename _Tp, typename _Alloc >
    void list< _Tp, _Alloc >::merge(list & __x)
    {
        if (this != &__x)
        {
            _M_check_equal_allocators(__x);
            iterator __first1 = begin();
            iterator __last1 = end();
            iterator __first2 = __x.begin();
            iterator __last2 = __x.end();
            while (__first1 != __last1 && __first2 != __last2)
                if (*__first2 < *__first1)
                {
                    iterator __next = __first2;
                    _M_transfer(__first1, __first2, ++__next);
                    __first2 = __next;
                }
                else
                    ++__first1;
            if (__first2 != __last2)
                _M_transfer(__last1, __first2, __last2);
        }
    }
    template<typename _Tp, typename _Alloc >
    template<typename _StrictWeakOrdering >
    void list< _Tp, _Alloc >::merge(list & __x, _StrictWeakOrdering __comp)
    {
        if (this != &__x)
        {
            _M_check_equal_allocators(__x);
            iterator __first1 = begin();
            iterator __last1 = end();
            iterator __first2 = __x.begin();
            iterator __last2 = __x.end();
            while (__first1 != __last1 && __first2 != __last2)
                if (__comp(*__first2, *__first1))
                {
                    iterator __next = __first2;
                    _M_transfer(__first1, __first2, ++__next);
                    __first2 = __next;
                }
                else
                    ++__first1;
            if (__first2 != __last2)
                _M_transfer(__last1, __first2, __last2);
        }
    }
    template<typename _Tp, typename _Alloc >
    void list< _Tp, _Alloc >::sort()
    {
        if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
        {
            list __carry;
            list __tmp[64];
            list * __fill = &__tmp[0];
            list * __counter;
            do
            {
                __carry.splice(__carry.begin(), *this, begin());
                for (__counter = &__tmp[0];
                    __counter != __fill && !__counter->empty();
                    ++__counter)
                {
                    __counter->merge(__carry);
                    __carry.swap(*__counter);
                }
                __carry.swap(*__counter);
                if (__counter == __fill)
                    ++__fill;
            }
            while (!empty());
            for (__counter = &__tmp[1];
                __counter != __fill;
                ++__counter)
            __counter->merge(*(__counter - 1));
            swap(*(__fill - 1));
        }
    }
    template<typename _Tp, typename _Alloc >
    template<typename _Predicate >
    void list< _Tp, _Alloc >::remove_if(_Predicate __pred)
    {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
        {
            iterator __next = __first;
            ++__next;
            if (__pred(*__first))
                _M_erase(__first);
            __first = __next;
        }
    }
    template<typename _Tp, typename _Alloc >
    template<typename _BinaryPredicate >
    void list< _Tp, _Alloc >::unique(_BinaryPredicate __binary_pred)
    {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
            return;
        iterator __next = __first;
        while (++__next != __last)
        {
            if (__binary_pred(*__first, *__next))
                _M_erase(__next);
            else
                __first = __next;
            __next = __first;
        }
    }
    template<typename _Tp, typename _Alloc >
    template<typename _StrictWeakOrdering >
    void list< _Tp, _Alloc >::sort(_StrictWeakOrdering __comp)
    {
        if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
        {
            list __carry;
            list __tmp[64];
            list * __fill = &__tmp[0];
            list * __counter;
            do
            {
                __carry.splice(__carry.begin(), *this, begin());
                for (__counter = &__tmp[0];
                    __counter != __fill && !__counter->empty();
                    ++__counter)
                {
                    __counter->merge(__carry, __comp);
                    __carry.swap(*__counter);
                }
                __carry.swap(*__counter);
                if (__counter == __fill)
                    ++__fill;
            }
            while (!empty());
            for (__counter = &__tmp[1];
                __counter != __fill;
                ++__counter)
            __counter->merge(*(__counter - 1), __comp);
            swap(*(__fill - 1));
        }
    }
}
extern "C"
{
    typedef signed char gint8;
    typedef unsigned char guint8;
    typedef signed short gint16;
    typedef unsigned short guint16;
    typedef signed int gint32;
    typedef unsigned int guint32;
    typedef signed long gint64;
    typedef unsigned long guint64;
    typedef signed long gssize;
    typedef unsigned long gsize;
    typedef gint64 goffset;
    typedef struct _GStaticMutex GStaticMutex;
    struct _GStaticMutex
    {
            struct _GMutex * runtime_mutex;
            union 
            {
                    char pad[40];
                    double dummy_double;
                    void * dummy_pointer;
                    long dummy_long;
            } static_mutex;
    };
    typedef union _GSystemThread GSystemThread;
    union _GSystemThread
    {
            char data[8];
            double dummy_double;
            void * dummy_pointer;
            long dummy_long;
    };
    typedef int GPid;
}
extern "C"
{
    typedef char gchar;
    typedef short gshort;
    typedef long glong;
    typedef int gint;
    typedef gint gboolean;
    typedef unsigned char guchar;
    typedef unsigned short gushort;
    typedef unsigned long gulong;
    typedef unsigned int guint;
    typedef float gfloat;
    typedef double gdouble;
    typedef void * gpointer;
    typedef const void * gconstpointer;
    typedef gint (* GCompareFunc)(gconstpointer a, gconstpointer b);
    typedef gint (* GCompareDataFunc)(gconstpointer a, gconstpointer b, gpointer user_data);
    typedef gboolean (* GEqualFunc)(gconstpointer a, gconstpointer b);
    typedef void (* GDestroyNotify)(gpointer data);
    typedef void (* GFunc)(gpointer data, gpointer user_data);
    typedef guint (* GHashFunc)(gconstpointer key);
    typedef void (* GHFunc)(gpointer key, gpointer value, gpointer user_data);
    typedef void (* GFreeFunc)(gpointer data);
    typedef const gchar * (* GTranslateFunc)(const gchar * str, gpointer data);
    typedef union _GDoubleIEEE754 GDoubleIEEE754;
    typedef union _GFloatIEEE754 GFloatIEEE754;
    union _GFloatIEEE754
    {
            gfloat v_float;
            struct 
            {
                    guint mantissa : 23;
                    guint biased_exponent : 8;
                    guint sign : 1;
            } mpn;
    };
    union _GDoubleIEEE754
    {
            gdouble v_double;
            struct 
            {
                    guint mantissa_low : 32;
                    guint mantissa_high : 20;
                    guint biased_exponent : 11;
                    guint sign : 1;
            } mpn;
    };
    typedef struct _GTimeVal GTimeVal;
    struct _GTimeVal
    {
            glong tv_sec;
            glong tv_usec;
    };
}
extern "C"
{
    typedef struct _GArray GArray;
    typedef struct _GByteArray GByteArray;
    typedef struct _GPtrArray GPtrArray;
    struct _GArray
    {
            gchar * data;
            guint len;
    };
    struct _GByteArray
    {
            guint8 * data;
            guint len;
    };
    struct _GPtrArray
    {
            gpointer * pdata;
            guint len;
    };
    GArray * g_array_new(gboolean zero_terminated, gboolean clear_, guint element_size);
    GArray * g_array_sized_new(gboolean zero_terminated, gboolean clear_, guint element_size, guint reserved_size);
    gchar * g_array_free(GArray * array, gboolean free_segment);
    GArray * g_array_append_vals(GArray * array, gconstpointer data, guint len);
    GArray * g_array_prepend_vals(GArray * array, gconstpointer data, guint len);
    GArray * g_array_insert_vals(GArray * array, guint index_, gconstpointer data, guint len);
    GArray * g_array_set_size(GArray * array, guint length);
    GArray * g_array_remove_index(GArray * array, guint index_);
    GArray * g_array_remove_index_fast(GArray * array, guint index_);
    GArray * g_array_remove_range(GArray * array, guint index_, guint length);
    void g_array_sort(GArray * array, GCompareFunc compare_func);
    void g_array_sort_with_data(GArray * array, GCompareDataFunc compare_func, gpointer user_data);
    GPtrArray * g_ptr_array_new(void);
    GPtrArray * g_ptr_array_sized_new(guint reserved_size);
    gpointer * g_ptr_array_free(GPtrArray * array, gboolean free_seg);
    void g_ptr_array_set_size(GPtrArray * array, gint length);
    gpointer g_ptr_array_remove_index(GPtrArray * array, guint index_);
    gpointer g_ptr_array_remove_index_fast(GPtrArray * array, guint index_);
    gboolean g_ptr_array_remove(GPtrArray * array, gpointer data);
    gboolean g_ptr_array_remove_fast(GPtrArray * array, gpointer data);
    void g_ptr_array_remove_range(GPtrArray * array, guint index_, guint length);
    void g_ptr_array_add(GPtrArray * array, gpointer data);
    void g_ptr_array_sort(GPtrArray * array, GCompareFunc compare_func);
    void g_ptr_array_sort_with_data(GPtrArray * array, GCompareDataFunc compare_func, gpointer user_data);
    void g_ptr_array_foreach(GPtrArray * array, GFunc func, gpointer user_data);
    GByteArray * g_byte_array_new(void);
    GByteArray * g_byte_array_sized_new(guint reserved_size);
    guint8 * g_byte_array_free(GByteArray * array, gboolean free_segment);
    GByteArray * g_byte_array_append(GByteArray * array, const guint8 * data, guint len);
    GByteArray * g_byte_array_prepend(GByteArray * array, const guint8 * data, guint len);
    GByteArray * g_byte_array_set_size(GByteArray * array, guint length);
    GByteArray * g_byte_array_remove_index(GByteArray * array, guint index_);
    GByteArray * g_byte_array_remove_index_fast(GByteArray * array, guint index_);
    GByteArray * g_byte_array_remove_range(GByteArray * array, guint index_, guint length);
    void g_byte_array_sort(GByteArray * array, GCompareFunc compare_func);
    void g_byte_array_sort_with_data(GByteArray * array, GCompareDataFunc compare_func, gpointer user_data);
}
extern "C"
{
    typedef guint32 GQuark;
    GQuark g_quark_try_string(const gchar * string);
    GQuark g_quark_from_static_string(const gchar * string);
    GQuark g_quark_from_string(const gchar * string);
    const gchar * g_quark_to_string(GQuark quark) __attribute__((__const__));
    const gchar * g_intern_string(const gchar * string);
    const gchar * g_intern_static_string(const gchar * string);
}
extern "C"
{
    typedef struct _GError GError;
    struct _GError
    {
            GQuark domain;
            gint code;
            gchar * message;
    };
    GError * g_error_new(GQuark domain, gint code, const gchar * format, ...) __attribute__((__format__(__printf__, 3, 4)));
    GError * g_error_new_literal(GQuark domain, gint code, const gchar * message);
    void g_error_free(GError * error);
    GError * g_error_copy(const GError * error);
    gboolean g_error_matches(const GError * error, GQuark domain, gint code);
    void g_set_error(GError * * err, GQuark domain, gint code, const gchar * format, ...) __attribute__((__format__(__printf__, 4, 5)));
    void g_propagate_error(GError * * dest, GError * src);
    void g_clear_error(GError * * err);
    void g_prefix_error(GError * * err, const gchar * format, ...) __attribute__((__format__(__printf__, 2, 3)));
    void g_propagate_prefixed_error(GError * * dest, GError * src, const gchar * format, ...) __attribute__((__format__(__printf__, 3, 4)));
}
extern "C"
{
    const gchar * g_get_user_name(void);
    const gchar * g_get_real_name(void);
    const gchar * g_get_home_dir(void);
    const gchar * g_get_tmp_dir(void);
    const gchar * g_get_host_name(void);
    gchar * g_get_prgname(void);
    void g_set_prgname(const gchar * prgname);
    const gchar * g_get_application_name(void);
    void g_set_application_name(const gchar * application_name);
    const gchar * g_get_user_data_dir(void);
    const gchar * g_get_user_config_dir(void);
    const gchar * g_get_user_cache_dir(void);
    const gchar *const * g_get_system_data_dirs(void);
    const gchar *const * g_get_system_config_dirs(void);
    const gchar *const * g_get_language_names(void);
    typedef enum 
    {
        G_USER_DIRECTORY_DESKTOP, 
        G_USER_DIRECTORY_DOCUMENTS, 
        G_USER_DIRECTORY_DOWNLOAD, 
        G_USER_DIRECTORY_MUSIC, 
        G_USER_DIRECTORY_PICTURES, 
        G_USER_DIRECTORY_PUBLIC_SHARE, 
        G_USER_DIRECTORY_TEMPLATES, 
        G_USER_DIRECTORY_VIDEOS, 
        G_USER_N_DIRECTORIES
    } GUserDirectory;
    const gchar * g_get_user_special_dir(GUserDirectory directory);
    typedef struct _GDebugKey GDebugKey;
    struct _GDebugKey
    {
            gchar * key;
            guint value;
    };
    guint g_parse_debug_string(const gchar * string, const GDebugKey * keys, guint nkeys);
    gint g_snprintf(gchar * string, gulong n, gchar const * format, ...) __attribute__((__format__(__printf__, 3, 4)));
    gint g_vsnprintf(gchar * string, gulong n, gchar const * format, va_list args);
    gboolean g_path_is_absolute(const gchar * file_name);
    const gchar * g_path_skip_root(const gchar * file_name);
    const gchar * g_basename(const gchar * file_name);
    gchar * g_get_current_dir(void);
    gchar * g_path_get_basename(const gchar * file_name) __attribute__((__malloc__));
    gchar * g_path_get_dirname(const gchar * file_name) __attribute__((__malloc__));
    void g_nullify_pointer(gpointer * nullify_location);
    const gchar * g_getenv(const gchar * variable);
    gboolean g_setenv(const gchar * variable, const gchar * value, gboolean overwrite);
    void g_unsetenv(const gchar * variable);
    gchar * * g_listenv(void);
    const gchar * _g_getenv_nomalloc(const gchar * variable, gchar buffer[1024]);
    typedef void (* GVoidFunc)(void);
    void g_atexit(GVoidFunc func);
    gchar * g_find_program_in_path(const gchar * program);
    extern inline __attribute__((__gnu_inline__)) gint g_bit_nth_lsf(gulong mask, gint nth_bit) __attribute__((__const__));
    extern inline __attribute__((__gnu_inline__)) gint g_bit_nth_msf(gulong mask, gint nth_bit) __attribute__((__const__));
    extern inline __attribute__((__gnu_inline__)) guint g_bit_storage(gulong number) __attribute__((__const__));
    typedef struct _GTrashStack GTrashStack;
    struct _GTrashStack
    {
            GTrashStack * next;
    };
    extern inline __attribute__((__gnu_inline__)) void g_trash_stack_push(GTrashStack * * stack_p, gpointer data_p);
    extern inline __attribute__((__gnu_inline__)) gpointer g_trash_stack_pop(GTrashStack * * stack_p);
    extern inline __attribute__((__gnu_inline__)) gpointer g_trash_stack_peek(GTrashStack * * stack_p);
    extern inline __attribute__((__gnu_inline__)) guint g_trash_stack_height(GTrashStack * * stack_p);
    extern inline __attribute__((__gnu_inline__)) gint g_bit_nth_lsf(gulong mask, gint nth_bit)
    {
        if ((nth_bit < -1))
            nth_bit = -1;
        while (nth_bit < ((8 * 8) - 1))
        {
            nth_bit++;
            if (mask & (1UL << nth_bit))
                return nth_bit;
        }
        return -1;
    }
    extern inline __attribute__((__gnu_inline__)) gint g_bit_nth_msf(gulong mask, gint nth_bit)
    {
        if (nth_bit < 0 || (nth_bit > 8 * 8))
            nth_bit = 8 * 8;
        while (nth_bit > 0)
        {
            nth_bit--;
            if (mask & (1UL << nth_bit))
                return nth_bit;
        }
        return -1;
    }
    extern inline __attribute__((__gnu_inline__)) guint g_bit_storage(gulong number)
    {
        register guint n_bits = 0;
        do
        {
            n_bits++;
            number >>= 1;
        }
        while (number);
        return n_bits;
    }
    extern inline __attribute__((__gnu_inline__)) void g_trash_stack_push(GTrashStack * * stack_p, gpointer data_p)
    {
        GTrashStack * data = (GTrashStack *) data_p;
        data->next = *stack_p;
        *stack_p = data;
    }
    extern inline __attribute__((__gnu_inline__)) gpointer g_trash_stack_pop(GTrashStack * * stack_p)
    {
        GTrashStack * data;
        data = *stack_p;
        if (data)
        {
            *stack_p = data->next;
            data->next = __null;
        }
        return data;
    }
    extern inline __attribute__((__gnu_inline__)) gpointer g_trash_stack_peek(GTrashStack * * stack_p)
    {
        GTrashStack * data;
        data = *stack_p;
        return data;
    }
    extern inline __attribute__((__gnu_inline__)) guint g_trash_stack_height(GTrashStack * * stack_p)
    {
        GTrashStack * data;
        guint i = 0;
        for (data = *stack_p;
            data;
            data = data->next)
        i++;
        return i;
    }
    extern const guint glib_major_version;
    extern const guint glib_minor_version;
    extern const guint glib_micro_version;
    extern const guint glib_interface_age;
    extern const guint glib_binary_age;
    const gchar * glib_check_version(guint required_major, guint required_minor, guint required_micro);
}
extern "C"
{
    gint g_atomic_int_exchange_and_add(volatile gint * atomic, gint val);
    void g_atomic_int_add(volatile gint * atomic, gint val);
    gboolean g_atomic_int_compare_and_exchange(volatile gint * atomic, gint oldval, gint newval);
    gboolean g_atomic_pointer_compare_and_exchange(volatile gpointer * atomic, gpointer oldval, gpointer newval);
    gint g_atomic_int_get(volatile gint * atomic);
    void g_atomic_int_set(volatile gint * atomic, gint newval);
    gpointer g_atomic_pointer_get(volatile gpointer * atomic);
    void g_atomic_pointer_set(volatile gpointer * atomic, gpointer newval);
}
extern "C"
{
    extern GQuark g_thread_error_quark(void);
    typedef enum 
    {
        G_THREAD_ERROR_AGAIN
    } GThreadError;
    typedef gpointer (* GThreadFunc)(gpointer data);
    typedef enum 
    {
        G_THREAD_PRIORITY_LOW, 
        G_THREAD_PRIORITY_NORMAL, 
        G_THREAD_PRIORITY_HIGH, 
        G_THREAD_PRIORITY_URGENT
    } GThreadPriority;
    typedef struct _GThread GThread;
    struct _GThread
    {
            GThreadFunc func;
            gpointer data;
            gboolean joinable;
            GThreadPriority priority;
    };
    typedef struct _GMutex GMutex;
    typedef struct _GCond GCond;
    typedef struct _GPrivate GPrivate;
    typedef struct _GStaticPrivate GStaticPrivate;
    typedef struct _GThreadFunctions GThreadFunctions;
    struct _GThreadFunctions
    {
            GMutex * (* mutex_new)(void);
            void (* mutex_lock)(GMutex * mutex);
            gboolean (* mutex_trylock)(GMutex * mutex);
            void (* mutex_unlock)(GMutex * mutex);
            void (* mutex_free)(GMutex * mutex);
            GCond * (* cond_new)(void);
            void (* cond_signal)(GCond * cond);
            void (* cond_broadcast)(GCond * cond);
            void (* cond_wait)(GCond * cond, GMutex * mutex);
            gboolean (* cond_timed_wait)(GCond * cond, GMutex * mutex, GTimeVal * end_time);
            void (* cond_free)(GCond * cond);
            GPrivate * (* private_new)(GDestroyNotify destructor);
            gpointer (* private_get)(GPrivate * private_key);
            void (* private_set)(GPrivate * private_key, gpointer data);
            void (* thread_create)(GThreadFunc func, gpointer data, gulong stack_size, gboolean joinable, gboolean bound, GThreadPriority priority, gpointer thread, GError * * error);
            void (* thread_yield)(void);
            void (* thread_join)(gpointer thread);
            void (* thread_exit)(void);
            void (* thread_set_priority)(gpointer thread, GThreadPriority priority);
            void (* thread_self)(gpointer thread);
            gboolean (* thread_equal)(gpointer thread1, gpointer thread2);
    };
    extern GThreadFunctions g_thread_functions_for_glib_use;
    extern gboolean g_thread_use_default_impl;
    extern gboolean g_threads_got_initialized;
    extern guint64 (* g_thread_gettime)(void);
    void g_thread_init(GThreadFunctions * vtable);
    void g_thread_init_with_errorcheck_mutexes(GThreadFunctions * vtable);
    GMutex * g_static_mutex_get_mutex_impl(GMutex * * mutex);
    GThread * g_thread_create_full(GThreadFunc func, gpointer data, gulong stack_size, gboolean joinable, gboolean bound, GThreadPriority priority, GError * * error);
    GThread * g_thread_self(void);
    void g_thread_exit(gpointer retval);
    gpointer g_thread_join(GThread * thread);
    void g_thread_set_priority(GThread * thread, GThreadPriority priority);
    void g_static_mutex_init(GStaticMutex * mutex);
    void g_static_mutex_free(GStaticMutex * mutex);
    struct _GStaticPrivate
    {
            guint index;
    };
    void g_static_private_init(GStaticPrivate * private_key);
    gpointer g_static_private_get(GStaticPrivate * private_key);
    void g_static_private_set(GStaticPrivate * private_key, gpointer data, GDestroyNotify notify);
    void g_static_private_free(GStaticPrivate * private_key);
    typedef struct _GStaticRecMutex GStaticRecMutex;
    struct _GStaticRecMutex
    {
            GStaticMutex mutex;
            guint depth;
            GSystemThread owner;
    };
    void g_static_rec_mutex_init(GStaticRecMutex * mutex);
    void g_static_rec_mutex_lock(GStaticRecMutex * mutex);
    gboolean g_static_rec_mutex_trylock(GStaticRecMutex * mutex);
    void g_static_rec_mutex_unlock(GStaticRecMutex * mutex);
    void g_static_rec_mutex_lock_full(GStaticRecMutex * mutex, guint depth);
    guint g_static_rec_mutex_unlock_full(GStaticRecMutex * mutex);
    void g_static_rec_mutex_free(GStaticRecMutex * mutex);
    typedef struct _GStaticRWLock GStaticRWLock;
    struct _GStaticRWLock
    {
            GStaticMutex mutex;
            GCond * read_cond;
            GCond * write_cond;
            guint read_counter;
            gboolean have_writer;
            guint want_to_read;
            guint want_to_write;
    };
    void g_static_rw_lock_init(GStaticRWLock * lock);
    void g_static_rw_lock_reader_lock(GStaticRWLock * lock);
    gboolean g_static_rw_lock_reader_trylock(GStaticRWLock * lock);
    void g_static_rw_lock_reader_unlock(GStaticRWLock * lock);
    void g_static_rw_lock_writer_lock(GStaticRWLock * lock);
    gboolean g_static_rw_lock_writer_trylock(GStaticRWLock * lock);
    void g_static_rw_lock_writer_unlock(GStaticRWLock * lock);
    void g_static_rw_lock_free(GStaticRWLock * lock);
    void g_thread_foreach(GFunc thread_func, gpointer user_data);
    typedef enum 
    {
        G_ONCE_STATUS_NOTCALLED, 
        G_ONCE_STATUS_PROGRESS, 
        G_ONCE_STATUS_READY
    } GOnceStatus;
    typedef struct _GOnce GOnce;
    struct _GOnce
    {
            volatile GOnceStatus status;
            volatile gpointer retval;
    };
    gpointer g_once_impl(GOnce * once, GThreadFunc func, gpointer arg);
    extern inline __attribute__((__gnu_inline__)) gboolean g_once_init_enter(volatile gsize * value_location);
    gboolean g_once_init_enter_impl(volatile gsize * value_location);
    void g_once_init_leave(volatile gsize * value_location, gsize initialization_value);
    extern inline __attribute__((__gnu_inline__)) gboolean g_once_init_enter(volatile gsize * value_location)
    {
        if ((*((void *volatile*) value_location)) != __null)
            return (0);
        else
            return g_once_init_enter_impl(value_location);
    }
    extern void glib_dummy_decl(void);
}
extern "C"
{
    typedef struct _GAsyncQueue GAsyncQueue;
    GAsyncQueue * g_async_queue_new(void);
    GAsyncQueue * g_async_queue_new_full(GDestroyNotify item_free_func);
    void g_async_queue_lock(GAsyncQueue * queue);
    void g_async_queue_unlock(GAsyncQueue * queue);
    GAsyncQueue * g_async_queue_ref(GAsyncQueue * queue);
    void g_async_queue_unref(GAsyncQueue * queue);
    void g_async_queue_ref_unlocked(GAsyncQueue * queue);
    void g_async_queue_unref_and_unlock(GAsyncQueue * queue);
    void g_async_queue_push(GAsyncQueue * queue, gpointer data);
    void g_async_queue_push_unlocked(GAsyncQueue * queue, gpointer data);
    void g_async_queue_push_sorted(GAsyncQueue * queue, gpointer data, GCompareDataFunc func, gpointer user_data);
    void g_async_queue_push_sorted_unlocked(GAsyncQueue * queue, gpointer data, GCompareDataFunc func, gpointer user_data);
    gpointer g_async_queue_pop(GAsyncQueue * queue);
    gpointer g_async_queue_pop_unlocked(GAsyncQueue * queue);
    gpointer g_async_queue_try_pop(GAsyncQueue * queue);
    gpointer g_async_queue_try_pop_unlocked(GAsyncQueue * queue);
    gpointer g_async_queue_timed_pop(GAsyncQueue * queue, GTimeVal * end_time);
    gpointer g_async_queue_timed_pop_unlocked(GAsyncQueue * queue, GTimeVal * end_time);
    gint g_async_queue_length(GAsyncQueue * queue);
    gint g_async_queue_length_unlocked(GAsyncQueue * queue);
    void g_async_queue_sort(GAsyncQueue * queue, GCompareDataFunc func, gpointer user_data);
    void g_async_queue_sort_unlocked(GAsyncQueue * queue, GCompareDataFunc func, gpointer user_data);
    GMutex * _g_async_queue_get_mutex(GAsyncQueue * queue);
}
extern "C"
{
    void g_on_error_query(const gchar * prg_name);
    void g_on_error_stack_trace(const gchar * prg_name);
}
extern "C"
{
    gsize g_base64_encode_step(const guchar * in, gsize len, gboolean break_lines, gchar * out, gint * state, gint * save);
    gsize g_base64_encode_close(gboolean break_lines, gchar * out, gint * state, gint * save);
    gchar * g_base64_encode(const guchar * data, gsize len) __attribute__((__malloc__));
    gsize g_base64_decode_step(const gchar * in, gsize len, guchar * out, gint * state, guint * save);
    guchar * g_base64_decode(const gchar * text, gsize * out_len) __attribute__((__malloc__));
}
extern "C"
{
    typedef enum 
    {
        G_BOOKMARK_FILE_ERROR_INVALID_URI, 
        G_BOOKMARK_FILE_ERROR_INVALID_VALUE, 
        G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED, 
        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND, 
        G_BOOKMARK_FILE_ERROR_READ, 
        G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING, 
        G_BOOKMARK_FILE_ERROR_WRITE, 
        G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND
    } GBookmarkFileError;
    GQuark g_bookmark_file_error_quark(void);
    typedef struct _GBookmarkFile GBookmarkFile;
    GBookmarkFile * g_bookmark_file_new(void);
    void g_bookmark_file_free(GBookmarkFile * bookmark);
    gboolean g_bookmark_file_load_from_file(GBookmarkFile * bookmark, const gchar * filename, GError * * error);
    gboolean g_bookmark_file_load_from_data(GBookmarkFile * bookmark, const gchar * data, gsize length, GError * * error);
    gboolean g_bookmark_file_load_from_data_dirs(GBookmarkFile * bookmark, const gchar * file, gchar * * full_path, GError * * error);
    gchar * g_bookmark_file_to_data(GBookmarkFile * bookmark, gsize * length, GError * * error) __attribute__((__malloc__));
    gboolean g_bookmark_file_to_file(GBookmarkFile * bookmark, const gchar * filename, GError * * error);
    void g_bookmark_file_set_title(GBookmarkFile * bookmark, const gchar * uri, const gchar * title);
    gchar * g_bookmark_file_get_title(GBookmarkFile * bookmark, const gchar * uri, GError * * error) __attribute__((__malloc__));
    void g_bookmark_file_set_description(GBookmarkFile * bookmark, const gchar * uri, const gchar * description);
    gchar * g_bookmark_file_get_description(GBookmarkFile * bookmark, const gchar * uri, GError * * error) __attribute__((__malloc__));
    void g_bookmark_file_set_mime_type(GBookmarkFile * bookmark, const gchar * uri, const gchar * mime_type);
    gchar * g_bookmark_file_get_mime_type(GBookmarkFile * bookmark, const gchar * uri, GError * * error) __attribute__((__malloc__));
    void g_bookmark_file_set_groups(GBookmarkFile * bookmark, const gchar * uri, const gchar * * groups, gsize length);
    void g_bookmark_file_add_group(GBookmarkFile * bookmark, const gchar * uri, const gchar * group);
    gboolean g_bookmark_file_has_group(GBookmarkFile * bookmark, const gchar * uri, const gchar * group, GError * * error);
    gchar * * g_bookmark_file_get_groups(GBookmarkFile * bookmark, const gchar * uri, gsize * length, GError * * error) __attribute__((__malloc__));
    void g_bookmark_file_add_application(GBookmarkFile * bookmark, const gchar * uri, const gchar * name, const gchar * exec);
    gboolean g_bookmark_file_has_application(GBookmarkFile * bookmark, const gchar * uri, const gchar * name, GError * * error);
    gchar * * g_bookmark_file_get_applications(GBookmarkFile * bookmark, const gchar * uri, gsize * length, GError * * error) __attribute__((__malloc__));
    gboolean g_bookmark_file_set_app_info(GBookmarkFile * bookmark, const gchar * uri, const gchar * name, const gchar * exec, gint count, time_t stamp, GError * * error);
    gboolean g_bookmark_file_get_app_info(GBookmarkFile * bookmark, const gchar * uri, const gchar * name, gchar * * exec, guint * count, time_t * stamp, GError * * error);
    void g_bookmark_file_set_is_private(GBookmarkFile * bookmark, const gchar * uri, gboolean is_private);
    gboolean g_bookmark_file_get_is_private(GBookmarkFile * bookmark, const gchar * uri, GError * * error);
    void g_bookmark_file_set_icon(GBookmarkFile * bookmark, const gchar * uri, const gchar * href, const gchar * mime_type);
    gboolean g_bookmark_file_get_icon(GBookmarkFile * bookmark, const gchar * uri, gchar * * href, gchar * * mime_type, GError * * error);
    void g_bookmark_file_set_added(GBookmarkFile * bookmark, const gchar * uri, time_t added);
    time_t g_bookmark_file_get_added(GBookmarkFile * bookmark, const gchar * uri, GError * * error);
    void g_bookmark_file_set_modified(GBookmarkFile * bookmark, const gchar * uri, time_t modified);
    time_t g_bookmark_file_get_modified(GBookmarkFile * bookmark, const gchar * uri, GError * * error);
    void g_bookmark_file_set_visited(GBookmarkFile * bookmark, const gchar * uri, time_t visited);
    time_t g_bookmark_file_get_visited(GBookmarkFile * bookmark, const gchar * uri, GError * * error);
    gboolean g_bookmark_file_has_item(GBookmarkFile * bookmark, const gchar * uri);
    gint g_bookmark_file_get_size(GBookmarkFile * bookmark);
    gchar * * g_bookmark_file_get_uris(GBookmarkFile * bookmark, gsize * length) __attribute__((__malloc__));
    gboolean g_bookmark_file_remove_group(GBookmarkFile * bookmark, const gchar * uri, const gchar * group, GError * * error);
    gboolean g_bookmark_file_remove_application(GBookmarkFile * bookmark, const gchar * uri, const gchar * name, GError * * error);
    gboolean g_bookmark_file_remove_item(GBookmarkFile * bookmark, const gchar * uri, GError * * error);
    gboolean g_bookmark_file_move_item(GBookmarkFile * bookmark, const gchar * old_uri, const gchar * new_uri, GError * * error);
}
extern "C"
{
    gpointer g_slice_alloc(gsize block_size) __attribute__((__malloc__));
    gpointer g_slice_alloc0(gsize block_size) __attribute__((__malloc__));
    gpointer g_slice_copy(gsize block_size, gconstpointer mem_block) __attribute__((__malloc__));
    void g_slice_free1(gsize block_size, gpointer mem_block);
    void g_slice_free_chain_with_offset(gsize block_size, gpointer mem_chain, gsize next_offset);
    typedef enum 
    {
        G_SLICE_CONFIG_ALWAYS_MALLOC = 1, 
        G_SLICE_CONFIG_BYPASS_MAGAZINES, 
        G_SLICE_CONFIG_WORKING_SET_MSECS, 
        G_SLICE_CONFIG_COLOR_INCREMENT, 
        G_SLICE_CONFIG_CHUNK_SIZES, 
        G_SLICE_CONFIG_CONTENTION_COUNTER
    } GSliceConfig;
    void g_slice_set_config(GSliceConfig ckey, gint64 value);
    gint64 g_slice_get_config(GSliceConfig ckey);
    gint64 * g_slice_get_config_state(GSliceConfig ckey, gint64 address, guint * n_values);
}
extern "C"
{
    typedef struct _GMemVTable GMemVTable;
    gpointer g_malloc(gsize n_bytes) __attribute__((__malloc__));
    gpointer g_malloc0(gsize n_bytes) __attribute__((__malloc__));
    gpointer g_realloc(gpointer mem, gsize n_bytes) __attribute__((warn_unused_result));
    void g_free(gpointer mem);
    gpointer g_try_malloc(gsize n_bytes) __attribute__((__malloc__));
    gpointer g_try_malloc0(gsize n_bytes) __attribute__((__malloc__));
    gpointer g_try_realloc(gpointer mem, gsize n_bytes) __attribute__((warn_unused_result));
    struct _GMemVTable
    {
            gpointer (* malloc)(gsize n_bytes);
            gpointer (* realloc)(gpointer mem, gsize n_bytes);
            void (* free)(gpointer mem);
            gpointer (* calloc)(gsize n_blocks, gsize n_block_bytes);
            gpointer (* try_malloc)(gsize n_bytes);
            gpointer (* try_realloc)(gpointer mem, gsize n_bytes);
    };
    void g_mem_set_vtable(GMemVTable * vtable);
    gboolean g_mem_is_system_malloc(void);
    extern gboolean g_mem_gc_friendly;
    extern GMemVTable * glib_mem_profiler_table;
    void g_mem_profile(void);
    typedef struct _GAllocator GAllocator;
    typedef struct _GMemChunk GMemChunk;
    GMemChunk * g_mem_chunk_new(const gchar * name, gint atom_size, gsize area_size, gint type);
    void g_mem_chunk_destroy(GMemChunk * mem_chunk);
    gpointer g_mem_chunk_alloc(GMemChunk * mem_chunk);
    gpointer g_mem_chunk_alloc0(GMemChunk * mem_chunk);
    void g_mem_chunk_free(GMemChunk * mem_chunk, gpointer mem);
    void g_mem_chunk_clean(GMemChunk * mem_chunk);
    void g_mem_chunk_reset(GMemChunk * mem_chunk);
    void g_mem_chunk_print(GMemChunk * mem_chunk);
    void g_mem_chunk_info(void);
    void g_blow_chunks(void);
    GAllocator * g_allocator_new(const gchar * name, guint n_preallocs);
    void g_allocator_free(GAllocator * allocator);
}
extern "C"
{
    typedef struct _GList GList;
    struct _GList
    {
            gpointer data;
            GList * next;
            GList * prev;
    };
    GList * g_list_alloc(void) __attribute__((warn_unused_result));
    void g_list_free(GList * list);
    void g_list_free_1(GList * list);
    GList * g_list_append(GList * list, gpointer data) __attribute__((warn_unused_result));
    GList * g_list_prepend(GList * list, gpointer data) __attribute__((warn_unused_result));
    GList * g_list_insert(GList * list, gpointer data, gint position) __attribute__((warn_unused_result));
    GList * g_list_insert_sorted(GList * list, gpointer data, GCompareFunc func) __attribute__((warn_unused_result));
    GList * g_list_insert_sorted_with_data(GList * list, gpointer data, GCompareDataFunc func, gpointer user_data) __attribute__((warn_unused_result));
    GList * g_list_insert_before(GList * list, GList * sibling, gpointer data) __attribute__((warn_unused_result));
    GList * g_list_concat(GList * list1, GList * list2) __attribute__((warn_unused_result));
    GList * g_list_remove(GList * list, gconstpointer data) __attribute__((warn_unused_result));
    GList * g_list_remove_all(GList * list, gconstpointer data) __attribute__((warn_unused_result));
    GList * g_list_remove_link(GList * list, GList * llink) __attribute__((warn_unused_result));
    GList * g_list_delete_link(GList * list, GList * link_) __attribute__((warn_unused_result));
    GList * g_list_reverse(GList * list) __attribute__((warn_unused_result));
    GList * g_list_copy(GList * list) __attribute__((warn_unused_result));
    GList * g_list_nth(GList * list, guint n);
    GList * g_list_nth_prev(GList * list, guint n);
    GList * g_list_find(GList * list, gconstpointer data);
    GList * g_list_find_custom(GList * list, gconstpointer data, GCompareFunc func);
    gint g_list_position(GList * list, GList * llink);
    gint g_list_index(GList * list, gconstpointer data);
    GList * g_list_last(GList * list);
    GList * g_list_first(GList * list);
    guint g_list_length(GList * list);
    void g_list_foreach(GList * list, GFunc func, gpointer user_data);
    GList * g_list_sort(GList * list, GCompareFunc compare_func) __attribute__((warn_unused_result));
    GList * g_list_sort_with_data(GList * list, GCompareDataFunc compare_func, gpointer user_data) __attribute__((warn_unused_result));
    gpointer g_list_nth_data(GList * list, guint n);
    void g_list_push_allocator(gpointer allocator);
    void g_list_pop_allocator(void);
}
extern "C"
{
    typedef struct _GCache GCache;
    typedef gpointer (* GCacheNewFunc)(gpointer key);
    typedef gpointer (* GCacheDupFunc)(gpointer value);
    typedef void (* GCacheDestroyFunc)(gpointer value);
    GCache * g_cache_new(GCacheNewFunc value_new_func, GCacheDestroyFunc value_destroy_func, GCacheDupFunc key_dup_func, GCacheDestroyFunc key_destroy_func, GHashFunc hash_key_func, GHashFunc hash_value_func, GEqualFunc key_equal_func);
    void g_cache_destroy(GCache * cache);
    gpointer g_cache_insert(GCache * cache, gpointer key);
    void g_cache_remove(GCache * cache, gconstpointer value);
    void g_cache_key_foreach(GCache * cache, GHFunc func, gpointer user_data);
    void g_cache_value_foreach(GCache * cache, GHFunc func, gpointer user_data);
}
extern "C"
{
    typedef enum 
    {
        G_CHECKSUM_MD5, 
        G_CHECKSUM_SHA1, 
        G_CHECKSUM_SHA256
    } GChecksumType;
    typedef struct _GChecksum GChecksum;
    gssize g_checksum_type_get_length(GChecksumType checksum_type);
    GChecksum * g_checksum_new(GChecksumType checksum_type);
    GChecksum * g_checksum_copy(const GChecksum * checksum);
    void g_checksum_free(GChecksum * checksum);
    void g_checksum_update(GChecksum * checksum, const guchar * data, gssize length);
    const gchar * g_checksum_get_string(GChecksum * checksum);
    void g_checksum_get_digest(GChecksum * checksum, guint8 * buffer, gsize * digest_len);
    gchar * g_compute_checksum_for_data(GChecksumType checksum_type, const guchar * data, gsize length);
    gchar * g_compute_checksum_for_string(GChecksumType checksum_type, const gchar * str, gssize length);
}
extern "C"
{
    typedef struct _GCompletion GCompletion;
    typedef gchar * (* GCompletionFunc)(gpointer);
    typedef gint (* GCompletionStrncmpFunc)(const gchar * s1, const gchar * s2, gsize n);
    struct _GCompletion
    {
            GList * items;
            GCompletionFunc func;
            gchar * prefix;
            GList * cache;
            GCompletionStrncmpFunc strncmp_func;
    };
    GCompletion * g_completion_new(GCompletionFunc func);
    void g_completion_add_items(GCompletion * cmp, GList * items);
    void g_completion_remove_items(GCompletion * cmp, GList * items);
    void g_completion_clear_items(GCompletion * cmp);
    GList * g_completion_complete(GCompletion * cmp, const gchar * prefix, gchar * * new_prefix);
    GList * g_completion_complete_utf8(GCompletion * cmp, const gchar * prefix, gchar * * new_prefix);
    void g_completion_set_compare(GCompletion * cmp, GCompletionStrncmpFunc strncmp_func);
    void g_completion_free(GCompletion * cmp);
}
extern "C"
{
    typedef enum 
    {
        G_CONVERT_ERROR_NO_CONVERSION, 
        G_CONVERT_ERROR_ILLEGAL_SEQUENCE, 
        G_CONVERT_ERROR_FAILED, 
        G_CONVERT_ERROR_PARTIAL_INPUT, 
        G_CONVERT_ERROR_BAD_URI, 
        G_CONVERT_ERROR_NOT_ABSOLUTE_PATH
    } GConvertError;
    GQuark g_convert_error_quark(void);
    typedef struct _GIConv * GIConv;
    GIConv g_iconv_open(const gchar * to_codeset, const gchar * from_codeset);
    gsize g_iconv(GIConv converter, gchar * * inbuf, gsize * inbytes_left, gchar * * outbuf, gsize * outbytes_left);
    gint g_iconv_close(GIConv converter);
    gchar * g_convert(const gchar * str, gssize len, const gchar * to_codeset, const gchar * from_codeset, gsize * bytes_read, gsize * bytes_written, GError * * error) __attribute__((__malloc__));
    gchar * g_convert_with_iconv(const gchar * str, gssize len, GIConv converter, gsize * bytes_read, gsize * bytes_written, GError * * error) __attribute__((__malloc__));
    gchar * g_convert_with_fallback(const gchar * str, gssize len, const gchar * to_codeset, const gchar * from_codeset, gchar * fallback, gsize * bytes_read, gsize * bytes_written, GError * * error) __attribute__((__malloc__));
    gchar * g_locale_to_utf8(const gchar * opsysstring, gssize len, gsize * bytes_read, gsize * bytes_written, GError * * error) __attribute__((__malloc__));
    gchar * g_locale_from_utf8(const gchar * utf8string, gssize len, gsize * bytes_read, gsize * bytes_written, GError * * error) __attribute__((__malloc__));
    gchar * g_filename_to_utf8(const gchar * opsysstring, gssize len, gsize * bytes_read, gsize * bytes_written, GError * * error) __attribute__((__malloc__));
    gchar * g_filename_from_utf8(const gchar * utf8string, gssize len, gsize * bytes_read, gsize * bytes_written, GError * * error) __attribute__((__malloc__));
    gchar * g_filename_from_uri(const gchar * uri, gchar * * hostname, GError * * error) __attribute__((__malloc__));
    gchar * g_filename_to_uri(const gchar * filename, const gchar * hostname, GError * * error) __attribute__((__malloc__));
    gchar * g_filename_display_name(const gchar * filename) __attribute__((__malloc__));
    gboolean g_get_filename_charsets(const gchar * * * charsets);
    gchar * g_filename_display_basename(const gchar * filename) __attribute__((__malloc__));
    gchar * * g_uri_list_extract_uris(const gchar * uri_list) __attribute__((__malloc__));
}
extern "C"
{
    typedef struct _GData GData;
    typedef void (* GDataForeachFunc)(GQuark key_id, gpointer data, gpointer user_data);
    void g_datalist_init(GData * * datalist);
    void g_datalist_clear(GData * * datalist);
    gpointer g_datalist_id_get_data(GData * * datalist, GQuark key_id);
    void g_datalist_id_set_data_full(GData * * datalist, GQuark key_id, gpointer data, GDestroyNotify destroy_func);
    gpointer g_datalist_id_remove_no_notify(GData * * datalist, GQuark key_id);
    void g_datalist_foreach(GData * * datalist, GDataForeachFunc func, gpointer user_data);
    void g_datalist_set_flags(GData * * datalist, guint flags);
    void g_datalist_unset_flags(GData * * datalist, guint flags);
    guint g_datalist_get_flags(GData * * datalist);
    void g_dataset_destroy(gconstpointer dataset_location);
    gpointer g_dataset_id_get_data(gconstpointer dataset_location, GQuark key_id);
    void g_dataset_id_set_data_full(gconstpointer dataset_location, GQuark key_id, gpointer data, GDestroyNotify destroy_func);
    gpointer g_dataset_id_remove_no_notify(gconstpointer dataset_location, GQuark key_id);
    void g_dataset_foreach(gconstpointer dataset_location, GDataForeachFunc func, gpointer user_data);
}
extern "C"
{
    typedef gint32 GTime;
    typedef guint16 GDateYear;
    typedef guint8 GDateDay;
    typedef struct _GDate GDate;
    typedef enum 
    {
        G_DATE_DAY = 0, 
        G_DATE_MONTH = 1, 
        G_DATE_YEAR = 2
    } GDateDMY;
    typedef enum 
    {
        G_DATE_BAD_WEEKDAY = 0, 
        G_DATE_MONDAY = 1, 
        G_DATE_TUESDAY = 2, 
        G_DATE_WEDNESDAY = 3, 
        G_DATE_THURSDAY = 4, 
        G_DATE_FRIDAY = 5, 
        G_DATE_SATURDAY = 6, 
        G_DATE_SUNDAY = 7
    } GDateWeekday;
    typedef enum 
    {
        G_DATE_BAD_MONTH = 0, 
        G_DATE_JANUARY = 1, 
        G_DATE_FEBRUARY = 2, 
        G_DATE_MARCH = 3, 
        G_DATE_APRIL = 4, 
        G_DATE_MAY = 5, 
        G_DATE_JUNE = 6, 
        G_DATE_JULY = 7, 
        G_DATE_AUGUST = 8, 
        G_DATE_SEPTEMBER = 9, 
        G_DATE_OCTOBER = 10, 
        G_DATE_NOVEMBER = 11, 
        G_DATE_DECEMBER = 12
    } GDateMonth;
    struct _GDate
    {
            guint julian_days : 32;
            guint julian : 1;
            guint dmy : 1;
            guint day : 6;
            guint month : 4;
            guint year : 16;
    };
    GDate * g_date_new(void);
    GDate * g_date_new_dmy(GDateDay day, GDateMonth month, GDateYear year);
    GDate * g_date_new_julian(guint32 julian_day);
    void g_date_free(GDate * date);
    gboolean g_date_valid(const GDate * date);
    gboolean g_date_valid_day(GDateDay day) __attribute__((__const__));
    gboolean g_date_valid_month(GDateMonth month) __attribute__((__const__));
    gboolean g_date_valid_year(GDateYear year) __attribute__((__const__));
    gboolean g_date_valid_weekday(GDateWeekday weekday) __attribute__((__const__));
    gboolean g_date_valid_julian(guint32 julian_date) __attribute__((__const__));
    gboolean g_date_valid_dmy(GDateDay day, GDateMonth month, GDateYear year) __attribute__((__const__));
    GDateWeekday g_date_get_weekday(const GDate * date);
    GDateMonth g_date_get_month(const GDate * date);
    GDateYear g_date_get_year(const GDate * date);
    GDateDay g_date_get_day(const GDate * date);
    guint32 g_date_get_julian(const GDate * date);
    guint g_date_get_day_of_year(const GDate * date);
    guint g_date_get_monday_week_of_year(const GDate * date);
    guint g_date_get_sunday_week_of_year(const GDate * date);
    guint g_date_get_iso8601_week_of_year(const GDate * date);
    void g_date_clear(GDate * date, guint n_dates);
    void g_date_set_parse(GDate * date, const gchar * str);
    void g_date_set_time_t(GDate * date, time_t timet);
    void g_date_set_time_val(GDate * date, GTimeVal * timeval);
    void g_date_set_time(GDate * date, GTime time_);
    void g_date_set_month(GDate * date, GDateMonth month);
    void g_date_set_day(GDate * date, GDateDay day);
    void g_date_set_year(GDate * date, GDateYear year);
    void g_date_set_dmy(GDate * date, GDateDay day, GDateMonth month, GDateYear y);
    void g_date_set_julian(GDate * date, guint32 julian_date);
    gboolean g_date_is_first_of_month(const GDate * date);
    gboolean g_date_is_last_of_month(const GDate * date);
    void g_date_add_days(GDate * date, guint n_days);
    void g_date_subtract_days(GDate * date, guint n_days);
    void g_date_add_months(GDate * date, guint n_months);
    void g_date_subtract_months(GDate * date, guint n_months);
    void g_date_add_years(GDate * date, guint n_years);
    void g_date_subtract_years(GDate * date, guint n_years);
    gboolean g_date_is_leap_year(GDateYear year) __attribute__((__const__));
    guint8 g_date_get_days_in_month(GDateMonth month, GDateYear year) __attribute__((__const__));
    guint8 g_date_get_monday_weeks_in_year(GDateYear year) __attribute__((__const__));
    guint8 g_date_get_sunday_weeks_in_year(GDateYear year) __attribute__((__const__));
    gint g_date_days_between(const GDate * date1, const GDate * date2);
    gint g_date_compare(const GDate * lhs, const GDate * rhs);
    void g_date_to_struct_tm(const GDate * date, struct tm * tm);
    void g_date_clamp(GDate * date, const GDate * min_date, const GDate * max_date);
    void g_date_order(GDate * date1, GDate * date2);
    gsize g_date_strftime(gchar * s, gsize slen, const gchar * format, const GDate * date);
}
extern "C"
{
    typedef struct _GDir GDir;
    GDir * g_dir_open(const gchar * path, guint flags, GError * * error);
    const gchar * g_dir_read_name(GDir * dir);
    void g_dir_rewind(GDir * dir);
    void g_dir_close(GDir * dir);
}
extern "C"
{
    typedef enum 
    {
        G_FILE_ERROR_EXIST, 
        G_FILE_ERROR_ISDIR, 
        G_FILE_ERROR_ACCES, 
        G_FILE_ERROR_NAMETOOLONG, 
        G_FILE_ERROR_NOENT, 
        G_FILE_ERROR_NOTDIR, 
        G_FILE_ERROR_NXIO, 
        G_FILE_ERROR_NODEV, 
        G_FILE_ERROR_ROFS, 
        G_FILE_ERROR_TXTBSY, 
        G_FILE_ERROR_FAULT, 
        G_FILE_ERROR_LOOP, 
        G_FILE_ERROR_NOSPC, 
        G_FILE_ERROR_NOMEM, 
        G_FILE_ERROR_MFILE, 
        G_FILE_ERROR_NFILE, 
        G_FILE_ERROR_BADF, 
        G_FILE_ERROR_INVAL, 
        G_FILE_ERROR_PIPE, 
        G_FILE_ERROR_AGAIN, 
        G_FILE_ERROR_INTR, 
        G_FILE_ERROR_IO, 
        G_FILE_ERROR_PERM, 
        G_FILE_ERROR_NOSYS, 
        G_FILE_ERROR_FAILED
    } GFileError;
    typedef enum 
    {
        G_FILE_TEST_IS_REGULAR = 1 << 0, 
        G_FILE_TEST_IS_SYMLINK = 1 << 1, 
        G_FILE_TEST_IS_DIR = 1 << 2, 
        G_FILE_TEST_IS_EXECUTABLE = 1 << 3, 
        G_FILE_TEST_EXISTS = 1 << 4
    } GFileTest;
    GQuark g_file_error_quark(void);
    GFileError g_file_error_from_errno(gint err_no);
    gboolean g_file_test(const gchar * filename, GFileTest test);
    gboolean g_file_get_contents(const gchar * filename, gchar * * contents, gsize * length, GError * * error);
    gboolean g_file_set_contents(const gchar * filename, const gchar * contents, gssize length, GError * * error);
    gchar * g_file_read_link(const gchar * filename, GError * * error);
    gint g_mkstemp(gchar * tmpl);
    gint g_file_open_tmp(const gchar * tmpl, gchar * * name_used, GError * * error);
    char * g_format_size_for_display(goffset size);
    gchar * g_build_path(const gchar * separator, const gchar * first_element, ...) __attribute__((__malloc__)) __attribute__((__sentinel__));
    gchar * g_build_pathv(const gchar * separator, gchar * * args) __attribute__((__malloc__));
    gchar * g_build_filename(const gchar * first_element, ...) __attribute__((__malloc__)) __attribute__((__sentinel__));
    gchar * g_build_filenamev(gchar * * args) __attribute__((__malloc__));
    int g_mkdir_with_parents(const gchar * pathname, int mode);
}
extern "C"
{
    typedef struct _GHashTable GHashTable;
    typedef gboolean (* GHRFunc)(gpointer key, gpointer value, gpointer user_data);
    typedef struct _GHashTableIter GHashTableIter;
    struct _GHashTableIter
    {
            gpointer dummy1;
            gpointer dummy2;
            gpointer dummy3;
            int dummy4;
            gboolean dummy5;
            gpointer dummy6;
    };
    GHashTable * g_hash_table_new(GHashFunc hash_func, GEqualFunc key_equal_func);
    GHashTable * g_hash_table_new_full(GHashFunc hash_func, GEqualFunc key_equal_func, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func);
    void g_hash_table_destroy(GHashTable * hash_table);
    void g_hash_table_insert(GHashTable * hash_table, gpointer key, gpointer value);
    void g_hash_table_replace(GHashTable * hash_table, gpointer key, gpointer value);
    gboolean g_hash_table_remove(GHashTable * hash_table, gconstpointer key);
    void g_hash_table_remove_all(GHashTable * hash_table);
    gboolean g_hash_table_steal(GHashTable * hash_table, gconstpointer key);
    void g_hash_table_steal_all(GHashTable * hash_table);
    gpointer g_hash_table_lookup(GHashTable * hash_table, gconstpointer key);
    gboolean g_hash_table_lookup_extended(GHashTable * hash_table, gconstpointer lookup_key, gpointer * orig_key, gpointer * value);
    void g_hash_table_foreach(GHashTable * hash_table, GHFunc func, gpointer user_data);
    gpointer g_hash_table_find(GHashTable * hash_table, GHRFunc predicate, gpointer user_data);
    guint g_hash_table_foreach_remove(GHashTable * hash_table, GHRFunc func, gpointer user_data);
    guint g_hash_table_foreach_steal(GHashTable * hash_table, GHRFunc func, gpointer user_data);
    guint g_hash_table_size(GHashTable * hash_table);
    GList * g_hash_table_get_keys(GHashTable * hash_table);
    GList * g_hash_table_get_values(GHashTable * hash_table);
    void g_hash_table_iter_init(GHashTableIter * iter, GHashTable * hash_table);
    gboolean g_hash_table_iter_next(GHashTableIter * iter, gpointer * key, gpointer * value);
    GHashTable * g_hash_table_iter_get_hash_table(GHashTableIter * iter);
    void g_hash_table_iter_remove(GHashTableIter * iter);
    void g_hash_table_iter_steal(GHashTableIter * iter);
    GHashTable * g_hash_table_ref(GHashTable * hash_table);
    void g_hash_table_unref(GHashTable * hash_table);
    gboolean g_str_equal(gconstpointer v1, gconstpointer v2);
    guint g_str_hash(gconstpointer v);
    gboolean g_int_equal(gconstpointer v1, gconstpointer v2);
    guint g_int_hash(gconstpointer v);
    guint g_direct_hash(gconstpointer v) __attribute__((__const__));
    gboolean g_direct_equal(gconstpointer v1, gconstpointer v2) __attribute__((__const__));
}
extern "C"
{
    typedef struct _GHook GHook;
    typedef struct _GHookList GHookList;
    typedef gint (* GHookCompareFunc)(GHook * new_hook, GHook * sibling);
    typedef gboolean (* GHookFindFunc)(GHook * hook, gpointer data);
    typedef void (* GHookMarshaller)(GHook * hook, gpointer marshal_data);
    typedef gboolean (* GHookCheckMarshaller)(GHook * hook, gpointer marshal_data);
    typedef void (* GHookFunc)(gpointer data);
    typedef gboolean (* GHookCheckFunc)(gpointer data);
    typedef void (* GHookFinalizeFunc)(GHookList * hook_list, GHook * hook);
    typedef enum 
    {
        G_HOOK_FLAG_ACTIVE = 1 << 0, 
        G_HOOK_FLAG_IN_CALL = 1 << 1, 
        G_HOOK_FLAG_MASK = 0x0f
    } GHookFlagMask;
    struct _GHookList
    {
            gulong seq_id;
            guint hook_size : 16;
            guint is_setup : 1;
            GHook * hooks;
            gpointer dummy3;
            GHookFinalizeFunc finalize_hook;
            gpointer dummy[2];
    };
    struct _GHook
    {
            gpointer data;
            GHook * next;
            GHook * prev;
            guint ref_count;
            gulong hook_id;
            guint flags;
            gpointer func;
            GDestroyNotify destroy;
    };
    void g_hook_list_init(GHookList * hook_list, guint hook_size);
    void g_hook_list_clear(GHookList * hook_list);
    GHook * g_hook_alloc(GHookList * hook_list);
    void g_hook_free(GHookList * hook_list, GHook * hook);
    GHook * g_hook_ref(GHookList * hook_list, GHook * hook);
    void g_hook_unref(GHookList * hook_list, GHook * hook);
    gboolean g_hook_destroy(GHookList * hook_list, gulong hook_id);
    void g_hook_destroy_link(GHookList * hook_list, GHook * hook);
    void g_hook_prepend(GHookList * hook_list, GHook * hook);
    void g_hook_insert_before(GHookList * hook_list, GHook * sibling, GHook * hook);
    void g_hook_insert_sorted(GHookList * hook_list, GHook * hook, GHookCompareFunc func);
    GHook * g_hook_get(GHookList * hook_list, gulong hook_id);
    GHook * g_hook_find(GHookList * hook_list, gboolean need_valids, GHookFindFunc func, gpointer data);
    GHook * g_hook_find_data(GHookList * hook_list, gboolean need_valids, gpointer data);
    GHook * g_hook_find_func(GHookList * hook_list, gboolean need_valids, gpointer func);
    GHook * g_hook_find_func_data(GHookList * hook_list, gboolean need_valids, gpointer func, gpointer data);
    GHook * g_hook_first_valid(GHookList * hook_list, gboolean may_be_in_call);
    GHook * g_hook_next_valid(GHookList * hook_list, GHook * hook, gboolean may_be_in_call);
    gint g_hook_compare_ids(GHook * new_hook, GHook * sibling);
    void g_hook_list_invoke(GHookList * hook_list, gboolean may_recurse);
    void g_hook_list_invoke_check(GHookList * hook_list, gboolean may_recurse);
    void g_hook_list_marshal(GHookList * hook_list, gboolean may_recurse, GHookMarshaller marshaller, gpointer marshal_data);
    void g_hook_list_marshal_check(GHookList * hook_list, gboolean may_recurse, GHookCheckMarshaller marshaller, gpointer marshal_data);
}
extern "C"
{
    typedef struct _GSList GSList;
    struct _GSList
    {
            gpointer data;
            GSList * next;
    };
    GSList * g_slist_alloc(void) __attribute__((warn_unused_result));
    void g_slist_free(GSList * list);
    void g_slist_free_1(GSList * list);
    GSList * g_slist_append(GSList * list, gpointer data) __attribute__((warn_unused_result));
    GSList * g_slist_prepend(GSList * list, gpointer data) __attribute__((warn_unused_result));
    GSList * g_slist_insert(GSList * list, gpointer data, gint position) __attribute__((warn_unused_result));
    GSList * g_slist_insert_sorted(GSList * list, gpointer data, GCompareFunc func) __attribute__((warn_unused_result));
    GSList * g_slist_insert_sorted_with_data(GSList * list, gpointer data, GCompareDataFunc func, gpointer user_data) __attribute__((warn_unused_result));
    GSList * g_slist_insert_before(GSList * slist, GSList * sibling, gpointer data) __attribute__((warn_unused_result));
    GSList * g_slist_concat(GSList * list1, GSList * list2) __attribute__((warn_unused_result));
    GSList * g_slist_remove(GSList * list, gconstpointer data) __attribute__((warn_unused_result));
    GSList * g_slist_remove_all(GSList * list, gconstpointer data) __attribute__((warn_unused_result));
    GSList * g_slist_remove_link(GSList * list, GSList * link_) __attribute__((warn_unused_result));
    GSList * g_slist_delete_link(GSList * list, GSList * link_) __attribute__((warn_unused_result));
    GSList * g_slist_reverse(GSList * list) __attribute__((warn_unused_result));
    GSList * g_slist_copy(GSList * list) __attribute__((warn_unused_result));
    GSList * g_slist_nth(GSList * list, guint n);
    GSList * g_slist_find(GSList * list, gconstpointer data);
    GSList * g_slist_find_custom(GSList * list, gconstpointer data, GCompareFunc func);
    gint g_slist_position(GSList * list, GSList * llink);
    gint g_slist_index(GSList * list, gconstpointer data);
    GSList * g_slist_last(GSList * list);
    guint g_slist_length(GSList * list);
    void g_slist_foreach(GSList * list, GFunc func, gpointer user_data);
    GSList * g_slist_sort(GSList * list, GCompareFunc compare_func) __attribute__((warn_unused_result));
    GSList * g_slist_sort_with_data(GSList * list, GCompareDataFunc compare_func, gpointer user_data) __attribute__((warn_unused_result));
    gpointer g_slist_nth_data(GSList * list, guint n);
    void g_slist_push_allocator(gpointer dummy);
    void g_slist_pop_allocator(void);
}
extern "C"
{
    typedef struct _GMainContext GMainContext;
    typedef struct _GMainLoop GMainLoop;
    typedef struct _GSource GSource;
    typedef struct _GSourceCallbackFuncs GSourceCallbackFuncs;
    typedef struct _GSourceFuncs GSourceFuncs;
    typedef gboolean (* GSourceFunc)(gpointer data);
    typedef void (* GChildWatchFunc)(GPid pid, gint status, gpointer data);
    struct _GSource
    {
            gpointer callback_data;
            GSourceCallbackFuncs * callback_funcs;
            GSourceFuncs * source_funcs;
            guint ref_count;
            GMainContext * context;
            gint priority;
            guint flags;
            guint source_id;
            GSList * poll_fds;
            GSource * prev;
            GSource * next;
            gpointer reserved1;
            gpointer reserved2;
    };
    struct _GSourceCallbackFuncs
    {
            void (* ref)(gpointer cb_data);
            void (* unref)(gpointer cb_data);
            void (* get)(gpointer cb_data, GSource * source, GSourceFunc * func, gpointer * data);
    };
    typedef void (* GSourceDummyMarshal)(void);
    struct _GSourceFuncs
    {
            gboolean (* prepare)(GSource * source, gint * timeout_);
            gboolean (* check)(GSource * source);
            gboolean (* dispatch)(GSource * source, GSourceFunc callback, gpointer user_data);
            void (* finalize)(GSource * source);
            GSourceFunc closure_callback;
            GSourceDummyMarshal closure_marshal;
    };
    typedef struct _GPollFD GPollFD;
    typedef gint (* GPollFunc)(GPollFD * ufds, guint nfsd, gint timeout_);
    struct _GPollFD
    {
            gint fd;
            gushort events;
            gushort revents;
    };
    GMainContext * g_main_context_new(void);
    GMainContext * g_main_context_ref(GMainContext * context);
    void g_main_context_unref(GMainContext * context);
    GMainContext * g_main_context_default(void);
    gboolean g_main_context_iteration(GMainContext * context, gboolean may_block);
    gboolean g_main_context_pending(GMainContext * context);
    GSource * g_main_context_find_source_by_id(GMainContext * context, guint source_id);
    GSource * g_main_context_find_source_by_user_data(GMainContext * context, gpointer user_data);
    GSource * g_main_context_find_source_by_funcs_user_data(GMainContext * context, GSourceFuncs * funcs, gpointer user_data);
    void g_main_context_wakeup(GMainContext * context);
    gboolean g_main_context_acquire(GMainContext * context);
    void g_main_context_release(GMainContext * context);
    gboolean g_main_context_is_owner(GMainContext * context);
    gboolean g_main_context_wait(GMainContext * context, GCond * cond, GMutex * mutex);
    gboolean g_main_context_prepare(GMainContext * context, gint * priority);
    gint g_main_context_query(GMainContext * context, gint max_priority, gint * timeout_, GPollFD * fds, gint n_fds);
    gint g_main_context_check(GMainContext * context, gint max_priority, GPollFD * fds, gint n_fds);
    void g_main_context_dispatch(GMainContext * context);
    void g_main_context_set_poll_func(GMainContext * context, GPollFunc func);
    GPollFunc g_main_context_get_poll_func(GMainContext * context);
    void g_main_context_add_poll(GMainContext * context, GPollFD * fd, gint priority);
    void g_main_context_remove_poll(GMainContext * context, GPollFD * fd);
    gint g_main_depth(void);
    GSource * g_main_current_source(void);
    GMainLoop * g_main_loop_new(GMainContext * context, gboolean is_running);
    void g_main_loop_run(GMainLoop * loop);
    void g_main_loop_quit(GMainLoop * loop);
    GMainLoop * g_main_loop_ref(GMainLoop * loop);
    void g_main_loop_unref(GMainLoop * loop);
    gboolean g_main_loop_is_running(GMainLoop * loop);
    GMainContext * g_main_loop_get_context(GMainLoop * loop);
    GSource * g_source_new(GSourceFuncs * source_funcs, guint struct_size);
    GSource * g_source_ref(GSource * source);
    void g_source_unref(GSource * source);
    guint g_source_attach(GSource * source, GMainContext * context);
    void g_source_destroy(GSource * source);
    void g_source_set_priority(GSource * source, gint priority);
    gint g_source_get_priority(GSource * source);
    void g_source_set_can_recurse(GSource * source, gboolean can_recurse);
    gboolean g_source_get_can_recurse(GSource * source);
    guint g_source_get_id(GSource * source);
    GMainContext * g_source_get_context(GSource * source);
    void g_source_set_callback(GSource * source, GSourceFunc func, gpointer data, GDestroyNotify notify);
    void g_source_set_funcs(GSource * source, GSourceFuncs * funcs);
    gboolean g_source_is_destroyed(GSource * source);
    void g_source_set_callback_indirect(GSource * source, gpointer callback_data, GSourceCallbackFuncs * callback_funcs);
    void g_source_add_poll(GSource * source, GPollFD * fd);
    void g_source_remove_poll(GSource * source, GPollFD * fd);
    void g_source_get_current_time(GSource * source, GTimeVal * timeval);
    GSource * g_idle_source_new(void);
    GSource * g_child_watch_source_new(GPid pid);
    GSource * g_timeout_source_new(guint interval);
    GSource * g_timeout_source_new_seconds(guint interval);
    void g_get_current_time(GTimeVal * result);
    gboolean g_source_remove(guint tag);
    gboolean g_source_remove_by_user_data(gpointer user_data);
    gboolean g_source_remove_by_funcs_user_data(GSourceFuncs * funcs, gpointer user_data);
    guint g_timeout_add_full(gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify);
    guint g_timeout_add(guint interval, GSourceFunc function, gpointer data);
    guint g_timeout_add_seconds_full(gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify);
    guint g_timeout_add_seconds(guint interval, GSourceFunc function, gpointer data);
    guint g_child_watch_add_full(gint priority, GPid pid, GChildWatchFunc function, gpointer data, GDestroyNotify notify);
    guint g_child_watch_add(GPid pid, GChildWatchFunc function, gpointer data);
    guint g_idle_add(GSourceFunc function, gpointer data);
    guint g_idle_add_full(gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify);
    gboolean g_idle_remove_by_data(gpointer data);
    extern GSourceFuncs g_timeout_funcs;
    extern GSourceFuncs g_child_watch_funcs;
    extern GSourceFuncs g_idle_funcs;
}
extern "C"
{
    typedef guint32 gunichar;
    typedef guint16 gunichar2;
    typedef enum 
    {
        G_UNICODE_CONTROL, 
        G_UNICODE_FORMAT, 
        G_UNICODE_UNASSIGNED, 
        G_UNICODE_PRIVATE_USE, 
        G_UNICODE_SURROGATE, 
        G_UNICODE_LOWERCASE_LETTER, 
        G_UNICODE_MODIFIER_LETTER, 
        G_UNICODE_OTHER_LETTER, 
        G_UNICODE_TITLECASE_LETTER, 
        G_UNICODE_UPPERCASE_LETTER, 
        G_UNICODE_COMBINING_MARK, 
        G_UNICODE_ENCLOSING_MARK, 
        G_UNICODE_NON_SPACING_MARK, 
        G_UNICODE_DECIMAL_NUMBER, 
        G_UNICODE_LETTER_NUMBER, 
        G_UNICODE_OTHER_NUMBER, 
        G_UNICODE_CONNECT_PUNCTUATION, 
        G_UNICODE_DASH_PUNCTUATION, 
        G_UNICODE_CLOSE_PUNCTUATION, 
        G_UNICODE_FINAL_PUNCTUATION, 
        G_UNICODE_INITIAL_PUNCTUATION, 
        G_UNICODE_OTHER_PUNCTUATION, 
        G_UNICODE_OPEN_PUNCTUATION, 
        G_UNICODE_CURRENCY_SYMBOL, 
        G_UNICODE_MODIFIER_SYMBOL, 
        G_UNICODE_MATH_SYMBOL, 
        G_UNICODE_OTHER_SYMBOL, 
        G_UNICODE_LINE_SEPARATOR, 
        G_UNICODE_PARAGRAPH_SEPARATOR, 
        G_UNICODE_SPACE_SEPARATOR
    } GUnicodeType;
    typedef enum 
    {
        G_UNICODE_BREAK_MANDATORY, 
        G_UNICODE_BREAK_CARRIAGE_RETURN, 
        G_UNICODE_BREAK_LINE_FEED, 
        G_UNICODE_BREAK_COMBINING_MARK, 
        G_UNICODE_BREAK_SURROGATE, 
        G_UNICODE_BREAK_ZERO_WIDTH_SPACE, 
        G_UNICODE_BREAK_INSEPARABLE, 
        G_UNICODE_BREAK_NON_BREAKING_GLUE, 
        G_UNICODE_BREAK_CONTINGENT, 
        G_UNICODE_BREAK_SPACE, 
        G_UNICODE_BREAK_AFTER, 
        G_UNICODE_BREAK_BEFORE, 
        G_UNICODE_BREAK_BEFORE_AND_AFTER, 
        G_UNICODE_BREAK_HYPHEN, 
        G_UNICODE_BREAK_NON_STARTER, 
        G_UNICODE_BREAK_OPEN_PUNCTUATION, 
        G_UNICODE_BREAK_CLOSE_PUNCTUATION, 
        G_UNICODE_BREAK_QUOTATION, 
        G_UNICODE_BREAK_EXCLAMATION, 
        G_UNICODE_BREAK_IDEOGRAPHIC, 
        G_UNICODE_BREAK_NUMERIC, 
        G_UNICODE_BREAK_INFIX_SEPARATOR, 
        G_UNICODE_BREAK_SYMBOL, 
        G_UNICODE_BREAK_ALPHABETIC, 
        G_UNICODE_BREAK_PREFIX, 
        G_UNICODE_BREAK_POSTFIX, 
        G_UNICODE_BREAK_COMPLEX_CONTEXT, 
        G_UNICODE_BREAK_AMBIGUOUS, 
        G_UNICODE_BREAK_UNKNOWN, 
        G_UNICODE_BREAK_NEXT_LINE, 
        G_UNICODE_BREAK_WORD_JOINER, 
        G_UNICODE_BREAK_HANGUL_L_JAMO, 
        G_UNICODE_BREAK_HANGUL_V_JAMO, 
        G_UNICODE_BREAK_HANGUL_T_JAMO, 
        G_UNICODE_BREAK_HANGUL_LV_SYLLABLE, 
        G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE
    } GUnicodeBreakType;
    typedef enum 
    {
        G_UNICODE_SCRIPT_INVALID_CODE = -1, 
        G_UNICODE_SCRIPT_COMMON = 0, 
        G_UNICODE_SCRIPT_INHERITED, 
        G_UNICODE_SCRIPT_ARABIC, 
        G_UNICODE_SCRIPT_ARMENIAN, 
        G_UNICODE_SCRIPT_BENGALI, 
        G_UNICODE_SCRIPT_BOPOMOFO, 
        G_UNICODE_SCRIPT_CHEROKEE, 
        G_UNICODE_SCRIPT_COPTIC, 
        G_UNICODE_SCRIPT_CYRILLIC, 
        G_UNICODE_SCRIPT_DESERET, 
        G_UNICODE_SCRIPT_DEVANAGARI, 
        G_UNICODE_SCRIPT_ETHIOPIC, 
        G_UNICODE_SCRIPT_GEORGIAN, 
        G_UNICODE_SCRIPT_GOTHIC, 
        G_UNICODE_SCRIPT_GREEK, 
        G_UNICODE_SCRIPT_GUJARATI, 
        G_UNICODE_SCRIPT_GURMUKHI, 
        G_UNICODE_SCRIPT_HAN, 
        G_UNICODE_SCRIPT_HANGUL, 
        G_UNICODE_SCRIPT_HEBREW, 
        G_UNICODE_SCRIPT_HIRAGANA, 
        G_UNICODE_SCRIPT_KANNADA, 
        G_UNICODE_SCRIPT_KATAKANA, 
        G_UNICODE_SCRIPT_KHMER, 
        G_UNICODE_SCRIPT_LAO, 
        G_UNICODE_SCRIPT_LATIN, 
        G_UNICODE_SCRIPT_MALAYALAM, 
        G_UNICODE_SCRIPT_MONGOLIAN, 
        G_UNICODE_SCRIPT_MYANMAR, 
        G_UNICODE_SCRIPT_OGHAM, 
        G_UNICODE_SCRIPT_OLD_ITALIC, 
        G_UNICODE_SCRIPT_ORIYA, 
        G_UNICODE_SCRIPT_RUNIC, 
        G_UNICODE_SCRIPT_SINHALA, 
        G_UNICODE_SCRIPT_SYRIAC, 
        G_UNICODE_SCRIPT_TAMIL, 
        G_UNICODE_SCRIPT_TELUGU, 
        G_UNICODE_SCRIPT_THAANA, 
        G_UNICODE_SCRIPT_THAI, 
        G_UNICODE_SCRIPT_TIBETAN, 
        G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL, 
        G_UNICODE_SCRIPT_YI, 
        G_UNICODE_SCRIPT_TAGALOG, 
        G_UNICODE_SCRIPT_HANUNOO, 
        G_UNICODE_SCRIPT_BUHID, 
        G_UNICODE_SCRIPT_TAGBANWA, 
        G_UNICODE_SCRIPT_BRAILLE, 
        G_UNICODE_SCRIPT_CYPRIOT, 
        G_UNICODE_SCRIPT_LIMBU, 
        G_UNICODE_SCRIPT_OSMANYA, 
        G_UNICODE_SCRIPT_SHAVIAN, 
        G_UNICODE_SCRIPT_LINEAR_B, 
        G_UNICODE_SCRIPT_TAI_LE, 
        G_UNICODE_SCRIPT_UGARITIC, 
        G_UNICODE_SCRIPT_NEW_TAI_LUE, 
        G_UNICODE_SCRIPT_BUGINESE, 
        G_UNICODE_SCRIPT_GLAGOLITIC, 
        G_UNICODE_SCRIPT_TIFINAGH, 
        G_UNICODE_SCRIPT_SYLOTI_NAGRI, 
        G_UNICODE_SCRIPT_OLD_PERSIAN, 
        G_UNICODE_SCRIPT_KHAROSHTHI, 
        G_UNICODE_SCRIPT_UNKNOWN, 
        G_UNICODE_SCRIPT_BALINESE, 
        G_UNICODE_SCRIPT_CUNEIFORM, 
        G_UNICODE_SCRIPT_PHOENICIAN, 
        G_UNICODE_SCRIPT_PHAGS_PA, 
        G_UNICODE_SCRIPT_NKO, 
        G_UNICODE_SCRIPT_KAYAH_LI, 
        G_UNICODE_SCRIPT_LEPCHA, 
        G_UNICODE_SCRIPT_REJANG, 
        G_UNICODE_SCRIPT_SUNDANESE, 
        G_UNICODE_SCRIPT_SAURASHTRA, 
        G_UNICODE_SCRIPT_CHAM, 
        G_UNICODE_SCRIPT_OL_CHIKI, 
        G_UNICODE_SCRIPT_VAI, 
        G_UNICODE_SCRIPT_CARIAN, 
        G_UNICODE_SCRIPT_LYCIAN, 
        G_UNICODE_SCRIPT_LYDIAN
    } GUnicodeScript;
    gboolean g_get_charset(const char * * charset);
    gboolean g_unichar_isalnum(gunichar c) __attribute__((__const__));
    gboolean g_unichar_isalpha(gunichar c) __attribute__((__const__));
    gboolean g_unichar_iscntrl(gunichar c) __attribute__((__const__));
    gboolean g_unichar_isdigit(gunichar c) __attribute__((__const__));
    gboolean g_unichar_isgraph(gunichar c) __attribute__((__const__));
    gboolean g_unichar_islower(gunichar c) __attribute__((__const__));
    gboolean g_unichar_isprint(gunichar c) __attribute__((__const__));
    gboolean g_unichar_ispunct(gunichar c) __attribute__((__const__));
    gboolean g_unichar_isspace(gunichar c) __attribute__((__const__));
    gboolean g_unichar_isupper(gunichar c) __attribute__((__const__));
    gboolean g_unichar_isxdigit(gunichar c) __attribute__((__const__));
    gboolean g_unichar_istitle(gunichar c) __attribute__((__const__));
    gboolean g_unichar_isdefined(gunichar c) __attribute__((__const__));
    gboolean g_unichar_iswide(gunichar c) __attribute__((__const__));
    gboolean g_unichar_iswide_cjk(gunichar c) __attribute__((__const__));
    gboolean g_unichar_iszerowidth(gunichar c) __attribute__((__const__));
    gboolean g_unichar_ismark(gunichar c) __attribute__((__const__));
    gunichar g_unichar_toupper(gunichar c) __attribute__((__const__));
    gunichar g_unichar_tolower(gunichar c) __attribute__((__const__));
    gunichar g_unichar_totitle(gunichar c) __attribute__((__const__));
    gint g_unichar_digit_value(gunichar c) __attribute__((__const__));
    gint g_unichar_xdigit_value(gunichar c) __attribute__((__const__));
    GUnicodeType g_unichar_type(gunichar c) __attribute__((__const__));
    GUnicodeBreakType g_unichar_break_type(gunichar c) __attribute__((__const__));
    gint g_unichar_combining_class(gunichar uc) __attribute__((__const__));
    void g_unicode_canonical_ordering(gunichar * string, gsize len);
    gunichar * g_unicode_canonical_decomposition(gunichar ch, gsize * result_len) __attribute__((__malloc__));
    extern const gchar *const g_utf8_skip;
    gunichar g_utf8_get_char(const gchar * p) __attribute__((__pure__));
    gunichar g_utf8_get_char_validated(const gchar * p, gssize max_len) __attribute__((__pure__));
    gchar * g_utf8_offset_to_pointer(const gchar * str, glong offset) __attribute__((__pure__));
    glong g_utf8_pointer_to_offset(const gchar * str, const gchar * pos) __attribute__((__pure__));
    gchar * g_utf8_prev_char(const gchar * p) __attribute__((__pure__));
    gchar * g_utf8_find_next_char(const gchar * p, const gchar * end) __attribute__((__pure__));
    gchar * g_utf8_find_prev_char(const gchar * str, const gchar * p) __attribute__((__pure__));
    glong g_utf8_strlen(const gchar * p, gssize max) __attribute__((__pure__));
    gchar * g_utf8_strncpy(gchar * dest, const gchar * src, gsize n);
    gchar * g_utf8_strchr(const gchar * p, gssize len, gunichar c);
    gchar * g_utf8_strrchr(const gchar * p, gssize len, gunichar c);
    gchar * g_utf8_strreverse(const gchar * str, gssize len);
    gunichar2 * g_utf8_to_utf16(const gchar * str, glong len, glong * items_read, glong * items_written, GError * * error) __attribute__((__malloc__));
    gunichar * g_utf8_to_ucs4(const gchar * str, glong len, glong * items_read, glong * items_written, GError * * error) __attribute__((__malloc__));
    gunichar * g_utf8_to_ucs4_fast(const gchar * str, glong len, glong * items_written) __attribute__((__malloc__));
    gunichar * g_utf16_to_ucs4(const gunichar2 * str, glong len, glong * items_read, glong * items_written, GError * * error) __attribute__((__malloc__));
    gchar * g_utf16_to_utf8(const gunichar2 * str, glong len, glong * items_read, glong * items_written, GError * * error) __attribute__((__malloc__));
    gunichar2 * g_ucs4_to_utf16(const gunichar * str, glong len, glong * items_read, glong * items_written, GError * * error) __attribute__((__malloc__));
    gchar * g_ucs4_to_utf8(const gunichar * str, glong len, glong * items_read, glong * items_written, GError * * error) __attribute__((__malloc__));
    gint g_unichar_to_utf8(gunichar c, gchar * outbuf);
    gboolean g_utf8_validate(const gchar * str, gssize max_len, const gchar * * end);
    gboolean g_unichar_validate(gunichar ch) __attribute__((__const__));
    gchar * g_utf8_strup(const gchar * str, gssize len) __attribute__((__malloc__));
    gchar * g_utf8_strdown(const gchar * str, gssize len) __attribute__((__malloc__));
    gchar * g_utf8_casefold(const gchar * str, gssize len) __attribute__((__malloc__));
    typedef enum 
    {
        G_NORMALIZE_DEFAULT, 
        G_NORMALIZE_NFD = G_NORMALIZE_DEFAULT, 
        G_NORMALIZE_DEFAULT_COMPOSE, 
        G_NORMALIZE_NFC = G_NORMALIZE_DEFAULT_COMPOSE, 
        G_NORMALIZE_ALL, 
        G_NORMALIZE_NFKD = G_NORMALIZE_ALL, 
        G_NORMALIZE_ALL_COMPOSE, 
        G_NORMALIZE_NFKC = G_NORMALIZE_ALL_COMPOSE
    } GNormalizeMode;
    gchar * g_utf8_normalize(const gchar * str, gssize len, GNormalizeMode mode) __attribute__((__malloc__));
    gint g_utf8_collate(const gchar * str1, const gchar * str2) __attribute__((__pure__));
    gchar * g_utf8_collate_key(const gchar * str, gssize len) __attribute__((__malloc__));
    gchar * g_utf8_collate_key_for_filename(const gchar * str, gssize len) __attribute__((__malloc__));
    gboolean g_unichar_get_mirror_char(gunichar ch, gunichar * mirrored_ch);
    GUnicodeScript g_unichar_get_script(gunichar ch) __attribute__((__const__));
    gchar * _g_utf8_make_valid(const gchar * name);
}
extern "C"
{
    typedef struct _GString GString;
    typedef struct _GStringChunk GStringChunk;
    struct _GString
    {
            gchar * str;
            gsize len;
            gsize allocated_len;
    };
    GStringChunk * g_string_chunk_new(gsize size);
    void g_string_chunk_free(GStringChunk * chunk);
    void g_string_chunk_clear(GStringChunk * chunk);
    gchar * g_string_chunk_insert(GStringChunk * chunk, const gchar * string);
    gchar * g_string_chunk_insert_len(GStringChunk * chunk, const gchar * string, gssize len);
    gchar * g_string_chunk_insert_const(GStringChunk * chunk, const gchar * string);
    GString * g_string_new(const gchar * init);
    GString * g_string_new_len(const gchar * init, gssize len);
    GString * g_string_sized_new(gsize dfl_size);
    gchar * g_string_free(GString * string, gboolean free_segment);
    gboolean g_string_equal(const GString * v, const GString * v2);
    guint g_string_hash(const GString * str);
    GString * g_string_assign(GString * string, const gchar * rval);
    GString * g_string_truncate(GString * string, gsize len);
    GString * g_string_set_size(GString * string, gsize len);
    GString * g_string_insert_len(GString * string, gssize pos, const gchar * val, gssize len);
    GString * g_string_append(GString * string, const gchar * val);
    GString * g_string_append_len(GString * string, const gchar * val, gssize len);
    GString * g_string_append_c(GString * string, gchar c);
    GString * g_string_append_unichar(GString * string, gunichar wc);
    GString * g_string_prepend(GString * string, const gchar * val);
    GString * g_string_prepend_c(GString * string, gchar c);
    GString * g_string_prepend_unichar(GString * string, gunichar wc);
    GString * g_string_prepend_len(GString * string, const gchar * val, gssize len);
    GString * g_string_insert(GString * string, gssize pos, const gchar * val);
    GString * g_string_insert_c(GString * string, gssize pos, gchar c);
    GString * g_string_insert_unichar(GString * string, gssize pos, gunichar wc);
    GString * g_string_overwrite(GString * string, gsize pos, const gchar * val);
    GString * g_string_overwrite_len(GString * string, gsize pos, const gchar * val, gssize len);
    GString * g_string_erase(GString * string, gssize pos, gssize len);
    GString * g_string_ascii_down(GString * string);
    GString * g_string_ascii_up(GString * string);
    void g_string_vprintf(GString * string, const gchar * format, va_list args);
    void g_string_printf(GString * string, const gchar * format, ...) __attribute__((__format__(__printf__, 2, 3)));
    void g_string_append_vprintf(GString * string, const gchar * format, va_list args);
    void g_string_append_printf(GString * string, const gchar * format, ...) __attribute__((__format__(__printf__, 2, 3)));
    GString * g_string_append_uri_escaped(GString * string, const char * unescaped, const char * reserved_chars_allowed, gboolean allow_utf8);
    static inline GString * g_string_append_c_inline(GString * gstring, gchar c)
    {
        if (gstring->len + 1 < gstring->allocated_len)
        {
            gstring->str[gstring->len++] = c;
            gstring->str[gstring->len] = 0;
        }
        else
            g_string_insert_c(gstring, -1, c);
        return gstring;
    }
    GString * g_string_down(GString * string);
    GString * g_string_up(GString * string);
}
extern "C"
{
    typedef struct _GIOChannel GIOChannel;
    typedef struct _GIOFuncs GIOFuncs;
    typedef enum 
    {
        G_IO_ERROR_NONE, 
        G_IO_ERROR_AGAIN, 
        G_IO_ERROR_INVAL, 
        G_IO_ERROR_UNKNOWN
    } GIOError;
    typedef enum 
    {
        G_IO_CHANNEL_ERROR_FBIG, 
        G_IO_CHANNEL_ERROR_INVAL, 
        G_IO_CHANNEL_ERROR_IO, 
        G_IO_CHANNEL_ERROR_ISDIR, 
        G_IO_CHANNEL_ERROR_NOSPC, 
        G_IO_CHANNEL_ERROR_NXIO, 
        G_IO_CHANNEL_ERROR_OVERFLOW, 
        G_IO_CHANNEL_ERROR_PIPE, 
        G_IO_CHANNEL_ERROR_FAILED
    } GIOChannelError;
    typedef enum 
    {
        G_IO_STATUS_ERROR, 
        G_IO_STATUS_NORMAL, 
        G_IO_STATUS_EOF, 
        G_IO_STATUS_AGAIN
    } GIOStatus;
    typedef enum 
    {
        G_SEEK_CUR, 
        G_SEEK_SET, 
        G_SEEK_END
    } GSeekType;
    typedef enum 
    {
        G_IO_IN = 1, 
        G_IO_OUT = 4, 
        G_IO_PRI = 2, 
        G_IO_ERR = 8, 
        G_IO_HUP = 16, 
        G_IO_NVAL = 32
    } GIOCondition;
    typedef enum 
    {
        G_IO_FLAG_APPEND = 1 << 0, 
        G_IO_FLAG_NONBLOCK = 1 << 1, 
        G_IO_FLAG_IS_READABLE = 1 << 2, 
        G_IO_FLAG_IS_WRITEABLE = 1 << 3, 
        G_IO_FLAG_IS_SEEKABLE = 1 << 4, 
        G_IO_FLAG_MASK = (1 << 5) - 1, 
        G_IO_FLAG_GET_MASK = G_IO_FLAG_MASK, 
        G_IO_FLAG_SET_MASK = G_IO_FLAG_APPEND | G_IO_FLAG_NONBLOCK
    } GIOFlags;
    struct _GIOChannel
    {
            gint ref_count;
            GIOFuncs * funcs;
            gchar * encoding;
            GIConv read_cd;
            GIConv write_cd;
            gchar * line_term;
            guint line_term_len;
            gsize buf_size;
            GString * read_buf;
            GString * encoded_read_buf;
            GString * write_buf;
            gchar partial_write_buf[6];
            guint use_buffer : 1;
            guint do_encode : 1;
            guint close_on_unref : 1;
            guint is_readable : 1;
            guint is_writeable : 1;
            guint is_seekable : 1;
            gpointer reserved1;
            gpointer reserved2;
    };
    typedef gboolean (* GIOFunc)(GIOChannel * source, GIOCondition condition, gpointer data);
    struct _GIOFuncs
    {
            GIOStatus (* io_read)(GIOChannel * channel, gchar * buf, gsize count, gsize * bytes_read, GError * * err);
            GIOStatus (* io_write)(GIOChannel * channel, const gchar * buf, gsize count, gsize * bytes_written, GError * * err);
            GIOStatus (* io_seek)(GIOChannel * channel, gint64 offset, GSeekType type, GError * * err);
            GIOStatus (* io_close)(GIOChannel * channel, GError * * err);
            GSource * (* io_create_watch)(GIOChannel * channel, GIOCondition condition);
            void (* io_free)(GIOChannel * channel);
            GIOStatus (* io_set_flags)(GIOChannel * channel, GIOFlags flags, GError * * err);
            GIOFlags (* io_get_flags)(GIOChannel * channel);
    };
    void g_io_channel_init(GIOChannel * channel);
    GIOChannel * g_io_channel_ref(GIOChannel * channel);
    void g_io_channel_unref(GIOChannel * channel);
    GIOError g_io_channel_read(GIOChannel * channel, gchar * buf, gsize count, gsize * bytes_read);
    GIOError g_io_channel_write(GIOChannel * channel, const gchar * buf, gsize count, gsize * bytes_written);
    GIOError g_io_channel_seek(GIOChannel * channel, gint64 offset, GSeekType type);
    void g_io_channel_close(GIOChannel * channel);
    GIOStatus g_io_channel_shutdown(GIOChannel * channel, gboolean flush, GError * * err);
    guint g_io_add_watch_full(GIOChannel * channel, gint priority, GIOCondition condition, GIOFunc func, gpointer user_data, GDestroyNotify notify);
    GSource * g_io_create_watch(GIOChannel * channel, GIOCondition condition);
    guint g_io_add_watch(GIOChannel * channel, GIOCondition condition, GIOFunc func, gpointer user_data);
    void g_io_channel_set_buffer_size(GIOChannel * channel, gsize size);
    gsize g_io_channel_get_buffer_size(GIOChannel * channel);
    GIOCondition g_io_channel_get_buffer_condition(GIOChannel * channel);
    GIOStatus g_io_channel_set_flags(GIOChannel * channel, GIOFlags flags, GError * * error);
    GIOFlags g_io_channel_get_flags(GIOChannel * channel);
    void g_io_channel_set_line_term(GIOChannel * channel, const gchar * line_term, gint length);
    const gchar * g_io_channel_get_line_term(GIOChannel * channel, gint * length);
    void g_io_channel_set_buffered(GIOChannel * channel, gboolean buffered);
    gboolean g_io_channel_get_buffered(GIOChannel * channel);
    GIOStatus g_io_channel_set_encoding(GIOChannel * channel, const gchar * encoding, GError * * error);
    const gchar * g_io_channel_get_encoding(GIOChannel * channel);
    void g_io_channel_set_close_on_unref(GIOChannel * channel, gboolean do_close);
    gboolean g_io_channel_get_close_on_unref(GIOChannel * channel);
    GIOStatus g_io_channel_flush(GIOChannel * channel, GError * * error);
    GIOStatus g_io_channel_read_line(GIOChannel * channel, gchar * * str_return, gsize * length, gsize * terminator_pos, GError * * error);
    GIOStatus g_io_channel_read_line_string(GIOChannel * channel, GString * buffer, gsize * terminator_pos, GError * * error);
    GIOStatus g_io_channel_read_to_end(GIOChannel * channel, gchar * * str_return, gsize * length, GError * * error);
    GIOStatus g_io_channel_read_chars(GIOChannel * channel, gchar * buf, gsize count, gsize * bytes_read, GError * * error);
    GIOStatus g_io_channel_read_unichar(GIOChannel * channel, gunichar * thechar, GError * * error);
    GIOStatus g_io_channel_write_chars(GIOChannel * channel, const gchar * buf, gssize count, gsize * bytes_written, GError * * error);
    GIOStatus g_io_channel_write_unichar(GIOChannel * channel, gunichar thechar, GError * * error);
    GIOStatus g_io_channel_seek_position(GIOChannel * channel, gint64 offset, GSeekType type, GError * * error);
    GIOChannel * g_io_channel_new_file(const gchar * filename, const gchar * mode, GError * * error);
    GQuark g_io_channel_error_quark(void);
    GIOChannelError g_io_channel_error_from_errno(gint en);
    GIOChannel * g_io_channel_unix_new(int fd);
    gint g_io_channel_unix_get_fd(GIOChannel * channel);
    extern GSourceFuncs g_io_watch_funcs;
}
extern "C"
{
    typedef enum 
    {
        G_KEY_FILE_ERROR_UNKNOWN_ENCODING, 
        G_KEY_FILE_ERROR_PARSE, 
        G_KEY_FILE_ERROR_NOT_FOUND, 
        G_KEY_FILE_ERROR_KEY_NOT_FOUND, 
        G_KEY_FILE_ERROR_GROUP_NOT_FOUND, 
        G_KEY_FILE_ERROR_INVALID_VALUE
    } GKeyFileError;
    GQuark g_key_file_error_quark(void);
    typedef struct _GKeyFile GKeyFile;
    typedef enum 
    {
        G_KEY_FILE_NONE = 0, 
        G_KEY_FILE_KEEP_COMMENTS = 1 << 0, 
        G_KEY_FILE_KEEP_TRANSLATIONS = 1 << 1
    } GKeyFileFlags;
    GKeyFile * g_key_file_new(void);
    void g_key_file_free(GKeyFile * key_file);
    void g_key_file_set_list_separator(GKeyFile * key_file, gchar separator);
    gboolean g_key_file_load_from_file(GKeyFile * key_file, const gchar * file, GKeyFileFlags flags, GError * * error);
    gboolean g_key_file_load_from_data(GKeyFile * key_file, const gchar * data, gsize length, GKeyFileFlags flags, GError * * error);
    gboolean g_key_file_load_from_dirs(GKeyFile * key_file, const gchar * file, const gchar * * search_dirs, gchar * * full_path, GKeyFileFlags flags, GError * * error);
    gboolean g_key_file_load_from_data_dirs(GKeyFile * key_file, const gchar * file, gchar * * full_path, GKeyFileFlags flags, GError * * error);
    gchar * g_key_file_to_data(GKeyFile * key_file, gsize * length, GError * * error) __attribute__((__malloc__));
    gchar * g_key_file_get_start_group(GKeyFile * key_file) __attribute__((__malloc__));
    gchar * * g_key_file_get_groups(GKeyFile * key_file, gsize * length) __attribute__((__malloc__));
    gchar * * g_key_file_get_keys(GKeyFile * key_file, const gchar * group_name, gsize * length, GError * * error) __attribute__((__malloc__));
    gboolean g_key_file_has_group(GKeyFile * key_file, const gchar * group_name);
    gboolean g_key_file_has_key(GKeyFile * key_file, const gchar * group_name, const gchar * key, GError * * error);
    gchar * g_key_file_get_value(GKeyFile * key_file, const gchar * group_name, const gchar * key, GError * * error) __attribute__((__malloc__));
    void g_key_file_set_value(GKeyFile * key_file, const gchar * group_name, const gchar * key, const gchar * value);
    gchar * g_key_file_get_string(GKeyFile * key_file, const gchar * group_name, const gchar * key, GError * * error) __attribute__((__malloc__));
    void g_key_file_set_string(GKeyFile * key_file, const gchar * group_name, const gchar * key, const gchar * string);
    gchar * g_key_file_get_locale_string(GKeyFile * key_file, const gchar * group_name, const gchar * key, const gchar * locale, GError * * error) __attribute__((__malloc__));
    void g_key_file_set_locale_string(GKeyFile * key_file, const gchar * group_name, const gchar * key, const gchar * locale, const gchar * string);
    gboolean g_key_file_get_boolean(GKeyFile * key_file, const gchar * group_name, const gchar * key, GError * * error);
    void g_key_file_set_boolean(GKeyFile * key_file, const gchar * group_name, const gchar * key, gboolean value);
    gint g_key_file_get_integer(GKeyFile * key_file, const gchar * group_name, const gchar * key, GError * * error);
    void g_key_file_set_integer(GKeyFile * key_file, const gchar * group_name, const gchar * key, gint value);
    gdouble g_key_file_get_double(GKeyFile * key_file, const gchar * group_name, const gchar * key, GError * * error);
    void g_key_file_set_double(GKeyFile * key_file, const gchar * group_name, const gchar * key, gdouble value);
    gchar * * g_key_file_get_string_list(GKeyFile * key_file, const gchar * group_name, const gchar * key, gsize * length, GError * * error) __attribute__((__malloc__));
    void g_key_file_set_string_list(GKeyFile * key_file, const gchar * group_name, const gchar * key, const gchar *const list[], gsize length);
    gchar * * g_key_file_get_locale_string_list(GKeyFile * key_file, const gchar * group_name, const gchar * key, const gchar * locale, gsize * length, GError * * error) __attribute__((__malloc__));
    void g_key_file_set_locale_string_list(GKeyFile * key_file, const gchar * group_name, const gchar * key, const gchar * locale, const gchar *const list[], gsize length);
    gboolean * g_key_file_get_boolean_list(GKeyFile * key_file, const gchar * group_name, const gchar * key, gsize * length, GError * * error) __attribute__((__malloc__));
    void g_key_file_set_boolean_list(GKeyFile * key_file, const gchar * group_name, const gchar * key, gboolean list[], gsize length);
    gint * g_key_file_get_integer_list(GKeyFile * key_file, const gchar * group_name, const gchar * key, gsize * length, GError * * error) __attribute__((__malloc__));
    void g_key_file_set_double_list(GKeyFile * key_file, const gchar * group_name, const gchar * key, gdouble list[], gsize length);
    gdouble * g_key_file_get_double_list(GKeyFile * key_file, const gchar * group_name, const gchar * key, gsize * length, GError * * error) __attribute__((__malloc__));
    void g_key_file_set_integer_list(GKeyFile * key_file, const gchar * group_name, const gchar * key, gint list[], gsize length);
    gboolean g_key_file_set_comment(GKeyFile * key_file, const gchar * group_name, const gchar * key, const gchar * comment, GError * * error);
    gchar * g_key_file_get_comment(GKeyFile * key_file, const gchar * group_name, const gchar * key, GError * * error) __attribute__((__malloc__));
    gboolean g_key_file_remove_comment(GKeyFile * key_file, const gchar * group_name, const gchar * key, GError * * error);
    gboolean g_key_file_remove_key(GKeyFile * key_file, const gchar * group_name, const gchar * key, GError * * error);
    gboolean g_key_file_remove_group(GKeyFile * key_file, const gchar * group_name, GError * * error);
}
extern "C"
{
    typedef struct _GMappedFile GMappedFile;
    GMappedFile * g_mapped_file_new(const gchar * filename, gboolean writable, GError * * error) __attribute__((__malloc__));
    gsize g_mapped_file_get_length(GMappedFile * file);
    gchar * g_mapped_file_get_contents(GMappedFile * file);
    void g_mapped_file_free(GMappedFile * file);
}
extern "C"
{
    typedef enum 
    {
        G_MARKUP_ERROR_BAD_UTF8, 
        G_MARKUP_ERROR_EMPTY, 
        G_MARKUP_ERROR_PARSE, 
        G_MARKUP_ERROR_UNKNOWN_ELEMENT, 
        G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, 
        G_MARKUP_ERROR_INVALID_CONTENT, 
        G_MARKUP_ERROR_MISSING_ATTRIBUTE
    } GMarkupError;
    GQuark g_markup_error_quark(void);
    typedef enum 
    {
        G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1 << 0, 
        G_MARKUP_TREAT_CDATA_AS_TEXT = 1 << 1, 
        G_MARKUP_PREFIX_ERROR_POSITION = 1 << 2
    } GMarkupParseFlags;
    typedef struct _GMarkupParseContext GMarkupParseContext;
    typedef struct _GMarkupParser GMarkupParser;
    struct _GMarkupParser
    {
            void (* start_element)(GMarkupParseContext * context, const gchar * element_name, const gchar * * attribute_names, const gchar * * attribute_values, gpointer user_data, GError * * error);
            void (* end_element)(GMarkupParseContext * context, const gchar * element_name, gpointer user_data, GError * * error);
            void (* text)(GMarkupParseContext * context, const gchar * text, gsize text_len, gpointer user_data, GError * * error);
            void (* passthrough)(GMarkupParseContext * context, const gchar * passthrough_text, gsize text_len, gpointer user_data, GError * * error);
            void (* error)(GMarkupParseContext * context, GError * error, gpointer user_data);
    };
    GMarkupParseContext * g_markup_parse_context_new(const GMarkupParser * parser, GMarkupParseFlags flags, gpointer user_data, GDestroyNotify user_data_dnotify);
    void g_markup_parse_context_free(GMarkupParseContext * context);
    gboolean g_markup_parse_context_parse(GMarkupParseContext * context, const gchar * text, gssize text_len, GError * * error);
    gboolean g_markup_parse_context_end_parse(GMarkupParseContext * context, GError * * error);
    const gchar * g_markup_parse_context_get_element(GMarkupParseContext * context);
    const GSList * g_markup_parse_context_get_element_stack(GMarkupParseContext * context);
    void g_markup_parse_context_get_position(GMarkupParseContext * context, gint * line_number, gint * char_number);
    gchar * g_markup_escape_text(const gchar * text, gssize length);
    gchar * g_markup_printf_escaped(const char * format, ...) __attribute__((__format__(__printf__, 1, 2)));
    gchar * g_markup_vprintf_escaped(const char * format, va_list args);
    typedef enum 
    {
        G_MARKUP_COLLECT_INVALID, 
        G_MARKUP_COLLECT_STRING, 
        G_MARKUP_COLLECT_STRDUP, 
        G_MARKUP_COLLECT_BOOLEAN, 
        G_MARKUP_COLLECT_TRISTATE, 
        G_MARKUP_COLLECT_OPTIONAL = (1 << 16)
    } GMarkupCollectType;
    gboolean g_markup_collect_attributes(const gchar * element_name, const gchar * * attribute_names, const gchar * * attribute_values, GError * * error, GMarkupCollectType first_type, const gchar * first_attr, ...);
}
extern "C"
{
    gsize g_printf_string_upper_bound(const gchar * format, va_list args);
    typedef enum 
    {
        G_LOG_FLAG_RECURSION = 1 << 0, 
        G_LOG_FLAG_FATAL = 1 << 1, 
        G_LOG_LEVEL_ERROR = 1 << 2, 
        G_LOG_LEVEL_CRITICAL = 1 << 3, 
        G_LOG_LEVEL_WARNING = 1 << 4, 
        G_LOG_LEVEL_MESSAGE = 1 << 5, 
        G_LOG_LEVEL_INFO = 1 << 6, 
        G_LOG_LEVEL_DEBUG = 1 << 7, 
        G_LOG_LEVEL_MASK = ~(G_LOG_FLAG_RECURSION | G_LOG_FLAG_FATAL)
    } GLogLevelFlags;
    typedef void (* GLogFunc)(const gchar * log_domain, GLogLevelFlags log_level, const gchar * message, gpointer user_data);
    guint g_log_set_handler(const gchar * log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data);
    void g_log_remove_handler(const gchar * log_domain, guint handler_id);
    void g_log_default_handler(const gchar * log_domain, GLogLevelFlags log_level, const gchar * message, gpointer unused_data);
    GLogFunc g_log_set_default_handler(GLogFunc log_func, gpointer user_data);
    void g_log(const gchar * log_domain, GLogLevelFlags log_level, const gchar * format, ...) __attribute__((__format__(__printf__, 3, 4)));
    void g_logv(const gchar * log_domain, GLogLevelFlags log_level, const gchar * format, va_list args);
    GLogLevelFlags g_log_set_fatal_mask(const gchar * log_domain, GLogLevelFlags fatal_mask);
    GLogLevelFlags g_log_set_always_fatal(GLogLevelFlags fatal_mask);
    __attribute__((visibility("hidden"))) void _g_log_fallback_handler(const gchar * log_domain, GLogLevelFlags log_level, const gchar * message, gpointer unused_data);
    void g_return_if_fail_warning(const char * log_domain, const char * pretty_function, const char * expression);
    void g_warn_message(const char * domain, const char * file, int line, const char * func, const char * warnexpr);
    void g_assert_warning(const char * log_domain, const char * file, const int line, const char * pretty_function, const char * expression) __attribute__((__noreturn__));
    typedef void (* GPrintFunc)(const gchar * string);
    void g_print(const gchar * format, ...) __attribute__((__format__(__printf__, 1, 2)));
    GPrintFunc g_set_print_handler(GPrintFunc func);
    void g_printerr(const gchar * format, ...) __attribute__((__format__(__printf__, 1, 2)));
    GPrintFunc g_set_printerr_handler(GPrintFunc func);
}
extern "C"
{
    typedef struct _GNode GNode;
    typedef enum 
    {
        G_TRAVERSE_LEAVES = 1 << 0, 
        G_TRAVERSE_NON_LEAVES = 1 << 1, 
        G_TRAVERSE_ALL = G_TRAVERSE_LEAVES | G_TRAVERSE_NON_LEAVES, 
        G_TRAVERSE_MASK = 0x03, 
        G_TRAVERSE_LEAFS = G_TRAVERSE_LEAVES, 
        G_TRAVERSE_NON_LEAFS = G_TRAVERSE_NON_LEAVES
    } GTraverseFlags;
    typedef enum 
    {
        G_IN_ORDER, 
        G_PRE_ORDER, 
        G_POST_ORDER, 
        G_LEVEL_ORDER
    } GTraverseType;
    typedef gboolean (* GNodeTraverseFunc)(GNode * node, gpointer data);
    typedef void (* GNodeForeachFunc)(GNode * node, gpointer data);
    typedef gpointer (* GCopyFunc)(gconstpointer src, gpointer data);
    struct _GNode
    {
            gpointer data;
            GNode * next;
            GNode * prev;
            GNode * parent;
            GNode * children;
    };
    GNode * g_node_new(gpointer data);
    void g_node_destroy(GNode * root);
    void g_node_unlink(GNode * node);
    GNode * g_node_copy_deep(GNode * node, GCopyFunc copy_func, gpointer data);
    GNode * g_node_copy(GNode * node);
    GNode * g_node_insert(GNode * parent, gint position, GNode * node);
    GNode * g_node_insert_before(GNode * parent, GNode * sibling, GNode * node);
    GNode * g_node_insert_after(GNode * parent, GNode * sibling, GNode * node);
    GNode * g_node_prepend(GNode * parent, GNode * node);
    guint g_node_n_nodes(GNode * root, GTraverseFlags flags);
    GNode * g_node_get_root(GNode * node);
    gboolean g_node_is_ancestor(GNode * node, GNode * descendant);
    guint g_node_depth(GNode * node);
    GNode * g_node_find(GNode * root, GTraverseType order, GTraverseFlags flags, gpointer data);
    void g_node_traverse(GNode * root, GTraverseType order, GTraverseFlags flags, gint max_depth, GNodeTraverseFunc func, gpointer data);
    guint g_node_max_height(GNode * root);
    void g_node_children_foreach(GNode * node, GTraverseFlags flags, GNodeForeachFunc func, gpointer data);
    void g_node_reverse_children(GNode * node);
    guint g_node_n_children(GNode * node);
    GNode * g_node_nth_child(GNode * node, guint n);
    GNode * g_node_last_child(GNode * node);
    GNode * g_node_find_child(GNode * node, GTraverseFlags flags, gpointer data);
    gint g_node_child_position(GNode * node, GNode * child);
    gint g_node_child_index(GNode * node, gpointer data);
    GNode * g_node_first_sibling(GNode * node);
    GNode * g_node_last_sibling(GNode * node);
    void g_node_push_allocator(gpointer dummy);
    void g_node_pop_allocator(void);
}
extern "C"
{
    typedef struct _GOptionContext GOptionContext;
    typedef struct _GOptionGroup GOptionGroup;
    typedef struct _GOptionEntry GOptionEntry;
    typedef enum 
    {
        G_OPTION_FLAG_HIDDEN = 1 << 0, 
        G_OPTION_FLAG_IN_MAIN = 1 << 1, 
        G_OPTION_FLAG_REVERSE = 1 << 2, 
        G_OPTION_FLAG_NO_ARG = 1 << 3, 
        G_OPTION_FLAG_FILENAME = 1 << 4, 
        G_OPTION_FLAG_OPTIONAL_ARG = 1 << 5, 
        G_OPTION_FLAG_NOALIAS = 1 << 6
    } GOptionFlags;
    typedef enum 
    {
        G_OPTION_ARG_NONE, 
        G_OPTION_ARG_STRING, 
        G_OPTION_ARG_INT, 
        G_OPTION_ARG_CALLBACK, 
        G_OPTION_ARG_FILENAME, 
        G_OPTION_ARG_STRING_ARRAY, 
        G_OPTION_ARG_FILENAME_ARRAY, 
        G_OPTION_ARG_DOUBLE, 
        G_OPTION_ARG_INT64
    } GOptionArg;
    typedef gboolean (* GOptionArgFunc)(const gchar * option_name, const gchar * value, gpointer data, GError * * error);
    typedef gboolean (* GOptionParseFunc)(GOptionContext * context, GOptionGroup * group, gpointer data, GError * * error);
    typedef void (* GOptionErrorFunc)(GOptionContext * context, GOptionGroup * group, gpointer data, GError * * error);
    typedef enum 
    {
        G_OPTION_ERROR_UNKNOWN_OPTION, 
        G_OPTION_ERROR_BAD_VALUE, 
        G_OPTION_ERROR_FAILED
    } GOptionError;
    GQuark g_option_error_quark(void);
    struct _GOptionEntry
    {
            const gchar * long_name;
            gchar short_name;
            gint flags;
            GOptionArg arg;
            gpointer arg_data;
            const gchar * description;
            const gchar * arg_description;
    };
    GOptionContext * g_option_context_new(const gchar * parameter_string);
    void g_option_context_set_summary(GOptionContext * context, const gchar * summary);
    const gchar * g_option_context_get_summary(GOptionContext * context);
    void g_option_context_set_description(GOptionContext * context, const gchar * description);
    const gchar * g_option_context_get_description(GOptionContext * context);
    void g_option_context_free(GOptionContext * context);
    void g_option_context_set_help_enabled(GOptionContext * context, gboolean help_enabled);
    gboolean g_option_context_get_help_enabled(GOptionContext * context);
    void g_option_context_set_ignore_unknown_options(GOptionContext * context, gboolean ignore_unknown);
    gboolean g_option_context_get_ignore_unknown_options(GOptionContext * context);
    void g_option_context_add_main_entries(GOptionContext * context, const GOptionEntry * entries, const gchar * translation_domain);
    gboolean g_option_context_parse(GOptionContext * context, gint * argc, gchar * * * argv, GError * * error);
    void g_option_context_set_translate_func(GOptionContext * context, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
    void g_option_context_set_translation_domain(GOptionContext * context, const gchar * domain);
    void g_option_context_add_group(GOptionContext * context, GOptionGroup * group);
    void g_option_context_set_main_group(GOptionContext * context, GOptionGroup * group);
    GOptionGroup * g_option_context_get_main_group(GOptionContext * context);
    gchar * g_option_context_get_help(GOptionContext * context, gboolean main_help, GOptionGroup * group);
    GOptionGroup * g_option_group_new(const gchar * name, const gchar * description, const gchar * help_description, gpointer user_data, GDestroyNotify destroy);
    void g_option_group_set_parse_hooks(GOptionGroup * group, GOptionParseFunc pre_parse_func, GOptionParseFunc post_parse_func);
    void g_option_group_set_error_hook(GOptionGroup * group, GOptionErrorFunc error_func);
    void g_option_group_free(GOptionGroup * group);
    void g_option_group_add_entries(GOptionGroup * group, const GOptionEntry * entries);
    void g_option_group_set_translate_func(GOptionGroup * group, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
    void g_option_group_set_translation_domain(GOptionGroup * group, const gchar * domain);
}
extern "C"
{
    typedef struct _GPatternSpec GPatternSpec;
    GPatternSpec * g_pattern_spec_new(const gchar * pattern);
    void g_pattern_spec_free(GPatternSpec * pspec);
    gboolean g_pattern_spec_equal(GPatternSpec * pspec1, GPatternSpec * pspec2);
    gboolean g_pattern_match(GPatternSpec * pspec, guint string_length, const gchar * string, const gchar * string_reversed);
    gboolean g_pattern_match_string(GPatternSpec * pspec, const gchar * string);
    gboolean g_pattern_match_simple(const gchar * pattern, const gchar * string);
}
extern "C"
{
    guint g_spaced_primes_closest(guint num) __attribute__((__const__));
}
extern "C"
{
    void g_qsort_with_data(gconstpointer pbase, gint total_elems, gsize size, GCompareDataFunc compare_func, gpointer user_data);
}
extern "C"
{
    typedef struct _GQueue GQueue;
    struct _GQueue
    {
            GList * head;
            GList * tail;
            guint length;
    };
    GQueue * g_queue_new(void);
    void g_queue_free(GQueue * queue);
    void g_queue_init(GQueue * queue);
    void g_queue_clear(GQueue * queue);
    gboolean g_queue_is_empty(GQueue * queue);
    guint g_queue_get_length(GQueue * queue);
    void g_queue_reverse(GQueue * queue);
    GQueue * g_queue_copy(GQueue * queue);
    void g_queue_foreach(GQueue * queue, GFunc func, gpointer user_data);
    GList * g_queue_find(GQueue * queue, gconstpointer data);
    GList * g_queue_find_custom(GQueue * queue, gconstpointer data, GCompareFunc func);
    void g_queue_sort(GQueue * queue, GCompareDataFunc compare_func, gpointer user_data);
    void g_queue_push_head(GQueue * queue, gpointer data);
    void g_queue_push_tail(GQueue * queue, gpointer data);
    void g_queue_push_nth(GQueue * queue, gpointer data, gint n);
    gpointer g_queue_pop_head(GQueue * queue);
    gpointer g_queue_pop_tail(GQueue * queue);
    gpointer g_queue_pop_nth(GQueue * queue, guint n);
    gpointer g_queue_peek_head(GQueue * queue);
    gpointer g_queue_peek_tail(GQueue * queue);
    gpointer g_queue_peek_nth(GQueue * queue, guint n);
    gint g_queue_index(GQueue * queue, gconstpointer data);
    void g_queue_remove(GQueue * queue, gconstpointer data);
    void g_queue_remove_all(GQueue * queue, gconstpointer data);
    void g_queue_insert_before(GQueue * queue, GList * sibling, gpointer data);
    void g_queue_insert_after(GQueue * queue, GList * sibling, gpointer data);
    void g_queue_insert_sorted(GQueue * queue, gpointer data, GCompareDataFunc func, gpointer user_data);
    void g_queue_push_head_link(GQueue * queue, GList * link_);
    void g_queue_push_tail_link(GQueue * queue, GList * link_);
    void g_queue_push_nth_link(GQueue * queue, gint n, GList * link_);
    GList * g_queue_pop_head_link(GQueue * queue);
    GList * g_queue_pop_tail_link(GQueue * queue);
    GList * g_queue_pop_nth_link(GQueue * queue, guint n);
    GList * g_queue_peek_head_link(GQueue * queue);
    GList * g_queue_peek_tail_link(GQueue * queue);
    GList * g_queue_peek_nth_link(GQueue * queue, guint n);
    gint g_queue_link_index(GQueue * queue, GList * link_);
    void g_queue_unlink(GQueue * queue, GList * link_);
    void g_queue_delete_link(GQueue * queue, GList * link_);
}
extern "C"
{
    typedef struct _GRand GRand;
    GRand * g_rand_new_with_seed(guint32 seed);
    GRand * g_rand_new_with_seed_array(const guint32 * seed, guint seed_length);
    GRand * g_rand_new(void);
    void g_rand_free(GRand * rand_);
    GRand * g_rand_copy(GRand * rand_);
    void g_rand_set_seed(GRand * rand_, guint32 seed);
    void g_rand_set_seed_array(GRand * rand_, const guint32 * seed, guint seed_length);
    guint32 g_rand_int(GRand * rand_);
    gint32 g_rand_int_range(GRand * rand_, gint32 begin, gint32 end);
    gdouble g_rand_double(GRand * rand_);
    gdouble g_rand_double_range(GRand * rand_, gdouble begin, gdouble end);
    void g_random_set_seed(guint32 seed);
    guint32 g_random_int(void);
    gint32 g_random_int_range(gint32 begin, gint32 end);
    gdouble g_random_double(void);
    gdouble g_random_double_range(gdouble begin, gdouble end);
}
extern "C"
{
    typedef struct _GRelation GRelation;
    typedef struct _GTuples GTuples;
    struct _GTuples
    {
            guint len;
    };
    GRelation * g_relation_new(gint fields);
    void g_relation_destroy(GRelation * relation);
    void g_relation_index(GRelation * relation, gint field, GHashFunc hash_func, GEqualFunc key_equal_func);
    void g_relation_insert(GRelation * relation, ...);
    gint g_relation_delete(GRelation * relation, gconstpointer key, gint field);
    GTuples * g_relation_select(GRelation * relation, gconstpointer key, gint field);
    gint g_relation_count(GRelation * relation, gconstpointer key, gint field);
    gboolean g_relation_exists(GRelation * relation, ...);
    void g_relation_print(GRelation * relation);
    void g_tuples_destroy(GTuples * tuples);
    gpointer g_tuples_index(GTuples * tuples, gint index_, gint field);
}
extern "C"
{
    typedef enum 
    {
        G_REGEX_ERROR_COMPILE, 
        G_REGEX_ERROR_OPTIMIZE, 
        G_REGEX_ERROR_REPLACE, 
        G_REGEX_ERROR_MATCH, 
        G_REGEX_ERROR_INTERNAL, 
        G_REGEX_ERROR_STRAY_BACKSLASH = 101, 
        G_REGEX_ERROR_MISSING_CONTROL_CHAR = 102, 
        G_REGEX_ERROR_UNRECOGNIZED_ESCAPE = 103, 
        G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER = 104, 
        G_REGEX_ERROR_QUANTIFIER_TOO_BIG = 105, 
        G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS = 106, 
        G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS = 107, 
        G_REGEX_ERROR_RANGE_OUT_OF_ORDER = 108, 
        G_REGEX_ERROR_NOTHING_TO_REPEAT = 109, 
        G_REGEX_ERROR_UNRECOGNIZED_CHARACTER = 112, 
        G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113, 
        G_REGEX_ERROR_UNMATCHED_PARENTHESIS = 114, 
        G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE = 115, 
        G_REGEX_ERROR_UNTERMINATED_COMMENT = 118, 
        G_REGEX_ERROR_EXPRESSION_TOO_LARGE = 120, 
        G_REGEX_ERROR_MEMORY_ERROR = 121, 
        G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND = 125, 
        G_REGEX_ERROR_MALFORMED_CONDITION = 126, 
        G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES = 127, 
        G_REGEX_ERROR_ASSERTION_EXPECTED = 128, 
        G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME = 130, 
        G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131, 
        G_REGEX_ERROR_HEX_CODE_TOO_LARGE = 134, 
        G_REGEX_ERROR_INVALID_CONDITION = 135, 
        G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136, 
        G_REGEX_ERROR_INFINITE_LOOP = 140, 
        G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR = 142, 
        G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME = 143, 
        G_REGEX_ERROR_MALFORMED_PROPERTY = 146, 
        G_REGEX_ERROR_UNKNOWN_PROPERTY = 147, 
        G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG = 148, 
        G_REGEX_ERROR_TOO_MANY_SUBPATTERNS = 149, 
        G_REGEX_ERROR_INVALID_OCTAL_VALUE = 151, 
        G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE = 154, 
        G_REGEX_ERROR_DEFINE_REPETION = 155, 
        G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS = 156, 
        G_REGEX_ERROR_MISSING_BACK_REFERENCE = 157
    } GRegexError;
    GQuark g_regex_error_quark(void);
    typedef enum 
    {
        G_REGEX_CASELESS = 1 << 0, 
        G_REGEX_MULTILINE = 1 << 1, 
        G_REGEX_DOTALL = 1 << 2, 
        G_REGEX_EXTENDED = 1 << 3, 
        G_REGEX_ANCHORED = 1 << 4, 
        G_REGEX_DOLLAR_ENDONLY = 1 << 5, 
        G_REGEX_UNGREEDY = 1 << 9, 
        G_REGEX_RAW = 1 << 11, 
        G_REGEX_NO_AUTO_CAPTURE = 1 << 12, 
        G_REGEX_OPTIMIZE = 1 << 13, 
        G_REGEX_DUPNAMES = 1 << 19, 
        G_REGEX_NEWLINE_CR = 1 << 20, 
        G_REGEX_NEWLINE_LF = 1 << 21, 
        G_REGEX_NEWLINE_CRLF = G_REGEX_NEWLINE_CR | G_REGEX_NEWLINE_LF
    } GRegexCompileFlags;
    typedef enum 
    {
        G_REGEX_MATCH_ANCHORED = 1 << 4, 
        G_REGEX_MATCH_NOTBOL = 1 << 7, 
        G_REGEX_MATCH_NOTEOL = 1 << 8, 
        G_REGEX_MATCH_NOTEMPTY = 1 << 10, 
        G_REGEX_MATCH_PARTIAL = 1 << 15, 
        G_REGEX_MATCH_NEWLINE_CR = 1 << 20, 
        G_REGEX_MATCH_NEWLINE_LF = 1 << 21, 
        G_REGEX_MATCH_NEWLINE_CRLF = G_REGEX_MATCH_NEWLINE_CR | G_REGEX_MATCH_NEWLINE_LF, 
        G_REGEX_MATCH_NEWLINE_ANY = 1 << 22
    } GRegexMatchFlags;
    typedef struct _GRegex GRegex;
    typedef struct _GMatchInfo GMatchInfo;
    typedef gboolean (* GRegexEvalCallback)(const GMatchInfo * match_info, GString * result, gpointer user_data);
    GRegex * g_regex_new(const gchar * pattern, GRegexCompileFlags compile_options, GRegexMatchFlags match_options, GError * * error);
    GRegex * g_regex_ref(GRegex * regex);
    void g_regex_unref(GRegex * regex);
    const gchar * g_regex_get_pattern(const GRegex * regex);
    gint g_regex_get_max_backref(const GRegex * regex);
    gint g_regex_get_capture_count(const GRegex * regex);
    gint g_regex_get_string_number(const GRegex * regex, const gchar * name);
    gchar * g_regex_escape_string(const gchar * string, gint length);
    gboolean g_regex_match_simple(const gchar * pattern, const gchar * string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options);
    gboolean g_regex_match(const GRegex * regex, const gchar * string, GRegexMatchFlags match_options, GMatchInfo * * match_info);
    gboolean g_regex_match_full(const GRegex * regex, const gchar * string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo * * match_info, GError * * error);
    gboolean g_regex_match_all(const GRegex * regex, const gchar * string, GRegexMatchFlags match_options, GMatchInfo * * match_info);
    gboolean g_regex_match_all_full(const GRegex * regex, const gchar * string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo * * match_info, GError * * error);
    gchar * * g_regex_split_simple(const gchar * pattern, const gchar * string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options);
    gchar * * g_regex_split(const GRegex * regex, const gchar * string, GRegexMatchFlags match_options);
    gchar * * g_regex_split_full(const GRegex * regex, const gchar * string, gssize string_len, gint start_position, GRegexMatchFlags match_options, gint max_tokens, GError * * error);
    gchar * g_regex_replace(const GRegex * regex, const gchar * string, gssize string_len, gint start_position, const gchar * replacement, GRegexMatchFlags match_options, GError * * error);
    gchar * g_regex_replace_literal(const GRegex * regex, const gchar * string, gssize string_len, gint start_position, const gchar * replacement, GRegexMatchFlags match_options, GError * * error);
    gchar * g_regex_replace_eval(const GRegex * regex, const gchar * string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GRegexEvalCallback eval, gpointer user_data, GError * * error);
    gboolean g_regex_check_replacement(const gchar * replacement, gboolean * has_references, GError * * error);
    GRegex * g_match_info_get_regex(const GMatchInfo * match_info);
    const gchar * g_match_info_get_string(const GMatchInfo * match_info);
    void g_match_info_free(GMatchInfo * match_info);
    gboolean g_match_info_next(GMatchInfo * match_info, GError * * error);
    gboolean g_match_info_matches(const GMatchInfo * match_info);
    gint g_match_info_get_match_count(const GMatchInfo * match_info);
    gboolean g_match_info_is_partial_match(const GMatchInfo * match_info);
    gchar * g_match_info_expand_references(const GMatchInfo * match_info, const gchar * string_to_expand, GError * * error);
    gchar * g_match_info_fetch(const GMatchInfo * match_info, gint match_num);
    gboolean g_match_info_fetch_pos(const GMatchInfo * match_info, gint match_num, gint * start_pos, gint * end_pos);
    gchar * g_match_info_fetch_named(const GMatchInfo * match_info, const gchar * name);
    gboolean g_match_info_fetch_named_pos(const GMatchInfo * match_info, const gchar * name, gint * start_pos, gint * end_pos);
    gchar * * g_match_info_fetch_all(const GMatchInfo * match_info);
}
extern "C"
{
    typedef struct _GScanner GScanner;
    typedef struct _GScannerConfig GScannerConfig;
    typedef union _GTokenValue GTokenValue;
    typedef void (* GScannerMsgFunc)(GScanner * scanner, gchar * message, gboolean error);
    typedef enum 
    {
        G_ERR_UNKNOWN, 
        G_ERR_UNEXP_EOF, 
        G_ERR_UNEXP_EOF_IN_STRING, 
        G_ERR_UNEXP_EOF_IN_COMMENT, 
        G_ERR_NON_DIGIT_IN_CONST, 
        G_ERR_DIGIT_RADIX, 
        G_ERR_FLOAT_RADIX, 
        G_ERR_FLOAT_MALFORMED
    } GErrorType;
    typedef enum 
    {
        G_TOKEN_EOF = 0, 
        G_TOKEN_LEFT_PAREN = '(', 
        G_TOKEN_RIGHT_PAREN = ')', 
        G_TOKEN_LEFT_CURLY = '{', 
        G_TOKEN_RIGHT_CURLY = '}', 
        G_TOKEN_LEFT_BRACE = '[', 
        G_TOKEN_RIGHT_BRACE = ']', 
        G_TOKEN_EQUAL_SIGN = '=', 
        G_TOKEN_COMMA = ',', 
        G_TOKEN_NONE = 256, 
        G_TOKEN_ERROR, 
        G_TOKEN_CHAR, 
        G_TOKEN_BINARY, 
        G_TOKEN_OCTAL, 
        G_TOKEN_INT, 
        G_TOKEN_HEX, 
        G_TOKEN_FLOAT, 
        G_TOKEN_STRING, 
        G_TOKEN_SYMBOL, 
        G_TOKEN_IDENTIFIER, 
        G_TOKEN_IDENTIFIER_NULL, 
        G_TOKEN_COMMENT_SINGLE, 
        G_TOKEN_COMMENT_MULTI, 
        G_TOKEN_LAST
    } GTokenType;
    union _GTokenValue
    {
            gpointer v_symbol;
            gchar * v_identifier;
            gulong v_binary;
            gulong v_octal;
            gulong v_int;
            guint64 v_int64;
            gdouble v_float;
            gulong v_hex;
            gchar * v_string;
            gchar * v_comment;
            guchar v_char;
            guint v_error;
    };
    struct _GScannerConfig
    {
            gchar * cset_skip_characters;
            gchar * cset_identifier_first;
            gchar * cset_identifier_nth;
            gchar * cpair_comment_single;
            guint case_sensitive : 1;
            guint skip_comment_multi : 1;
            guint skip_comment_single : 1;
            guint scan_comment_multi : 1;
            guint scan_identifier : 1;
            guint scan_identifier_1char : 1;
            guint scan_identifier_NULL : 1;
            guint scan_symbols : 1;
            guint scan_binary : 1;
            guint scan_octal : 1;
            guint scan_float : 1;
            guint scan_hex : 1;
            guint scan_hex_dollar : 1;
            guint scan_string_sq : 1;
            guint scan_string_dq : 1;
            guint numbers_2_int : 1;
            guint int_2_float : 1;
            guint identifier_2_string : 1;
            guint char_2_token : 1;
            guint symbol_2_token : 1;
            guint scope_0_fallback : 1;
            guint store_int64 : 1;
            guint padding_dummy;
    };
    struct _GScanner
    {
            gpointer user_data;
            guint max_parse_errors;
            guint parse_errors;
            const gchar * input_name;
            GData * qdata;
            GScannerConfig * config;
            GTokenType token;
            GTokenValue value;
            guint line;
            guint position;
            GTokenType next_token;
            GTokenValue next_value;
            guint next_line;
            guint next_position;
            GHashTable * symbol_table;
            gint input_fd;
            const gchar * text;
            const gchar * text_end;
            gchar * buffer;
            guint scope_id;
            GScannerMsgFunc msg_handler;
    };
    GScanner * g_scanner_new(const GScannerConfig * config_templ);
    void g_scanner_destroy(GScanner * scanner);
    void g_scanner_input_file(GScanner * scanner, gint input_fd);
    void g_scanner_sync_file_offset(GScanner * scanner);
    void g_scanner_input_text(GScanner * scanner, const gchar * text, guint text_len);
    GTokenType g_scanner_get_next_token(GScanner * scanner);
    GTokenType g_scanner_peek_next_token(GScanner * scanner);
    GTokenType g_scanner_cur_token(GScanner * scanner);
    GTokenValue g_scanner_cur_value(GScanner * scanner);
    guint g_scanner_cur_line(GScanner * scanner);
    guint g_scanner_cur_position(GScanner * scanner);
    gboolean g_scanner_eof(GScanner * scanner);
    guint g_scanner_set_scope(GScanner * scanner, guint scope_id);
    void g_scanner_scope_add_symbol(GScanner * scanner, guint scope_id, const gchar * symbol, gpointer value);
    void g_scanner_scope_remove_symbol(GScanner * scanner, guint scope_id, const gchar * symbol);
    gpointer g_scanner_scope_lookup_symbol(GScanner * scanner, guint scope_id, const gchar * symbol);
    void g_scanner_scope_foreach_symbol(GScanner * scanner, guint scope_id, GHFunc func, gpointer user_data);
    gpointer g_scanner_lookup_symbol(GScanner * scanner, const gchar * symbol);
    void g_scanner_unexp_token(GScanner * scanner, GTokenType expected_token, const gchar * identifier_spec, const gchar * symbol_spec, const gchar * symbol_name, const gchar * message, gint is_error);
    void g_scanner_error(GScanner * scanner, const gchar * format, ...) __attribute__((__format__(__printf__, 2, 3)));
    void g_scanner_warn(GScanner * scanner, const gchar * format, ...) __attribute__((__format__(__printf__, 2, 3)));
}
typedef struct _GSequence GSequence;
typedef struct _GSequenceNode GSequenceIter;
typedef gint (* GSequenceIterCompareFunc)(GSequenceIter * a, GSequenceIter * b, gpointer data);
GSequence * g_sequence_new(GDestroyNotify data_destroy);
void g_sequence_free(GSequence * seq);
gint g_sequence_get_length(GSequence * seq);
void g_sequence_foreach(GSequence * seq, GFunc func, gpointer user_data);
void g_sequence_foreach_range(GSequenceIter * begin, GSequenceIter * end, GFunc func, gpointer user_data);
void g_sequence_sort(GSequence * seq, GCompareDataFunc cmp_func, gpointer cmp_data);
void g_sequence_sort_iter(GSequence * seq, GSequenceIterCompareFunc cmp_func, gpointer cmp_data);
GSequenceIter * g_sequence_get_begin_iter(GSequence * seq);
GSequenceIter * g_sequence_get_end_iter(GSequence * seq);
GSequenceIter * g_sequence_get_iter_at_pos(GSequence * seq, gint pos);
GSequenceIter * g_sequence_append(GSequence * seq, gpointer data);
GSequenceIter * g_sequence_prepend(GSequence * seq, gpointer data);
GSequenceIter * g_sequence_insert_before(GSequenceIter * iter, gpointer data);
void g_sequence_move(GSequenceIter * src, GSequenceIter * dest);
void g_sequence_swap(GSequenceIter * a, GSequenceIter * b);
GSequenceIter * g_sequence_insert_sorted(GSequence * seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
GSequenceIter * g_sequence_insert_sorted_iter(GSequence * seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
void g_sequence_sort_changed(GSequenceIter * iter, GCompareDataFunc cmp_func, gpointer cmp_data);
void g_sequence_sort_changed_iter(GSequenceIter * iter, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
void g_sequence_remove(GSequenceIter * iter);
void g_sequence_remove_range(GSequenceIter * begin, GSequenceIter * end);
void g_sequence_move_range(GSequenceIter * dest, GSequenceIter * begin, GSequenceIter * end);
GSequenceIter * g_sequence_search(GSequence * seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
GSequenceIter * g_sequence_search_iter(GSequence * seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
gpointer g_sequence_get(GSequenceIter * iter);
void g_sequence_set(GSequenceIter * iter, gpointer data);
gboolean g_sequence_iter_is_begin(GSequenceIter * iter);
gboolean g_sequence_iter_is_end(GSequenceIter * iter);
GSequenceIter * g_sequence_iter_next(GSequenceIter * iter);
GSequenceIter * g_sequence_iter_prev(GSequenceIter * iter);
gint g_sequence_iter_get_position(GSequenceIter * iter);
GSequenceIter * g_sequence_iter_move(GSequenceIter * iter, gint delta);
GSequence * g_sequence_iter_get_sequence(GSequenceIter * iter);
gint g_sequence_iter_compare(GSequenceIter * a, GSequenceIter * b);
GSequenceIter * g_sequence_range_get_midpoint(GSequenceIter * begin, GSequenceIter * end);
extern "C"
{
    typedef enum 
    {
        G_SHELL_ERROR_BAD_QUOTING, 
        G_SHELL_ERROR_EMPTY_STRING, 
        G_SHELL_ERROR_FAILED
    } GShellError;
    GQuark g_shell_error_quark(void);
    gchar * g_shell_quote(const gchar * unquoted_string);
    gchar * g_shell_unquote(const gchar * quoted_string, GError * * error);
    gboolean g_shell_parse_argv(const gchar * command_line, gint * argcp, gchar * * * argvp, GError * * error);
}
extern "C"
{
    typedef enum 
    {
        G_SPAWN_ERROR_FORK, 
        G_SPAWN_ERROR_READ, 
        G_SPAWN_ERROR_CHDIR, 
        G_SPAWN_ERROR_ACCES, 
        G_SPAWN_ERROR_PERM, 
        G_SPAWN_ERROR_2BIG, 
        G_SPAWN_ERROR_NOEXEC, 
        G_SPAWN_ERROR_NAMETOOLONG, 
        G_SPAWN_ERROR_NOENT, 
        G_SPAWN_ERROR_NOMEM, 
        G_SPAWN_ERROR_NOTDIR, 
        G_SPAWN_ERROR_LOOP, 
        G_SPAWN_ERROR_TXTBUSY, 
        G_SPAWN_ERROR_IO, 
        G_SPAWN_ERROR_NFILE, 
        G_SPAWN_ERROR_MFILE, 
        G_SPAWN_ERROR_INVAL, 
        G_SPAWN_ERROR_ISDIR, 
        G_SPAWN_ERROR_LIBBAD, 
        G_SPAWN_ERROR_FAILED
    } GSpawnError;
    typedef void (* GSpawnChildSetupFunc)(gpointer user_data);
    typedef enum 
    {
        G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1 << 0, 
        G_SPAWN_DO_NOT_REAP_CHILD = 1 << 1, 
        G_SPAWN_SEARCH_PATH = 1 << 2, 
        G_SPAWN_STDOUT_TO_DEV_NULL = 1 << 3, 
        G_SPAWN_STDERR_TO_DEV_NULL = 1 << 4, 
        G_SPAWN_CHILD_INHERITS_STDIN = 1 << 5, 
        G_SPAWN_FILE_AND_ARGV_ZERO = 1 << 6
    } GSpawnFlags;
    GQuark g_spawn_error_quark(void);
    gboolean g_spawn_async(const gchar * working_directory, gchar * * argv, gchar * * envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid * child_pid, GError * * error);
    gboolean g_spawn_async_with_pipes(const gchar * working_directory, gchar * * argv, gchar * * envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid * child_pid, gint * standard_input, gint * standard_output, gint * standard_error, GError * * error);
    gboolean g_spawn_sync(const gchar * working_directory, gchar * * argv, gchar * * envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gchar * * standard_output, gchar * * standard_error, gint * exit_status, GError * * error);
    gboolean g_spawn_command_line_sync(const gchar * command_line, gchar * * standard_output, gchar * * standard_error, gint * exit_status, GError * * error);
    gboolean g_spawn_command_line_async(const gchar * command_line, GError * * error);
    void g_spawn_close_pid(GPid pid);
}
extern "C"
{
    typedef enum 
    {
        G_ASCII_ALNUM = 1 << 0, 
        G_ASCII_ALPHA = 1 << 1, 
        G_ASCII_CNTRL = 1 << 2, 
        G_ASCII_DIGIT = 1 << 3, 
        G_ASCII_GRAPH = 1 << 4, 
        G_ASCII_LOWER = 1 << 5, 
        G_ASCII_PRINT = 1 << 6, 
        G_ASCII_PUNCT = 1 << 7, 
        G_ASCII_SPACE = 1 << 8, 
        G_ASCII_UPPER = 1 << 9, 
        G_ASCII_XDIGIT = 1 << 10
    } GAsciiType;
    extern const guint16 *const g_ascii_table;
    gchar g_ascii_tolower(gchar c) __attribute__((__const__));
    gchar g_ascii_toupper(gchar c) __attribute__((__const__));
    gint g_ascii_digit_value(gchar c) __attribute__((__const__));
    gint g_ascii_xdigit_value(gchar c) __attribute__((__const__));
    gchar * g_strdelimit(gchar * string, const gchar * delimiters, gchar new_delimiter);
    gchar * g_strcanon(gchar * string, const gchar * valid_chars, gchar substitutor);
    const gchar * g_strerror(gint errnum) __attribute__((__const__));
    const gchar * g_strsignal(gint signum) __attribute__((__const__));
    gchar * g_strreverse(gchar * string);
    gsize g_strlcpy(gchar * dest, const gchar * src, gsize dest_size);
    gsize g_strlcat(gchar * dest, const gchar * src, gsize dest_size);
    gchar * g_strstr_len(const gchar * haystack, gssize haystack_len, const gchar * needle);
    gchar * g_strrstr(const gchar * haystack, const gchar * needle);
    gchar * g_strrstr_len(const gchar * haystack, gssize haystack_len, const gchar * needle);
    gboolean g_str_has_suffix(const gchar * str, const gchar * suffix);
    gboolean g_str_has_prefix(const gchar * str, const gchar * prefix);
    gdouble g_strtod(const gchar * nptr, gchar * * endptr);
    gdouble g_ascii_strtod(const gchar * nptr, gchar * * endptr);
    guint64 g_ascii_strtoull(const gchar * nptr, gchar * * endptr, guint base);
    gint64 g_ascii_strtoll(const gchar * nptr, gchar * * endptr, guint base);
    gchar * g_ascii_dtostr(gchar * buffer, gint buf_len, gdouble d);
    gchar * g_ascii_formatd(gchar * buffer, gint buf_len, const gchar * format, gdouble d);
    gchar * g_strchug(gchar * string);
    gchar * g_strchomp(gchar * string);
    gint g_ascii_strcasecmp(const gchar * s1, const gchar * s2);
    gint g_ascii_strncasecmp(const gchar * s1, const gchar * s2, gsize n);
    gchar * g_ascii_strdown(const gchar * str, gssize len) __attribute__((__malloc__));
    gchar * g_ascii_strup(const gchar * str, gssize len) __attribute__((__malloc__));
    gint g_strcasecmp(const gchar * s1, const gchar * s2);
    gint g_strncasecmp(const gchar * s1, const gchar * s2, guint n);
    gchar * g_strdown(gchar * string);
    gchar * g_strup(gchar * string);
    gchar * g_strdup(const gchar * str) __attribute__((__malloc__));
    gchar * g_strdup_printf(const gchar * format, ...) __attribute__((__format__(__printf__, 1, 2))) __attribute__((__malloc__));
    gchar * g_strdup_vprintf(const gchar * format, va_list args) __attribute__((__malloc__));
    gchar * g_strndup(const gchar * str, gsize n) __attribute__((__malloc__));
    gchar * g_strnfill(gsize length, gchar fill_char) __attribute__((__malloc__));
    gchar * g_strconcat(const gchar * string1, ...) __attribute__((__malloc__)) __attribute__((__sentinel__));
    gchar * g_strjoin(const gchar * separator, ...) __attribute__((__malloc__)) __attribute__((__sentinel__));
    gchar * g_strcompress(const gchar * source) __attribute__((__malloc__));
    gchar * g_strescape(const gchar * source, const gchar * exceptions) __attribute__((__malloc__));
    gpointer g_memdup(gconstpointer mem, guint byte_size) __attribute__((__malloc__));
    gchar * * g_strsplit(const gchar * string, const gchar * delimiter, gint max_tokens) __attribute__((__malloc__));
    gchar * * g_strsplit_set(const gchar * string, const gchar * delimiters, gint max_tokens) __attribute__((__malloc__));
    gchar * g_strjoinv(const gchar * separator, gchar * * str_array) __attribute__((__malloc__));
    void g_strfreev(gchar * * str_array);
    gchar * * g_strdupv(gchar * * str_array) __attribute__((__malloc__));
    guint g_strv_length(gchar * * str_array);
    gchar * g_stpcpy(gchar * dest, const char * src);
    const gchar * g_strip_context(const gchar * msgid, const gchar * msgval);
    const gchar * g_dpgettext(const gchar * domain, const gchar * msgctxtid, gsize msgidoffset);
}
extern "C"
{
    typedef struct GTestCase GTestCase;
    typedef struct GTestSuite GTestSuite;
    int g_strcmp0(const char * str1, const char * str2);
    void g_test_minimized_result(double minimized_quantity, const char * format, ...) __attribute__((__format__(__printf__, 2, 3)));
    void g_test_maximized_result(double maximized_quantity, const char * format, ...) __attribute__((__format__(__printf__, 2, 3)));
    void g_test_init(int * argc, char * * * argv, ...);
    int g_test_run(void);
    void g_test_add_func(const char * testpath, void (* test_func)(void));
    void g_test_add_data_func(const char * testpath, gconstpointer test_data, void (* test_func)(gconstpointer));
    void g_test_message(const char * format, ...) __attribute__((__format__(__printf__, 1, 2)));
    void g_test_bug_base(const char * uri_pattern);
    void g_test_bug(const char * bug_uri_snippet);
    void g_test_timer_start(void);
    double g_test_timer_elapsed(void);
    double g_test_timer_last(void);
    void g_test_queue_free(gpointer gfree_pointer);
    void g_test_queue_destroy(GDestroyNotify destroy_func, gpointer destroy_data);
    typedef enum 
    {
        G_TEST_TRAP_SILENCE_STDOUT = 1 << 7, 
        G_TEST_TRAP_SILENCE_STDERR = 1 << 8, 
        G_TEST_TRAP_INHERIT_STDIN = 1 << 9
    } GTestTrapFlags;
    gboolean g_test_trap_fork(guint64 usec_timeout, GTestTrapFlags test_trap_flags);
    gboolean g_test_trap_has_passed(void);
    gboolean g_test_trap_reached_timeout(void);
    gint32 g_test_rand_int(void);
    gint32 g_test_rand_int_range(gint32 begin, gint32 end);
    double g_test_rand_double(void);
    double g_test_rand_double_range(double range_start, double range_end);
    GTestCase * g_test_create_case(const char * test_name, gsize data_size, gconstpointer test_data, void (* data_setup)(void), void (* data_test)(void), void (* data_teardown)(void));
    GTestSuite * g_test_create_suite(const char * suite_name);
    GTestSuite * g_test_get_root(void);
    void g_test_suite_add(GTestSuite * suite, GTestCase * test_case);
    void g_test_suite_add_suite(GTestSuite * suite, GTestSuite * nestedsuite);
    int g_test_run_suite(GTestSuite * suite);
    void g_test_trap_assertions(const char * domain, const char * file, int line, const char * func, guint64 assertion_flags, const char * pattern);
    void g_assertion_message(const char * domain, const char * file, int line, const char * func, const char * message) __attribute__((__noreturn__));
    void g_assertion_message_expr(const char * domain, const char * file, int line, const char * func, const char * expr) __attribute__((__noreturn__));
    void g_assertion_message_cmpstr(const char * domain, const char * file, int line, const char * func, const char * expr, const char * arg1, const char * cmp, const char * arg2) __attribute__((__noreturn__));
    void g_assertion_message_cmpnum(const char * domain, const char * file, int line, const char * func, const char * expr, long double arg1, const char * cmp, long double arg2, char numtype) __attribute__((__noreturn__));
    void g_test_add_vtable(const char * testpath, gsize data_size, gconstpointer test_data, void (* data_setup)(void), void (* data_test)(void), void (* data_teardown)(void));
    typedef struct 
    {
            gboolean test_initialized;
            gboolean test_quick;
            gboolean test_perf;
            gboolean test_verbose;
            gboolean test_quiet;
    } GTestConfig;
    extern const GTestConfig *const g_test_config_vars;
    typedef enum 
    {
        G_TEST_LOG_NONE, 
        G_TEST_LOG_ERROR, 
        G_TEST_LOG_START_BINARY, 
        G_TEST_LOG_LIST_CASE, 
        G_TEST_LOG_SKIP_CASE, 
        G_TEST_LOG_START_CASE, 
        G_TEST_LOG_STOP_CASE, 
        G_TEST_LOG_MIN_RESULT, 
        G_TEST_LOG_MAX_RESULT, 
        G_TEST_LOG_MESSAGE
    } GTestLogType;
    typedef struct 
    {
            GTestLogType log_type;
            guint n_strings;
            gchar * * strings;
            guint n_nums;
            long double * nums;
    } GTestLogMsg;
    typedef struct 
    {
            GString * data;
            GSList * msgs;
    } GTestLogBuffer;
    const char * g_test_log_type_name(GTestLogType log_type);
    GTestLogBuffer * g_test_log_buffer_new(void);
    void g_test_log_buffer_free(GTestLogBuffer * tbuffer);
    void g_test_log_buffer_push(GTestLogBuffer * tbuffer, guint n_bytes, const guint8 * bytes);
    GTestLogMsg * g_test_log_buffer_pop(GTestLogBuffer * tbuffer);
    void g_test_log_msg_free(GTestLogMsg * tmsg);
}
extern "C"
{
    typedef struct _GThreadPool GThreadPool;
    struct _GThreadPool
    {
            GFunc func;
            gpointer user_data;
            gboolean exclusive;
    };
    GThreadPool * g_thread_pool_new(GFunc func, gpointer user_data, gint max_threads, gboolean exclusive, GError * * error);
    void g_thread_pool_push(GThreadPool * pool, gpointer data, GError * * error);
    void g_thread_pool_set_max_threads(GThreadPool * pool, gint max_threads, GError * * error);
    gint g_thread_pool_get_max_threads(GThreadPool * pool);
    guint g_thread_pool_get_num_threads(GThreadPool * pool);
    guint g_thread_pool_unprocessed(GThreadPool * pool);
    void g_thread_pool_free(GThreadPool * pool, gboolean immediate, gboolean wait_);
    void g_thread_pool_set_max_unused_threads(gint max_threads);
    gint g_thread_pool_get_max_unused_threads(void);
    guint g_thread_pool_get_num_unused_threads(void);
    void g_thread_pool_stop_unused_threads(void);
    void g_thread_pool_set_sort_function(GThreadPool * pool, GCompareDataFunc func, gpointer user_data);
    void g_thread_pool_set_max_idle_time(guint interval);
    guint g_thread_pool_get_max_idle_time(void);
}
extern "C"
{
    typedef struct _GTimer GTimer;
    GTimer * g_timer_new(void);
    void g_timer_destroy(GTimer * timer);
    void g_timer_start(GTimer * timer);
    void g_timer_stop(GTimer * timer);
    void g_timer_reset(GTimer * timer);
    void g_timer_continue(GTimer * timer);
    gdouble g_timer_elapsed(GTimer * timer, gulong * microseconds);
    void g_usleep(gulong microseconds);
    void g_time_val_add(GTimeVal * time_, glong microseconds);
    gboolean g_time_val_from_iso8601(const gchar * iso_date, GTimeVal * time_);
    gchar * g_time_val_to_iso8601(GTimeVal * time_) __attribute__((__malloc__));
}
extern "C"
{
    typedef struct _GTree GTree;
    typedef gboolean (* GTraverseFunc)(gpointer key, gpointer value, gpointer data);
    GTree * g_tree_new(GCompareFunc key_compare_func);
    GTree * g_tree_new_with_data(GCompareDataFunc key_compare_func, gpointer key_compare_data);
    GTree * g_tree_new_full(GCompareDataFunc key_compare_func, gpointer key_compare_data, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func);
    void g_tree_destroy(GTree * tree);
    void g_tree_insert(GTree * tree, gpointer key, gpointer value);
    void g_tree_replace(GTree * tree, gpointer key, gpointer value);
    gboolean g_tree_remove(GTree * tree, gconstpointer key);
    gboolean g_tree_steal(GTree * tree, gconstpointer key);
    gpointer g_tree_lookup(GTree * tree, gconstpointer key);
    gboolean g_tree_lookup_extended(GTree * tree, gconstpointer lookup_key, gpointer * orig_key, gpointer * value);
    void g_tree_foreach(GTree * tree, GTraverseFunc func, gpointer user_data);
    void g_tree_traverse(GTree * tree, GTraverseFunc traverse_func, GTraverseType traverse_type, gpointer user_data);
    gpointer g_tree_search(GTree * tree, GCompareFunc search_func, gconstpointer user_data);
    gint g_tree_height(GTree * tree);
    gint g_tree_nnodes(GTree * tree);
}
extern "C"
{
    char * g_uri_unescape_string(const char * escaped_string, const char * illegal_characters);
    char * g_uri_unescape_segment(const char * escaped_string, const char * escaped_string_end, const char * illegal_characters);
    char * g_uri_parse_scheme(const char * uri);
    char * g_uri_escape_string(const char * unescaped, const char * reserved_chars_allowed, gboolean allow_utf8);
}
extern "C"
{
    typedef gulong GType;
    typedef struct _GValue GValue;
    typedef union _GTypeCValue GTypeCValue;
    typedef struct _GTypePlugin GTypePlugin;
    typedef struct _GTypeClass GTypeClass;
    typedef struct _GTypeInterface GTypeInterface;
    typedef struct _GTypeInstance GTypeInstance;
    typedef struct _GTypeInfo GTypeInfo;
    typedef struct _GTypeFundamentalInfo GTypeFundamentalInfo;
    typedef struct _GInterfaceInfo GInterfaceInfo;
    typedef struct _GTypeValueTable GTypeValueTable;
    typedef struct _GTypeQuery GTypeQuery;
    struct _GTypeClass
    {
            GType g_type;
    };
    struct _GTypeInstance
    {
            GTypeClass * g_class;
    };
    struct _GTypeInterface
    {
            GType g_type;
            GType g_instance_type;
    };
    struct _GTypeQuery
    {
            GType type;
            const gchar * type_name;
            guint class_size;
            guint instance_size;
    };
    typedef enum 
    {
        G_TYPE_DEBUG_NONE = 0, 
        G_TYPE_DEBUG_OBJECTS = 1 << 0, 
        G_TYPE_DEBUG_SIGNALS = 1 << 1, 
        G_TYPE_DEBUG_MASK = 0x03
    } GTypeDebugFlags;
    void g_type_init(void);
    void g_type_init_with_debug_flags(GTypeDebugFlags debug_flags);
    const gchar * g_type_name(GType type);
    GQuark g_type_qname(GType type);
    GType g_type_from_name(const gchar * name);
    GType g_type_parent(GType type);
    guint g_type_depth(GType type);
    GType g_type_next_base(GType leaf_type, GType root_type);
    gboolean g_type_is_a(GType type, GType is_a_type);
    gpointer g_type_class_ref(GType type);
    gpointer g_type_class_peek(GType type);
    gpointer g_type_class_peek_static(GType type);
    void g_type_class_unref(gpointer g_class);
    gpointer g_type_class_peek_parent(gpointer g_class);
    gpointer g_type_interface_peek(gpointer instance_class, GType iface_type);
    gpointer g_type_interface_peek_parent(gpointer g_iface);
    gpointer g_type_default_interface_ref(GType g_type);
    gpointer g_type_default_interface_peek(GType g_type);
    void g_type_default_interface_unref(gpointer g_iface);
    GType * g_type_children(GType type, guint * n_children);
    GType * g_type_interfaces(GType type, guint * n_interfaces);
    void g_type_set_qdata(GType type, GQuark quark, gpointer data);
    gpointer g_type_get_qdata(GType type, GQuark quark);
    void g_type_query(GType type, GTypeQuery * query);
    typedef void (* GBaseInitFunc)(gpointer g_class);
    typedef void (* GBaseFinalizeFunc)(gpointer g_class);
    typedef void (* GClassInitFunc)(gpointer g_class, gpointer class_data);
    typedef void (* GClassFinalizeFunc)(gpointer g_class, gpointer class_data);
    typedef void (* GInstanceInitFunc)(GTypeInstance * instance, gpointer g_class);
    typedef void (* GInterfaceInitFunc)(gpointer g_iface, gpointer iface_data);
    typedef void (* GInterfaceFinalizeFunc)(gpointer g_iface, gpointer iface_data);
    typedef gboolean (* GTypeClassCacheFunc)(gpointer cache_data, GTypeClass * g_class);
    typedef void (* GTypeInterfaceCheckFunc)(gpointer check_data, gpointer g_iface);
    typedef enum 
    {
        G_TYPE_FLAG_CLASSED = (1 << 0), 
        G_TYPE_FLAG_INSTANTIATABLE = (1 << 1), 
        G_TYPE_FLAG_DERIVABLE = (1 << 2), 
        G_TYPE_FLAG_DEEP_DERIVABLE = (1 << 3)
    } GTypeFundamentalFlags;
    typedef enum 
    {
        G_TYPE_FLAG_ABSTRACT = (1 << 4), 
        G_TYPE_FLAG_VALUE_ABSTRACT = (1 << 5)
    } GTypeFlags;
    struct _GTypeInfo
    {
            guint16 class_size;
            GBaseInitFunc base_init;
            GBaseFinalizeFunc base_finalize;
            GClassInitFunc class_init;
            GClassFinalizeFunc class_finalize;
            gconstpointer class_data;
            guint16 instance_size;
            guint16 n_preallocs;
            GInstanceInitFunc instance_init;
            const GTypeValueTable * value_table;
    };
    struct _GTypeFundamentalInfo
    {
            GTypeFundamentalFlags type_flags;
    };
    struct _GInterfaceInfo
    {
            GInterfaceInitFunc interface_init;
            GInterfaceFinalizeFunc interface_finalize;
            gpointer interface_data;
    };
    struct _GTypeValueTable
    {
            void (* value_init)(GValue * value);
            void (* value_free)(GValue * value);
            void (* value_copy)(const GValue * src_value, GValue * dest_value);
            gpointer (* value_peek_pointer)(const GValue * value);
            gchar * collect_format;
            gchar * (* collect_value)(GValue * value, guint n_collect_values, GTypeCValue * collect_values, guint collect_flags);
            gchar * lcopy_format;
            gchar * (* lcopy_value)(const GValue * value, guint n_collect_values, GTypeCValue * collect_values, guint collect_flags);
    };
    GType g_type_register_static(GType parent_type, const gchar * type_name, const GTypeInfo * info, GTypeFlags flags);
    GType g_type_register_static_simple(GType parent_type, const gchar * type_name, guint class_size, GClassInitFunc class_init, guint instance_size, GInstanceInitFunc instance_init, GTypeFlags flags);
    GType g_type_register_dynamic(GType parent_type, const gchar * type_name, GTypePlugin * plugin, GTypeFlags flags);
    GType g_type_register_fundamental(GType type_id, const gchar * type_name, const GTypeInfo * info, const GTypeFundamentalInfo * finfo, GTypeFlags flags);
    void g_type_add_interface_static(GType instance_type, GType interface_type, const GInterfaceInfo * info);
    void g_type_add_interface_dynamic(GType instance_type, GType interface_type, GTypePlugin * plugin);
    void g_type_interface_add_prerequisite(GType interface_type, GType prerequisite_type);
    GType * g_type_interface_prerequisites(GType interface_type, guint * n_prerequisites);
    void g_type_class_add_private(gpointer g_class, gsize private_size);
    gpointer g_type_instance_get_private(GTypeInstance * instance, GType private_type);
    GTypePlugin * g_type_get_plugin(GType type);
    GTypePlugin * g_type_interface_get_plugin(GType instance_type, GType interface_type);
    GType g_type_fundamental_next(void);
    GType g_type_fundamental(GType type_id);
    GTypeInstance * g_type_create_instance(GType type);
    void g_type_free_instance(GTypeInstance * instance);
    void g_type_add_class_cache_func(gpointer cache_data, GTypeClassCacheFunc cache_func);
    void g_type_remove_class_cache_func(gpointer cache_data, GTypeClassCacheFunc cache_func);
    void g_type_class_unref_uncached(gpointer g_class);
    void g_type_add_interface_check(gpointer check_data, GTypeInterfaceCheckFunc check_func);
    void g_type_remove_interface_check(gpointer check_data, GTypeInterfaceCheckFunc check_func);
    GTypeValueTable * g_type_value_table_peek(GType type);
    gboolean g_type_check_instance(GTypeInstance * instance) __attribute__((__pure__));
    GTypeInstance * g_type_check_instance_cast(GTypeInstance * instance, GType iface_type);
    gboolean g_type_check_instance_is_a(GTypeInstance * instance, GType iface_type) __attribute__((__pure__));
    GTypeClass * g_type_check_class_cast(GTypeClass * g_class, GType is_a_type);
    gboolean g_type_check_class_is_a(GTypeClass * g_class, GType is_a_type) __attribute__((__pure__));
    gboolean g_type_check_is_value_type(GType type) __attribute__((__const__));
    gboolean g_type_check_value(GValue * value) __attribute__((__pure__));
    gboolean g_type_check_value_holds(GValue * value, GType type) __attribute__((__pure__));
    gboolean g_type_test_flags(GType type, guint flags) __attribute__((__const__));
    const gchar * g_type_name_from_instance(GTypeInstance * instance);
    const gchar * g_type_name_from_class(GTypeClass * g_class);
    __attribute__((visibility("hidden"))) void g_value_c_init(void);
    __attribute__((visibility("hidden"))) void g_value_types_init(void);
    __attribute__((visibility("hidden"))) void g_enum_types_init(void);
    __attribute__((visibility("hidden"))) void g_param_type_init(void);
    __attribute__((visibility("hidden"))) void g_boxed_type_init(void);
    __attribute__((visibility("hidden"))) void g_object_type_init(void);
    __attribute__((visibility("hidden"))) void g_param_spec_types_init(void);
    __attribute__((visibility("hidden"))) void g_value_transforms_init(void);
    __attribute__((visibility("hidden"))) void g_signal_init(void);
    extern GTypeDebugFlags _g_type_debug_flags;
}
extern "C"
{
    typedef gpointer (* GBoxedCopyFunc)(gpointer boxed);
    typedef void (* GBoxedFreeFunc)(gpointer boxed);
    gpointer g_boxed_copy(GType boxed_type, gconstpointer src_boxed);
    void g_boxed_free(GType boxed_type, gpointer boxed);
    void g_value_set_boxed(GValue * value, gconstpointer v_boxed);
    void g_value_set_static_boxed(GValue * value, gconstpointer v_boxed);
    gpointer g_value_get_boxed(const GValue * value);
    gpointer g_value_dup_boxed(const GValue * value);
    GType g_boxed_type_register_static(const gchar * name, GBoxedCopyFunc boxed_copy, GBoxedFreeFunc boxed_free);
    void g_value_take_boxed(GValue * value, gconstpointer v_boxed);
    void g_value_set_boxed_take_ownership(GValue * value, gconstpointer v_boxed);
    GType g_closure_get_type(void) __attribute__((__const__));
    GType g_value_get_type(void) __attribute__((__const__));
    GType g_value_array_get_type(void) __attribute__((__const__));
    GType g_date_get_type(void) __attribute__((__const__));
    GType g_strv_get_type(void) __attribute__((__const__));
    GType g_gstring_get_type(void) __attribute__((__const__));
    GType g_hash_table_get_type(void) __attribute__((__const__));
    GType g_regex_get_type(void) __attribute__((__const__));
    typedef gchar * * GStrv;
}
extern "C"
{
    typedef struct _GEnumClass GEnumClass;
    typedef struct _GFlagsClass GFlagsClass;
    typedef struct _GEnumValue GEnumValue;
    typedef struct _GFlagsValue GFlagsValue;
    struct _GEnumClass
    {
            GTypeClass g_type_class;
            gint minimum;
            gint maximum;
            guint n_values;
            GEnumValue * values;
    };
    struct _GFlagsClass
    {
            GTypeClass g_type_class;
            guint mask;
            guint n_values;
            GFlagsValue * values;
    };
    struct _GEnumValue
    {
            gint value;
            const gchar * value_name;
            const gchar * value_nick;
    };
    struct _GFlagsValue
    {
            guint value;
            const gchar * value_name;
            const gchar * value_nick;
    };
    GEnumValue * g_enum_get_value(GEnumClass * enum_class, gint value);
    GEnumValue * g_enum_get_value_by_name(GEnumClass * enum_class, const gchar * name);
    GEnumValue * g_enum_get_value_by_nick(GEnumClass * enum_class, const gchar * nick);
    GFlagsValue * g_flags_get_first_value(GFlagsClass * flags_class, guint value);
    GFlagsValue * g_flags_get_value_by_name(GFlagsClass * flags_class, const gchar * name);
    GFlagsValue * g_flags_get_value_by_nick(GFlagsClass * flags_class, const gchar * nick);
    void g_value_set_enum(GValue * value, gint v_enum);
    gint g_value_get_enum(const GValue * value);
    void g_value_set_flags(GValue * value, guint v_flags);
    guint g_value_get_flags(const GValue * value);
    GType g_enum_register_static(const gchar * name, const GEnumValue * const_static_values);
    GType g_flags_register_static(const gchar * name, const GFlagsValue * const_static_values);
    void g_enum_complete_type_info(GType g_enum_type, GTypeInfo * info, const GEnumValue * const_values);
    void g_flags_complete_type_info(GType g_flags_type, GTypeInfo * info, const GFlagsValue * const_values);
}
extern "C"
{
    typedef void (* GValueTransform)(const GValue * src_value, GValue * dest_value);
    struct _GValue
    {
            GType g_type;
            union 
            {
                    gint v_int;
                    guint v_uint;
                    glong v_long;
                    gulong v_ulong;
                    gint64 v_int64;
                    guint64 v_uint64;
                    gfloat v_float;
                    gdouble v_double;
                    gpointer v_pointer;
            } data[2];
    };
    GValue * g_value_init(GValue * value, GType g_type);
    void g_value_copy(const GValue * src_value, GValue * dest_value);
    GValue * g_value_reset(GValue * value);
    void g_value_unset(GValue * value);
    void g_value_set_instance(GValue * value, gpointer instance);
    gboolean g_value_fits_pointer(const GValue * value);
    gpointer g_value_peek_pointer(const GValue * value);
    gboolean g_value_type_compatible(GType src_type, GType dest_type);
    gboolean g_value_type_transformable(GType src_type, GType dest_type);
    gboolean g_value_transform(const GValue * src_value, GValue * dest_value);
    void g_value_register_transform_func(GType src_type, GType dest_type, GValueTransform transform_func);
}
extern "C"
{
    typedef enum 
    {
        G_PARAM_READABLE = 1 << 0, 
        G_PARAM_WRITABLE = 1 << 1, 
        G_PARAM_CONSTRUCT = 1 << 2, 
        G_PARAM_CONSTRUCT_ONLY = 1 << 3, 
        G_PARAM_LAX_VALIDATION = 1 << 4, 
        G_PARAM_STATIC_NAME = 1 << 5, 
        G_PARAM_PRIVATE = G_PARAM_STATIC_NAME, 
        G_PARAM_STATIC_NICK = 1 << 6, 
        G_PARAM_STATIC_BLURB = 1 << 7
    } GParamFlags;
    typedef struct _GParamSpec GParamSpec;
    typedef struct _GParamSpecClass GParamSpecClass;
    typedef struct _GParameter GParameter;
    typedef struct _GParamSpecPool GParamSpecPool;
    struct _GParamSpec
    {
            GTypeInstance g_type_instance;
            gchar * name;
            GParamFlags flags;
            GType value_type;
            GType owner_type;
            gchar * _nick;
            gchar * _blurb;
            GData * qdata;
            guint ref_count;
            guint param_id;
    };
    struct _GParamSpecClass
    {
            GTypeClass g_type_class;
            GType value_type;
            void (* finalize)(GParamSpec * pspec);
            void (* value_set_default)(GParamSpec * pspec, GValue * value);
            gboolean (* value_validate)(GParamSpec * pspec, GValue * value);
            gint (* values_cmp)(GParamSpec * pspec, const GValue * value1, const GValue * value2);
            gpointer dummy[4];
    };
    struct _GParameter
    {
            const gchar * name;
            GValue value;
    };
    GParamSpec * g_param_spec_ref(GParamSpec * pspec);
    void g_param_spec_unref(GParamSpec * pspec);
    void g_param_spec_sink(GParamSpec * pspec);
    GParamSpec * g_param_spec_ref_sink(GParamSpec * pspec);
    gpointer g_param_spec_get_qdata(GParamSpec * pspec, GQuark quark);
    void g_param_spec_set_qdata(GParamSpec * pspec, GQuark quark, gpointer data);
    void g_param_spec_set_qdata_full(GParamSpec * pspec, GQuark quark, gpointer data, GDestroyNotify destroy);
    gpointer g_param_spec_steal_qdata(GParamSpec * pspec, GQuark quark);
    GParamSpec * g_param_spec_get_redirect_target(GParamSpec * pspec);
    void g_param_value_set_default(GParamSpec * pspec, GValue * value);
    gboolean g_param_value_defaults(GParamSpec * pspec, GValue * value);
    gboolean g_param_value_validate(GParamSpec * pspec, GValue * value);
    gboolean g_param_value_convert(GParamSpec * pspec, const GValue * src_value, GValue * dest_value, gboolean strict_validation);
    gint g_param_values_cmp(GParamSpec * pspec, const GValue * value1, const GValue * value2);
    const gchar * g_param_spec_get_name(GParamSpec * pspec);
    const gchar * g_param_spec_get_nick(GParamSpec * pspec);
    const gchar * g_param_spec_get_blurb(GParamSpec * pspec);
    void g_value_set_param(GValue * value, GParamSpec * param);
    GParamSpec * g_value_get_param(const GValue * value);
    GParamSpec * g_value_dup_param(const GValue * value);
    void g_value_take_param(GValue * value, GParamSpec * param);
    void g_value_set_param_take_ownership(GValue * value, GParamSpec * param);
    typedef struct _GParamSpecTypeInfo GParamSpecTypeInfo;
    struct _GParamSpecTypeInfo
    {
            guint16 instance_size;
            guint16 n_preallocs;
            void (* instance_init)(GParamSpec * pspec);
            GType value_type;
            void (* finalize)(GParamSpec * pspec);
            void (* value_set_default)(GParamSpec * pspec, GValue * value);
            gboolean (* value_validate)(GParamSpec * pspec, GValue * value);
            gint (* values_cmp)(GParamSpec * pspec, const GValue * value1, const GValue * value2);
    };
    GType g_param_type_register_static(const gchar * name, const GParamSpecTypeInfo * pspec_info);
    GType _g_param_type_register_static_constant(const gchar * name, const GParamSpecTypeInfo * pspec_info, GType opt_type);
    gpointer g_param_spec_internal(GType param_type, const gchar * name, const gchar * nick, const gchar * blurb, GParamFlags flags);
    GParamSpecPool * g_param_spec_pool_new(gboolean type_prefixing);
    void g_param_spec_pool_insert(GParamSpecPool * pool, GParamSpec * pspec, GType owner_type);
    void g_param_spec_pool_remove(GParamSpecPool * pool, GParamSpec * pspec);
    GParamSpec * g_param_spec_pool_lookup(GParamSpecPool * pool, const gchar * param_name, GType owner_type, gboolean walk_ancestors);
    GList * g_param_spec_pool_list_owned(GParamSpecPool * pool, GType owner_type);
    GParamSpec * * g_param_spec_pool_list(GParamSpecPool * pool, GType owner_type, guint * n_pspecs_p);
}
extern "C"
{
    typedef struct _GClosure GClosure;
    typedef struct _GClosureNotifyData GClosureNotifyData;
    typedef void (* GCallback)(void);
    typedef void (* GClosureNotify)(gpointer data, GClosure * closure);
    typedef void (* GClosureMarshal)(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    typedef struct _GCClosure GCClosure;
    struct _GClosureNotifyData
    {
            gpointer data;
            GClosureNotify notify;
    };
    struct _GClosure
    {
            volatile guint ref_count : 15;
            volatile guint meta_marshal : 1;
            volatile guint n_guards : 1;
            volatile guint n_fnotifiers : 2;
            volatile guint n_inotifiers : 8;
            volatile guint in_inotify : 1;
            volatile guint floating : 1;
            volatile guint derivative_flag : 1;
            volatile guint in_marshal : 1;
            volatile guint is_invalid : 1;
            void (* marshal)(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
            gpointer data;
            GClosureNotifyData * notifiers;
    };
    struct _GCClosure
    {
            GClosure closure;
            gpointer callback;
    };
    GClosure * g_cclosure_new(GCallback callback_func, gpointer user_data, GClosureNotify destroy_data);
    GClosure * g_cclosure_new_swap(GCallback callback_func, gpointer user_data, GClosureNotify destroy_data);
    GClosure * g_signal_type_cclosure_new(GType itype, guint struct_offset);
    GClosure * g_closure_ref(GClosure * closure);
    void g_closure_sink(GClosure * closure);
    void g_closure_unref(GClosure * closure);
    GClosure * g_closure_new_simple(guint sizeof_closure, gpointer data);
    void g_closure_add_finalize_notifier(GClosure * closure, gpointer notify_data, GClosureNotify notify_func);
    void g_closure_remove_finalize_notifier(GClosure * closure, gpointer notify_data, GClosureNotify notify_func);
    void g_closure_add_invalidate_notifier(GClosure * closure, gpointer notify_data, GClosureNotify notify_func);
    void g_closure_remove_invalidate_notifier(GClosure * closure, gpointer notify_data, GClosureNotify notify_func);
    void g_closure_add_marshal_guards(GClosure * closure, gpointer pre_marshal_data, GClosureNotify pre_marshal_notify, gpointer post_marshal_data, GClosureNotify post_marshal_notify);
    void g_closure_set_marshal(GClosure * closure, GClosureMarshal marshal);
    void g_closure_set_meta_marshal(GClosure * closure, gpointer marshal_data, GClosureMarshal meta_marshal);
    void g_closure_invalidate(GClosure * closure);
    void g_closure_invoke(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint);
}
extern "C"
{
    extern void g_cclosure_marshal_VOID__VOID(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_VOID__BOOLEAN(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_VOID__CHAR(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_VOID__UCHAR(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_VOID__INT(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_VOID__UINT(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_VOID__LONG(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_VOID__ULONG(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_VOID__ENUM(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_VOID__FLAGS(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_VOID__FLOAT(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_VOID__DOUBLE(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_VOID__STRING(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_VOID__PARAM(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_VOID__BOXED(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_VOID__POINTER(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_VOID__OBJECT(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_VOID__UINT_POINTER(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_BOOLEAN__FLAGS(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
    extern void g_cclosure_marshal_STRING__OBJECT_POINTER(GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
}
extern "C"
{
    typedef struct _GSignalQuery GSignalQuery;
    typedef struct _GSignalInvocationHint GSignalInvocationHint;
    typedef GClosureMarshal GSignalCMarshaller;
    typedef gboolean (* GSignalEmissionHook)(GSignalInvocationHint * ihint, guint n_param_values, const GValue * param_values, gpointer data);
    typedef gboolean (* GSignalAccumulator)(GSignalInvocationHint * ihint, GValue * return_accu, const GValue * handler_return, gpointer data);
    typedef enum 
    {
        G_SIGNAL_RUN_FIRST = 1 << 0, 
        G_SIGNAL_RUN_LAST = 1 << 1, 
        G_SIGNAL_RUN_CLEANUP = 1 << 2, 
        G_SIGNAL_NO_RECURSE = 1 << 3, 
        G_SIGNAL_DETAILED = 1 << 4, 
        G_SIGNAL_ACTION = 1 << 5, 
        G_SIGNAL_NO_HOOKS = 1 << 6
    } GSignalFlags;
    typedef enum 
    {
        G_CONNECT_AFTER = 1 << 0, 
        G_CONNECT_SWAPPED = 1 << 1
    } GConnectFlags;
    typedef enum 
    {
        G_SIGNAL_MATCH_ID = 1 << 0, 
        G_SIGNAL_MATCH_DETAIL = 1 << 1, 
        G_SIGNAL_MATCH_CLOSURE = 1 << 2, 
        G_SIGNAL_MATCH_FUNC = 1 << 3, 
        G_SIGNAL_MATCH_DATA = 1 << 4, 
        G_SIGNAL_MATCH_UNBLOCKED = 1 << 5
    } GSignalMatchType;
    struct _GSignalInvocationHint
    {
            guint signal_id;
            GQuark detail;
            GSignalFlags run_type;
    };
    struct _GSignalQuery
    {
            guint signal_id;
            const gchar * signal_name;
            GType itype;
            GSignalFlags signal_flags;
            GType return_type;
            guint n_params;
            const GType * param_types;
    };
    guint g_signal_newv(const gchar * signal_name, GType itype, GSignalFlags signal_flags, GClosure * class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, GType * param_types);
    guint g_signal_new_valist(const gchar * signal_name, GType itype, GSignalFlags signal_flags, GClosure * class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, va_list args);
    guint g_signal_new(const gchar * signal_name, GType itype, GSignalFlags signal_flags, guint class_offset, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, ...);
    void g_signal_emitv(const GValue * instance_and_params, guint signal_id, GQuark detail, GValue * return_value);
    void g_signal_emit_valist(gpointer instance, guint signal_id, GQuark detail, va_list var_args);
    void g_signal_emit(gpointer instance, guint signal_id, GQuark detail, ...);
    void g_signal_emit_by_name(gpointer instance, const gchar * detailed_signal, ...);
    guint g_signal_lookup(const gchar * name, GType itype);
    const gchar * g_signal_name(guint signal_id);
    void g_signal_query(guint signal_id, GSignalQuery * query);
    guint * g_signal_list_ids(GType itype, guint * n_ids);
    gboolean g_signal_parse_name(const gchar * detailed_signal, GType itype, guint * signal_id_p, GQuark * detail_p, gboolean force_detail_quark);
    GSignalInvocationHint * g_signal_get_invocation_hint(gpointer instance);
    void g_signal_stop_emission(gpointer instance, guint signal_id, GQuark detail);
    void g_signal_stop_emission_by_name(gpointer instance, const gchar * detailed_signal);
    gulong g_signal_add_emission_hook(guint signal_id, GQuark detail, GSignalEmissionHook hook_func, gpointer hook_data, GDestroyNotify data_destroy);
    void g_signal_remove_emission_hook(guint signal_id, gulong hook_id);
    gboolean g_signal_has_handler_pending(gpointer instance, guint signal_id, GQuark detail, gboolean may_be_blocked);
    gulong g_signal_connect_closure_by_id(gpointer instance, guint signal_id, GQuark detail, GClosure * closure, gboolean after);
    gulong g_signal_connect_closure(gpointer instance, const gchar * detailed_signal, GClosure * closure, gboolean after);
    gulong g_signal_connect_data(gpointer instance, const gchar * detailed_signal, GCallback c_handler, gpointer data, GClosureNotify destroy_data, GConnectFlags connect_flags);
    void g_signal_handler_block(gpointer instance, gulong handler_id);
    void g_signal_handler_unblock(gpointer instance, gulong handler_id);
    void g_signal_handler_disconnect(gpointer instance, gulong handler_id);
    gboolean g_signal_handler_is_connected(gpointer instance, gulong handler_id);
    gulong g_signal_handler_find(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure * closure, gpointer func, gpointer data);
    guint g_signal_handlers_block_matched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure * closure, gpointer func, gpointer data);
    guint g_signal_handlers_unblock_matched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure * closure, gpointer func, gpointer data);
    guint g_signal_handlers_disconnect_matched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure * closure, gpointer func, gpointer data);
    void g_signal_override_class_closure(guint signal_id, GType instance_type, GClosure * class_closure);
    void g_signal_chain_from_overridden(const GValue * instance_and_params, GValue * return_value);
    gboolean g_signal_accumulator_true_handled(GSignalInvocationHint * ihint, GValue * return_accu, const GValue * handler_return, gpointer dummy);
    void g_signal_handlers_destroy(gpointer instance);
    void _g_signals_destroy(GType itype);
}
extern "C"
{
    typedef struct _GObject GObject;
    typedef struct _GObjectClass GObjectClass;
    typedef struct _GObject GInitiallyUnowned;
    typedef struct _GObjectClass GInitiallyUnownedClass;
    typedef struct _GObjectConstructParam GObjectConstructParam;
    typedef void (* GObjectGetPropertyFunc)(GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
    typedef void (* GObjectSetPropertyFunc)(GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
    typedef void (* GObjectFinalizeFunc)(GObject * object);
    typedef void (* GWeakNotify)(gpointer data, GObject * where_the_object_was);
    struct _GObject
    {
            GTypeInstance g_type_instance;
            volatile guint ref_count;
            GData * qdata;
    };
    struct _GObjectClass
    {
            GTypeClass g_type_class;
            GSList * construct_properties;
            GObject * (* constructor)(GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
            void (* set_property)(GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
            void (* get_property)(GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
            void (* dispose)(GObject * object);
            void (* finalize)(GObject * object);
            void (* dispatch_properties_changed)(GObject * object, guint n_pspecs, GParamSpec * * pspecs);
            void (* notify)(GObject * object, GParamSpec * pspec);
            void (* constructed)(GObject * object);
            gpointer pdummy[7];
    };
    struct _GObjectConstructParam
    {
            GParamSpec * pspec;
            GValue * value;
    };
    GType g_initially_unowned_get_type(void);
    void g_object_class_install_property(GObjectClass * oclass, guint property_id, GParamSpec * pspec);
    GParamSpec * g_object_class_find_property(GObjectClass * oclass, const gchar * property_name);
    GParamSpec * * g_object_class_list_properties(GObjectClass * oclass, guint * n_properties);
    void g_object_class_override_property(GObjectClass * oclass, guint property_id, const gchar * name);
    void g_object_interface_install_property(gpointer g_iface, GParamSpec * pspec);
    GParamSpec * g_object_interface_find_property(gpointer g_iface, const gchar * property_name);
    GParamSpec * * g_object_interface_list_properties(gpointer g_iface, guint * n_properties_p);
    gpointer g_object_new(GType object_type, const gchar * first_property_name, ...);
    gpointer g_object_newv(GType object_type, guint n_parameters, GParameter * parameters);
    GObject * g_object_new_valist(GType object_type, const gchar * first_property_name, va_list var_args);
    void g_object_set(gpointer object, const gchar * first_property_name, ...) __attribute__((__sentinel__));
    void g_object_get(gpointer object, const gchar * first_property_name, ...) __attribute__((__sentinel__));
    gpointer g_object_connect(gpointer object, const gchar * signal_spec, ...) __attribute__((__sentinel__));
    void g_object_disconnect(gpointer object, const gchar * signal_spec, ...) __attribute__((__sentinel__));
    void g_object_set_valist(GObject * object, const gchar * first_property_name, va_list var_args);
    void g_object_get_valist(GObject * object, const gchar * first_property_name, va_list var_args);
    void g_object_set_property(GObject * object, const gchar * property_name, const GValue * value);
    void g_object_get_property(GObject * object, const gchar * property_name, GValue * value);
    void g_object_freeze_notify(GObject * object);
    void g_object_notify(GObject * object, const gchar * property_name);
    void g_object_thaw_notify(GObject * object);
    gboolean g_object_is_floating(gpointer object);
    gpointer g_object_ref_sink(gpointer object);
    gpointer g_object_ref(gpointer object);
    void g_object_unref(gpointer object);
    void g_object_weak_ref(GObject * object, GWeakNotify notify, gpointer data);
    void g_object_weak_unref(GObject * object, GWeakNotify notify, gpointer data);
    void g_object_add_weak_pointer(GObject * object, gpointer * weak_pointer_location);
    void g_object_remove_weak_pointer(GObject * object, gpointer * weak_pointer_location);
    typedef void (* GToggleNotify)(gpointer data, GObject * object, gboolean is_last_ref);
    void g_object_add_toggle_ref(GObject * object, GToggleNotify notify, gpointer data);
    void g_object_remove_toggle_ref(GObject * object, GToggleNotify notify, gpointer data);
    gpointer g_object_get_qdata(GObject * object, GQuark quark);
    void g_object_set_qdata(GObject * object, GQuark quark, gpointer data);
    void g_object_set_qdata_full(GObject * object, GQuark quark, gpointer data, GDestroyNotify destroy);
    gpointer g_object_steal_qdata(GObject * object, GQuark quark);
    gpointer g_object_get_data(GObject * object, const gchar * key);
    void g_object_set_data(GObject * object, const gchar * key, gpointer data);
    void g_object_set_data_full(GObject * object, const gchar * key, gpointer data, GDestroyNotify destroy);
    gpointer g_object_steal_data(GObject * object, const gchar * key);
    void g_object_watch_closure(GObject * object, GClosure * closure);
    GClosure * g_cclosure_new_object(GCallback callback_func, GObject * object);
    GClosure * g_cclosure_new_object_swap(GCallback callback_func, GObject * object);
    GClosure * g_closure_new_object(guint sizeof_closure, GObject * object);
    void g_value_set_object(GValue * value, gpointer v_object);
    gpointer g_value_get_object(const GValue * value);
    gpointer g_value_dup_object(const GValue * value);
    gulong g_signal_connect_object(gpointer instance, const gchar * detailed_signal, GCallback c_handler, gpointer gobject, GConnectFlags connect_flags);
    void g_object_force_floating(GObject * object);
    void g_object_run_dispose(GObject * object);
    void g_value_take_object(GValue * value, gpointer v_object);
    void g_value_set_object_take_ownership(GValue * value, gpointer v_object);
    gsize g_object_compat_control(gsize what, gpointer data);
}
extern "C"
{
    typedef struct _GParamSpecChar GParamSpecChar;
    typedef struct _GParamSpecUChar GParamSpecUChar;
    typedef struct _GParamSpecBoolean GParamSpecBoolean;
    typedef struct _GParamSpecInt GParamSpecInt;
    typedef struct _GParamSpecUInt GParamSpecUInt;
    typedef struct _GParamSpecLong GParamSpecLong;
    typedef struct _GParamSpecULong GParamSpecULong;
    typedef struct _GParamSpecInt64 GParamSpecInt64;
    typedef struct _GParamSpecUInt64 GParamSpecUInt64;
    typedef struct _GParamSpecUnichar GParamSpecUnichar;
    typedef struct _GParamSpecEnum GParamSpecEnum;
    typedef struct _GParamSpecFlags GParamSpecFlags;
    typedef struct _GParamSpecFloat GParamSpecFloat;
    typedef struct _GParamSpecDouble GParamSpecDouble;
    typedef struct _GParamSpecString GParamSpecString;
    typedef struct _GParamSpecParam GParamSpecParam;
    typedef struct _GParamSpecBoxed GParamSpecBoxed;
    typedef struct _GParamSpecPointer GParamSpecPointer;
    typedef struct _GParamSpecValueArray GParamSpecValueArray;
    typedef struct _GParamSpecObject GParamSpecObject;
    typedef struct _GParamSpecOverride GParamSpecOverride;
    typedef struct _GParamSpecGType GParamSpecGType;
    struct _GParamSpecChar
    {
            GParamSpec parent_instance;
            gint8 minimum;
            gint8 maximum;
            gint8 default_value;
    };
    struct _GParamSpecUChar
    {
            GParamSpec parent_instance;
            guint8 minimum;
            guint8 maximum;
            guint8 default_value;
    };
    struct _GParamSpecBoolean
    {
            GParamSpec parent_instance;
            gboolean default_value;
    };
    struct _GParamSpecInt
    {
            GParamSpec parent_instance;
            gint minimum;
            gint maximum;
            gint default_value;
    };
    struct _GParamSpecUInt
    {
            GParamSpec parent_instance;
            guint minimum;
            guint maximum;
            guint default_value;
    };
    struct _GParamSpecLong
    {
            GParamSpec parent_instance;
            glong minimum;
            glong maximum;
            glong default_value;
    };
    struct _GParamSpecULong
    {
            GParamSpec parent_instance;
            gulong minimum;
            gulong maximum;
            gulong default_value;
    };
    struct _GParamSpecInt64
    {
            GParamSpec parent_instance;
            gint64 minimum;
            gint64 maximum;
            gint64 default_value;
    };
    struct _GParamSpecUInt64
    {
            GParamSpec parent_instance;
            guint64 minimum;
            guint64 maximum;
            guint64 default_value;
    };
    struct _GParamSpecUnichar
    {
            GParamSpec parent_instance;
            gunichar default_value;
    };
    struct _GParamSpecEnum
    {
            GParamSpec parent_instance;
            GEnumClass * enum_class;
            gint default_value;
    };
    struct _GParamSpecFlags
    {
            GParamSpec parent_instance;
            GFlagsClass * flags_class;
            guint default_value;
    };
    struct _GParamSpecFloat
    {
            GParamSpec parent_instance;
            gfloat minimum;
            gfloat maximum;
            gfloat default_value;
            gfloat epsilon;
    };
    struct _GParamSpecDouble
    {
            GParamSpec parent_instance;
            gdouble minimum;
            gdouble maximum;
            gdouble default_value;
            gdouble epsilon;
    };
    struct _GParamSpecString
    {
            GParamSpec parent_instance;
            gchar * default_value;
            gchar * cset_first;
            gchar * cset_nth;
            gchar substitutor;
            guint null_fold_if_empty : 1;
            guint ensure_non_null : 1;
    };
    struct _GParamSpecParam
    {
            GParamSpec parent_instance;
    };
    struct _GParamSpecBoxed
    {
            GParamSpec parent_instance;
    };
    struct _GParamSpecPointer
    {
            GParamSpec parent_instance;
    };
    struct _GParamSpecValueArray
    {
            GParamSpec parent_instance;
            GParamSpec * element_spec;
            guint fixed_n_elements;
    };
    struct _GParamSpecObject
    {
            GParamSpec parent_instance;
    };
    struct _GParamSpecOverride
    {
            GParamSpec parent_instance;
            GParamSpec * overridden;
    };
    struct _GParamSpecGType
    {
            GParamSpec parent_instance;
            GType is_a_type;
    };
    GParamSpec * g_param_spec_char(const gchar * name, const gchar * nick, const gchar * blurb, gint8 minimum, gint8 maximum, gint8 default_value, GParamFlags flags);
    GParamSpec * g_param_spec_uchar(const gchar * name, const gchar * nick, const gchar * blurb, guint8 minimum, guint8 maximum, guint8 default_value, GParamFlags flags);
    GParamSpec * g_param_spec_boolean(const gchar * name, const gchar * nick, const gchar * blurb, gboolean default_value, GParamFlags flags);
    GParamSpec * g_param_spec_int(const gchar * name, const gchar * nick, const gchar * blurb, gint minimum, gint maximum, gint default_value, GParamFlags flags);
    GParamSpec * g_param_spec_uint(const gchar * name, const gchar * nick, const gchar * blurb, guint minimum, guint maximum, guint default_value, GParamFlags flags);
    GParamSpec * g_param_spec_long(const gchar * name, const gchar * nick, const gchar * blurb, glong minimum, glong maximum, glong default_value, GParamFlags flags);
    GParamSpec * g_param_spec_ulong(const gchar * name, const gchar * nick, const gchar * blurb, gulong minimum, gulong maximum, gulong default_value, GParamFlags flags);
    GParamSpec * g_param_spec_int64(const gchar * name, const gchar * nick, const gchar * blurb, gint64 minimum, gint64 maximum, gint64 default_value, GParamFlags flags);
    GParamSpec * g_param_spec_uint64(const gchar * name, const gchar * nick, const gchar * blurb, guint64 minimum, guint64 maximum, guint64 default_value, GParamFlags flags);
    GParamSpec * g_param_spec_unichar(const gchar * name, const gchar * nick, const gchar * blurb, gunichar default_value, GParamFlags flags);
    GParamSpec * g_param_spec_enum(const gchar * name, const gchar * nick, const gchar * blurb, GType enum_type, gint default_value, GParamFlags flags);
    GParamSpec * g_param_spec_flags(const gchar * name, const gchar * nick, const gchar * blurb, GType flags_type, guint default_value, GParamFlags flags);
    GParamSpec * g_param_spec_float(const gchar * name, const gchar * nick, const gchar * blurb, gfloat minimum, gfloat maximum, gfloat default_value, GParamFlags flags);
    GParamSpec * g_param_spec_double(const gchar * name, const gchar * nick, const gchar * blurb, gdouble minimum, gdouble maximum, gdouble default_value, GParamFlags flags);
    GParamSpec * g_param_spec_string(const gchar * name, const gchar * nick, const gchar * blurb, const gchar * default_value, GParamFlags flags);
    GParamSpec * g_param_spec_param(const gchar * name, const gchar * nick, const gchar * blurb, GType param_type, GParamFlags flags);
    GParamSpec * g_param_spec_boxed(const gchar * name, const gchar * nick, const gchar * blurb, GType boxed_type, GParamFlags flags);
    GParamSpec * g_param_spec_pointer(const gchar * name, const gchar * nick, const gchar * blurb, GParamFlags flags);
    GParamSpec * g_param_spec_value_array(const gchar * name, const gchar * nick, const gchar * blurb, GParamSpec * element_spec, GParamFlags flags);
    GParamSpec * g_param_spec_object(const gchar * name, const gchar * nick, const gchar * blurb, GType object_type, GParamFlags flags);
    GParamSpec * g_param_spec_override(const gchar * name, GParamSpec * overridden);
    GParamSpec * g_param_spec_gtype(const gchar * name, const gchar * nick, const gchar * blurb, GType is_a_type, GParamFlags flags);
    extern GType * g_param_spec_types;
}
extern "C"
{
    void g_source_set_closure(GSource * source, GClosure * closure);
    GType g_io_channel_get_type(void);
    GType g_io_condition_get_type(void);
}
extern "C"
{
    typedef struct _GTypeModule GTypeModule;
    typedef struct _GTypeModuleClass GTypeModuleClass;
    struct _GTypeModule
    {
            GObject parent_instance;
            guint use_count;
            GSList * type_infos;
            GSList * interface_infos;
            gchar * name;
    };
    struct _GTypeModuleClass
    {
            GObjectClass parent_class;
            gboolean (* load)(GTypeModule * module);
            void (* unload)(GTypeModule * module);
            void (* reserved1)(void);
            void (* reserved2)(void);
            void (* reserved3)(void);
            void (* reserved4)(void);
    };
    GType g_type_module_get_type(void) __attribute__((__const__));
    gboolean g_type_module_use(GTypeModule * module);
    void g_type_module_unuse(GTypeModule * module);
    void g_type_module_set_name(GTypeModule * module, const gchar * name);
    GType g_type_module_register_type(GTypeModule * module, GType parent_type, const gchar * type_name, const GTypeInfo * type_info, GTypeFlags flags);
    void g_type_module_add_interface(GTypeModule * module, GType instance_type, GType interface_type, const GInterfaceInfo * interface_info);
    GType g_type_module_register_enum(GTypeModule * module, const gchar * name, const GEnumValue * const_static_values);
    GType g_type_module_register_flags(GTypeModule * module, const gchar * name, const GFlagsValue * const_static_values);
}
extern "C"
{
    typedef struct _GTypePluginClass GTypePluginClass;
    typedef void (* GTypePluginUse)(GTypePlugin * plugin);
    typedef void (* GTypePluginUnuse)(GTypePlugin * plugin);
    typedef void (* GTypePluginCompleteTypeInfo)(GTypePlugin * plugin, GType g_type, GTypeInfo * info, GTypeValueTable * value_table);
    typedef void (* GTypePluginCompleteInterfaceInfo)(GTypePlugin * plugin, GType instance_type, GType interface_type, GInterfaceInfo * info);
    struct _GTypePluginClass
    {
            GTypeInterface base_iface;
            GTypePluginUse use_plugin;
            GTypePluginUnuse unuse_plugin;
            GTypePluginCompleteTypeInfo complete_type_info;
            GTypePluginCompleteInterfaceInfo complete_interface_info;
    };
    GType g_type_plugin_get_type(void) __attribute__((__const__));
    void g_type_plugin_use(GTypePlugin * plugin);
    void g_type_plugin_unuse(GTypePlugin * plugin);
    void g_type_plugin_complete_type_info(GTypePlugin * plugin, GType g_type, GTypeInfo * info, GTypeValueTable * value_table);
    void g_type_plugin_complete_interface_info(GTypePlugin * plugin, GType instance_type, GType interface_type, GInterfaceInfo * info);
}
extern "C"
{
    typedef struct _GValueArray GValueArray;
    struct _GValueArray
    {
            guint n_values;
            GValue * values;
            guint n_prealloced;
    };
    GValue * g_value_array_get_nth(GValueArray * value_array, guint index_);
    GValueArray * g_value_array_new(guint n_prealloced);
    void g_value_array_free(GValueArray * value_array);
    GValueArray * g_value_array_copy(const GValueArray * value_array);
    GValueArray * g_value_array_prepend(GValueArray * value_array, const GValue * value);
    GValueArray * g_value_array_append(GValueArray * value_array, const GValue * value);
    GValueArray * g_value_array_insert(GValueArray * value_array, guint index_, const GValue * value);
    GValueArray * g_value_array_remove(GValueArray * value_array, guint index_);
    GValueArray * g_value_array_sort(GValueArray * value_array, GCompareFunc compare_func);
    GValueArray * g_value_array_sort_with_data(GValueArray * value_array, GCompareDataFunc compare_func, gpointer user_data);
}
extern "C"
{
    void g_value_set_char(GValue * value, gchar v_char);
    gchar g_value_get_char(const GValue * value);
    void g_value_set_uchar(GValue * value, guchar v_uchar);
    guchar g_value_get_uchar(const GValue * value);
    void g_value_set_boolean(GValue * value, gboolean v_boolean);
    gboolean g_value_get_boolean(const GValue * value);
    void g_value_set_int(GValue * value, gint v_int);
    gint g_value_get_int(const GValue * value);
    void g_value_set_uint(GValue * value, guint v_uint);
    guint g_value_get_uint(const GValue * value);
    void g_value_set_long(GValue * value, glong v_long);
    glong g_value_get_long(const GValue * value);
    void g_value_set_ulong(GValue * value, gulong v_ulong);
    gulong g_value_get_ulong(const GValue * value);
    void g_value_set_int64(GValue * value, gint64 v_int64);
    gint64 g_value_get_int64(const GValue * value);
    void g_value_set_uint64(GValue * value, guint64 v_uint64);
    guint64 g_value_get_uint64(const GValue * value);
    void g_value_set_float(GValue * value, gfloat v_float);
    gfloat g_value_get_float(const GValue * value);
    void g_value_set_double(GValue * value, gdouble v_double);
    gdouble g_value_get_double(const GValue * value);
    void g_value_set_string(GValue * value, const gchar * v_string);
    void g_value_set_static_string(GValue * value, const gchar * v_string);
    const gchar * g_value_get_string(const GValue * value);
    gchar * g_value_dup_string(const GValue * value);
    void g_value_set_pointer(GValue * value, gpointer v_pointer);
    gpointer g_value_get_pointer(const GValue * value);
    GType g_gtype_get_type(void);
    void g_value_set_gtype(GValue * value, GType v_gtype);
    GType g_value_get_gtype(const GValue * value);
    GType g_pointer_type_register_static(const gchar * name);
    gchar * g_strdup_value_contents(const GValue * value);
    void g_value_take_string(GValue * value, gchar * v_string);
    void g_value_set_string_take_ownership(GValue * value, gchar * v_string);
    typedef gchar * gchararray;
}
namespace Glib {
    template<class T_CppObject >
    class RefPtr
    {
        public :
            inline RefPtr();
            inline ~RefPtr();
            explicit inline RefPtr(T_CppObject * pCppObject);
            inline RefPtr(const RefPtr< T_CppObject > & src);
            template<class T_CastFrom >
            inline RefPtr(const RefPtr< T_CastFrom > & src);
            inline void swap(RefPtr< T_CppObject > & other);
            inline RefPtr< T_CppObject > & operator =(const RefPtr< T_CppObject > & src);
            template<class T_CastFrom >
            inline RefPtr< T_CppObject > & operator =(const RefPtr< T_CastFrom > & src);
            inline bool operator ==(const RefPtr< T_CppObject > & src) const;
            inline bool operator !=(const RefPtr< T_CppObject > & src) const;
            inline T_CppObject * operator ->() const;
            inline operator bool() const;
            inline void clear();
            inline void reset();
            template<class T_CastFrom >
            static inline RefPtr< T_CppObject > cast_dynamic(const RefPtr< T_CastFrom > & src);
            template<class T_CastFrom >
            static inline RefPtr< T_CppObject > cast_static(const RefPtr< T_CastFrom > & src);
            template<class T_CastFrom >
            static inline RefPtr< T_CppObject > cast_const(const RefPtr< T_CastFrom > & src);
        private :
            T_CppObject * pCppObject_;
    };
    template<class T_CppObject >
    inline T_CppObject * RefPtr< T_CppObject >::operator ->() const
    {
        return pCppObject_;
    }
    template<class T_CppObject >
    inline RefPtr< T_CppObject >::RefPtr()
        : pCppObject_(0) 
    {
    }
    template<class T_CppObject >
    inline RefPtr< T_CppObject >::~RefPtr()
    {
        if (pCppObject_)
            pCppObject_->unreference();
    }
    template<class T_CppObject >
    inline RefPtr< T_CppObject >::RefPtr(T_CppObject * pCppObject)
        : pCppObject_(pCppObject) 
    {
    }
    template<class T_CppObject >
    inline RefPtr< T_CppObject >::RefPtr(const RefPtr< T_CppObject > & src)
        : pCppObject_(src.pCppObject_) 
    {
        if (pCppObject_)
            pCppObject_->reference();
    }
    template<class T_CppObject >
    template<class T_CastFrom >
    inline RefPtr< T_CppObject >::RefPtr(const RefPtr< T_CastFrom > & src)
        : pCppObject_(src.operator ->()) 
    {
        if (pCppObject_)
            pCppObject_->reference();
    }
    template<class T_CppObject >
    inline void RefPtr< T_CppObject >::swap(RefPtr< T_CppObject > & other)
    {
        T_CppObject *const temp = pCppObject_;
        pCppObject_ = other.pCppObject_;
        other.pCppObject_ = temp;
    }
    template<class T_CppObject >
    inline RefPtr< T_CppObject > & RefPtr< T_CppObject >::operator =(const RefPtr< T_CppObject > & src)
    {
        RefPtr< T_CppObject > temp(src);
        this->swap(temp);
        return *this;
    }
    template<class T_CppObject >
    template<class T_CastFrom >
    inline RefPtr< T_CppObject > & RefPtr< T_CppObject >::operator =(const RefPtr< T_CastFrom > & src)
    {
        RefPtr< T_CppObject > temp(src);
        this->swap(temp);
        return *this;
    }
    template<class T_CppObject >
    inline bool RefPtr< T_CppObject >::operator ==(const RefPtr< T_CppObject > & src) const
    {
        return (pCppObject_ == src.pCppObject_);
    }
    template<class T_CppObject >
    inline bool RefPtr< T_CppObject >::operator !=(const RefPtr< T_CppObject > & src) const
    {
        return (pCppObject_ != src.pCppObject_);
    }
    template<class T_CppObject >
    inline RefPtr< T_CppObject >::operator bool() const
    {
        return (pCppObject_ != 0);
    }
    template<class T_CppObject >
    inline void RefPtr< T_CppObject >::clear()
    {
        reset();
    }
    template<class T_CppObject >
    inline void RefPtr< T_CppObject >::reset()
    {
        RefPtr< T_CppObject > temp;
        this->swap(temp);
    }
    template<class T_CppObject >
    template<class T_CastFrom >
    inline RefPtr< T_CppObject > RefPtr< T_CppObject >::cast_dynamic(const RefPtr< T_CastFrom > & src)
    {
        T_CppObject *const pCppObject = dynamic_cast<T_CppObject * >(src.operator ->());
        if (pCppObject)
            pCppObject->reference();
        return RefPtr< T_CppObject >(pCppObject);
    }
    template<class T_CppObject >
    template<class T_CastFrom >
    inline RefPtr< T_CppObject > RefPtr< T_CppObject >::cast_static(const RefPtr< T_CastFrom > & src)
    {
        T_CppObject *const pCppObject = static_cast<T_CppObject * >(src.operator ->());
        if (pCppObject)
            pCppObject->reference();
        return RefPtr< T_CppObject >(pCppObject);
    }
    template<class T_CppObject >
    template<class T_CastFrom >
    inline RefPtr< T_CppObject > RefPtr< T_CppObject >::cast_const(const RefPtr< T_CastFrom > & src)
    {
        T_CppObject *const pCppObject = const_cast<T_CppObject * >(src.operator ->());
        if (pCppObject)
            pCppObject->reference();
        return RefPtr< T_CppObject >(pCppObject);
    }
    template<class T_CppObject >
    inline void swap(RefPtr< T_CppObject > & lhs, RefPtr< T_CppObject > & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    enum UnicodeType
    {
        UNICODE_CONTROL, 
        UNICODE_FORMAT, 
        UNICODE_UNASSIGNED, 
        UNICODE_PRIVATE_USE, 
        UNICODE_SURROGATE, 
        UNICODE_LOWERCASE_LETTER, 
        UNICODE_MODIFIER_LETTER, 
        UNICODE_OTHER_LETTER, 
        UNICODE_TITLECASE_LETTER, 
        UNICODE_UPPERCASE_LETTER, 
        UNICODE_COMBINING_MARK, 
        UNICODE_ENCLOSING_MARK, 
        UNICODE_NON_SPACING_MARK, 
        UNICODE_DECIMAL_NUMBER, 
        UNICODE_LETTER_NUMBER, 
        UNICODE_OTHER_NUMBER, 
        UNICODE_CONNECT_PUNCTUATION, 
        UNICODE_DASH_PUNCTUATION, 
        UNICODE_CLOSE_PUNCTUATION, 
        UNICODE_FINAL_PUNCTUATION, 
        UNICODE_INITIAL_PUNCTUATION, 
        UNICODE_OTHER_PUNCTUATION, 
        UNICODE_OPEN_PUNCTUATION, 
        UNICODE_CURRENCY_SYMBOL, 
        UNICODE_MODIFIER_SYMBOL, 
        UNICODE_MATH_SYMBOL, 
        UNICODE_OTHER_SYMBOL, 
        UNICODE_LINE_SEPARATOR, 
        UNICODE_PARAGRAPH_SEPARATOR, 
        UNICODE_SPACE_SEPARATOR
    };
    enum UnicodeBreakType
    {
        UNICODE_BREAK_MANDATORY, 
        UNICODE_BREAK_CARRIAGE_RETURN, 
        UNICODE_BREAK_LINE_FEED, 
        UNICODE_BREAK_COMBINING_MARK, 
        UNICODE_BREAK_SURROGATE, 
        UNICODE_BREAK_ZERO_WIDTH_SPACE, 
        UNICODE_BREAK_INSEPARABLE, 
        UNICODE_BREAK_NON_BREAKING_GLUE, 
        UNICODE_BREAK_CONTINGENT, 
        UNICODE_BREAK_SPACE, 
        UNICODE_BREAK_AFTER, 
        UNICODE_BREAK_BEFORE, 
        UNICODE_BREAK_BEFORE_AND_AFTER, 
        UNICODE_BREAK_HYPHEN, 
        UNICODE_BREAK_NON_STARTER, 
        UNICODE_BREAK_OPEN_PUNCTUATION, 
        UNICODE_BREAK_CLOSE_PUNCTUATION, 
        UNICODE_BREAK_QUOTATION, 
        UNICODE_BREAK_EXCLAMATION, 
        UNICODE_BREAK_IDEOGRAPHIC, 
        UNICODE_BREAK_NUMERIC, 
        UNICODE_BREAK_INFIX_SEPARATOR, 
        UNICODE_BREAK_SYMBOL, 
        UNICODE_BREAK_ALPHABETIC, 
        UNICODE_BREAK_PREFIX, 
        UNICODE_BREAK_POSTFIX, 
        UNICODE_BREAK_COMPLEX_CONTEXT, 
        UNICODE_BREAK_AMBIGUOUS, 
        UNICODE_BREAK_UNKNOWN, 
        UNICODE_BREAK_NEXT_LINE, 
        UNICODE_BREAK_WORD_JOINER, 
        UNICODE_BREAK_HANGUL_L_JAMO, 
        UNICODE_BREAK_HANGUL_V_JAMO, 
        UNICODE_BREAK_HANGUL_T_JAMO, 
        UNICODE_BREAK_HANGUL_LV_SYLLABLE, 
        UNICODE_BREAK_HANGUL_LVT_SYLLABLE
    };
    enum AsciiType
    {
        ASCII_ALNUM = 1 << 0, 
        ASCII_ALPHA = 1 << 1, 
        ASCII_CNTRL = 1 << 2, 
        ASCII_DIGIT = 1 << 3, 
        ASCII_GRAPH = 1 << 4, 
        ASCII_LOWER = 1 << 5, 
        ASCII_PRINT = 1 << 6, 
        ASCII_PUNCT = 1 << 7, 
        ASCII_SPACE = 1 << 8, 
        ASCII_UPPER = 1 << 9, 
        ASCII_XDIGIT = 1 << 10
    };
    inline AsciiType operator |(AsciiType lhs, AsciiType rhs)
    {
        return static_cast<AsciiType >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline AsciiType operator &(AsciiType lhs, AsciiType rhs)
    {
        return static_cast<AsciiType >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline AsciiType operator ^(AsciiType lhs, AsciiType rhs)
    {
        return static_cast<AsciiType >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline AsciiType operator ~(AsciiType flags)
    {
        return static_cast<AsciiType >(~static_cast<unsigned >(flags));
    }
    inline AsciiType & operator |=(AsciiType & lhs, AsciiType rhs)
    {
        return (lhs = static_cast<AsciiType >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline AsciiType & operator &=(AsciiType & lhs, AsciiType rhs)
    {
        return (lhs = static_cast<AsciiType >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline AsciiType & operator ^=(AsciiType & lhs, AsciiType rhs)
    {
        return (lhs = static_cast<AsciiType >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
    enum NormalizeMode
    {
        NORMALIZE_DEFAULT, 
        NORMALIZE_NFD, 
        NORMALIZE_DEFAULT_COMPOSE, 
        NORMALIZE_NFC = NORMALIZE_DEFAULT_COMPOSE, 
        NORMALIZE_ALL, 
        NORMALIZE_NFKD = NORMALIZE_ALL, 
        NORMALIZE_ALL_COMPOSE, 
        NORMALIZE_NFKC = NORMALIZE_ALL_COMPOSE
    };
    namespace Unicode {
        inline bool validate(gunichar uc)
        {
            return (g_unichar_validate(uc) != 0);
        }
        inline bool isalnum(gunichar uc)
        {
            return (g_unichar_isalnum(uc) != 0);
        }
        inline bool isalpha(gunichar uc)
        {
            return (g_unichar_isalpha(uc) != 0);
        }
        inline bool iscntrl(gunichar uc)
        {
            return (g_unichar_iscntrl(uc) != 0);
        }
        inline bool isdigit(gunichar uc)
        {
            return (g_unichar_isdigit(uc) != 0);
        }
        inline bool isgraph(gunichar uc)
        {
            return (g_unichar_isgraph(uc) != 0);
        }
        inline bool islower(gunichar uc)
        {
            return (g_unichar_islower(uc) != 0);
        }
        inline bool isprint(gunichar uc)
        {
            return (g_unichar_isprint(uc) != 0);
        }
        inline bool ispunct(gunichar uc)
        {
            return (g_unichar_ispunct(uc) != 0);
        }
        inline bool isspace(gunichar uc)
        {
            return (g_unichar_isspace(uc) != 0);
        }
        inline bool isupper(gunichar uc)
        {
            return (g_unichar_isupper(uc) != 0);
        }
        inline bool isxdigit(gunichar uc)
        {
            return (g_unichar_isxdigit(uc) != 0);
        }
        inline bool istitle(gunichar uc)
        {
            return (g_unichar_istitle(uc) != 0);
        }
        inline bool isdefined(gunichar uc)
        {
            return (g_unichar_isdefined(uc) != 0);
        }
        inline bool iswide(gunichar uc)
        {
            return (g_unichar_iswide(uc) != 0);
        }
        inline gunichar toupper(gunichar uc)
        {
            return g_unichar_toupper(uc);
        }
        inline gunichar tolower(gunichar uc)
        {
            return g_unichar_tolower(uc);
        }
        inline gunichar totitle(gunichar uc)
        {
            return g_unichar_totitle(uc);
        }
        inline int digit_value(gunichar uc)
        {
            return g_unichar_digit_value(uc);
        }
        inline int xdigit_value(gunichar uc)
        {
            return g_unichar_xdigit_value(uc);
        }
        inline Glib::UnicodeType type(gunichar uc)
        {
            return static_cast<Glib::UnicodeType >(static_cast<int >(g_unichar_type(uc)));
        }
        inline Glib::UnicodeBreakType break_type(gunichar uc)
        {
            return static_cast<Glib::UnicodeBreakType >(static_cast<int >(g_unichar_break_type(uc)));
        }
    }
    namespace Ascii {
        inline bool isalnum(char c)
        {
            return ((g_ascii_table[(guchar) (c)] & G_ASCII_ALNUM) != 0);
        }
        inline bool isalpha(char c)
        {
            return ((g_ascii_table[(guchar) (c)] & G_ASCII_ALPHA) != 0);
        }
        inline bool iscntrl(char c)
        {
            return ((g_ascii_table[(guchar) (c)] & G_ASCII_CNTRL) != 0);
        }
        inline bool isdigit(char c)
        {
            return ((g_ascii_table[(guchar) (c)] & G_ASCII_DIGIT) != 0);
        }
        inline bool isgraph(char c)
        {
            return ((g_ascii_table[(guchar) (c)] & G_ASCII_GRAPH) != 0);
        }
        inline bool islower(char c)
        {
            return ((g_ascii_table[(guchar) (c)] & G_ASCII_LOWER) != 0);
        }
        inline bool isprint(char c)
        {
            return ((g_ascii_table[(guchar) (c)] & G_ASCII_PRINT) != 0);
        }
        inline bool ispunct(char c)
        {
            return ((g_ascii_table[(guchar) (c)] & G_ASCII_PUNCT) != 0);
        }
        inline bool isspace(char c)
        {
            return ((g_ascii_table[(guchar) (c)] & G_ASCII_SPACE) != 0);
        }
        inline bool isupper(char c)
        {
            return ((g_ascii_table[(guchar) (c)] & G_ASCII_UPPER) != 0);
        }
        inline bool isxdigit(char c)
        {
            return ((g_ascii_table[(guchar) (c)] & G_ASCII_XDIGIT) != 0);
        }
        inline char tolower(char c)
        {
            return g_ascii_tolower(c);
        }
        inline char toupper(char c)
        {
            return g_ascii_toupper(c);
        }
        inline int digit_value(char c)
        {
            return g_ascii_digit_value(c);
        }
        inline int xdigit_value(char c)
        {
            return g_ascii_xdigit_value(c);
        }
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _CharT, typename _Traits, typename _Alloc >
    class basic_stringbuf : public basic_streambuf< _CharT, _Traits >
    {
        public :
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef _Alloc allocator_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            typedef basic_streambuf< char_type, traits_type > __streambuf_type;
            typedef basic_string< char_type, _Traits, _Alloc > __string_type;
            typedef typename __string_type::size_type __size_type;
        protected :
            ios_base::openmode _M_mode;
            __string_type _M_string;
        public :
            explicit basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
                : __streambuf_type(), _M_mode(__mode), _M_string() 
            {
            }
            explicit basic_stringbuf(const __string_type & __str, ios_base::openmode __mode = ios_base::in | ios_base::out)
                : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size()) 
            {
                _M_stringbuf_init(__mode);
            }
            __string_type str() const
            {
                __string_type __ret;
                if (this->pptr())
                {
                    if (this->pptr() > this->egptr())
                        __ret = __string_type(this->pbase(), this->pptr());
                    else
                        __ret = __string_type(this->pbase(), this->egptr());
                }
                else
                    __ret = _M_string;
                return __ret;
            }
            void str(const __string_type & __s)
            {
                _M_string.assign(__s.data(), __s.size());
                _M_stringbuf_init(_M_mode);
            }
        protected :
            void _M_stringbuf_init(ios_base::openmode __mode)
            {
                _M_mode = __mode;
                __size_type __len = 0;
                if (_M_mode & (ios_base::ate | ios_base::app))
                    __len = _M_string.size();
                _M_sync(const_cast<char_type * >(_M_string.data()), 0, __len);
            }
            virtual streamsize showmanyc()
            {
                streamsize __ret = -1;
                if (_M_mode & ios_base::in)
                {
                    _M_update_egptr();
                    __ret = this->egptr() - this->gptr();
                }
                return __ret;
            }
            virtual int_type underflow();
            virtual int_type pbackfail(int_type __c = traits_type::eof());
            virtual int_type overflow(int_type __c = traits_type::eof());
            virtual __streambuf_type * setbuf(char_type * __s, streamsize __n)
            {
                if (__s && __n >= 0)
                {
                    _M_string.clear();
                    _M_sync(__s, __n, 0);
                }
                return this;
            }
            virtual pos_type seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode = ios_base::in | ios_base::out);
            virtual pos_type seekpos(pos_type __sp, ios_base::openmode __mode = ios_base::in | ios_base::out);
            void _M_sync(char_type * __base, __size_type __i, __size_type __o);
            void _M_update_egptr()
            {
                const bool __testin = _M_mode & ios_base::in;
                if (this->pptr() && this->pptr() > this->egptr())
                    if (__testin)
                        this->setg(this->eback(), this->gptr(), this->pptr());
                    else
                        this->setg(this->pptr(), this->pptr(), this->pptr());
            }
    };
    template<typename _CharT, typename _Traits, typename _Alloc >
    class basic_istringstream : public basic_istream< _CharT, _Traits >
    {
        public :
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef _Alloc allocator_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            typedef basic_string< _CharT, _Traits, _Alloc > __string_type;
            typedef basic_stringbuf< _CharT, _Traits, _Alloc > __stringbuf_type;
            typedef basic_istream< char_type, traits_type > __istream_type;
        private :
            __stringbuf_type _M_stringbuf;
        public :
            explicit basic_istringstream(ios_base::openmode __mode = ios_base::in)
                : __istream_type(), _M_stringbuf(__mode | ios_base::in) 
            {
                this->init(&_M_stringbuf);
            }
            explicit basic_istringstream(const __string_type & __str, ios_base::openmode __mode = ios_base::in)
                : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in) 
            {
                this->init(&_M_stringbuf);
            }
            ~basic_istringstream()
            {
            }
            __stringbuf_type * rdbuf() const
            {
                return const_cast<__stringbuf_type * >(&_M_stringbuf);
            }
            __string_type str() const
            {
                return _M_stringbuf.str();
            }
            void str(const __string_type & __s)
            {
                _M_stringbuf.str(__s);
            }
    };
    template<typename _CharT, typename _Traits, typename _Alloc >
    class basic_ostringstream : public basic_ostream< _CharT, _Traits >
    {
        public :
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef _Alloc allocator_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            typedef basic_string< _CharT, _Traits, _Alloc > __string_type;
            typedef basic_stringbuf< _CharT, _Traits, _Alloc > __stringbuf_type;
            typedef basic_ostream< char_type, traits_type > __ostream_type;
        private :
            __stringbuf_type _M_stringbuf;
        public :
            explicit basic_ostringstream(ios_base::openmode __mode = ios_base::out)
                : __ostream_type(), _M_stringbuf(__mode | ios_base::out) 
            {
                this->init(&_M_stringbuf);
            }
            explicit basic_ostringstream(const __string_type & __str, ios_base::openmode __mode = ios_base::out)
                : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out) 
            {
                this->init(&_M_stringbuf);
            }
            ~basic_ostringstream()
            {
            }
            __stringbuf_type * rdbuf() const
            {
                return const_cast<__stringbuf_type * >(&_M_stringbuf);
            }
            __string_type str() const
            {
                return _M_stringbuf.str();
            }
            void str(const __string_type & __s)
            {
                _M_stringbuf.str(__s);
            }
    };
    template<typename _CharT, typename _Traits, typename _Alloc >
    class basic_stringstream : public basic_iostream< _CharT, _Traits >
    {
        public :
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef _Alloc allocator_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            typedef basic_string< _CharT, _Traits, _Alloc > __string_type;
            typedef basic_stringbuf< _CharT, _Traits, _Alloc > __stringbuf_type;
            typedef basic_iostream< char_type, traits_type > __iostream_type;
        private :
            __stringbuf_type _M_stringbuf;
        public :
            explicit basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
                : __iostream_type(), _M_stringbuf(__m) 
            {
                this->init(&_M_stringbuf);
            }
            explicit basic_stringstream(const __string_type & __str, ios_base::openmode __m = ios_base::out | ios_base::in)
                : __iostream_type(), _M_stringbuf(__str, __m) 
            {
                this->init(&_M_stringbuf);
            }
            ~basic_stringstream()
            {
            }
            __stringbuf_type * rdbuf() const
            {
                return const_cast<__stringbuf_type * >(&_M_stringbuf);
            }
            __string_type str() const
            {
                return _M_stringbuf.str();
            }
            void str(const __string_type & __s)
            {
                _M_stringbuf.str(__s);
            }
    };
}
namespace std __attribute__((__visibility__("default"))) {
    template<class _CharT, class _Traits, class _Alloc >
    typename basic_stringbuf< _CharT, _Traits, _Alloc >::int_type basic_stringbuf< _CharT, _Traits, _Alloc >::pbackfail(int_type __c)
    {
        int_type __ret = traits_type::eof();
        if (this->eback() < this->gptr())
        {
            const bool __testeof = traits_type::eq_int_type(__c, __ret);
            if (!__testeof)
            {
                const bool __testeq = traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]);
                const bool __testout = this->_M_mode & ios_base::out;
                if (__testeq || __testout)
                {
                    this->gbump(-1);
                    if (!__testeq)
                        *this->gptr() = traits_type::to_char_type(__c);
                    __ret = __c;
                }
            }
            else
            {
                this->gbump(-1);
                __ret = traits_type::not_eof(__c);
            }
        }
        return __ret;
    }
    template<class _CharT, class _Traits, class _Alloc >
    typename basic_stringbuf< _CharT, _Traits, _Alloc >::int_type basic_stringbuf< _CharT, _Traits, _Alloc >::overflow(int_type __c)
    {
        const bool __testout = this->_M_mode & ios_base::out;
        if (__builtin_expect(!__testout, false))
            return traits_type::eof();
        const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
        if (__builtin_expect(__testeof, false))
            return traits_type::not_eof(__c);
        const __size_type __capacity = _M_string.capacity();
        const __size_type __max_size = _M_string.max_size();
        const bool __testput = this->pptr() < this->epptr();
        if (__builtin_expect(!__testput && __capacity == __max_size, false))
            return traits_type::eof();
        const char_type __conv = traits_type::to_char_type(__c);
        if (!__testput)
        {
            const __size_type __opt_len = std::max(__size_type(2 * __capacity), __size_type(512));
            const __size_type __len = std::min(__opt_len, __max_size);
            __string_type __tmp;
            __tmp.reserve(__len);
            if (this->pbase())
                __tmp.assign(this->pbase(), this->epptr() - this->pbase());
            __tmp.push_back(__conv);
            _M_string.swap(__tmp);
            _M_sync(const_cast<char_type * >(_M_string.data()), this->gptr() - this->eback(), this->pptr() - this->pbase());
        }
        else
            *this->pptr() = __conv;
        this->pbump(1);
        return __c;
    }
    template<class _CharT, class _Traits, class _Alloc >
    typename basic_stringbuf< _CharT, _Traits, _Alloc >::int_type basic_stringbuf< _CharT, _Traits, _Alloc >::underflow()
    {
        int_type __ret = traits_type::eof();
        const bool __testin = this->_M_mode & ios_base::in;
        if (__testin)
        {
            _M_update_egptr();
            if (this->gptr() < this->egptr())
                __ret = traits_type::to_int_type(*this->gptr());
        }
        return __ret;
    }
    template<class _CharT, class _Traits, class _Alloc >
    typename basic_stringbuf< _CharT, _Traits, _Alloc >::pos_type basic_stringbuf< _CharT, _Traits, _Alloc >::seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
        pos_type __ret = pos_type(off_type(-1));
        bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
        bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
        const bool __testboth = __testin && __testout && __way != ios_base::cur;
        __testin &= !(__mode & ios_base::out);
        __testout &= !(__mode & ios_base::in);
        const char_type * __beg = __testin ? this->eback() : this->pbase();
        if ((__beg || !__off) && (__testin || __testout || __testboth))
        {
            _M_update_egptr();
            off_type __newoffi = __off;
            off_type __newoffo = __newoffi;
            if (__way == ios_base::cur)
            {
                __newoffi += this->gptr() - __beg;
                __newoffo += this->pptr() - __beg;
            }
            else
                if (__way == ios_base::end)
                    __newoffo = __newoffi += this->egptr() - __beg;
            if ((__testin || __testboth) && __newoffi >= 0 && this->egptr() - __beg >= __newoffi)
            {
                this->gbump((__beg + __newoffi) - this->gptr());
                __ret = pos_type(__newoffi);
            }
            if ((__testout || __testboth) && __newoffo >= 0 && this->egptr() - __beg >= __newoffo)
            {
                this->pbump((__beg + __newoffo) - this->pptr());
                __ret = pos_type(__newoffo);
            }
        }
        return __ret;
    }
    template<class _CharT, class _Traits, class _Alloc >
    typename basic_stringbuf< _CharT, _Traits, _Alloc >::pos_type basic_stringbuf< _CharT, _Traits, _Alloc >::seekpos(pos_type __sp, ios_base::openmode __mode)
    {
        pos_type __ret = pos_type(off_type(-1));
        const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
        const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
        const char_type * __beg = __testin ? this->eback() : this->pbase();
        if ((__beg || !off_type(__sp)) && (__testin || __testout))
        {
            _M_update_egptr();
            const off_type __pos(__sp);
            const bool __testpos = (0 <= __pos && __pos <= this->egptr() - __beg);
            if (__testpos)
            {
                if (__testin)
                    this->gbump((__beg + __pos) - this->gptr());
                if (__testout)
                    this->pbump((__beg + __pos) - this->pptr());
                __ret = __sp;
            }
        }
        return __ret;
    }
    template<class _CharT, class _Traits, class _Alloc >
    void basic_stringbuf< _CharT, _Traits, _Alloc >::_M_sync(char_type * __base, __size_type __i, __size_type __o)
    {
        const bool __testin = _M_mode & ios_base::in;
        const bool __testout = _M_mode & ios_base::out;
        char_type * __endg = __base + _M_string.size();
        char_type * __endp = __base + _M_string.capacity();
        if (__base != _M_string.data())
        {
            __endg += __i;
            __i = 0;
            __endp = __endg;
        }
        if (__testin)
            this->setg(__base, __base + __i, __endg);
        if (__testout)
        {
            this->setp(__base, __endp);
            this->pbump(__o);
            if (!__testin)
                this->setg(__endg, __endg, __endg);
        }
    }
    extern template class basic_stringbuf< char > ;
    extern template class basic_istringstream< char > ;
    extern template class basic_ostringstream< char > ;
    extern template class basic_stringstream< char > ;
    extern template class basic_stringbuf< wchar_t > ;
    extern template class basic_istringstream< wchar_t > ;
    extern template class basic_ostringstream< wchar_t > ;
    extern template class basic_stringstream< wchar_t > ;
}
namespace Glib {
    template<class T >
    class ustring_Iterator
    {
        public :
            typedef std::bidirectional_iterator_tag iterator_category;
            typedef gunichar value_type;
            typedef std::string::difference_type difference_type;
            typedef value_type reference;
            typedef void pointer;
            inline ustring_Iterator();
            inline ustring_Iterator(const ustring_Iterator< std::string::iterator > & other);
            inline value_type operator *() const;
            inline ustring_Iterator< T > & operator ++();
            inline const ustring_Iterator< T > operator ++(int);
            inline ustring_Iterator< T > & operator --();
            inline const ustring_Iterator< T > operator --(int);
            explicit inline ustring_Iterator(T pos);
            inline T base() const;
        private :
            T pos_;
    };
    gunichar get_unichar_from_std_iterator(std::string::const_iterator pos) __attribute__((__pure__));
    class ustring
    {
        public :
            typedef std::string::size_type size_type;
            typedef std::string::difference_type difference_type;
            typedef gunichar value_type;
            typedef gunichar & reference;
            typedef const gunichar & const_reference;
            typedef ustring_Iterator< std::string::iterator > iterator;
            typedef ustring_Iterator< std::string::const_iterator > const_iterator;
            typedef std::reverse_iterator< iterator > reverse_iterator;
            typedef std::reverse_iterator< const_iterator > const_reverse_iterator;
            static const size_type npos = std::string::npos;
            ustring();
            ~ustring();
            ustring(const ustring & other);
            ustring & operator =(const ustring & other);
            void swap(ustring & other);
            ustring(const std::string & src);
            ustring(const ustring & src, size_type i, size_type n = npos);
            ustring(const char * src, size_type n);
            ustring(const char * src);
            ustring(size_type n, gunichar uc);
            ustring(size_type n, char c);
            template<class In >
            ustring(In pbegin, In pend);
            ustring & operator =(const std::string & src);
            ustring & operator =(const char * src);
            ustring & operator =(gunichar uc);
            ustring & operator =(char c);
            ustring & assign(const ustring & src);
            ustring & assign(const ustring & src, size_type i, size_type n);
            ustring & assign(const char * src, size_type n);
            ustring & assign(const char * src);
            ustring & assign(size_type n, gunichar uc);
            ustring & assign(size_type n, char c);
            template<class In >
            ustring & assign(In pbegin, In pend);
            ustring & operator +=(const ustring & src);
            ustring & operator +=(const char * src);
            ustring & operator +=(gunichar uc);
            ustring & operator +=(char c);
            void push_back(gunichar uc);
            void push_back(char c);
            ustring & append(const ustring & src);
            ustring & append(const ustring & src, size_type i, size_type n);
            ustring & append(const char * src, size_type n);
            ustring & append(const char * src);
            ustring & append(size_type n, gunichar uc);
            ustring & append(size_type n, char c);
            template<class In >
            ustring & append(In pbegin, In pend);
            ustring & insert(size_type i, const ustring & src);
            ustring & insert(size_type i, const ustring & src, size_type i2, size_type n);
            ustring & insert(size_type i, const char * src, size_type n);
            ustring & insert(size_type i, const char * src);
            ustring & insert(size_type i, size_type n, gunichar uc);
            ustring & insert(size_type i, size_type n, char c);
            iterator insert(iterator p, gunichar uc);
            iterator insert(iterator p, char c);
            void insert(iterator p, size_type n, gunichar uc);
            void insert(iterator p, size_type n, char c);
            template<class In >
            void insert(iterator p, In pbegin, In pend);
            ustring & replace(size_type i, size_type n, const ustring & src);
            ustring & replace(size_type i, size_type n, const ustring & src, size_type i2, size_type n2);
            ustring & replace(size_type i, size_type n, const char * src, size_type n2);
            ustring & replace(size_type i, size_type n, const char * src);
            ustring & replace(size_type i, size_type n, size_type n2, gunichar uc);
            ustring & replace(size_type i, size_type n, size_type n2, char c);
            ustring & replace(iterator pbegin, iterator pend, const ustring & src);
            ustring & replace(iterator pbegin, iterator pend, const char * src, size_type n);
            ustring & replace(iterator pbegin, iterator pend, const char * src);
            ustring & replace(iterator pbegin, iterator pend, size_type n, gunichar uc);
            ustring & replace(iterator pbegin, iterator pend, size_type n, char c);
            template<class In >
            ustring & replace(iterator pbegin, iterator pend, In pbegin2, In pend2);
            void clear();
            ustring & erase(size_type i, size_type n = npos);
            ustring & erase();
            iterator erase(iterator p);
            iterator erase(iterator pbegin, iterator pend);
            int compare(const ustring & rhs) const;
            int compare(const char * rhs) const;
            int compare(size_type i, size_type n, const ustring & rhs) const;
            int compare(size_type i, size_type n, const ustring & rhs, size_type i2, size_type n2) const;
            int compare(size_type i, size_type n, const char * rhs, size_type n2) const;
            int compare(size_type i, size_type n, const char * rhs) const;
            std::string collate_key() const;
            std::string casefold_collate_key() const;
            value_type operator [](size_type i) const;
            value_type at(size_type i) const;
            inline ustring substr(size_type i = 0, size_type n = npos) const;
            iterator begin();
            iterator end();
            const_iterator begin() const;
            const_iterator end() const;
            reverse_iterator rbegin();
            reverse_iterator rend();
            const_reverse_iterator rbegin() const;
            const_reverse_iterator rend() const;
            size_type find(const ustring & str, size_type i = 0) const;
            size_type find(const char * str, size_type i, size_type n) const;
            size_type find(const char * str, size_type i = 0) const;
            size_type find(gunichar uc, size_type i = 0) const;
            size_type find(char c, size_type i = 0) const;
            size_type rfind(const ustring & str, size_type i = npos) const;
            size_type rfind(const char * str, size_type i, size_type n) const;
            size_type rfind(const char * str, size_type i = npos) const;
            size_type rfind(gunichar uc, size_type i = npos) const;
            size_type rfind(char c, size_type i = npos) const;
            size_type find_first_of(const ustring & match, size_type i = 0) const;
            size_type find_first_of(const char * match, size_type i, size_type n) const;
            size_type find_first_of(const char * match, size_type i = 0) const;
            size_type find_first_of(gunichar uc, size_type i = 0) const;
            size_type find_first_of(char c, size_type i = 0) const;
            size_type find_last_of(const ustring & match, size_type i = npos) const;
            size_type find_last_of(const char * match, size_type i, size_type n) const;
            size_type find_last_of(const char * match, size_type i = npos) const;
            size_type find_last_of(gunichar uc, size_type i = npos) const;
            size_type find_last_of(char c, size_type i = npos) const;
            size_type find_first_not_of(const ustring & match, size_type i = 0) const;
            size_type find_first_not_of(const char * match, size_type i, size_type n) const;
            size_type find_first_not_of(const char * match, size_type i = 0) const;
            size_type find_first_not_of(gunichar uc, size_type i = 0) const;
            size_type find_first_not_of(char c, size_type i = 0) const;
            size_type find_last_not_of(const ustring & match, size_type i = npos) const;
            size_type find_last_not_of(const char * match, size_type i, size_type n) const;
            size_type find_last_not_of(const char * match, size_type i = npos) const;
            size_type find_last_not_of(gunichar uc, size_type i = npos) const;
            size_type find_last_not_of(char c, size_type i = npos) const;
            bool empty() const;
            size_type size() const;
            size_type length() const;
            size_type bytes() const;
            void resize(size_type n, gunichar uc);
            void resize(size_type n, char c = '\0');
            size_type capacity() const;
            size_type max_size() const;
            void reserve(size_type n = 0);
            inline operator std::string() const;
            inline const std::string & raw() const;
            const char * data() const;
            const char * c_str() const;
            size_type copy(char * dest, size_type n, size_type i = 0) const;
            bool validate() const;
            bool validate(iterator & first_invalid);
            bool validate(const_iterator & first_invalid) const;
            bool is_ascii() const;
            ustring normalize(NormalizeMode mode = NORMALIZE_DEFAULT_COMPOSE) const;
            ustring uppercase() const;
            ustring lowercase() const;
            ustring casefold() const;
            template<class T1 >
            static inline ustring compose(const ustring & fmt, const T1 & a1);
            template<class T1, class T2 >
            static inline ustring compose(const ustring & fmt, const T1 & a1, const T2 & a2);
            template<class T1, class T2, class T3 >
            static inline ustring compose(const ustring & fmt, const T1 & a1, const T2 & a2, const T3 & a3);
            template<class T1, class T2, class T3, class T4 >
            static inline ustring compose(const ustring & fmt, const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4);
            template<class T1, class T2, class T3, class T4, class T5 >
            static inline ustring compose(const ustring & fmt, const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5);
            template<class T1, class T2, class T3, class T4, class T5, class T6 >
            static inline ustring compose(const ustring & fmt, const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5, const T6 & a6);
            template<class T1, class T2, class T3, class T4, class T5, class T6, class T7 >
            static inline ustring compose(const ustring & fmt, const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5, const T6 & a6, const T7 & a7);
            template<class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8 >
            static inline ustring compose(const ustring & fmt, const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5, const T6 & a6, const T7 & a7, const T8 & a8);
            template<class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9 >
            static inline ustring compose(const ustring & fmt, const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5, const T6 & a6, const T7 & a7, const T8 & a8, const T9 & a9);
            template<class T1 >
            static inline ustring format(const T1 & a1);
            template<class T1, class T2 >
            static inline ustring format(const T1 & a1, const T2 & a2);
            template<class T1, class T2, class T3 >
            static inline ustring format(const T1 & a1, const T2 & a2, const T3 & a3);
            template<class T1, class T2, class T3, class T4 >
            static inline ustring format(const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4);
            template<class T1, class T2, class T3, class T4, class T5 >
            static inline ustring format(const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5);
            template<class T1, class T2, class T3, class T4, class T5, class T6 >
            static inline ustring format(const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5, const T6 & a6);
            template<class T1, class T2, class T3, class T4, class T5, class T6, class T7 >
            static inline ustring format(const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5, const T6 & a6, const T7 & a7);
            template<class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8 >
            static inline ustring format(const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5, const T6 & a6, const T7 & a7, const T8 & a8);
        private :
            template<class In, class ValueType = typename std::iterator_traits< In >::value_type >
            struct SequenceToString;
            template<class In >
            struct SequenceToString< In, char >;
            template<class In >
            struct SequenceToString< In, gunichar >;
            template<class T >
            class Stringify;
            class FormatStream;
            static ustring compose_argv(const ustring & fmt, int argc, const ustring *const * argv);
            std::string string_;
    };
    template<class In, class ValueType >
    struct ustring::SequenceToString
    {
    };
    template<class In >
    struct ustring::SequenceToString< In, char > : public std::string
    {
            SequenceToString(In pbegin, In pend);
    };
    template<class In >
    struct ustring::SequenceToString< In, gunichar > : public std::string
    {
            SequenceToString(In pbegin, In pend);
    };
    template<>
    struct ustring::SequenceToString< Glib::ustring::iterator, gunichar > : public std::string
    {
            SequenceToString(Glib::ustring::iterator pbegin, Glib::ustring::iterator pend);
    };
    template<>
    struct ustring::SequenceToString< Glib::ustring::const_iterator, gunichar > : public std::string
    {
            SequenceToString(Glib::ustring::const_iterator pbegin, Glib::ustring::const_iterator pend);
    };
    class ustring::FormatStream
    {
        private :
            typedef std::wostringstream StreamType;
            StreamType stream_;
            FormatStream(const ustring::FormatStream &);
            FormatStream & operator =(const ustring::FormatStream &);
        public :
            FormatStream();
            ~FormatStream();
            template<class T >
            inline void stream(const T & value);
            inline void stream(const char * value);
            ustring to_string() const;
    };
    std::istream & operator >>(std::istream & is, Glib::ustring & utf8_string);
    std::ostream & operator <<(std::ostream & os, const Glib::ustring & utf8_string);
    std::wistream & operator >>(std::wistream & is, ustring & utf8_string);
    std::wostream & operator <<(std::wostream & os, const ustring & utf8_string);
    template<class T >
    inline ustring_Iterator< T >::ustring_Iterator(T pos)
        : pos_(pos) 
    {
    }
    template<class T >
    inline T ustring_Iterator< T >::base() const
    {
        return pos_;
    }
    template<class T >
    inline ustring_Iterator< T >::ustring_Iterator()
        : pos_() 
    {
    }
    template<class T >
    inline ustring_Iterator< T >::ustring_Iterator(const ustring_Iterator< std::string::iterator > & other)
        : pos_(other.base()) 
    {
    }
    template<class T >
    inline typename ustring_Iterator< T >::value_type ustring_Iterator< T >::operator *() const
    {
        return Glib::get_unichar_from_std_iterator(pos_);
    }
    template<class T >
    inline ustring_Iterator< T > & ustring_Iterator< T >::operator ++()
    {
        pos_ += g_utf8_skip[static_cast<unsigned char >(*pos_)];
        return *this;
    }
    template<class T >
    inline const ustring_Iterator< T > ustring_Iterator< T >::operator ++(int)
    {
        const ustring_Iterator< T > temp(*this);
        this->operator ++();
        return temp;
    }
    template<class T >
    inline ustring_Iterator< T > & ustring_Iterator< T >::operator --()
    {
        do
        --pos_;
        while ((static_cast<unsigned char >(*pos_) & 0xC0u) == 0x80);
        return *this;
    }
    template<class T >
    inline const ustring_Iterator< T > ustring_Iterator< T >::operator --(int)
    {
        const ustring_Iterator< T > temp(*this);
        this->operator --();
        return temp;
    }
    template<class T >
    inline bool operator ==(const ustring_Iterator< T > & lhs, const ustring_Iterator< T > & rhs)
    {
        return (lhs.base() == rhs.base());
    }
    template<class T >
    inline bool operator !=(const ustring_Iterator< T > & lhs, const ustring_Iterator< T > & rhs)
    {
        return (lhs.base() != rhs.base());
    }
    template<class T >
    inline bool operator <(const ustring_Iterator< T > & lhs, const ustring_Iterator< T > & rhs)
    {
        return (lhs.base() < rhs.base());
    }
    template<class T >
    inline bool operator >(const ustring_Iterator< T > & lhs, const ustring_Iterator< T > & rhs)
    {
        return (lhs.base() > rhs.base());
    }
    template<class T >
    inline bool operator <=(const ustring_Iterator< T > & lhs, const ustring_Iterator< T > & rhs)
    {
        return (lhs.base() <= rhs.base());
    }
    template<class T >
    inline bool operator >=(const ustring_Iterator< T > & lhs, const ustring_Iterator< T > & rhs)
    {
        return (lhs.base() >= rhs.base());
    }
    template<class In >
    ustring::SequenceToString< In, char >::SequenceToString(In pbegin, In pend)
        : std::string(pbegin, pend) 
    {
    }
    template<class In >
    ustring::SequenceToString< In, gunichar >::SequenceToString(In pbegin, In pend)
    {
        char utf8_buf[6];
        for (;
            pbegin != pend;
            ++pbegin)
        {
            const std::string::size_type utf8_len = g_unichar_to_utf8(*pbegin, utf8_buf);
            this->append(utf8_buf, utf8_len);
        }
    }
    template<class T >
    inline void ustring::FormatStream::stream(const T & value)
    {
        stream_ << value;
    }
    inline void ustring::FormatStream::stream(const char * value)
    {
        stream_ << ustring(value);
    }
    template<class In >
    ustring::ustring(In pbegin, In pend)
        : string_(Glib::ustring::SequenceToString< In >(pbegin, pend)) 
    {
    }
    template<class In >
    ustring & ustring::assign(In pbegin, In pend)
    {
        Glib::ustring::SequenceToString< In > temp_string(pbegin, pend);
        string_.swap(temp_string);
        return *this;
    }
    template<class In >
    ustring & ustring::append(In pbegin, In pend)
    {
        string_.append(Glib::ustring::SequenceToString< In >(pbegin, pend));
        return *this;
    }
    template<class In >
    void ustring::insert(ustring::iterator p, In pbegin, In pend)
    {
        string_.insert(p.base(), Glib::ustring::SequenceToString< In >(pbegin, pend));
    }
    template<class In >
    ustring & ustring::replace(ustring::iterator pbegin, ustring::iterator pend, In pbegin2, In pend2)
    {
        string_.replace(pbegin.base(), pend.base(), Glib::ustring::SequenceToString< In >(pbegin2, pend2));
        return *this;
    }
    inline ustring ustring::substr(ustring::size_type i, ustring::size_type n) const
    {
        return ustring(*this, i, n);
    }
    inline ustring::operator std::string() const
    {
        return string_;
    }
    inline const std::string & ustring::raw() const
    {
        return string_;
    }
    template<class T1 >
    inline ustring ustring::format(const T1 & a1)
    {
        ustring::FormatStream buf;
        buf.stream(a1);
        return buf.to_string();
    }
    template<class T1, class T2 >
    inline ustring ustring::format(const T1 & a1, const T2 & a2)
    {
        ustring::FormatStream buf;
        buf.stream(a1);
        buf.stream(a2);
        return buf.to_string();
    }
    template<class T1, class T2, class T3 >
    inline ustring ustring::format(const T1 & a1, const T2 & a2, const T3 & a3)
    {
        ustring::FormatStream buf;
        buf.stream(a1);
        buf.stream(a2);
        buf.stream(a3);
        return buf.to_string();
    }
    template<class T1, class T2, class T3, class T4 >
    inline ustring ustring::format(const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4)
    {
        ustring::FormatStream buf;
        buf.stream(a1);
        buf.stream(a2);
        buf.stream(a3);
        buf.stream(a4);
        return buf.to_string();
    }
    template<class T1, class T2, class T3, class T4, class T5 >
    inline ustring ustring::format(const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5)
    {
        ustring::FormatStream buf;
        buf.stream(a1);
        buf.stream(a2);
        buf.stream(a3);
        buf.stream(a4);
        buf.stream(a5);
        return buf.to_string();
    }
    template<class T1, class T2, class T3, class T4, class T5, class T6 >
    inline ustring ustring::format(const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5, const T6 & a6)
    {
        ustring::FormatStream buf;
        buf.stream(a1);
        buf.stream(a2);
        buf.stream(a3);
        buf.stream(a4);
        buf.stream(a5);
        buf.stream(a6);
        return buf.to_string();
    }
    template<class T1, class T2, class T3, class T4, class T5, class T6, class T7 >
    inline ustring ustring::format(const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5, const T6 & a6, const T7 & a7)
    {
        ustring::FormatStream buf;
        buf.stream(a1);
        buf.stream(a2);
        buf.stream(a3);
        buf.stream(a4);
        buf.stream(a5);
        buf.stream(a6);
        buf.stream(a7);
        return buf.to_string();
    }
    template<class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8 >
    inline ustring ustring::format(const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5, const T6 & a6, const T7 & a7, const T8 & a8)
    {
        ustring::FormatStream buf;
        buf.stream(a1);
        buf.stream(a2);
        buf.stream(a3);
        buf.stream(a4);
        buf.stream(a5);
        buf.stream(a6);
        buf.stream(a7);
        buf.stream(a8);
        return buf.to_string();
    }
    template<class T >
    class ustring::Stringify
    {
        private :
            ustring string_;
            Stringify(const ustring::Stringify< T > &);
            Stringify< T > & operator =(const ustring::Stringify< T > &);
        public :
            explicit inline Stringify(const T & arg)
                : string_(ustring::format(arg)) 
            {
            }
            explicit inline Stringify(const char * arg)
                : string_(arg) 
            {
            }
            inline const ustring * ptr() const
            {
                return &string_;
            }
    };
    template<>
    class ustring::Stringify< ustring >
    {
        private :
            const ustring & string_;
            Stringify(const ustring::Stringify< ustring > &);
            Stringify< ustring > & operator =(const ustring::Stringify< ustring > &);
        public :
            explicit inline Stringify(const ustring & arg)
                : string_(arg) 
            {
            }
            inline const ustring * ptr() const
            {
                return &string_;
            }
    };
    template<class T1 >
    inline ustring ustring::compose(const ustring & fmt, const T1 & a1)
    {
        const ustring::Stringify< T1 > s1(a1);
        const ustring *const argv[] = {s1.ptr()};
        return ustring::compose_argv(fmt, (sizeof (argv) / sizeof ((argv)[0])), argv);
    }
    template<class T1, class T2 >
    inline ustring ustring::compose(const ustring & fmt, const T1 & a1, const T2 & a2)
    {
        const ustring::Stringify< T1 > s1(a1);
        const ustring::Stringify< T2 > s2(a2);
        const ustring *const argv[] = {s1.ptr(), s2.ptr()};
        return ustring::compose_argv(fmt, (sizeof (argv) / sizeof ((argv)[0])), argv);
    }
    template<class T1, class T2, class T3 >
    inline ustring ustring::compose(const ustring & fmt, const T1 & a1, const T2 & a2, const T3 & a3)
    {
        const ustring::Stringify< T1 > s1(a1);
        const ustring::Stringify< T2 > s2(a2);
        const ustring::Stringify< T3 > s3(a3);
        const ustring *const argv[] = {s1.ptr(), s2.ptr(), s3.ptr()};
        return ustring::compose_argv(fmt, (sizeof (argv) / sizeof ((argv)[0])), argv);
    }
    template<class T1, class T2, class T3, class T4 >
    inline ustring ustring::compose(const ustring & fmt, const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4)
    {
        const ustring::Stringify< T1 > s1(a1);
        const ustring::Stringify< T2 > s2(a2);
        const ustring::Stringify< T3 > s3(a3);
        const ustring::Stringify< T4 > s4(a4);
        const ustring *const argv[] = {s1.ptr(), s2.ptr(), s3.ptr(), s4.ptr()};
        return ustring::compose_argv(fmt, (sizeof (argv) / sizeof ((argv)[0])), argv);
    }
    template<class T1, class T2, class T3, class T4, class T5 >
    inline ustring ustring::compose(const ustring & fmt, const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5)
    {
        const ustring::Stringify< T1 > s1(a1);
        const ustring::Stringify< T2 > s2(a2);
        const ustring::Stringify< T3 > s3(a3);
        const ustring::Stringify< T4 > s4(a4);
        const ustring::Stringify< T5 > s5(a5);
        const ustring *const argv[] = {s1.ptr(), s2.ptr(), s3.ptr(), s4.ptr(), s5.ptr()};
        return ustring::compose_argv(fmt, (sizeof (argv) / sizeof ((argv)[0])), argv);
    }
    template<class T1, class T2, class T3, class T4, class T5, class T6 >
    inline ustring ustring::compose(const ustring & fmt, const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5, const T6 & a6)
    {
        const ustring::Stringify< T1 > s1(a1);
        const ustring::Stringify< T2 > s2(a2);
        const ustring::Stringify< T3 > s3(a3);
        const ustring::Stringify< T4 > s4(a4);
        const ustring::Stringify< T5 > s5(a5);
        const ustring::Stringify< T6 > s6(a6);
        const ustring *const argv[] = {s1.ptr(), s2.ptr(), s3.ptr(), s4.ptr(), s5.ptr(), s6.ptr()};
        return ustring::compose_argv(fmt, (sizeof (argv) / sizeof ((argv)[0])), argv);
    }
    template<class T1, class T2, class T3, class T4, class T5, class T6, class T7 >
    inline ustring ustring::compose(const ustring & fmt, const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5, const T6 & a6, const T7 & a7)
    {
        const ustring::Stringify< T1 > s1(a1);
        const ustring::Stringify< T2 > s2(a2);
        const ustring::Stringify< T3 > s3(a3);
        const ustring::Stringify< T4 > s4(a4);
        const ustring::Stringify< T5 > s5(a5);
        const ustring::Stringify< T6 > s6(a6);
        const ustring::Stringify< T7 > s7(a7);
        const ustring *const argv[] = {s1.ptr(), s2.ptr(), s3.ptr(), s4.ptr(), s5.ptr(), s6.ptr(), s7.ptr()};
        return ustring::compose_argv(fmt, (sizeof (argv) / sizeof ((argv)[0])), argv);
    }
    template<class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8 >
    inline ustring ustring::compose(const ustring & fmt, const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5, const T6 & a6, const T7 & a7, const T8 & a8)
    {
        const ustring::Stringify< T1 > s1(a1);
        const ustring::Stringify< T2 > s2(a2);
        const ustring::Stringify< T3 > s3(a3);
        const ustring::Stringify< T4 > s4(a4);
        const ustring::Stringify< T5 > s5(a5);
        const ustring::Stringify< T6 > s6(a6);
        const ustring::Stringify< T7 > s7(a7);
        const ustring::Stringify< T8 > s8(a8);
        const ustring *const argv[] = {s1.ptr(), s2.ptr(), s3.ptr(), s4.ptr(), s5.ptr(), s6.ptr(), s7.ptr(), s8.ptr()};
        return ustring::compose_argv(fmt, (sizeof (argv) / sizeof ((argv)[0])), argv);
    }
    template<class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9 >
    inline ustring ustring::compose(const ustring & fmt, const T1 & a1, const T2 & a2, const T3 & a3, const T4 & a4, const T5 & a5, const T6 & a6, const T7 & a7, const T8 & a8, const T9 & a9)
    {
        const ustring::Stringify< T1 > s1(a1);
        const ustring::Stringify< T2 > s2(a2);
        const ustring::Stringify< T3 > s3(a3);
        const ustring::Stringify< T4 > s4(a4);
        const ustring::Stringify< T5 > s5(a5);
        const ustring::Stringify< T6 > s6(a6);
        const ustring::Stringify< T7 > s7(a7);
        const ustring::Stringify< T8 > s8(a8);
        const ustring::Stringify< T9 > s9(a9);
        const ustring *const argv[] = {s1.ptr(), s2.ptr(), s3.ptr(), s4.ptr(), s5.ptr(), s6.ptr(), s7.ptr(), s8.ptr(), s9.ptr()};
        return ustring::compose_argv(fmt, (sizeof (argv) / sizeof ((argv)[0])), argv);
    }
    inline void swap(ustring & lhs, ustring & rhs)
    {
        lhs.swap(rhs);
    }
    inline bool operator ==(const ustring & lhs, const ustring & rhs)
    {
        return (lhs.compare(rhs) == 0);
    }
    inline bool operator ==(const ustring & lhs, const char * rhs)
    {
        return (lhs.compare(rhs) == 0);
    }
    inline bool operator ==(const char * lhs, const ustring & rhs)
    {
        return (rhs.compare(lhs) == 0);
    }
    inline bool operator !=(const ustring & lhs, const ustring & rhs)
    {
        return (lhs.compare(rhs) != 0);
    }
    inline bool operator !=(const ustring & lhs, const char * rhs)
    {
        return (lhs.compare(rhs) != 0);
    }
    inline bool operator !=(const char * lhs, const ustring & rhs)
    {
        return (rhs.compare(lhs) != 0);
    }
    inline bool operator <(const ustring & lhs, const ustring & rhs)
    {
        return (lhs.compare(rhs) < 0);
    }
    inline bool operator <(const ustring & lhs, const char * rhs)
    {
        return (lhs.compare(rhs) < 0);
    }
    inline bool operator <(const char * lhs, const ustring & rhs)
    {
        return (rhs.compare(lhs) > 0);
    }
    inline bool operator >(const ustring & lhs, const ustring & rhs)
    {
        return (lhs.compare(rhs) > 0);
    }
    inline bool operator >(const ustring & lhs, const char * rhs)
    {
        return (lhs.compare(rhs) > 0);
    }
    inline bool operator >(const char * lhs, const ustring & rhs)
    {
        return (rhs.compare(lhs) < 0);
    }
    inline bool operator <=(const ustring & lhs, const ustring & rhs)
    {
        return (lhs.compare(rhs) <= 0);
    }
    inline bool operator <=(const ustring & lhs, const char * rhs)
    {
        return (lhs.compare(rhs) <= 0);
    }
    inline bool operator <=(const char * lhs, const ustring & rhs)
    {
        return (rhs.compare(lhs) >= 0);
    }
    inline bool operator >=(const ustring & lhs, const ustring & rhs)
    {
        return (lhs.compare(rhs) >= 0);
    }
    inline bool operator >=(const ustring & lhs, const char * rhs)
    {
        return (lhs.compare(rhs) >= 0);
    }
    inline bool operator >=(const char * lhs, const ustring & rhs)
    {
        return (rhs.compare(lhs) <= 0);
    }
    inline ustring operator +(const ustring & lhs, const ustring & rhs)
    {
        ustring temp(lhs);
        temp += rhs;
        return temp;
    }
    inline ustring operator +(const ustring & lhs, const char * rhs)
    {
        ustring temp(lhs);
        temp += rhs;
        return temp;
    }
    inline ustring operator +(const char * lhs, const ustring & rhs)
    {
        ustring temp(lhs);
        temp += rhs;
        return temp;
    }
    inline ustring operator +(const ustring & lhs, gunichar rhs)
    {
        ustring temp(lhs);
        temp += rhs;
        return temp;
    }
    inline ustring operator +(gunichar lhs, const ustring & rhs)
    {
        ustring temp(1, lhs);
        temp += rhs;
        return temp;
    }
    inline ustring operator +(const ustring & lhs, char rhs)
    {
        ustring temp(lhs);
        temp += rhs;
        return temp;
    }
    inline ustring operator +(char lhs, const ustring & rhs)
    {
        ustring temp(1, lhs);
        temp += rhs;
        return temp;
    }
}
extern "C"
{
    typedef void (* GCallback)(void);
    typedef struct _GObject GObject;
}
namespace sigc {
    template<class T_type >
    struct type_trait
    {
            typedef T_type type;
            typedef T_type & pass;
            typedef const T_type & take;
            typedef T_type * pointer;
    };
    template<class T_type, int N >
    struct type_trait< T_type [N] >
    {
            typedef T_type * type;
            typedef T_type * & pass;
            typedef const T_type * & take;
            typedef T_type * * pointer;
    };
    template<class T_type >
    struct type_trait< T_type & >
    {
            typedef T_type type;
            typedef T_type & pass;
            typedef T_type & take;
            typedef T_type * pointer;
    };
    template<class T_type >
    struct type_trait< const T_type & >
    {
            typedef const T_type type;
            typedef const T_type & pass;
            typedef const T_type & take;
            typedef const T_type * pointer;
    };
    template<>
    struct type_trait< void >
    {
            typedef void type;
            typedef void pass;
            typedef void take;
            typedef void * pointer;
    };
    template<class T_base, class T_derived >
    struct is_base_and_derived
    {
        private :
            struct big
            {
                    char memory[64];
            };
            static big is_base_class_(...);
            static char is_base_class_(typename type_trait< T_base >::pointer);
        public :
            static const bool value = sizeof (is_base_class_(reinterpret_cast<typename type_trait< T_derived >::pointer >(0))) == sizeof(char);
            void avoid_gcc3_warning_();
    };
    template<class T_base >
    struct is_base_and_derived< T_base, T_base >
    {
            static const bool value = true;
    };
}
namespace sigc {
    namespace internal {
        typedef void * (* func_destroy_notify)(void * data);
        struct trackable_callback
        {
                void * data_;
                func_destroy_notify func_;
                trackable_callback(void * data, func_destroy_notify func)
                    : data_(data), func_(func) 
                {
                }
        };
        struct trackable_callback_list
        {
                void add_callback(void * data, func_destroy_notify func);
                void remove_callback(void * data);
                void clear();
                trackable_callback_list()
                    : clearing_(false) 
                {
                }
                ~trackable_callback_list();
            private :
                typedef std::list< trackable_callback > callback_list;
                callback_list callbacks_;
                bool clearing_;
        };
    }
    struct trackable
    {
            trackable();
            trackable(const trackable & src);
            trackable & operator =(const trackable & src);
            ~trackable();
            typedef internal::func_destroy_notify func_destroy_notify;
            void add_destroy_notify_callback(void * data, func_destroy_notify func) const;
            void remove_destroy_notify_callback(void * data) const;
            void notify_callbacks();
        private :
            internal::trackable_callback_list * callback_list() const;
            mutable internal::trackable_callback_list * callback_list_;
    };
}
namespace sigc {
    namespace internal {
        template<bool I_derived, class T_type, class T_limit >
        struct with_type;
        template<class T_type, class T_limit >
        struct with_type< false, T_type, T_limit >
        {
                static void execute_(const T_type &, const T_limit &)
                {
                }
        };
        template<class T_type, class T_limit >
        struct with_type< true, T_type, T_limit >
        {
                static void execute_(const T_type & _A_type, const T_limit & _A_action)
                {
                    _A_action.action_(_A_type);
                }
        };
        template<class T_target, class T_action >
        struct limit_derived_target
        {
                typedef limit_derived_target< T_target, T_action > T_self;
                template<class T_type >
                void operator ()(const T_type & _A_type) const
                {
                    with_type< is_base_and_derived< T_target, T_type >::value, T_type, T_self >::execute_(_A_type, *this);
                }
                limit_derived_target(const T_action & _A_action)
                    : action_(_A_action) 
                {
                }
                T_action action_;
        };
        template<bool I_derived, class T_type, class T_limit >
        struct with_type_pointer;
        template<class T_type, class T_limit >
        struct with_type_pointer< false, T_type, T_limit >
        {
                static void execute_(const T_type &, const T_limit &)
                {
                }
        };
        template<class T_type, class T_limit >
        struct with_type_pointer< true, T_type, T_limit >
        {
                static void execute_(const T_type & _A_type, const T_limit & _A_action)
                {
                    _A_action.action_(&_A_type);
                }
        };
        template<class T_target, class T_action >
        struct limit_derived_target< T_target *, T_action >
        {
                typedef limit_derived_target< T_target *, T_action > T_self;
                template<class T_type >
                void operator ()(const T_type & _A_type) const
                {
                    with_type_pointer< is_base_and_derived< T_target, T_type >::value, T_type, T_self >::execute_(_A_type, *this);
                }
                limit_derived_target(const T_action & _A_action)
                    : action_(_A_action) 
                {
                }
                T_action action_;
        };
    }
    template<class T_action, class T_functor >
    void visit_each(const T_action & _A_action, const T_functor & _A_functor)
    {
        _A_action(_A_functor);
    }
    template<class T_type, class T_action, class T_functor >
    void visit_each_type(const T_action & _A_action, const T_functor & _A_functor)
    {
        typedef internal::limit_derived_target< T_type, T_action > type_limited_action;
        type_limited_action limited_action(_A_action);
        visit_each(limited_action, _A_functor);
    }
}
namespace sigc {
    struct nil;
    struct functor_base
    {
    };
    template<class T_functor, bool I_derives_functor_base = is_base_and_derived< functor_base, T_functor >::value >
    struct functor_trait
    {
            typedef void result_type;
            typedef T_functor functor_type;
    };
    template<class T_functor >
    struct functor_trait< T_functor, true >
    {
            typedef typename T_functor::result_type result_type;
            typedef T_functor functor_type;
    };
    template<class T_return >
    class pointer_functor0;
    template<class T_return >
    struct functor_trait< T_return (*)(), false >
    {
            typedef T_return result_type;
            typedef pointer_functor0< T_return > functor_type;
    };
    template<class T_arg1, class T_return >
    class pointer_functor1;
    template<class T_arg1, class T_return >
    struct functor_trait< T_return (*)(T_arg1), false >
    {
            typedef T_return result_type;
            typedef pointer_functor1< T_arg1, T_return > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_return >
    class pointer_functor2;
    template<class T_arg1, class T_arg2, class T_return >
    struct functor_trait< T_return (*)(T_arg1, T_arg2), false >
    {
            typedef T_return result_type;
            typedef pointer_functor2< T_arg1, T_arg2, T_return > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_return >
    class pointer_functor3;
    template<class T_arg1, class T_arg2, class T_arg3, class T_return >
    struct functor_trait< T_return (*)(T_arg1, T_arg2, T_arg3), false >
    {
            typedef T_return result_type;
            typedef pointer_functor3< T_arg1, T_arg2, T_arg3, T_return > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return >
    class pointer_functor4;
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return >
    struct functor_trait< T_return (*)(T_arg1, T_arg2, T_arg3, T_arg4), false >
    {
            typedef T_return result_type;
            typedef pointer_functor4< T_arg1, T_arg2, T_arg3, T_arg4, T_return > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return >
    class pointer_functor5;
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return >
    struct functor_trait< T_return (*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5), false >
    {
            typedef T_return result_type;
            typedef pointer_functor5< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return >
    class pointer_functor6;
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return >
    struct functor_trait< T_return (*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6), false >
    {
            typedef T_return result_type;
            typedef pointer_functor6< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return >
    class pointer_functor7;
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return >
    struct functor_trait< T_return (*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7), false >
    {
            typedef T_return result_type;
            typedef pointer_functor7< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return > functor_type;
    };
    template<class T_return, class T_obj >
    class mem_functor0;
    template<class T_return, class T_obj >
    class const_mem_functor0;
    template<class T_return, class T_obj >
    struct functor_trait< T_return (T_obj:: *)(), false >
    {
            typedef T_return result_type;
            typedef mem_functor0< T_return, T_obj > functor_type;
    };
    template<class T_return, class T_obj >
    struct functor_trait< T_return (T_obj:: *)() const, false >
    {
            typedef T_return result_type;
            typedef const_mem_functor0< T_return, T_obj > functor_type;
    };
    template<class T_arg1, class T_return, class T_obj >
    class mem_functor1;
    template<class T_arg1, class T_return, class T_obj >
    class const_mem_functor1;
    template<class T_arg1, class T_return, class T_obj >
    struct functor_trait< T_return (T_obj:: *)(T_arg1), false >
    {
            typedef T_return result_type;
            typedef mem_functor1< T_arg1, T_return, T_obj > functor_type;
    };
    template<class T_arg1, class T_return, class T_obj >
    struct functor_trait< T_return (T_obj:: *)(T_arg1) const, false >
    {
            typedef T_return result_type;
            typedef const_mem_functor1< T_arg1, T_return, T_obj > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_return, class T_obj >
    class mem_functor2;
    template<class T_arg1, class T_arg2, class T_return, class T_obj >
    class const_mem_functor2;
    template<class T_arg1, class T_arg2, class T_return, class T_obj >
    struct functor_trait< T_return (T_obj:: *)(T_arg1, T_arg2), false >
    {
            typedef T_return result_type;
            typedef mem_functor2< T_arg1, T_arg2, T_return, T_obj > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_return, class T_obj >
    struct functor_trait< T_return (T_obj:: *)(T_arg1, T_arg2) const, false >
    {
            typedef T_return result_type;
            typedef const_mem_functor2< T_arg1, T_arg2, T_return, T_obj > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj >
    class mem_functor3;
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj >
    class const_mem_functor3;
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj >
    struct functor_trait< T_return (T_obj:: *)(T_arg1, T_arg2, T_arg3), false >
    {
            typedef T_return result_type;
            typedef mem_functor3< T_arg1, T_arg2, T_arg3, T_return, T_obj > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj >
    struct functor_trait< T_return (T_obj:: *)(T_arg1, T_arg2, T_arg3) const, false >
    {
            typedef T_return result_type;
            typedef const_mem_functor3< T_arg1, T_arg2, T_arg3, T_return, T_obj > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj >
    class mem_functor4;
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj >
    class const_mem_functor4;
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj >
    struct functor_trait< T_return (T_obj:: *)(T_arg1, T_arg2, T_arg3, T_arg4), false >
    {
            typedef T_return result_type;
            typedef mem_functor4< T_arg1, T_arg2, T_arg3, T_arg4, T_return, T_obj > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj >
    struct functor_trait< T_return (T_obj:: *)(T_arg1, T_arg2, T_arg3, T_arg4) const, false >
    {
            typedef T_return result_type;
            typedef const_mem_functor4< T_arg1, T_arg2, T_arg3, T_arg4, T_return, T_obj > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj >
    class mem_functor5;
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj >
    class const_mem_functor5;
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj >
    struct functor_trait< T_return (T_obj:: *)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5), false >
    {
            typedef T_return result_type;
            typedef mem_functor5< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return, T_obj > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj >
    struct functor_trait< T_return (T_obj:: *)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const, false >
    {
            typedef T_return result_type;
            typedef const_mem_functor5< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return, T_obj > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj >
    class mem_functor6;
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj >
    class const_mem_functor6;
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj >
    struct functor_trait< T_return (T_obj:: *)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6), false >
    {
            typedef T_return result_type;
            typedef mem_functor6< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return, T_obj > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj >
    struct functor_trait< T_return (T_obj:: *)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const, false >
    {
            typedef T_return result_type;
            typedef const_mem_functor6< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return, T_obj > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj >
    class mem_functor7;
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj >
    class const_mem_functor7;
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj >
    struct functor_trait< T_return (T_obj:: *)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7), false >
    {
            typedef T_return result_type;
            typedef mem_functor7< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return, T_obj > functor_type;
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj >
    struct functor_trait< T_return (T_obj:: *)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const, false >
    {
            typedef T_return result_type;
            typedef const_mem_functor7< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return, T_obj > functor_type;
    };
}
namespace sigc {
    template<class T_return >
    class pointer_functor0 : public functor_base
    {
            typedef T_return (* function_type)();
        protected :
            function_type func_ptr_;
        public :
            typedef T_return result_type;
            pointer_functor0()
            {
            }
            explicit pointer_functor0(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()() const
            {
                return func_ptr_();
            }
    };
    template<class T_arg1, class T_return >
    class pointer_functor1 : public functor_base
    {
            typedef T_return (* function_type)(T_arg1);
        protected :
            function_type func_ptr_;
        public :
            typedef T_return result_type;
            pointer_functor1()
            {
            }
            explicit pointer_functor1(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1) const
            {
                return func_ptr_(_A_a1);
            }
    };
    template<class T_arg1, class T_arg2, class T_return >
    class pointer_functor2 : public functor_base
    {
            typedef T_return (* function_type)(T_arg1, T_arg2);
        protected :
            function_type func_ptr_;
        public :
            typedef T_return result_type;
            pointer_functor2()
            {
            }
            explicit pointer_functor2(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2) const
            {
                return func_ptr_(_A_a1, _A_a2);
            }
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_return >
    class pointer_functor3 : public functor_base
    {
            typedef T_return (* function_type)(T_arg1, T_arg2, T_arg3);
        protected :
            function_type func_ptr_;
        public :
            typedef T_return result_type;
            pointer_functor3()
            {
            }
            explicit pointer_functor3(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3) const
            {
                return func_ptr_(_A_a1, _A_a2, _A_a3);
            }
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return >
    class pointer_functor4 : public functor_base
    {
            typedef T_return (* function_type)(T_arg1, T_arg2, T_arg3, T_arg4);
        protected :
            function_type func_ptr_;
        public :
            typedef T_return result_type;
            pointer_functor4()
            {
            }
            explicit pointer_functor4(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4) const
            {
                return func_ptr_(_A_a1, _A_a2, _A_a3, _A_a4);
            }
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return >
    class pointer_functor5 : public functor_base
    {
            typedef T_return (* function_type)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5);
        protected :
            function_type func_ptr_;
        public :
            typedef T_return result_type;
            pointer_functor5()
            {
            }
            explicit pointer_functor5(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5) const
            {
                return func_ptr_(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return >
    class pointer_functor6 : public functor_base
    {
            typedef T_return (* function_type)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6);
        protected :
            function_type func_ptr_;
        public :
            typedef T_return result_type;
            pointer_functor6()
            {
            }
            explicit pointer_functor6(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6) const
            {
                return func_ptr_(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
    };
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return >
    class pointer_functor7 : public functor_base
    {
            typedef T_return (* function_type)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7);
        protected :
            function_type func_ptr_;
        public :
            typedef T_return result_type;
            pointer_functor7()
            {
            }
            explicit pointer_functor7(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7) const
            {
                return func_ptr_(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
    };
    template<class T_return >
    inline pointer_functor0< T_return > ptr_fun0(T_return (* _A_func)())
    {
        return pointer_functor0< T_return >(_A_func);
    }
    template<class T_arg1, class T_return >
    inline pointer_functor1< T_arg1, T_return > ptr_fun1(T_return (* _A_func)(T_arg1))
    {
        return pointer_functor1< T_arg1, T_return >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_return >
    inline pointer_functor2< T_arg1, T_arg2, T_return > ptr_fun2(T_return (* _A_func)(T_arg1, T_arg2))
    {
        return pointer_functor2< T_arg1, T_arg2, T_return >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return >
    inline pointer_functor3< T_arg1, T_arg2, T_arg3, T_return > ptr_fun3(T_return (* _A_func)(T_arg1, T_arg2, T_arg3))
    {
        return pointer_functor3< T_arg1, T_arg2, T_arg3, T_return >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return >
    inline pointer_functor4< T_arg1, T_arg2, T_arg3, T_arg4, T_return > ptr_fun4(T_return (* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))
    {
        return pointer_functor4< T_arg1, T_arg2, T_arg3, T_arg4, T_return >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return >
    inline pointer_functor5< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return > ptr_fun5(T_return (* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))
    {
        return pointer_functor5< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return >
    inline pointer_functor6< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return > ptr_fun6(T_return (* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))
    {
        return pointer_functor6< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return >
    inline pointer_functor7< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return > ptr_fun7(T_return (* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))
    {
        return pointer_functor7< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return >(_A_func);
    }
    template<class T_return >
    inline pointer_functor0< T_return > ptr_fun(T_return (* _A_func)())
    {
        return pointer_functor0< T_return >(_A_func);
    }
    template<class T_arg1, class T_return >
    inline pointer_functor1< T_arg1, T_return > ptr_fun(T_return (* _A_func)(T_arg1))
    {
        return pointer_functor1< T_arg1, T_return >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_return >
    inline pointer_functor2< T_arg1, T_arg2, T_return > ptr_fun(T_return (* _A_func)(T_arg1, T_arg2))
    {
        return pointer_functor2< T_arg1, T_arg2, T_return >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return >
    inline pointer_functor3< T_arg1, T_arg2, T_arg3, T_return > ptr_fun(T_return (* _A_func)(T_arg1, T_arg2, T_arg3))
    {
        return pointer_functor3< T_arg1, T_arg2, T_arg3, T_return >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return >
    inline pointer_functor4< T_arg1, T_arg2, T_arg3, T_arg4, T_return > ptr_fun(T_return (* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))
    {
        return pointer_functor4< T_arg1, T_arg2, T_arg3, T_arg4, T_return >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return >
    inline pointer_functor5< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return > ptr_fun(T_return (* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))
    {
        return pointer_functor5< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return >
    inline pointer_functor6< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return > ptr_fun(T_return (* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))
    {
        return pointer_functor6< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return >
    inline pointer_functor7< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return > ptr_fun(T_return (* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))
    {
        return pointer_functor7< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return >(_A_func);
    }
}
namespace sigc {
    template<class T_type, bool I_derives_trackable = is_base_and_derived< trackable, T_type >::value >
    class limit_reference
    {
        public :
            limit_reference(T_type & _A_target)
                : visited(_A_target) 
            {
            }
            inline const T_type & visit() const
            {
                return visited;
            }
            inline T_type & invoke() const
            {
                return visited;
            }
        private :
            T_type & visited;
    };
    template<class T_type >
    class limit_reference< T_type, true >
    {
        public :
            limit_reference(T_type & _A_target)
                : visited(_A_target), invoked(_A_target) 
            {
            }
            inline const trackable & visit() const
            {
                return visited;
            }
            inline T_type & invoke() const
            {
                return invoked;
            }
        private :
            trackable & visited;
            T_type & invoked;
    };
    template<class T_action, class T_type, bool I_derives_trackable >
    void visit_each(const T_action & _A_action, const limit_reference< T_type, I_derives_trackable > & _A_target)
    {
        visit_each(_A_action, _A_target.visit());
    }
    template<class T_type, bool I_derives_trackable = is_base_and_derived< trackable, T_type >::value >
    class const_limit_reference
    {
        public :
            const_limit_reference(const T_type & _A_target)
                : visited(_A_target) 
            {
            }
            inline const T_type & visit() const
            {
                return visited;
            }
            inline const T_type & invoke() const
            {
                return visited;
            }
        private :
            const T_type & visited;
    };
    template<class T_type >
    class const_limit_reference< T_type, true >
    {
        public :
            const_limit_reference(const T_type & _A_target)
                : visited(_A_target), invoked(_A_target) 
            {
            }
            inline const trackable & visit() const
            {
                return visited;
            }
            inline const T_type & invoke() const
            {
                return invoked;
            }
        private :
            const trackable & visited;
            const T_type & invoked;
    };
    template<class T_action, class T_type, bool I_derives_trackable >
    void visit_each(const T_action & _A_action, const const_limit_reference< T_type, I_derives_trackable > & _A_target)
    {
        visit_each(_A_action, _A_target.visit());
    }
    template<class T_type, bool I_derives_trackable = is_base_and_derived< trackable, T_type >::value >
    class volatile_limit_reference
    {
        public :
            volatile_limit_reference(T_type & _A_target)
                : visited(_A_target) 
            {
            }
            inline const T_type & visit() const
            {
                return visited;
            }
            inline volatile T_type & invoke() const
            {
                return visited;
            }
        private :
            T_type & visited;
    };
    template<class T_type >
    class volatile_limit_reference< T_type, true >
    {
        public :
            volatile_limit_reference(T_type & _A_target)
                : visited(_A_target), invoked(_A_target) 
            {
            }
            inline const trackable & visit() const
            {
                return visited;
            }
            inline volatile T_type & invoke() const
            {
                return invoked;
            }
        private :
            trackable & visited;
            T_type & invoked;
    };
    template<class T_action, class T_type, bool I_derives_trackable >
    void visit_each(const T_action & _A_action, const volatile_limit_reference< T_type, I_derives_trackable > & _A_target)
    {
        visit_each(_A_action, _A_target.visit());
    }
    template<class T_type, bool I_derives_trackable = is_base_and_derived< trackable, T_type >::value >
    class const_volatile_limit_reference
    {
        public :
            const_volatile_limit_reference(const T_type & _A_target)
                : visited(_A_target) 
            {
            }
            inline const T_type & visit() const
            {
                return visited;
            }
            inline const volatile T_type & invoke() const
            {
                return visited;
            }
        private :
            const T_type & visited;
    };
    template<class T_type >
    class const_volatile_limit_reference< T_type, true >
    {
        public :
            const_volatile_limit_reference(const T_type & _A_target)
                : visited(_A_target), invoked(_A_target) 
            {
            }
            inline const trackable & visit() const
            {
                return visited;
            }
            inline const volatile T_type & invoke() const
            {
                return invoked;
            }
        private :
            const trackable & visited;
            const T_type & invoked;
    };
    template<class T_action, class T_type, bool I_derives_trackable >
    void visit_each(const T_action & _A_action, const const_volatile_limit_reference< T_type, I_derives_trackable > & _A_target)
    {
        visit_each(_A_action, _A_target.visit());
    }
}
namespace sigc {
    template<class T_return, class T_obj >
    class mem_functor0 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)();
            typedef T_return result_type;
            mem_functor0()
                : func_ptr_(0) 
            {
            }
            explicit mem_functor0(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(T_obj * _A_obj) const
            {
                return (_A_obj ->* (this->func_ptr_))();
            }
            T_return operator ()(T_obj & _A_obj) const
            {
                return (_A_obj .* func_ptr_)();
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1 >
    class mem_functor1 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1);
            typedef T_return result_type;
            mem_functor1()
                : func_ptr_(0) 
            {
            }
            explicit mem_functor1(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1);
            }
            T_return operator ()(T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1) const
            {
                return (_A_obj .* func_ptr_)(_A_a1);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2 >
    class mem_functor2 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2);
            typedef T_return result_type;
            mem_functor2()
                : func_ptr_(0) 
            {
            }
            explicit mem_functor2(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2);
            }
            T_return operator ()(T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    class mem_functor3 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3);
            typedef T_return result_type;
            mem_functor3()
                : func_ptr_(0) 
            {
            }
            explicit mem_functor3(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3);
            }
            T_return operator ()(T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    class mem_functor4 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3, T_arg4);
            typedef T_return result_type;
            mem_functor4()
                : func_ptr_(0) 
            {
            }
            explicit mem_functor4(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4);
            }
            T_return operator ()(T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3, _A_a4);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    class mem_functor5 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5);
            typedef T_return result_type;
            mem_functor5()
                : func_ptr_(0) 
            {
            }
            explicit mem_functor5(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
            T_return operator ()(T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    class mem_functor6 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6);
            typedef T_return result_type;
            mem_functor6()
                : func_ptr_(0) 
            {
            }
            explicit mem_functor6(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
            T_return operator ()(T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    class mem_functor7 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7);
            typedef T_return result_type;
            mem_functor7()
                : func_ptr_(0) 
            {
            }
            explicit mem_functor7(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
            T_return operator ()(T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj >
    class const_mem_functor0 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)() const;
            typedef T_return result_type;
            const_mem_functor0()
                : func_ptr_(0) 
            {
            }
            explicit const_mem_functor0(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(const T_obj * _A_obj) const
            {
                return (_A_obj ->* (this->func_ptr_))();
            }
            T_return operator ()(const T_obj & _A_obj) const
            {
                return (_A_obj .* func_ptr_)();
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1 >
    class const_mem_functor1 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1) const;
            typedef T_return result_type;
            const_mem_functor1()
                : func_ptr_(0) 
            {
            }
            explicit const_mem_functor1(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(const T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1);
            }
            T_return operator ()(const T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1) const
            {
                return (_A_obj .* func_ptr_)(_A_a1);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2 >
    class const_mem_functor2 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2) const;
            typedef T_return result_type;
            const_mem_functor2()
                : func_ptr_(0) 
            {
            }
            explicit const_mem_functor2(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(const T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2);
            }
            T_return operator ()(const T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    class const_mem_functor3 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3) const;
            typedef T_return result_type;
            const_mem_functor3()
                : func_ptr_(0) 
            {
            }
            explicit const_mem_functor3(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(const T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3);
            }
            T_return operator ()(const T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    class const_mem_functor4 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3, T_arg4) const;
            typedef T_return result_type;
            const_mem_functor4()
                : func_ptr_(0) 
            {
            }
            explicit const_mem_functor4(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(const T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4);
            }
            T_return operator ()(const T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3, _A_a4);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    class const_mem_functor5 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const;
            typedef T_return result_type;
            const_mem_functor5()
                : func_ptr_(0) 
            {
            }
            explicit const_mem_functor5(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(const T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
            T_return operator ()(const T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    class const_mem_functor6 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const;
            typedef T_return result_type;
            const_mem_functor6()
                : func_ptr_(0) 
            {
            }
            explicit const_mem_functor6(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(const T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
            T_return operator ()(const T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    class const_mem_functor7 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const;
            typedef T_return result_type;
            const_mem_functor7()
                : func_ptr_(0) 
            {
            }
            explicit const_mem_functor7(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(const T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
            T_return operator ()(const T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj >
    class volatile_mem_functor0 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)() volatile;
            typedef T_return result_type;
            volatile_mem_functor0()
                : func_ptr_(0) 
            {
            }
            explicit volatile_mem_functor0(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(T_obj * _A_obj) const
            {
                return (_A_obj ->* (this->func_ptr_))();
            }
            T_return operator ()(T_obj & _A_obj) const
            {
                return (_A_obj .* func_ptr_)();
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1 >
    class volatile_mem_functor1 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1) volatile;
            typedef T_return result_type;
            volatile_mem_functor1()
                : func_ptr_(0) 
            {
            }
            explicit volatile_mem_functor1(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1);
            }
            T_return operator ()(T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1) const
            {
                return (_A_obj .* func_ptr_)(_A_a1);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2 >
    class volatile_mem_functor2 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2) volatile;
            typedef T_return result_type;
            volatile_mem_functor2()
                : func_ptr_(0) 
            {
            }
            explicit volatile_mem_functor2(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2);
            }
            T_return operator ()(T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    class volatile_mem_functor3 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3) volatile;
            typedef T_return result_type;
            volatile_mem_functor3()
                : func_ptr_(0) 
            {
            }
            explicit volatile_mem_functor3(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3);
            }
            T_return operator ()(T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    class volatile_mem_functor4 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3, T_arg4) volatile;
            typedef T_return result_type;
            volatile_mem_functor4()
                : func_ptr_(0) 
            {
            }
            explicit volatile_mem_functor4(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4);
            }
            T_return operator ()(T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3, _A_a4);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    class volatile_mem_functor5 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile;
            typedef T_return result_type;
            volatile_mem_functor5()
                : func_ptr_(0) 
            {
            }
            explicit volatile_mem_functor5(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
            T_return operator ()(T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    class volatile_mem_functor6 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile;
            typedef T_return result_type;
            volatile_mem_functor6()
                : func_ptr_(0) 
            {
            }
            explicit volatile_mem_functor6(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
            T_return operator ()(T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    class volatile_mem_functor7 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile;
            typedef T_return result_type;
            volatile_mem_functor7()
                : func_ptr_(0) 
            {
            }
            explicit volatile_mem_functor7(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
            T_return operator ()(T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj >
    class const_volatile_mem_functor0 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)() const volatile;
            typedef T_return result_type;
            const_volatile_mem_functor0()
                : func_ptr_(0) 
            {
            }
            explicit const_volatile_mem_functor0(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(const T_obj * _A_obj) const
            {
                return (_A_obj ->* (this->func_ptr_))();
            }
            T_return operator ()(const T_obj & _A_obj) const
            {
                return (_A_obj .* func_ptr_)();
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1 >
    class const_volatile_mem_functor1 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1) const volatile;
            typedef T_return result_type;
            const_volatile_mem_functor1()
                : func_ptr_(0) 
            {
            }
            explicit const_volatile_mem_functor1(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(const T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1);
            }
            T_return operator ()(const T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1) const
            {
                return (_A_obj .* func_ptr_)(_A_a1);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2 >
    class const_volatile_mem_functor2 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2) const volatile;
            typedef T_return result_type;
            const_volatile_mem_functor2()
                : func_ptr_(0) 
            {
            }
            explicit const_volatile_mem_functor2(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(const T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2);
            }
            T_return operator ()(const T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    class const_volatile_mem_functor3 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3) const volatile;
            typedef T_return result_type;
            const_volatile_mem_functor3()
                : func_ptr_(0) 
            {
            }
            explicit const_volatile_mem_functor3(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(const T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3);
            }
            T_return operator ()(const T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    class const_volatile_mem_functor4 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile;
            typedef T_return result_type;
            const_volatile_mem_functor4()
                : func_ptr_(0) 
            {
            }
            explicit const_volatile_mem_functor4(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(const T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4);
            }
            T_return operator ()(const T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3, _A_a4);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    class const_volatile_mem_functor5 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile;
            typedef T_return result_type;
            const_volatile_mem_functor5()
                : func_ptr_(0) 
            {
            }
            explicit const_volatile_mem_functor5(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(const T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
            T_return operator ()(const T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    class const_volatile_mem_functor6 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile;
            typedef T_return result_type;
            const_volatile_mem_functor6()
                : func_ptr_(0) 
            {
            }
            explicit const_volatile_mem_functor6(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(const T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
            T_return operator ()(const T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    class const_volatile_mem_functor7 : public functor_base
    {
        public :
            typedef T_return (T_obj:: * function_type)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile;
            typedef T_return result_type;
            const_volatile_mem_functor7()
                : func_ptr_(0) 
            {
            }
            explicit const_volatile_mem_functor7(function_type _A_func)
                : func_ptr_(_A_func) 
            {
            }
            T_return operator ()(const T_obj * _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7) const
            {
                return (_A_obj ->* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
            T_return operator ()(const T_obj & _A_obj, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7) const
            {
                return (_A_obj .* func_ptr_)(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
        protected :
            function_type func_ptr_;
    };
    template<class T_return, class T_obj >
    class bound_mem_functor0 : public mem_functor0< T_return, T_obj >
    {
            typedef mem_functor0< T_return, T_obj > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_mem_functor0(T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_mem_functor0(T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()() const
            {
                return (obj_.invoke() .* (this->func_ptr_))();
            }
            limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj >
    void visit_each(const T_action & _A_action, const bound_mem_functor0< T_return, T_obj > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1 >
    class bound_mem_functor1 : public mem_functor1< T_return, T_obj, T_arg1 >
    {
            typedef mem_functor1< T_return, T_obj, T_arg1 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_mem_functor1(T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_mem_functor1(T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1);
            }
            limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1 >
    void visit_each(const T_action & _A_action, const bound_mem_functor1< T_return, T_obj, T_arg1 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2 >
    class bound_mem_functor2 : public mem_functor2< T_return, T_obj, T_arg1, T_arg2 >
    {
            typedef mem_functor2< T_return, T_obj, T_arg1, T_arg2 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_mem_functor2(T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_mem_functor2(T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2);
            }
            limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2 >
    void visit_each(const T_action & _A_action, const bound_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    class bound_mem_functor3 : public mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >
    {
            typedef mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_mem_functor3(T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_mem_functor3(T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3);
            }
            limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    void visit_each(const T_action & _A_action, const bound_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    class bound_mem_functor4 : public mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >
    {
            typedef mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_mem_functor4(T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_mem_functor4(T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4);
            }
            limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    void visit_each(const T_action & _A_action, const bound_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    class bound_mem_functor5 : public mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >
    {
            typedef mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_mem_functor5(T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_mem_functor5(T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
            limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    void visit_each(const T_action & _A_action, const bound_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    class bound_mem_functor6 : public mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >
    {
            typedef mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_mem_functor6(T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_mem_functor6(T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
            limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    void visit_each(const T_action & _A_action, const bound_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    class bound_mem_functor7 : public mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
    {
            typedef mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_mem_functor7(T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_mem_functor7(T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
            limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    void visit_each(const T_action & _A_action, const bound_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj >
    class bound_const_mem_functor0 : public const_mem_functor0< T_return, T_obj >
    {
            typedef const_mem_functor0< T_return, T_obj > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_const_mem_functor0(const T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_const_mem_functor0(const T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()() const
            {
                return (obj_.invoke() .* (this->func_ptr_))();
            }
            const_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj >
    void visit_each(const T_action & _A_action, const bound_const_mem_functor0< T_return, T_obj > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1 >
    class bound_const_mem_functor1 : public const_mem_functor1< T_return, T_obj, T_arg1 >
    {
            typedef const_mem_functor1< T_return, T_obj, T_arg1 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_const_mem_functor1(const T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_const_mem_functor1(const T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1);
            }
            const_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1 >
    void visit_each(const T_action & _A_action, const bound_const_mem_functor1< T_return, T_obj, T_arg1 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2 >
    class bound_const_mem_functor2 : public const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >
    {
            typedef const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_const_mem_functor2(const T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_const_mem_functor2(const T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2);
            }
            const_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2 >
    void visit_each(const T_action & _A_action, const bound_const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    class bound_const_mem_functor3 : public const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >
    {
            typedef const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_const_mem_functor3(const T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_const_mem_functor3(const T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3);
            }
            const_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    void visit_each(const T_action & _A_action, const bound_const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    class bound_const_mem_functor4 : public const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >
    {
            typedef const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_const_mem_functor4(const T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_const_mem_functor4(const T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4);
            }
            const_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    void visit_each(const T_action & _A_action, const bound_const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    class bound_const_mem_functor5 : public const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >
    {
            typedef const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_const_mem_functor5(const T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_const_mem_functor5(const T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
            const_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    void visit_each(const T_action & _A_action, const bound_const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    class bound_const_mem_functor6 : public const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >
    {
            typedef const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_const_mem_functor6(const T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_const_mem_functor6(const T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
            const_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    void visit_each(const T_action & _A_action, const bound_const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    class bound_const_mem_functor7 : public const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
    {
            typedef const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_const_mem_functor7(const T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_const_mem_functor7(const T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
            const_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    void visit_each(const T_action & _A_action, const bound_const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj >
    class bound_volatile_mem_functor0 : public volatile_mem_functor0< T_return, T_obj >
    {
            typedef volatile_mem_functor0< T_return, T_obj > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_volatile_mem_functor0(T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_volatile_mem_functor0(T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()() const
            {
                return (obj_.invoke() .* (this->func_ptr_))();
            }
            volatile_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj >
    void visit_each(const T_action & _A_action, const bound_volatile_mem_functor0< T_return, T_obj > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1 >
    class bound_volatile_mem_functor1 : public volatile_mem_functor1< T_return, T_obj, T_arg1 >
    {
            typedef volatile_mem_functor1< T_return, T_obj, T_arg1 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_volatile_mem_functor1(T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_volatile_mem_functor1(T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1);
            }
            volatile_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1 >
    void visit_each(const T_action & _A_action, const bound_volatile_mem_functor1< T_return, T_obj, T_arg1 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2 >
    class bound_volatile_mem_functor2 : public volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >
    {
            typedef volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_volatile_mem_functor2(T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_volatile_mem_functor2(T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2);
            }
            volatile_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2 >
    void visit_each(const T_action & _A_action, const bound_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    class bound_volatile_mem_functor3 : public volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >
    {
            typedef volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_volatile_mem_functor3(T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_volatile_mem_functor3(T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3);
            }
            volatile_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    void visit_each(const T_action & _A_action, const bound_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    class bound_volatile_mem_functor4 : public volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >
    {
            typedef volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_volatile_mem_functor4(T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_volatile_mem_functor4(T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4);
            }
            volatile_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    void visit_each(const T_action & _A_action, const bound_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    class bound_volatile_mem_functor5 : public volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >
    {
            typedef volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_volatile_mem_functor5(T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_volatile_mem_functor5(T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
            volatile_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    void visit_each(const T_action & _A_action, const bound_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    class bound_volatile_mem_functor6 : public volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >
    {
            typedef volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_volatile_mem_functor6(T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_volatile_mem_functor6(T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
            volatile_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    void visit_each(const T_action & _A_action, const bound_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    class bound_volatile_mem_functor7 : public volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
    {
            typedef volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_volatile_mem_functor7(T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_volatile_mem_functor7(T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
            volatile_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    void visit_each(const T_action & _A_action, const bound_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj >
    class bound_const_volatile_mem_functor0 : public const_volatile_mem_functor0< T_return, T_obj >
    {
            typedef const_volatile_mem_functor0< T_return, T_obj > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_const_volatile_mem_functor0(const T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_const_volatile_mem_functor0(const T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()() const
            {
                return (obj_.invoke() .* (this->func_ptr_))();
            }
            const_volatile_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj >
    void visit_each(const T_action & _A_action, const bound_const_volatile_mem_functor0< T_return, T_obj > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1 >
    class bound_const_volatile_mem_functor1 : public const_volatile_mem_functor1< T_return, T_obj, T_arg1 >
    {
            typedef const_volatile_mem_functor1< T_return, T_obj, T_arg1 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_const_volatile_mem_functor1(const T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_const_volatile_mem_functor1(const T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1);
            }
            const_volatile_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1 >
    void visit_each(const T_action & _A_action, const bound_const_volatile_mem_functor1< T_return, T_obj, T_arg1 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2 >
    class bound_const_volatile_mem_functor2 : public const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >
    {
            typedef const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_const_volatile_mem_functor2(const T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_const_volatile_mem_functor2(const T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2);
            }
            const_volatile_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2 >
    void visit_each(const T_action & _A_action, const bound_const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    class bound_const_volatile_mem_functor3 : public const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >
    {
            typedef const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_const_volatile_mem_functor3(const T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_const_volatile_mem_functor3(const T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3);
            }
            const_volatile_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    void visit_each(const T_action & _A_action, const bound_const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    class bound_const_volatile_mem_functor4 : public const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >
    {
            typedef const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_const_volatile_mem_functor4(const T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_const_volatile_mem_functor4(const T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4);
            }
            const_volatile_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    void visit_each(const T_action & _A_action, const bound_const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    class bound_const_volatile_mem_functor5 : public const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >
    {
            typedef const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_const_volatile_mem_functor5(const T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_const_volatile_mem_functor5(const T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
            const_volatile_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    void visit_each(const T_action & _A_action, const bound_const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    class bound_const_volatile_mem_functor6 : public const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >
    {
            typedef const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_const_volatile_mem_functor6(const T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_const_volatile_mem_functor6(const T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
            const_volatile_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    void visit_each(const T_action & _A_action, const bound_const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    class bound_const_volatile_mem_functor7 : public const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
    {
            typedef const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > base_type_;
        public :
            typedef typename base_type_::function_type function_type;
            bound_const_volatile_mem_functor7(const T_obj * _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(*_A_obj) 
            {
            }
            bound_const_volatile_mem_functor7(const T_obj & _A_obj, function_type _A_func)
                : base_type_(_A_func), obj_(_A_obj) 
            {
            }
            T_return operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7) const
            {
                return (obj_.invoke() .* (this->func_ptr_))(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
            const_volatile_limit_reference< T_obj > obj_;
    };
    template<class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    void visit_each(const T_action & _A_action, const bound_const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.obj_);
    }
    template<class T_return, class T_obj >
    inline mem_functor0< T_return, T_obj > mem_fun0(T_return (T_obj:: * _A_func)())
    {
        return mem_functor0< T_return, T_obj >(_A_func);
    }
    template<class T_arg1, class T_return, class T_obj >
    inline mem_functor1< T_return, T_obj, T_arg1 > mem_fun1(T_return (T_obj:: * _A_func)(T_arg1))
    {
        return mem_functor1< T_return, T_obj, T_arg1 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj >
    inline mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun2(T_return (T_obj:: * _A_func)(T_arg1, T_arg2))
    {
        return mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj >
    inline mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun3(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3))
    {
        return mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj >
    inline mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun4(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))
    {
        return mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj >
    inline mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun5(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))
    {
        return mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj >
    inline mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun6(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))
    {
        return mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj >
    inline mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun7(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))
    {
        return mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_func);
    }
    template<class T_return, class T_obj >
    inline const_mem_functor0< T_return, T_obj > mem_fun0(T_return (T_obj:: * _A_func)() const)
    {
        return const_mem_functor0< T_return, T_obj >(_A_func);
    }
    template<class T_arg1, class T_return, class T_obj >
    inline const_mem_functor1< T_return, T_obj, T_arg1 > mem_fun1(T_return (T_obj:: * _A_func)(T_arg1) const)
    {
        return const_mem_functor1< T_return, T_obj, T_arg1 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj >
    inline const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun2(T_return (T_obj:: * _A_func)(T_arg1, T_arg2) const)
    {
        return const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj >
    inline const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun3(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3) const)
    {
        return const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj >
    inline const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun4(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)
    {
        return const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj >
    inline const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun5(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)
    {
        return const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj >
    inline const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun6(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)
    {
        return const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj >
    inline const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun7(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)
    {
        return const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_func);
    }
    template<class T_return, class T_obj >
    inline volatile_mem_functor0< T_return, T_obj > mem_fun0(T_return (T_obj:: * _A_func)() volatile)
    {
        return volatile_mem_functor0< T_return, T_obj >(_A_func);
    }
    template<class T_arg1, class T_return, class T_obj >
    inline volatile_mem_functor1< T_return, T_obj, T_arg1 > mem_fun1(T_return (T_obj:: * _A_func)(T_arg1) volatile)
    {
        return volatile_mem_functor1< T_return, T_obj, T_arg1 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj >
    inline volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun2(T_return (T_obj:: * _A_func)(T_arg1, T_arg2) volatile)
    {
        return volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj >
    inline volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun3(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3) volatile)
    {
        return volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj >
    inline volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun4(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)
    {
        return volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj >
    inline volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun5(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)
    {
        return volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj >
    inline volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun6(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)
    {
        return volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj >
    inline volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun7(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)
    {
        return volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_func);
    }
    template<class T_return, class T_obj >
    inline const_volatile_mem_functor0< T_return, T_obj > mem_fun0(T_return (T_obj:: * _A_func)() const volatile)
    {
        return const_volatile_mem_functor0< T_return, T_obj >(_A_func);
    }
    template<class T_arg1, class T_return, class T_obj >
    inline const_volatile_mem_functor1< T_return, T_obj, T_arg1 > mem_fun1(T_return (T_obj:: * _A_func)(T_arg1) const volatile)
    {
        return const_volatile_mem_functor1< T_return, T_obj, T_arg1 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj >
    inline const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun2(T_return (T_obj:: * _A_func)(T_arg1, T_arg2) const volatile)
    {
        return const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj >
    inline const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun3(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3) const volatile)
    {
        return const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj >
    inline const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun4(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)
    {
        return const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj >
    inline const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun5(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)
    {
        return const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj >
    inline const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun6(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)
    {
        return const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj >
    inline const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun7(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)
    {
        return const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_func);
    }
    template<class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor0< T_return, T_obj > mem_fun0(T_obj * _A_obj, T_return (T_obj2:: * _A_func)())
    {
        return bound_mem_functor0< T_return, T_obj >(_A_obj, _A_func);
    }
    template<class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor0< T_return, T_obj > mem_fun0(T_obj & _A_obj, T_return (T_obj2:: * _A_func)())
    {
        return bound_mem_functor0< T_return, T_obj >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor1< T_return, T_obj, T_arg1 > mem_fun1(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1))
    {
        return bound_mem_functor1< T_return, T_obj, T_arg1 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor1< T_return, T_obj, T_arg1 > mem_fun1(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1))
    {
        return bound_mem_functor1< T_return, T_obj, T_arg1 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun2(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2))
    {
        return bound_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun2(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2))
    {
        return bound_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun3(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3))
    {
        return bound_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun3(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3))
    {
        return bound_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun4(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))
    {
        return bound_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun4(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))
    {
        return bound_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun5(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))
    {
        return bound_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun5(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))
    {
        return bound_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun6(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))
    {
        return bound_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun6(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))
    {
        return bound_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun7(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))
    {
        return bound_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun7(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))
    {
        return bound_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_obj, _A_func);
    }
    template<class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor0< T_return, T_obj > mem_fun0(T_obj * _A_obj, T_return (T_obj2:: * _A_func)() const)
    {
        return bound_const_mem_functor0< T_return, T_obj >(_A_obj, _A_func);
    }
    template<class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor0< T_return, T_obj > mem_fun0(T_obj & _A_obj, T_return (T_obj2:: * _A_func)() const)
    {
        return bound_const_mem_functor0< T_return, T_obj >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor1< T_return, T_obj, T_arg1 > mem_fun1(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1) const)
    {
        return bound_const_mem_functor1< T_return, T_obj, T_arg1 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor1< T_return, T_obj, T_arg1 > mem_fun1(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1) const)
    {
        return bound_const_mem_functor1< T_return, T_obj, T_arg1 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun2(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2) const)
    {
        return bound_const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun2(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2) const)
    {
        return bound_const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun3(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3) const)
    {
        return bound_const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun3(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3) const)
    {
        return bound_const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun4(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)
    {
        return bound_const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun4(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)
    {
        return bound_const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun5(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)
    {
        return bound_const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun5(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)
    {
        return bound_const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun6(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)
    {
        return bound_const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun6(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)
    {
        return bound_const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun7(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)
    {
        return bound_const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun7(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)
    {
        return bound_const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_obj, _A_func);
    }
    template<class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor0< T_return, T_obj > mem_fun0(T_obj * _A_obj, T_return (T_obj2:: * _A_func)() volatile)
    {
        return bound_volatile_mem_functor0< T_return, T_obj >(_A_obj, _A_func);
    }
    template<class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor0< T_return, T_obj > mem_fun0(T_obj & _A_obj, T_return (T_obj2:: * _A_func)() volatile)
    {
        return bound_volatile_mem_functor0< T_return, T_obj >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor1< T_return, T_obj, T_arg1 > mem_fun1(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1) volatile)
    {
        return bound_volatile_mem_functor1< T_return, T_obj, T_arg1 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor1< T_return, T_obj, T_arg1 > mem_fun1(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1) volatile)
    {
        return bound_volatile_mem_functor1< T_return, T_obj, T_arg1 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun2(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2) volatile)
    {
        return bound_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun2(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2) volatile)
    {
        return bound_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun3(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3) volatile)
    {
        return bound_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun3(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3) volatile)
    {
        return bound_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun4(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)
    {
        return bound_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun4(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)
    {
        return bound_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun5(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)
    {
        return bound_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun5(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)
    {
        return bound_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun6(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)
    {
        return bound_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun6(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)
    {
        return bound_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun7(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)
    {
        return bound_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun7(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)
    {
        return bound_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_obj, _A_func);
    }
    template<class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor0< T_return, T_obj > mem_fun0(T_obj * _A_obj, T_return (T_obj2:: * _A_func)() const volatile)
    {
        return bound_const_volatile_mem_functor0< T_return, T_obj >(_A_obj, _A_func);
    }
    template<class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor0< T_return, T_obj > mem_fun0(T_obj & _A_obj, T_return (T_obj2:: * _A_func)() const volatile)
    {
        return bound_const_volatile_mem_functor0< T_return, T_obj >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor1< T_return, T_obj, T_arg1 > mem_fun1(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1) const volatile)
    {
        return bound_const_volatile_mem_functor1< T_return, T_obj, T_arg1 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor1< T_return, T_obj, T_arg1 > mem_fun1(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1) const volatile)
    {
        return bound_const_volatile_mem_functor1< T_return, T_obj, T_arg1 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun2(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2) const volatile)
    {
        return bound_const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun2(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2) const volatile)
    {
        return bound_const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun3(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3) const volatile)
    {
        return bound_const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun3(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3) const volatile)
    {
        return bound_const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun4(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)
    {
        return bound_const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun4(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)
    {
        return bound_const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun5(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)
    {
        return bound_const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun5(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)
    {
        return bound_const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun6(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)
    {
        return bound_const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun6(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)
    {
        return bound_const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun7(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)
    {
        return bound_const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun7(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)
    {
        return bound_const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_obj, _A_func);
    }
    template<class T_return, class T_obj >
    inline mem_functor0< T_return, T_obj > mem_fun(T_return (T_obj:: * _A_func)())
    {
        return mem_functor0< T_return, T_obj >(_A_func);
    }
    template<class T_arg1, class T_return, class T_obj >
    inline mem_functor1< T_return, T_obj, T_arg1 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1))
    {
        return mem_functor1< T_return, T_obj, T_arg1 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj >
    inline mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2))
    {
        return mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj >
    inline mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3))
    {
        return mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj >
    inline mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))
    {
        return mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj >
    inline mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))
    {
        return mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj >
    inline mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))
    {
        return mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj >
    inline mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))
    {
        return mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_func);
    }
    template<class T_return, class T_obj >
    inline const_mem_functor0< T_return, T_obj > mem_fun(T_return (T_obj:: * _A_func)() const)
    {
        return const_mem_functor0< T_return, T_obj >(_A_func);
    }
    template<class T_arg1, class T_return, class T_obj >
    inline const_mem_functor1< T_return, T_obj, T_arg1 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1) const)
    {
        return const_mem_functor1< T_return, T_obj, T_arg1 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj >
    inline const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2) const)
    {
        return const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj >
    inline const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3) const)
    {
        return const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj >
    inline const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)
    {
        return const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj >
    inline const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)
    {
        return const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj >
    inline const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)
    {
        return const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj >
    inline const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)
    {
        return const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_func);
    }
    template<class T_return, class T_obj >
    inline volatile_mem_functor0< T_return, T_obj > mem_fun(T_return (T_obj:: * _A_func)() volatile)
    {
        return volatile_mem_functor0< T_return, T_obj >(_A_func);
    }
    template<class T_arg1, class T_return, class T_obj >
    inline volatile_mem_functor1< T_return, T_obj, T_arg1 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1) volatile)
    {
        return volatile_mem_functor1< T_return, T_obj, T_arg1 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj >
    inline volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2) volatile)
    {
        return volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj >
    inline volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3) volatile)
    {
        return volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj >
    inline volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)
    {
        return volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj >
    inline volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)
    {
        return volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj >
    inline volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)
    {
        return volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj >
    inline volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)
    {
        return volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_func);
    }
    template<class T_return, class T_obj >
    inline const_volatile_mem_functor0< T_return, T_obj > mem_fun(T_return (T_obj:: * _A_func)() const volatile)
    {
        return const_volatile_mem_functor0< T_return, T_obj >(_A_func);
    }
    template<class T_arg1, class T_return, class T_obj >
    inline const_volatile_mem_functor1< T_return, T_obj, T_arg1 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1) const volatile)
    {
        return const_volatile_mem_functor1< T_return, T_obj, T_arg1 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj >
    inline const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2) const volatile)
    {
        return const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj >
    inline const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3) const volatile)
    {
        return const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj >
    inline const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)
    {
        return const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj >
    inline const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)
    {
        return const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj >
    inline const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)
    {
        return const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj >
    inline const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun(T_return (T_obj:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)
    {
        return const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_func);
    }
    template<class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor0< T_return, T_obj > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)())
    {
        return bound_mem_functor0< T_return, T_obj >(_A_obj, _A_func);
    }
    template<class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor0< T_return, T_obj > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)())
    {
        return bound_mem_functor0< T_return, T_obj >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor1< T_return, T_obj, T_arg1 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1))
    {
        return bound_mem_functor1< T_return, T_obj, T_arg1 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor1< T_return, T_obj, T_arg1 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1))
    {
        return bound_mem_functor1< T_return, T_obj, T_arg1 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2))
    {
        return bound_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2))
    {
        return bound_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3))
    {
        return bound_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3))
    {
        return bound_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))
    {
        return bound_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))
    {
        return bound_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))
    {
        return bound_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))
    {
        return bound_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))
    {
        return bound_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))
    {
        return bound_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))
    {
        return bound_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2 >
    inline bound_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))
    {
        return bound_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_obj, _A_func);
    }
    template<class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor0< T_return, T_obj > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)() const)
    {
        return bound_const_mem_functor0< T_return, T_obj >(_A_obj, _A_func);
    }
    template<class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor0< T_return, T_obj > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)() const)
    {
        return bound_const_mem_functor0< T_return, T_obj >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor1< T_return, T_obj, T_arg1 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1) const)
    {
        return bound_const_mem_functor1< T_return, T_obj, T_arg1 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor1< T_return, T_obj, T_arg1 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1) const)
    {
        return bound_const_mem_functor1< T_return, T_obj, T_arg1 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2) const)
    {
        return bound_const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2) const)
    {
        return bound_const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3) const)
    {
        return bound_const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3) const)
    {
        return bound_const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)
    {
        return bound_const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)
    {
        return bound_const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)
    {
        return bound_const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)
    {
        return bound_const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)
    {
        return bound_const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)
    {
        return bound_const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)
    {
        return bound_const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2 >
    inline bound_const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)
    {
        return bound_const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_obj, _A_func);
    }
    template<class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor0< T_return, T_obj > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)() volatile)
    {
        return bound_volatile_mem_functor0< T_return, T_obj >(_A_obj, _A_func);
    }
    template<class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor0< T_return, T_obj > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)() volatile)
    {
        return bound_volatile_mem_functor0< T_return, T_obj >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor1< T_return, T_obj, T_arg1 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1) volatile)
    {
        return bound_volatile_mem_functor1< T_return, T_obj, T_arg1 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor1< T_return, T_obj, T_arg1 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1) volatile)
    {
        return bound_volatile_mem_functor1< T_return, T_obj, T_arg1 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2) volatile)
    {
        return bound_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2) volatile)
    {
        return bound_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3) volatile)
    {
        return bound_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3) volatile)
    {
        return bound_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)
    {
        return bound_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)
    {
        return bound_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)
    {
        return bound_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)
    {
        return bound_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)
    {
        return bound_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)
    {
        return bound_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)
    {
        return bound_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2 >
    inline bound_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)
    {
        return bound_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_obj, _A_func);
    }
    template<class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor0< T_return, T_obj > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)() const volatile)
    {
        return bound_const_volatile_mem_functor0< T_return, T_obj >(_A_obj, _A_func);
    }
    template<class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor0< T_return, T_obj > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)() const volatile)
    {
        return bound_const_volatile_mem_functor0< T_return, T_obj >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor1< T_return, T_obj, T_arg1 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1) const volatile)
    {
        return bound_const_volatile_mem_functor1< T_return, T_obj, T_arg1 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor1< T_return, T_obj, T_arg1 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1) const volatile)
    {
        return bound_const_volatile_mem_functor1< T_return, T_obj, T_arg1 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2) const volatile)
    {
        return bound_const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2) const volatile)
    {
        return bound_const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3) const volatile)
    {
        return bound_const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3) const volatile)
    {
        return bound_const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)
    {
        return bound_const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)
    {
        return bound_const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)
    {
        return bound_const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)
    {
        return bound_const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)
    {
        return bound_const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)
    {
        return bound_const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun(T_obj * _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)
    {
        return bound_const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_obj, _A_func);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2 >
    inline bound_const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > mem_fun(T_obj & _A_obj, T_return (T_obj2:: * _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)
    {
        return bound_const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_obj, _A_func);
    }
}
namespace sigc {
    struct adaptor_base : public functor_base
    {
    };
    template<class T_functor, class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void, bool I_derives_adaptor_base = is_base_and_derived< adaptor_base, T_functor >::value >
    struct deduce_result_type
    {
            typedef typename functor_trait< T_functor >::result_type type;
    };
    template<class T_functor >
    struct deduce_result_type< T_functor, void, void, void, void, void, void, void, true >
    {
            typedef typename T_functor::template deduce_result_type<  >::type type;
    };
    template<class T_functor, class T_arg1 >
    struct deduce_result_type< T_functor, T_arg1, void, void, void, void, void, void, true >
    {
            typedef typename T_functor::template deduce_result_type< T_arg1 >::type type;
    };
    template<class T_functor, class T_arg1, class T_arg2 >
    struct deduce_result_type< T_functor, T_arg1, T_arg2, void, void, void, void, void, true >
    {
            typedef typename T_functor::template deduce_result_type< T_arg1, T_arg2 >::type type;
    };
    template<class T_functor, class T_arg1, class T_arg2, class T_arg3 >
    struct deduce_result_type< T_functor, T_arg1, T_arg2, T_arg3, void, void, void, void, true >
    {
            typedef typename T_functor::template deduce_result_type< T_arg1, T_arg2, T_arg3 >::type type;
    };
    template<class T_functor, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    struct deduce_result_type< T_functor, T_arg1, T_arg2, T_arg3, T_arg4, void, void, void, true >
    {
            typedef typename T_functor::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type type;
    };
    template<class T_functor, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    struct deduce_result_type< T_functor, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, void, void, true >
    {
            typedef typename T_functor::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type type;
    };
    template<class T_functor, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    struct deduce_result_type< T_functor, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, void, true >
    {
            typedef typename T_functor::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type type;
    };
    template<class T_functor, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    struct deduce_result_type< T_functor, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, true >
    {
            typedef typename T_functor::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type type;
    };
}
namespace sigc {
    template<class T_functor >
    struct adapts;
    template<class T_functor >
    struct adaptor_functor : public adaptor_base
    {
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename sigc::deduce_result_type< T_functor, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type type;
            };
            typedef typename functor_trait< T_functor >::result_type result_type;
            result_type operator ()() const;
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_arg1) const
            {
                return functor_(_A_arg1);
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2) const
            {
                return functor_(_A_arg1, _A_arg2);
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3) const
            {
                return functor_(_A_arg1, _A_arg2, _A_arg3);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4) const
            {
                return functor_(_A_arg1, _A_arg2, _A_arg3, _A_arg4);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5) const
            {
                return functor_(_A_arg1, _A_arg2, _A_arg3, _A_arg4, _A_arg5);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5, T_arg6 _A_arg6) const
            {
                return functor_(_A_arg1, _A_arg2, _A_arg3, _A_arg4, _A_arg5, _A_arg6);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5, T_arg6 _A_arg6, T_arg7 _A_arg7) const
            {
                return functor_(_A_arg1, _A_arg2, _A_arg3, _A_arg4, _A_arg5, _A_arg6, _A_arg7);
            }
            adaptor_functor()
            {
            }
            explicit adaptor_functor(const T_functor & _A_functor)
                : functor_(_A_functor) 
            {
            }
            template<class T_type >
            explicit adaptor_functor(const T_type & _A_type)
                : functor_(_A_type) 
            {
            }
            mutable T_functor functor_;
    };
    template<class T_functor >
    typename adaptor_functor< T_functor >::result_type adaptor_functor< T_functor >::operator ()() const
    {
        return functor_();
    }
    template<class T_action, class T_functor >
    void visit_each(const T_action & _A_action, const adaptor_functor< T_functor > & _A_target)
    {
        sigc::visit_each(_A_action, _A_target.functor_);
    }
    template<class T_functor, bool I_isadaptor = is_base_and_derived< adaptor_base, T_functor >::value >
    struct adaptor_trait;
    template<class T_functor >
    struct adaptor_trait< T_functor, true >
    {
            typedef typename T_functor::result_type result_type;
            typedef T_functor functor_type;
            typedef T_functor adaptor_type;
    };
    template<class T_functor >
    struct adaptor_trait< T_functor, false >
    {
            typedef typename functor_trait< T_functor >::result_type result_type;
            typedef typename functor_trait< T_functor >::functor_type functor_type;
            typedef adaptor_functor< functor_type > adaptor_type;
    };
    template<class T_functor >
    struct adapts : public adaptor_base
    {
            typedef typename adaptor_trait< T_functor >::result_type result_type;
            typedef typename adaptor_trait< T_functor >::adaptor_type adaptor_type;
            explicit adapts(const T_functor & _A_functor)
                : functor_(_A_functor) 
            {
            }
            mutable adaptor_type functor_;
    };
}
namespace sigc {
    namespace internal {
        typedef void * (* hook)(void *);
        struct slot_rep : public trackable
        {
                hook call_;
                hook destroy_;
                hook dup_;
                hook cleanup_;
                void * parent_;
                inline slot_rep(hook call__, hook destroy__, hook dup__)
                    : call_(call__), destroy_(destroy__), dup_(dup__), cleanup_(0), parent_(0) 
                {
                }
                inline ~slot_rep()
                {
                    destroy();
                }
                inline void destroy()
                {
                    if (destroy_)
                        (*destroy_)(this);
                }
                inline slot_rep * dup() const
                {
                    return reinterpret_cast<slot_rep * >((*dup_)(const_cast<slot_rep * >(this)));
                }
                inline void set_parent(void * parent, hook cleanup)
                {
                    parent_ = parent;
                    cleanup_ = cleanup;
                }
                void disconnect();
                static void * notify(void * data);
        };
        struct slot_do_bind
        {
                slot_rep * rep_;
                inline slot_do_bind(slot_rep * rep)
                    : rep_(rep) 
                {
                }
                inline void operator ()(const trackable * t) const
                {
                    t->add_destroy_notify_callback(rep_, &slot_rep::notify);
                }
        };
        struct slot_do_unbind
        {
                slot_rep * rep_;
                inline slot_do_unbind(slot_rep * rep)
                    : rep_(rep) 
                {
                }
                inline void operator ()(const trackable * t) const
                {
                    t->remove_destroy_notify_callback(rep_);
                }
        };
    }
    class slot_base : public functor_base
    {
            typedef internal::slot_rep rep_type;
        public :
            slot_base();
            explicit slot_base(rep_type * rep);
            slot_base(const slot_base & src);
            ~slot_base();
            operator bool() const;
            void set_parent(void * parent, void * (* cleanup)(void *)) const;
            typedef trackable::func_destroy_notify func_destroy_notify;
            void add_destroy_notify_callback(void * data, func_destroy_notify func) const;
            void remove_destroy_notify_callback(void * data) const;
            inline bool empty() const
            {
                return (!rep_ || !rep_->call_);
            }
            inline bool blocked() const
            {
                return blocked_;
            }
            bool block(bool should_block = true);
            bool unblock();
            void disconnect();
            slot_base & operator =(const slot_base & src);
        public :
            mutable rep_type * rep_;
            bool blocked_;
    };
}
namespace sigc {
    namespace internal {
        template<class T_functor >
        struct typed_slot_rep : public slot_rep
        {
                typedef typed_slot_rep< T_functor > self;
                typedef typename adaptor_trait< T_functor >::adaptor_type adaptor_type;
                adaptor_type functor_;
                inline typed_slot_rep(const T_functor & functor)
                    : slot_rep(0, &destroy, &dup), functor_(functor) 
                {
                    visit_each_type< trackable * >(slot_do_bind(this), functor_);
                }
                inline typed_slot_rep(const typed_slot_rep & cl)
                    : slot_rep(cl.call_, &destroy, &dup), functor_(cl.functor_) 
                {
                    visit_each_type< trackable * >(slot_do_bind(this), functor_);
                }
                inline ~typed_slot_rep()
                {
                    call_ = 0;
                    destroy_ = 0;
                    visit_each_type< trackable * >(slot_do_unbind(this), functor_);
                }
                static void * destroy(void * data)
                {
                    self * self_ = static_cast<self * >(reinterpret_cast<slot_rep * >(data));
                    self_->call_ = 0;
                    self_->destroy_ = 0;
                    visit_each_type< trackable * >(slot_do_unbind(self_), self_->functor_);
                    self_->functor_.~adaptor_type();
                    return 0;
                }
                static void * dup(void * data)
                {
                    slot_rep * a_rep = reinterpret_cast<slot_rep * >(data);
                    return static_cast<slot_rep * >(new self (*static_cast<self * >(a_rep)));
                }
        };
        template<class T_functor, class T_return >
        struct slot_call0
        {
                static T_return call_it(slot_rep * rep)
                {
                    typedef typed_slot_rep< T_functor > typed_slot;
                    typed_slot * typed_rep = static_cast<typed_slot * >(rep);
                    return (typed_rep->functor_)();
                }
                static hook address()
                {
                    return reinterpret_cast<hook >(&call_it);
                }
        };
        template<class T_functor, class T_return, class T_arg1 >
        struct slot_call1
        {
                static T_return call_it(slot_rep * rep, typename type_trait< T_arg1 >::take a_1)
                {
                    typedef typed_slot_rep< T_functor > typed_slot;
                    typed_slot * typed_rep = static_cast<typed_slot * >(rep);
                    return (typed_rep->functor_).template operator ()<typename type_trait< T_arg1 >::take >(a_1);
                }
                static hook address()
                {
                    return reinterpret_cast<hook >(&call_it);
                }
        };
        template<class T_functor, class T_return, class T_arg1, class T_arg2 >
        struct slot_call2
        {
                static T_return call_it(slot_rep * rep, typename type_trait< T_arg1 >::take a_1, typename type_trait< T_arg2 >::take a_2)
                {
                    typedef typed_slot_rep< T_functor > typed_slot;
                    typed_slot * typed_rep = static_cast<typed_slot * >(rep);
                    return (typed_rep->functor_).template operator ()<typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take >(a_1, a_2);
                }
                static hook address()
                {
                    return reinterpret_cast<hook >(&call_it);
                }
        };
        template<class T_functor, class T_return, class T_arg1, class T_arg2, class T_arg3 >
        struct slot_call3
        {
                static T_return call_it(slot_rep * rep, typename type_trait< T_arg1 >::take a_1, typename type_trait< T_arg2 >::take a_2, typename type_trait< T_arg3 >::take a_3)
                {
                    typedef typed_slot_rep< T_functor > typed_slot;
                    typed_slot * typed_rep = static_cast<typed_slot * >(rep);
                    return (typed_rep->functor_).template operator ()<typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take, typename type_trait< T_arg3 >::take >(a_1, a_2, a_3);
                }
                static hook address()
                {
                    return reinterpret_cast<hook >(&call_it);
                }
        };
        template<class T_functor, class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
        struct slot_call4
        {
                static T_return call_it(slot_rep * rep, typename type_trait< T_arg1 >::take a_1, typename type_trait< T_arg2 >::take a_2, typename type_trait< T_arg3 >::take a_3, typename type_trait< T_arg4 >::take a_4)
                {
                    typedef typed_slot_rep< T_functor > typed_slot;
                    typed_slot * typed_rep = static_cast<typed_slot * >(rep);
                    return (typed_rep->functor_).template operator ()<typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take, typename type_trait< T_arg3 >::take, typename type_trait< T_arg4 >::take >(a_1, a_2, a_3, a_4);
                }
                static hook address()
                {
                    return reinterpret_cast<hook >(&call_it);
                }
        };
        template<class T_functor, class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
        struct slot_call5
        {
                static T_return call_it(slot_rep * rep, typename type_trait< T_arg1 >::take a_1, typename type_trait< T_arg2 >::take a_2, typename type_trait< T_arg3 >::take a_3, typename type_trait< T_arg4 >::take a_4, typename type_trait< T_arg5 >::take a_5)
                {
                    typedef typed_slot_rep< T_functor > typed_slot;
                    typed_slot * typed_rep = static_cast<typed_slot * >(rep);
                    return (typed_rep->functor_).template operator ()<typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take, typename type_trait< T_arg3 >::take, typename type_trait< T_arg4 >::take, typename type_trait< T_arg5 >::take >(a_1, a_2, a_3, a_4, a_5);
                }
                static hook address()
                {
                    return reinterpret_cast<hook >(&call_it);
                }
        };
        template<class T_functor, class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
        struct slot_call6
        {
                static T_return call_it(slot_rep * rep, typename type_trait< T_arg1 >::take a_1, typename type_trait< T_arg2 >::take a_2, typename type_trait< T_arg3 >::take a_3, typename type_trait< T_arg4 >::take a_4, typename type_trait< T_arg5 >::take a_5, typename type_trait< T_arg6 >::take a_6)
                {
                    typedef typed_slot_rep< T_functor > typed_slot;
                    typed_slot * typed_rep = static_cast<typed_slot * >(rep);
                    return (typed_rep->functor_).template operator ()<typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take, typename type_trait< T_arg3 >::take, typename type_trait< T_arg4 >::take, typename type_trait< T_arg5 >::take, typename type_trait< T_arg6 >::take >(a_1, a_2, a_3, a_4, a_5, a_6);
                }
                static hook address()
                {
                    return reinterpret_cast<hook >(&call_it);
                }
        };
        template<class T_functor, class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
        struct slot_call7
        {
                static T_return call_it(slot_rep * rep, typename type_trait< T_arg1 >::take a_1, typename type_trait< T_arg2 >::take a_2, typename type_trait< T_arg3 >::take a_3, typename type_trait< T_arg4 >::take a_4, typename type_trait< T_arg5 >::take a_5, typename type_trait< T_arg6 >::take a_6, typename type_trait< T_arg7 >::take a_7)
                {
                    typedef typed_slot_rep< T_functor > typed_slot;
                    typed_slot * typed_rep = static_cast<typed_slot * >(rep);
                    return (typed_rep->functor_).template operator ()<typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take, typename type_trait< T_arg3 >::take, typename type_trait< T_arg4 >::take, typename type_trait< T_arg5 >::take, typename type_trait< T_arg6 >::take, typename type_trait< T_arg7 >::take >(a_1, a_2, a_3, a_4, a_5, a_6, a_7);
                }
                static hook address()
                {
                    return reinterpret_cast<hook >(&call_it);
                }
        };
    }
    template<class T_return >
    class slot0 : public slot_base
    {
        public :
            typedef T_return result_type;
        private :
            typedef internal::slot_rep rep_type;
        public :
            typedef T_return (* call_type)(rep_type *);
            inline T_return operator ()() const
            {
                if (!empty() && !blocked())
                    return (reinterpret_cast<call_type >(slot_base::rep_->call_))(slot_base::rep_);
                return T_return();
            }
            inline slot0()
            {
            }
            template<class T_functor >
            slot0(const T_functor & _A_func)
                : slot_base(new internal::typed_slot_rep< T_functor > (_A_func)) 
            {
                slot_base::rep_->call_ = internal::slot_call0< T_functor, T_return >::address();
            }
            slot0(const slot0 & src)
                : slot_base(src) 
            {
            }
            slot0 & operator =(const slot0 & src)
            {
                slot_base::operator =(src);
                return *this;
            }
    };
    template<class T_return, class T_arg1 >
    class slot1 : public slot_base
    {
        public :
            typedef T_return result_type;
            typedef typename type_trait< T_arg1 >::take arg1_type_;
        private :
            typedef internal::slot_rep rep_type;
        public :
            typedef T_return (* call_type)(rep_type *, arg1_type_);
            inline T_return operator ()(arg1_type_ _A_a1) const
            {
                if (!empty() && !blocked())
                    return (reinterpret_cast<call_type >(slot_base::rep_->call_))(slot_base::rep_, _A_a1);
                return T_return();
            }
            inline slot1()
            {
            }
            template<class T_functor >
            slot1(const T_functor & _A_func)
                : slot_base(new internal::typed_slot_rep< T_functor > (_A_func)) 
            {
                slot_base::rep_->call_ = internal::slot_call1< T_functor, T_return, T_arg1 >::address();
            }
            slot1(const slot1 & src)
                : slot_base(src) 
            {
            }
            slot1 & operator =(const slot1 & src)
            {
                slot_base::operator =(src);
                return *this;
            }
    };
    template<class T_return, class T_arg1, class T_arg2 >
    class slot2 : public slot_base
    {
        public :
            typedef T_return result_type;
            typedef typename type_trait< T_arg1 >::take arg1_type_;
            typedef typename type_trait< T_arg2 >::take arg2_type_;
        private :
            typedef internal::slot_rep rep_type;
        public :
            typedef T_return (* call_type)(rep_type *, arg1_type_, arg2_type_);
            inline T_return operator ()(arg1_type_ _A_a1, arg2_type_ _A_a2) const
            {
                if (!empty() && !blocked())
                    return (reinterpret_cast<call_type >(slot_base::rep_->call_))(slot_base::rep_, _A_a1, _A_a2);
                return T_return();
            }
            inline slot2()
            {
            }
            template<class T_functor >
            slot2(const T_functor & _A_func)
                : slot_base(new internal::typed_slot_rep< T_functor > (_A_func)) 
            {
                slot_base::rep_->call_ = internal::slot_call2< T_functor, T_return, T_arg1, T_arg2 >::address();
            }
            slot2(const slot2 & src)
                : slot_base(src) 
            {
            }
            slot2 & operator =(const slot2 & src)
            {
                slot_base::operator =(src);
                return *this;
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3 >
    class slot3 : public slot_base
    {
        public :
            typedef T_return result_type;
            typedef typename type_trait< T_arg1 >::take arg1_type_;
            typedef typename type_trait< T_arg2 >::take arg2_type_;
            typedef typename type_trait< T_arg3 >::take arg3_type_;
        private :
            typedef internal::slot_rep rep_type;
        public :
            typedef T_return (* call_type)(rep_type *, arg1_type_, arg2_type_, arg3_type_);
            inline T_return operator ()(arg1_type_ _A_a1, arg2_type_ _A_a2, arg3_type_ _A_a3) const
            {
                if (!empty() && !blocked())
                    return (reinterpret_cast<call_type >(slot_base::rep_->call_))(slot_base::rep_, _A_a1, _A_a2, _A_a3);
                return T_return();
            }
            inline slot3()
            {
            }
            template<class T_functor >
            slot3(const T_functor & _A_func)
                : slot_base(new internal::typed_slot_rep< T_functor > (_A_func)) 
            {
                slot_base::rep_->call_ = internal::slot_call3< T_functor, T_return, T_arg1, T_arg2, T_arg3 >::address();
            }
            slot3(const slot3 & src)
                : slot_base(src) 
            {
            }
            slot3 & operator =(const slot3 & src)
            {
                slot_base::operator =(src);
                return *this;
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    class slot4 : public slot_base
    {
        public :
            typedef T_return result_type;
            typedef typename type_trait< T_arg1 >::take arg1_type_;
            typedef typename type_trait< T_arg2 >::take arg2_type_;
            typedef typename type_trait< T_arg3 >::take arg3_type_;
            typedef typename type_trait< T_arg4 >::take arg4_type_;
        private :
            typedef internal::slot_rep rep_type;
        public :
            typedef T_return (* call_type)(rep_type *, arg1_type_, arg2_type_, arg3_type_, arg4_type_);
            inline T_return operator ()(arg1_type_ _A_a1, arg2_type_ _A_a2, arg3_type_ _A_a3, arg4_type_ _A_a4) const
            {
                if (!empty() && !blocked())
                    return (reinterpret_cast<call_type >(slot_base::rep_->call_))(slot_base::rep_, _A_a1, _A_a2, _A_a3, _A_a4);
                return T_return();
            }
            inline slot4()
            {
            }
            template<class T_functor >
            slot4(const T_functor & _A_func)
                : slot_base(new internal::typed_slot_rep< T_functor > (_A_func)) 
            {
                slot_base::rep_->call_ = internal::slot_call4< T_functor, T_return, T_arg1, T_arg2, T_arg3, T_arg4 >::address();
            }
            slot4(const slot4 & src)
                : slot_base(src) 
            {
            }
            slot4 & operator =(const slot4 & src)
            {
                slot_base::operator =(src);
                return *this;
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    class slot5 : public slot_base
    {
        public :
            typedef T_return result_type;
            typedef typename type_trait< T_arg1 >::take arg1_type_;
            typedef typename type_trait< T_arg2 >::take arg2_type_;
            typedef typename type_trait< T_arg3 >::take arg3_type_;
            typedef typename type_trait< T_arg4 >::take arg4_type_;
            typedef typename type_trait< T_arg5 >::take arg5_type_;
        private :
            typedef internal::slot_rep rep_type;
        public :
            typedef T_return (* call_type)(rep_type *, arg1_type_, arg2_type_, arg3_type_, arg4_type_, arg5_type_);
            inline T_return operator ()(arg1_type_ _A_a1, arg2_type_ _A_a2, arg3_type_ _A_a3, arg4_type_ _A_a4, arg5_type_ _A_a5) const
            {
                if (!empty() && !blocked())
                    return (reinterpret_cast<call_type >(slot_base::rep_->call_))(slot_base::rep_, _A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
                return T_return();
            }
            inline slot5()
            {
            }
            template<class T_functor >
            slot5(const T_functor & _A_func)
                : slot_base(new internal::typed_slot_rep< T_functor > (_A_func)) 
            {
                slot_base::rep_->call_ = internal::slot_call5< T_functor, T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::address();
            }
            slot5(const slot5 & src)
                : slot_base(src) 
            {
            }
            slot5 & operator =(const slot5 & src)
            {
                slot_base::operator =(src);
                return *this;
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    class slot6 : public slot_base
    {
        public :
            typedef T_return result_type;
            typedef typename type_trait< T_arg1 >::take arg1_type_;
            typedef typename type_trait< T_arg2 >::take arg2_type_;
            typedef typename type_trait< T_arg3 >::take arg3_type_;
            typedef typename type_trait< T_arg4 >::take arg4_type_;
            typedef typename type_trait< T_arg5 >::take arg5_type_;
            typedef typename type_trait< T_arg6 >::take arg6_type_;
        private :
            typedef internal::slot_rep rep_type;
        public :
            typedef T_return (* call_type)(rep_type *, arg1_type_, arg2_type_, arg3_type_, arg4_type_, arg5_type_, arg6_type_);
            inline T_return operator ()(arg1_type_ _A_a1, arg2_type_ _A_a2, arg3_type_ _A_a3, arg4_type_ _A_a4, arg5_type_ _A_a5, arg6_type_ _A_a6) const
            {
                if (!empty() && !blocked())
                    return (reinterpret_cast<call_type >(slot_base::rep_->call_))(slot_base::rep_, _A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
                return T_return();
            }
            inline slot6()
            {
            }
            template<class T_functor >
            slot6(const T_functor & _A_func)
                : slot_base(new internal::typed_slot_rep< T_functor > (_A_func)) 
            {
                slot_base::rep_->call_ = internal::slot_call6< T_functor, T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::address();
            }
            slot6(const slot6 & src)
                : slot_base(src) 
            {
            }
            slot6 & operator =(const slot6 & src)
            {
                slot_base::operator =(src);
                return *this;
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    class slot7 : public slot_base
    {
        public :
            typedef T_return result_type;
            typedef typename type_trait< T_arg1 >::take arg1_type_;
            typedef typename type_trait< T_arg2 >::take arg2_type_;
            typedef typename type_trait< T_arg3 >::take arg3_type_;
            typedef typename type_trait< T_arg4 >::take arg4_type_;
            typedef typename type_trait< T_arg5 >::take arg5_type_;
            typedef typename type_trait< T_arg6 >::take arg6_type_;
            typedef typename type_trait< T_arg7 >::take arg7_type_;
        private :
            typedef internal::slot_rep rep_type;
        public :
            typedef T_return (* call_type)(rep_type *, arg1_type_, arg2_type_, arg3_type_, arg4_type_, arg5_type_, arg6_type_, arg7_type_);
            inline T_return operator ()(arg1_type_ _A_a1, arg2_type_ _A_a2, arg3_type_ _A_a3, arg4_type_ _A_a4, arg5_type_ _A_a5, arg6_type_ _A_a6, arg7_type_ _A_a7) const
            {
                if (!empty() && !blocked())
                    return (reinterpret_cast<call_type >(slot_base::rep_->call_))(slot_base::rep_, _A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
                return T_return();
            }
            inline slot7()
            {
            }
            template<class T_functor >
            slot7(const T_functor & _A_func)
                : slot_base(new internal::typed_slot_rep< T_functor > (_A_func)) 
            {
                slot_base::rep_->call_ = internal::slot_call7< T_functor, T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::address();
            }
            slot7(const slot7 & src)
                : slot_base(src) 
            {
            }
            slot7 & operator =(const slot7 & src)
            {
                slot_base::operator =(src);
                return *this;
            }
    };
    template<class T_return, class T_arg1 = nil, class T_arg2 = nil, class T_arg3 = nil, class T_arg4 = nil, class T_arg5 = nil, class T_arg6 = nil, class T_arg7 = nil >
    class slot : public slot7< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
    {
        public :
            typedef slot7< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > parent_type;
            inline slot()
            {
            }
            template<class T_functor >
            slot(const T_functor & _A_func)
                : parent_type(_A_func) 
            {
            }
            slot(const slot & src)
                : parent_type(reinterpret_cast<const parent_type & >(src)) 
            {
            }
    };
    template<class T_return >
    class slot< T_return, nil, nil, nil, nil, nil, nil, nil > : public slot0< T_return >
    {
        public :
            typedef slot0< T_return > parent_type;
            inline slot()
            {
            }
            template<class T_functor >
            slot(const T_functor & _A_func)
                : parent_type(_A_func) 
            {
            }
            slot(const slot & src)
                : parent_type(reinterpret_cast<const parent_type & >(src)) 
            {
            }
    };
    template<class T_return, class T_arg1 >
    class slot< T_return, T_arg1, nil, nil, nil, nil, nil, nil > : public slot1< T_return, T_arg1 >
    {
        public :
            typedef slot1< T_return, T_arg1 > parent_type;
            inline slot()
            {
            }
            template<class T_functor >
            slot(const T_functor & _A_func)
                : parent_type(_A_func) 
            {
            }
            slot(const slot & src)
                : parent_type(reinterpret_cast<const parent_type & >(src)) 
            {
            }
    };
    template<class T_return, class T_arg1, class T_arg2 >
    class slot< T_return, T_arg1, T_arg2, nil, nil, nil, nil, nil > : public slot2< T_return, T_arg1, T_arg2 >
    {
        public :
            typedef slot2< T_return, T_arg1, T_arg2 > parent_type;
            inline slot()
            {
            }
            template<class T_functor >
            slot(const T_functor & _A_func)
                : parent_type(_A_func) 
            {
            }
            slot(const slot & src)
                : parent_type(reinterpret_cast<const parent_type & >(src)) 
            {
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3 >
    class slot< T_return, T_arg1, T_arg2, T_arg3, nil, nil, nil, nil > : public slot3< T_return, T_arg1, T_arg2, T_arg3 >
    {
        public :
            typedef slot3< T_return, T_arg1, T_arg2, T_arg3 > parent_type;
            inline slot()
            {
            }
            template<class T_functor >
            slot(const T_functor & _A_func)
                : parent_type(_A_func) 
            {
            }
            slot(const slot & src)
                : parent_type(reinterpret_cast<const parent_type & >(src)) 
            {
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    class slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4, nil, nil, nil > : public slot4< T_return, T_arg1, T_arg2, T_arg3, T_arg4 >
    {
        public :
            typedef slot4< T_return, T_arg1, T_arg2, T_arg3, T_arg4 > parent_type;
            inline slot()
            {
            }
            template<class T_functor >
            slot(const T_functor & _A_func)
                : parent_type(_A_func) 
            {
            }
            slot(const slot & src)
                : parent_type(reinterpret_cast<const parent_type & >(src)) 
            {
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    class slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil, nil > : public slot5< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >
    {
        public :
            typedef slot5< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > parent_type;
            inline slot()
            {
            }
            template<class T_functor >
            slot(const T_functor & _A_func)
                : parent_type(_A_func) 
            {
            }
            slot(const slot & src)
                : parent_type(reinterpret_cast<const parent_type & >(src)) 
            {
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    class slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil > : public slot6< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >
    {
        public :
            typedef slot6< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > parent_type;
            inline slot()
            {
            }
            template<class T_functor >
            slot(const T_functor & _A_func)
                : parent_type(_A_func) 
            {
            }
            slot(const slot & src)
                : parent_type(reinterpret_cast<const parent_type & >(src)) 
            {
            }
    };
}
namespace sigc {
    namespace internal {
        struct signal_impl
        {
                typedef size_t size_type;
                typedef std::list< slot_base > slot_list;
                typedef slot_list::iterator iterator_type;
                typedef slot_list::const_iterator const_iterator_type;
                signal_impl();
                inline void reference()
                {
                    ++ref_count_;
                }
                inline void reference_exec()
                {
                    ++ref_count_;
                    ++exec_count_;
                }
                inline void unreference()
                {
                    if (!(--ref_count_))
                        delete this;
                }
                inline void unreference_exec()
                {
                    if (!(--ref_count_))
                        delete this;
                    else
                        if (!(--exec_count_) && deferred_)
                            sweep();
                }
                inline bool empty() const
                {
                    return slots_.empty();
                }
                void clear();
                size_type size() const;
                iterator_type connect(const slot_base & slot_);
                iterator_type insert(iterator_type i, const slot_base & slot_);
                iterator_type erase(iterator_type i);
                void sweep();
                static void * notify(void * d);
                short ref_count_;
                short exec_count_;
                bool deferred_;
                std::list< slot_base > slots_;
        };
        struct signal_exec
        {
                signal_impl * sig_;
                inline signal_exec(const signal_impl * sig)
                    : sig_(const_cast<signal_impl * >(sig)) 
                {
                    sig_->reference_exec();
                }
                inline ~signal_exec()
                {
                    sig_->unreference_exec();
                }
        };
        struct temp_slot_list
        {
                typedef signal_impl::slot_list slot_list;
                typedef signal_impl::iterator_type iterator;
                typedef signal_impl::const_iterator_type const_iterator;
                temp_slot_list(slot_list & slots)
                    : slots_(slots) 
                {
                    placeholder = slots_.insert(slots_.end(), slot_base());
                }
                ~temp_slot_list()
                {
                    slots_.erase(placeholder);
                }
                iterator begin()
                {
                    return slots_.begin();
                }
                iterator end()
                {
                    return placeholder;
                }
                const_iterator begin() const
                {
                    return slots_.begin();
                }
                const_iterator end() const
                {
                    return placeholder;
                }
            private :
                slot_list & slots_;
                slot_list::iterator placeholder;
        };
    }
    struct signal_base : public trackable
    {
            typedef size_t size_type;
            signal_base();
            signal_base(const signal_base & src);
            ~signal_base();
            signal_base & operator =(const signal_base & src);
            inline bool empty() const
            {
                return (!impl_ || impl_->empty());
            }
            void clear();
            size_type size() const;
        protected :
            typedef internal::signal_impl::iterator_type iterator_type;
            iterator_type connect(const slot_base & slot_);
            iterator_type insert(iterator_type i, const slot_base & slot_);
            iterator_type erase(iterator_type i);
            internal::signal_impl * impl() const;
            mutable internal::signal_impl * impl_;
    };
}
namespace sigc {
    template<typename T_slot >
    struct slot_iterator
    {
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef std::bidirectional_iterator_tag iterator_category;
            typedef T_slot slot_type;
            typedef T_slot value_type;
            typedef T_slot * pointer;
            typedef T_slot & reference;
            typedef typename internal::signal_impl::iterator_type iterator_type;
            slot_iterator()
            {
            }
            explicit slot_iterator(const iterator_type & i)
                : i_(i) 
            {
            }
            reference operator *() const
            {
                return static_cast<reference >(*i_);
            }
            pointer operator ->() const
            {
                return &(operator *());
            }
            slot_iterator & operator ++()
            {
                ++i_;
                return *this;
            }
            slot_iterator operator ++(int)
            {
                slot_iterator __tmp(*this);
                ++i_;
                return __tmp;
            }
            slot_iterator & operator --()
            {
                --i_;
                return *this;
            }
            slot_iterator operator --(int)
            {
                slot_iterator __tmp(*this);
                --i_;
                return __tmp;
            }
            bool operator ==(const slot_iterator & other) const
            {
                return i_ == other.i_;
            }
            bool operator !=(const slot_iterator & other) const
            {
                return i_ != other.i_;
            }
            iterator_type i_;
    };
    template<typename T_slot >
    struct slot_const_iterator
    {
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef std::bidirectional_iterator_tag iterator_category;
            typedef T_slot slot_type;
            typedef T_slot value_type;
            typedef const T_slot * pointer;
            typedef const T_slot & reference;
            typedef typename internal::signal_impl::const_iterator_type iterator_type;
            slot_const_iterator()
            {
            }
            explicit slot_const_iterator(const iterator_type & i)
                : i_(i) 
            {
            }
            reference operator *() const
            {
                return static_cast<reference >(*i_);
            }
            pointer operator ->() const
            {
                return &(operator *());
            }
            slot_const_iterator & operator ++()
            {
                ++i_;
                return *this;
            }
            slot_const_iterator operator ++(int)
            {
                slot_const_iterator __tmp(*this);
                ++i_;
                return __tmp;
            }
            slot_const_iterator & operator --()
            {
                --i_;
                return *this;
            }
            slot_const_iterator operator --(int)
            {
                slot_const_iterator __tmp(*this);
                --i_;
                return __tmp;
            }
            bool operator ==(const slot_const_iterator & other) const
            {
                return i_ == other.i_;
            }
            bool operator !=(const slot_const_iterator & other) const
            {
                return i_ != other.i_;
            }
            iterator_type i_;
    };
    template<class T_slot >
    struct slot_list
    {
            typedef T_slot slot_type;
            typedef slot_type & reference;
            typedef const slot_type & const_reference;
            typedef slot_iterator< slot_type > iterator;
            typedef slot_const_iterator< slot_type > const_iterator;
            typedef std::reverse_iterator< iterator > reverse_iterator;
            typedef std::reverse_iterator< const_iterator > const_reverse_iterator;
            slot_list()
                : list_(0) 
            {
            }
            explicit slot_list(internal::signal_impl * __list)
                : list_(__list) 
            {
            }
            iterator begin()
            {
                return iterator(list_->slots_.begin());
            }
            const_iterator begin() const
            {
                return const_iterator(list_->slots_.begin());
            }
            iterator end()
            {
                return iterator(list_->slots_.end());
            }
            const_iterator end() const
            {
                return const_iterator(list_->slots_.end());
            }
            reverse_iterator rbegin()
            {
                return reverse_iterator(end());
            }
            const_reverse_iterator rbegin() const
            {
                return const_reverse_iterator(end());
            }
            reverse_iterator rend()
            {
                return reverse_iterator(begin());
            }
            const_reverse_iterator rend() const
            {
                return const_reverse_iterator(begin());
            }
            reference front()
            {
                return *begin();
            }
            const_reference front() const
            {
                return *begin();
            }
            reference back()
            {
                return *(--end());
            }
            const_reference back() const
            {
                return *(--end());
            }
            iterator insert(iterator i, const slot_type & slot_)
            {
                return iterator(list_->insert(i.i_, static_cast<const slot_base & >(slot_)));
            }
            void push_front(const slot_type & c)
            {
                insert(begin(), c);
            }
            void push_back(const slot_type & c)
            {
                insert(end(), c);
            }
            iterator erase(iterator i)
            {
                return iterator(list_->erase(i.i_));
            }
            iterator erase(iterator first_, iterator last_)
            {
                while (first_ != last_)
                    first_ = erase(first_);
                return last_;
            }
            void pop_front()
            {
                erase(begin());
            }
            void pop_back()
            {
                iterator tmp_ = end();
                erase(--tmp_);
            }
        protected :
            internal::signal_impl * list_;
    };
    namespace internal {
        template<class T_emitter, class T_result = typename T_emitter::result_type >
        struct slot_iterator_buf
        {
                typedef size_t size_type;
                typedef ptrdiff_t difference_type;
                typedef std::bidirectional_iterator_tag iterator_category;
                typedef T_emitter emitter_type;
                typedef T_result result_type;
                typedef typename T_emitter::slot_type slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                slot_iterator_buf()
                    : c_(0), invoked_(false) 
                {
                }
                slot_iterator_buf(const iterator_type & i, const emitter_type * c)
                    : i_(i), c_(c), invoked_(false) 
                {
                }
                result_type operator *() const
                {
                    if (!i_->empty() && !i_->blocked() && !invoked_)
                    {
                        r_ = (*c_)(static_cast<const slot_type & >(*i_));
                        invoked_ = true;
                    }
                    return r_;
                }
                slot_iterator_buf & operator ++()
                {
                    ++i_;
                    invoked_ = false;
                    return *this;
                }
                slot_iterator_buf operator ++(int)
                {
                    slot_iterator_buf __tmp(*this);
                    ++i_;
                    invoked_ = false;
                    return __tmp;
                }
                slot_iterator_buf & operator --()
                {
                    --i_;
                    invoked_ = false;
                    return *this;
                }
                slot_iterator_buf operator --(int)
                {
                    slot_iterator_buf __tmp(*this);
                    --i_;
                    invoked_ = false;
                    return __tmp;
                }
                bool operator ==(const slot_iterator_buf & other) const
                {
                    return (!c_ || (i_ == other.i_));
                }
                bool operator !=(const slot_iterator_buf & other) const
                {
                    return (c_ && (i_ != other.i_));
                }
            private :
                iterator_type i_;
                const emitter_type * c_;
                mutable result_type r_;
                mutable bool invoked_;
        };
        template<class T_emitter >
        struct slot_iterator_buf< T_emitter, void >
        {
                typedef size_t size_type;
                typedef ptrdiff_t difference_type;
                typedef std::bidirectional_iterator_tag iterator_category;
                typedef T_emitter emitter_type;
                typedef void result_type;
                typedef typename T_emitter::slot_type slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                slot_iterator_buf()
                    : c_(0), invoked_(false) 
                {
                }
                slot_iterator_buf(const iterator_type & i, const emitter_type * c)
                    : i_(i), c_(c), invoked_(false) 
                {
                }
                void operator *() const
                {
                    if (!i_->empty() && !i_->blocked() && !invoked_)
                    {
                        (*c_)(static_cast<const slot_type & >(*i_));
                        invoked_ = true;
                    }
                }
                slot_iterator_buf & operator ++()
                {
                    ++i_;
                    invoked_ = false;
                    return *this;
                }
                slot_iterator_buf operator ++(int)
                {
                    slot_iterator_buf __tmp(*this);
                    ++i_;
                    invoked_ = false;
                    return __tmp;
                }
                slot_iterator_buf & operator --()
                {
                    --i_;
                    invoked_ = false;
                    return *this;
                }
                slot_iterator_buf operator --(int)
                {
                    slot_iterator_buf __tmp(*this);
                    --i_;
                    invoked_ = false;
                    return __tmp;
                }
                bool operator ==(const slot_iterator_buf & other) const
                {
                    return i_ == other.i_;
                }
                bool operator !=(const slot_iterator_buf & other) const
                {
                    return i_ != other.i_;
                }
            private :
                iterator_type i_;
                const emitter_type * c_;
                mutable bool invoked_;
        };
        template<class T_return, class T_accumulator >
        struct signal_emit0
        {
                typedef signal_emit0< T_return, T_accumulator > self_type;
                typedef typename T_accumulator::result_type result_type;
                typedef slot< T_return > slot_type;
                typedef internal::slot_iterator_buf< self_type > slot_iterator_buf_type;
                typedef signal_impl::const_iterator_type iterator_type;
                signal_emit0()
                {
                }
                T_return operator ()(const slot_type & _A_slot) const
                {
                    return (reinterpret_cast<typename slot_type::call_type >(_A_slot.rep_->call_))(_A_slot.rep_);
                }
                static result_type emit(signal_impl * impl)
                {
                    T_accumulator accumulator;
                    if (!impl)
                        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
                    signal_exec exec(impl);
                    temp_slot_list slots(impl->slots_);
                    self_type self;
                    return accumulator(slot_iterator_buf_type(slots.begin(), &self), slot_iterator_buf_type(slots.end(), &self));
                }
        };
        template<class T_return >
        struct signal_emit0< T_return, nil >
        {
                typedef signal_emit0< T_return, nil > self_type;
                typedef T_return result_type;
                typedef slot< T_return > slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                typedef typename slot_type::call_type call_type;
                static result_type emit(signal_impl * impl)
                {
                    if (!impl || impl->slots_.empty())
                        return T_return();
                    signal_exec exec(impl);
                    T_return r_ = T_return();
                    {
                        temp_slot_list slots(impl->slots_);
                        iterator_type it = slots.begin();
                        for (;
                            it != slots.end();
                            ++it)
                        if (!it->empty() && !it->blocked())
                            break;
                        if (it == slots.end())
                            return T_return();
                        r_ = (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_);
                        for (++it;
                            it != slots.end();
                            ++it)
                        {
                            if (it->empty() || it->blocked())
                                continue;
                            r_ = (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_);
                        }
                    }
                    return r_;
                }
        };
        template<>
        struct signal_emit0< void, nil >
        {
                typedef signal_emit0< void, nil > self_type;
                typedef void result_type;
                typedef slot< void > slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                typedef void (* call_type)(slot_rep *);
                static result_type emit(signal_impl * impl)
                {
                    if (!impl || impl->slots_.empty())
                        return;
                    signal_exec exec(impl);
                    temp_slot_list slots(impl->slots_);
                    for (iterator_type it = slots.begin();
                        it != slots.end();
                        ++it)
                    {
                        if (it->empty() || it->blocked())
                            continue;
                        (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_);
                    }
                }
        };
        template<class T_return, class T_arg1, class T_accumulator >
        struct signal_emit1
        {
                typedef signal_emit1< T_return, T_arg1, T_accumulator > self_type;
                typedef typename T_accumulator::result_type result_type;
                typedef slot< T_return, T_arg1 > slot_type;
                typedef internal::slot_iterator_buf< self_type > slot_iterator_buf_type;
                typedef signal_impl::const_iterator_type iterator_type;
                signal_emit1(typename type_trait< T_arg1 >::take _A_a1)
                    : _A_a1_(_A_a1) 
                {
                }
                T_return operator ()(const slot_type & _A_slot) const
                {
                    return (reinterpret_cast<typename slot_type::call_type >(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_);
                }
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1)
                {
                    T_accumulator accumulator;
                    if (!impl)
                        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
                    signal_exec exec(impl);
                    temp_slot_list slots(impl->slots_);
                    self_type self(_A_a1);
                    return accumulator(slot_iterator_buf_type(slots.begin(), &self), slot_iterator_buf_type(slots.end(), &self));
                }
                typename type_trait< T_arg1 >::take _A_a1_;
        };
        template<class T_return, class T_arg1 >
        struct signal_emit1< T_return, T_arg1, nil >
        {
                typedef signal_emit1< T_return, T_arg1, nil > self_type;
                typedef T_return result_type;
                typedef slot< T_return, T_arg1 > slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                typedef typename slot_type::call_type call_type;
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1)
                {
                    if (!impl || impl->slots_.empty())
                        return T_return();
                    signal_exec exec(impl);
                    T_return r_ = T_return();
                    {
                        temp_slot_list slots(impl->slots_);
                        iterator_type it = slots.begin();
                        for (;
                            it != slots.end();
                            ++it)
                        if (!it->empty() && !it->blocked())
                            break;
                        if (it == slots.end())
                            return T_return();
                        r_ = (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1);
                        for (++it;
                            it != slots.end();
                            ++it)
                        {
                            if (it->empty() || it->blocked())
                                continue;
                            r_ = (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1);
                        }
                    }
                    return r_;
                }
        };
        template<class T_arg1 >
        struct signal_emit1< void, T_arg1, nil >
        {
                typedef signal_emit1< void, T_arg1, nil > self_type;
                typedef void result_type;
                typedef slot< void, T_arg1 > slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                typedef typename slot_type::call_type call_type;
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1)
                {
                    if (!impl || impl->slots_.empty())
                        return;
                    signal_exec exec(impl);
                    temp_slot_list slots(impl->slots_);
                    for (iterator_type it = slots.begin();
                        it != slots.end();
                        ++it)
                    {
                        if (it->empty() || it->blocked())
                            continue;
                        (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1);
                    }
                }
        };
        template<class T_return, class T_arg1, class T_arg2, class T_accumulator >
        struct signal_emit2
        {
                typedef signal_emit2< T_return, T_arg1, T_arg2, T_accumulator > self_type;
                typedef typename T_accumulator::result_type result_type;
                typedef slot< T_return, T_arg1, T_arg2 > slot_type;
                typedef internal::slot_iterator_buf< self_type > slot_iterator_buf_type;
                typedef signal_impl::const_iterator_type iterator_type;
                signal_emit2(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2)
                    : _A_a1_(_A_a1), _A_a2_(_A_a2) 
                {
                }
                T_return operator ()(const slot_type & _A_slot) const
                {
                    return (reinterpret_cast<typename slot_type::call_type >(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_, _A_a2_);
                }
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2)
                {
                    T_accumulator accumulator;
                    if (!impl)
                        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
                    signal_exec exec(impl);
                    temp_slot_list slots(impl->slots_);
                    self_type self(_A_a1, _A_a2);
                    return accumulator(slot_iterator_buf_type(slots.begin(), &self), slot_iterator_buf_type(slots.end(), &self));
                }
                typename type_trait< T_arg1 >::take _A_a1_;
                typename type_trait< T_arg2 >::take _A_a2_;
        };
        template<class T_return, class T_arg1, class T_arg2 >
        struct signal_emit2< T_return, T_arg1, T_arg2, nil >
        {
                typedef signal_emit2< T_return, T_arg1, T_arg2, nil > self_type;
                typedef T_return result_type;
                typedef slot< T_return, T_arg1, T_arg2 > slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                typedef typename slot_type::call_type call_type;
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2)
                {
                    if (!impl || impl->slots_.empty())
                        return T_return();
                    signal_exec exec(impl);
                    T_return r_ = T_return();
                    {
                        temp_slot_list slots(impl->slots_);
                        iterator_type it = slots.begin();
                        for (;
                            it != slots.end();
                            ++it)
                        if (!it->empty() && !it->blocked())
                            break;
                        if (it == slots.end())
                            return T_return();
                        r_ = (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2);
                        for (++it;
                            it != slots.end();
                            ++it)
                        {
                            if (it->empty() || it->blocked())
                                continue;
                            r_ = (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2);
                        }
                    }
                    return r_;
                }
        };
        template<class T_arg1, class T_arg2 >
        struct signal_emit2< void, T_arg1, T_arg2, nil >
        {
                typedef signal_emit2< void, T_arg1, T_arg2, nil > self_type;
                typedef void result_type;
                typedef slot< void, T_arg1, T_arg2 > slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                typedef typename slot_type::call_type call_type;
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2)
                {
                    if (!impl || impl->slots_.empty())
                        return;
                    signal_exec exec(impl);
                    temp_slot_list slots(impl->slots_);
                    for (iterator_type it = slots.begin();
                        it != slots.end();
                        ++it)
                    {
                        if (it->empty() || it->blocked())
                            continue;
                        (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2);
                    }
                }
        };
        template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator >
        struct signal_emit3
        {
                typedef signal_emit3< T_return, T_arg1, T_arg2, T_arg3, T_accumulator > self_type;
                typedef typename T_accumulator::result_type result_type;
                typedef slot< T_return, T_arg1, T_arg2, T_arg3 > slot_type;
                typedef internal::slot_iterator_buf< self_type > slot_iterator_buf_type;
                typedef signal_impl::const_iterator_type iterator_type;
                signal_emit3(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3)
                    : _A_a1_(_A_a1), _A_a2_(_A_a2), _A_a3_(_A_a3) 
                {
                }
                T_return operator ()(const slot_type & _A_slot) const
                {
                    return (reinterpret_cast<typename slot_type::call_type >(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_, _A_a2_, _A_a3_);
                }
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3)
                {
                    T_accumulator accumulator;
                    if (!impl)
                        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
                    signal_exec exec(impl);
                    temp_slot_list slots(impl->slots_);
                    self_type self(_A_a1, _A_a2, _A_a3);
                    return accumulator(slot_iterator_buf_type(slots.begin(), &self), slot_iterator_buf_type(slots.end(), &self));
                }
                typename type_trait< T_arg1 >::take _A_a1_;
                typename type_trait< T_arg2 >::take _A_a2_;
                typename type_trait< T_arg3 >::take _A_a3_;
        };
        template<class T_return, class T_arg1, class T_arg2, class T_arg3 >
        struct signal_emit3< T_return, T_arg1, T_arg2, T_arg3, nil >
        {
                typedef signal_emit3< T_return, T_arg1, T_arg2, T_arg3, nil > self_type;
                typedef T_return result_type;
                typedef slot< T_return, T_arg1, T_arg2, T_arg3 > slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                typedef typename slot_type::call_type call_type;
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3)
                {
                    if (!impl || impl->slots_.empty())
                        return T_return();
                    signal_exec exec(impl);
                    T_return r_ = T_return();
                    {
                        temp_slot_list slots(impl->slots_);
                        iterator_type it = slots.begin();
                        for (;
                            it != slots.end();
                            ++it)
                        if (!it->empty() && !it->blocked())
                            break;
                        if (it == slots.end())
                            return T_return();
                        r_ = (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2, _A_a3);
                        for (++it;
                            it != slots.end();
                            ++it)
                        {
                            if (it->empty() || it->blocked())
                                continue;
                            r_ = (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2, _A_a3);
                        }
                    }
                    return r_;
                }
        };
        template<class T_arg1, class T_arg2, class T_arg3 >
        struct signal_emit3< void, T_arg1, T_arg2, T_arg3, nil >
        {
                typedef signal_emit3< void, T_arg1, T_arg2, T_arg3, nil > self_type;
                typedef void result_type;
                typedef slot< void, T_arg1, T_arg2, T_arg3 > slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                typedef typename slot_type::call_type call_type;
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3)
                {
                    if (!impl || impl->slots_.empty())
                        return;
                    signal_exec exec(impl);
                    temp_slot_list slots(impl->slots_);
                    for (iterator_type it = slots.begin();
                        it != slots.end();
                        ++it)
                    {
                        if (it->empty() || it->blocked())
                            continue;
                        (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2, _A_a3);
                    }
                }
        };
        template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_accumulator >
        struct signal_emit4
        {
                typedef signal_emit4< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_accumulator > self_type;
                typedef typename T_accumulator::result_type result_type;
                typedef slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4 > slot_type;
                typedef internal::slot_iterator_buf< self_type > slot_iterator_buf_type;
                typedef signal_impl::const_iterator_type iterator_type;
                signal_emit4(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4)
                    : _A_a1_(_A_a1), _A_a2_(_A_a2), _A_a3_(_A_a3), _A_a4_(_A_a4) 
                {
                }
                T_return operator ()(const slot_type & _A_slot) const
                {
                    return (reinterpret_cast<typename slot_type::call_type >(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_, _A_a2_, _A_a3_, _A_a4_);
                }
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4)
                {
                    T_accumulator accumulator;
                    if (!impl)
                        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
                    signal_exec exec(impl);
                    temp_slot_list slots(impl->slots_);
                    self_type self(_A_a1, _A_a2, _A_a3, _A_a4);
                    return accumulator(slot_iterator_buf_type(slots.begin(), &self), slot_iterator_buf_type(slots.end(), &self));
                }
                typename type_trait< T_arg1 >::take _A_a1_;
                typename type_trait< T_arg2 >::take _A_a2_;
                typename type_trait< T_arg3 >::take _A_a3_;
                typename type_trait< T_arg4 >::take _A_a4_;
        };
        template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
        struct signal_emit4< T_return, T_arg1, T_arg2, T_arg3, T_arg4, nil >
        {
                typedef signal_emit4< T_return, T_arg1, T_arg2, T_arg3, T_arg4, nil > self_type;
                typedef T_return result_type;
                typedef slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4 > slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                typedef typename slot_type::call_type call_type;
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4)
                {
                    if (!impl || impl->slots_.empty())
                        return T_return();
                    signal_exec exec(impl);
                    T_return r_ = T_return();
                    {
                        temp_slot_list slots(impl->slots_);
                        iterator_type it = slots.begin();
                        for (;
                            it != slots.end();
                            ++it)
                        if (!it->empty() && !it->blocked())
                            break;
                        if (it == slots.end())
                            return T_return();
                        r_ = (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2, _A_a3, _A_a4);
                        for (++it;
                            it != slots.end();
                            ++it)
                        {
                            if (it->empty() || it->blocked())
                                continue;
                            r_ = (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2, _A_a3, _A_a4);
                        }
                    }
                    return r_;
                }
        };
        template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
        struct signal_emit4< void, T_arg1, T_arg2, T_arg3, T_arg4, nil >
        {
                typedef signal_emit4< void, T_arg1, T_arg2, T_arg3, T_arg4, nil > self_type;
                typedef void result_type;
                typedef slot< void, T_arg1, T_arg2, T_arg3, T_arg4 > slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                typedef typename slot_type::call_type call_type;
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4)
                {
                    if (!impl || impl->slots_.empty())
                        return;
                    signal_exec exec(impl);
                    temp_slot_list slots(impl->slots_);
                    for (iterator_type it = slots.begin();
                        it != slots.end();
                        ++it)
                    {
                        if (it->empty() || it->blocked())
                            continue;
                        (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2, _A_a3, _A_a4);
                    }
                }
        };
        template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_accumulator >
        struct signal_emit5
        {
                typedef signal_emit5< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_accumulator > self_type;
                typedef typename T_accumulator::result_type result_type;
                typedef slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > slot_type;
                typedef internal::slot_iterator_buf< self_type > slot_iterator_buf_type;
                typedef signal_impl::const_iterator_type iterator_type;
                signal_emit5(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5)
                    : _A_a1_(_A_a1), _A_a2_(_A_a2), _A_a3_(_A_a3), _A_a4_(_A_a4), _A_a5_(_A_a5) 
                {
                }
                T_return operator ()(const slot_type & _A_slot) const
                {
                    return (reinterpret_cast<typename slot_type::call_type >(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_, _A_a2_, _A_a3_, _A_a4_, _A_a5_);
                }
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5)
                {
                    T_accumulator accumulator;
                    if (!impl)
                        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
                    signal_exec exec(impl);
                    temp_slot_list slots(impl->slots_);
                    self_type self(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
                    return accumulator(slot_iterator_buf_type(slots.begin(), &self), slot_iterator_buf_type(slots.end(), &self));
                }
                typename type_trait< T_arg1 >::take _A_a1_;
                typename type_trait< T_arg2 >::take _A_a2_;
                typename type_trait< T_arg3 >::take _A_a3_;
                typename type_trait< T_arg4 >::take _A_a4_;
                typename type_trait< T_arg5 >::take _A_a5_;
        };
        template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
        struct signal_emit5< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil >
        {
                typedef signal_emit5< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil > self_type;
                typedef T_return result_type;
                typedef slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                typedef typename slot_type::call_type call_type;
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5)
                {
                    if (!impl || impl->slots_.empty())
                        return T_return();
                    signal_exec exec(impl);
                    T_return r_ = T_return();
                    {
                        temp_slot_list slots(impl->slots_);
                        iterator_type it = slots.begin();
                        for (;
                            it != slots.end();
                            ++it)
                        if (!it->empty() && !it->blocked())
                            break;
                        if (it == slots.end())
                            return T_return();
                        r_ = (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
                        for (++it;
                            it != slots.end();
                            ++it)
                        {
                            if (it->empty() || it->blocked())
                                continue;
                            r_ = (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
                        }
                    }
                    return r_;
                }
        };
        template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
        struct signal_emit5< void, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil >
        {
                typedef signal_emit5< void, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil > self_type;
                typedef void result_type;
                typedef slot< void, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                typedef typename slot_type::call_type call_type;
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5)
                {
                    if (!impl || impl->slots_.empty())
                        return;
                    signal_exec exec(impl);
                    temp_slot_list slots(impl->slots_);
                    for (iterator_type it = slots.begin();
                        it != slots.end();
                        ++it)
                    {
                        if (it->empty() || it->blocked())
                            continue;
                        (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
                    }
                }
        };
        template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_accumulator >
        struct signal_emit6
        {
                typedef signal_emit6< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_accumulator > self_type;
                typedef typename T_accumulator::result_type result_type;
                typedef slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > slot_type;
                typedef internal::slot_iterator_buf< self_type > slot_iterator_buf_type;
                typedef signal_impl::const_iterator_type iterator_type;
                signal_emit6(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6)
                    : _A_a1_(_A_a1), _A_a2_(_A_a2), _A_a3_(_A_a3), _A_a4_(_A_a4), _A_a5_(_A_a5), _A_a6_(_A_a6) 
                {
                }
                T_return operator ()(const slot_type & _A_slot) const
                {
                    return (reinterpret_cast<typename slot_type::call_type >(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_, _A_a2_, _A_a3_, _A_a4_, _A_a5_, _A_a6_);
                }
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6)
                {
                    T_accumulator accumulator;
                    if (!impl)
                        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
                    signal_exec exec(impl);
                    temp_slot_list slots(impl->slots_);
                    self_type self(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
                    return accumulator(slot_iterator_buf_type(slots.begin(), &self), slot_iterator_buf_type(slots.end(), &self));
                }
                typename type_trait< T_arg1 >::take _A_a1_;
                typename type_trait< T_arg2 >::take _A_a2_;
                typename type_trait< T_arg3 >::take _A_a3_;
                typename type_trait< T_arg4 >::take _A_a4_;
                typename type_trait< T_arg5 >::take _A_a5_;
                typename type_trait< T_arg6 >::take _A_a6_;
        };
        template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
        struct signal_emit6< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil >
        {
                typedef signal_emit6< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil > self_type;
                typedef T_return result_type;
                typedef slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                typedef typename slot_type::call_type call_type;
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6)
                {
                    if (!impl || impl->slots_.empty())
                        return T_return();
                    signal_exec exec(impl);
                    T_return r_ = T_return();
                    {
                        temp_slot_list slots(impl->slots_);
                        iterator_type it = slots.begin();
                        for (;
                            it != slots.end();
                            ++it)
                        if (!it->empty() && !it->blocked())
                            break;
                        if (it == slots.end())
                            return T_return();
                        r_ = (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
                        for (++it;
                            it != slots.end();
                            ++it)
                        {
                            if (it->empty() || it->blocked())
                                continue;
                            r_ = (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
                        }
                    }
                    return r_;
                }
        };
        template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
        struct signal_emit6< void, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil >
        {
                typedef signal_emit6< void, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil > self_type;
                typedef void result_type;
                typedef slot< void, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                typedef typename slot_type::call_type call_type;
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6)
                {
                    if (!impl || impl->slots_.empty())
                        return;
                    signal_exec exec(impl);
                    temp_slot_list slots(impl->slots_);
                    for (iterator_type it = slots.begin();
                        it != slots.end();
                        ++it)
                    {
                        if (it->empty() || it->blocked())
                            continue;
                        (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
                    }
                }
        };
        template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_accumulator >
        struct signal_emit7
        {
                typedef signal_emit7< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_accumulator > self_type;
                typedef typename T_accumulator::result_type result_type;
                typedef slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > slot_type;
                typedef internal::slot_iterator_buf< self_type > slot_iterator_buf_type;
                typedef signal_impl::const_iterator_type iterator_type;
                signal_emit7(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7)
                    : _A_a1_(_A_a1), _A_a2_(_A_a2), _A_a3_(_A_a3), _A_a4_(_A_a4), _A_a5_(_A_a5), _A_a6_(_A_a6), _A_a7_(_A_a7) 
                {
                }
                T_return operator ()(const slot_type & _A_slot) const
                {
                    return (reinterpret_cast<typename slot_type::call_type >(_A_slot.rep_->call_))(_A_slot.rep_, _A_a1_, _A_a2_, _A_a3_, _A_a4_, _A_a5_, _A_a6_, _A_a7_);
                }
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7)
                {
                    T_accumulator accumulator;
                    if (!impl)
                        return accumulator(slot_iterator_buf_type(), slot_iterator_buf_type());
                    signal_exec exec(impl);
                    temp_slot_list slots(impl->slots_);
                    self_type self(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
                    return accumulator(slot_iterator_buf_type(slots.begin(), &self), slot_iterator_buf_type(slots.end(), &self));
                }
                typename type_trait< T_arg1 >::take _A_a1_;
                typename type_trait< T_arg2 >::take _A_a2_;
                typename type_trait< T_arg3 >::take _A_a3_;
                typename type_trait< T_arg4 >::take _A_a4_;
                typename type_trait< T_arg5 >::take _A_a5_;
                typename type_trait< T_arg6 >::take _A_a6_;
                typename type_trait< T_arg7 >::take _A_a7_;
        };
        template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
        struct signal_emit7< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, nil >
        {
                typedef signal_emit7< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, nil > self_type;
                typedef T_return result_type;
                typedef slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                typedef typename slot_type::call_type call_type;
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7)
                {
                    if (!impl || impl->slots_.empty())
                        return T_return();
                    signal_exec exec(impl);
                    T_return r_ = T_return();
                    {
                        temp_slot_list slots(impl->slots_);
                        iterator_type it = slots.begin();
                        for (;
                            it != slots.end();
                            ++it)
                        if (!it->empty() && !it->blocked())
                            break;
                        if (it == slots.end())
                            return T_return();
                        r_ = (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
                        for (++it;
                            it != slots.end();
                            ++it)
                        {
                            if (it->empty() || it->blocked())
                                continue;
                            r_ = (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
                        }
                    }
                    return r_;
                }
        };
        template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
        struct signal_emit7< void, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, nil >
        {
                typedef signal_emit7< void, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, nil > self_type;
                typedef void result_type;
                typedef slot< void, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > slot_type;
                typedef signal_impl::const_iterator_type iterator_type;
                typedef typename slot_type::call_type call_type;
                static result_type emit(signal_impl * impl, typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7)
                {
                    if (!impl || impl->slots_.empty())
                        return;
                    signal_exec exec(impl);
                    temp_slot_list slots(impl->slots_);
                    for (iterator_type it = slots.begin();
                        it != slots.end();
                        ++it)
                    {
                        if (it->empty() || it->blocked())
                            continue;
                        (reinterpret_cast<call_type >(it->rep_->call_))(it->rep_, _A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
                    }
                }
        };
    }
    template<class T_return, class T_accumulator = nil >
    class signal0 : public signal_base
    {
        public :
            typedef internal::signal_emit0< T_return, T_accumulator > emitter_type;
            typedef typename emitter_type::result_type result_type;
            typedef slot< T_return > slot_type;
            typedef slot_list< slot_type > slot_list_type;
            typedef typename slot_list_type::iterator iterator;
            typedef typename slot_list_type::const_iterator const_iterator;
            typedef typename slot_list_type::reverse_iterator reverse_iterator;
            typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
            iterator connect(const slot_type & slot_)
            {
                return iterator(signal_base::connect(static_cast<const slot_base & >(slot_)));
            }
            result_type emit() const
            {
                return emitter_type::emit(impl_);
            }
            result_type operator ()() const
            {
                return emit();
            }
            bound_const_mem_functor0< result_type, signal0 > make_slot() const
            {
                return bound_const_mem_functor0< result_type, signal0 >(this, &signal0::emit);
            }
            slot_list_type slots()
            {
                return slot_list_type(impl());
            }
            const slot_list_type slots() const
            {
                return slot_list_type(const_cast<signal0 * >(this)->impl());
            }
            signal0()
            {
            }
            signal0(const signal0 & src)
                : signal_base(src) 
            {
            }
    };
    template<class T_return, class T_arg1, class T_accumulator = nil >
    class signal1 : public signal_base
    {
        public :
            typedef internal::signal_emit1< T_return, T_arg1, T_accumulator > emitter_type;
            typedef typename emitter_type::result_type result_type;
            typedef slot< T_return, T_arg1 > slot_type;
            typedef slot_list< slot_type > slot_list_type;
            typedef typename slot_list_type::iterator iterator;
            typedef typename slot_list_type::const_iterator const_iterator;
            typedef typename slot_list_type::reverse_iterator reverse_iterator;
            typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
            iterator connect(const slot_type & slot_)
            {
                return iterator(signal_base::connect(static_cast<const slot_base & >(slot_)));
            }
            result_type emit(typename type_trait< T_arg1 >::take _A_a1) const
            {
                return emitter_type::emit(impl_, _A_a1);
            }
            result_type operator ()(typename type_trait< T_arg1 >::take _A_a1) const
            {
                return emit(_A_a1);
            }
            bound_const_mem_functor1< result_type, signal1, typename type_trait< T_arg1 >::take > make_slot() const
            {
                return bound_const_mem_functor1< result_type, signal1, typename type_trait< T_arg1 >::take >(this, &signal1::emit);
            }
            slot_list_type slots()
            {
                return slot_list_type(impl());
            }
            const slot_list_type slots() const
            {
                return slot_list_type(const_cast<signal1 * >(this)->impl());
            }
            signal1()
            {
            }
            signal1(const signal1 & src)
                : signal_base(src) 
            {
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_accumulator = nil >
    class signal2 : public signal_base
    {
        public :
            typedef internal::signal_emit2< T_return, T_arg1, T_arg2, T_accumulator > emitter_type;
            typedef typename emitter_type::result_type result_type;
            typedef slot< T_return, T_arg1, T_arg2 > slot_type;
            typedef slot_list< slot_type > slot_list_type;
            typedef typename slot_list_type::iterator iterator;
            typedef typename slot_list_type::const_iterator const_iterator;
            typedef typename slot_list_type::reverse_iterator reverse_iterator;
            typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
            iterator connect(const slot_type & slot_)
            {
                return iterator(signal_base::connect(static_cast<const slot_base & >(slot_)));
            }
            result_type emit(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2) const
            {
                return emitter_type::emit(impl_, _A_a1, _A_a2);
            }
            result_type operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2) const
            {
                return emit(_A_a1, _A_a2);
            }
            bound_const_mem_functor2< result_type, signal2, typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take > make_slot() const
            {
                return bound_const_mem_functor2< result_type, signal2, typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take >(this, &signal2::emit);
            }
            slot_list_type slots()
            {
                return slot_list_type(impl());
            }
            const slot_list_type slots() const
            {
                return slot_list_type(const_cast<signal2 * >(this)->impl());
            }
            signal2()
            {
            }
            signal2(const signal2 & src)
                : signal_base(src) 
            {
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil >
    class signal3 : public signal_base
    {
        public :
            typedef internal::signal_emit3< T_return, T_arg1, T_arg2, T_arg3, T_accumulator > emitter_type;
            typedef typename emitter_type::result_type result_type;
            typedef slot< T_return, T_arg1, T_arg2, T_arg3 > slot_type;
            typedef slot_list< slot_type > slot_list_type;
            typedef typename slot_list_type::iterator iterator;
            typedef typename slot_list_type::const_iterator const_iterator;
            typedef typename slot_list_type::reverse_iterator reverse_iterator;
            typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
            iterator connect(const slot_type & slot_)
            {
                return iterator(signal_base::connect(static_cast<const slot_base & >(slot_)));
            }
            result_type emit(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3) const
            {
                return emitter_type::emit(impl_, _A_a1, _A_a2, _A_a3);
            }
            result_type operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3) const
            {
                return emit(_A_a1, _A_a2, _A_a3);
            }
            bound_const_mem_functor3< result_type, signal3, typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take, typename type_trait< T_arg3 >::take > make_slot() const
            {
                return bound_const_mem_functor3< result_type, signal3, typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take, typename type_trait< T_arg3 >::take >(this, &signal3::emit);
            }
            slot_list_type slots()
            {
                return slot_list_type(impl());
            }
            const slot_list_type slots() const
            {
                return slot_list_type(const_cast<signal3 * >(this)->impl());
            }
            signal3()
            {
            }
            signal3(const signal3 & src)
                : signal_base(src) 
            {
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_accumulator = nil >
    class signal4 : public signal_base
    {
        public :
            typedef internal::signal_emit4< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_accumulator > emitter_type;
            typedef typename emitter_type::result_type result_type;
            typedef slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4 > slot_type;
            typedef slot_list< slot_type > slot_list_type;
            typedef typename slot_list_type::iterator iterator;
            typedef typename slot_list_type::const_iterator const_iterator;
            typedef typename slot_list_type::reverse_iterator reverse_iterator;
            typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
            iterator connect(const slot_type & slot_)
            {
                return iterator(signal_base::connect(static_cast<const slot_base & >(slot_)));
            }
            result_type emit(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4) const
            {
                return emitter_type::emit(impl_, _A_a1, _A_a2, _A_a3, _A_a4);
            }
            result_type operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4) const
            {
                return emit(_A_a1, _A_a2, _A_a3, _A_a4);
            }
            bound_const_mem_functor4< result_type, signal4, typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take, typename type_trait< T_arg3 >::take, typename type_trait< T_arg4 >::take > make_slot() const
            {
                return bound_const_mem_functor4< result_type, signal4, typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take, typename type_trait< T_arg3 >::take, typename type_trait< T_arg4 >::take >(this, &signal4::emit);
            }
            slot_list_type slots()
            {
                return slot_list_type(impl());
            }
            const slot_list_type slots() const
            {
                return slot_list_type(const_cast<signal4 * >(this)->impl());
            }
            signal4()
            {
            }
            signal4(const signal4 & src)
                : signal_base(src) 
            {
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_accumulator = nil >
    class signal5 : public signal_base
    {
        public :
            typedef internal::signal_emit5< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_accumulator > emitter_type;
            typedef typename emitter_type::result_type result_type;
            typedef slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > slot_type;
            typedef slot_list< slot_type > slot_list_type;
            typedef typename slot_list_type::iterator iterator;
            typedef typename slot_list_type::const_iterator const_iterator;
            typedef typename slot_list_type::reverse_iterator reverse_iterator;
            typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
            iterator connect(const slot_type & slot_)
            {
                return iterator(signal_base::connect(static_cast<const slot_base & >(slot_)));
            }
            result_type emit(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5) const
            {
                return emitter_type::emit(impl_, _A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
            result_type operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5) const
            {
                return emit(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
            bound_const_mem_functor5< result_type, signal5, typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take, typename type_trait< T_arg3 >::take, typename type_trait< T_arg4 >::take, typename type_trait< T_arg5 >::take > make_slot() const
            {
                return bound_const_mem_functor5< result_type, signal5, typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take, typename type_trait< T_arg3 >::take, typename type_trait< T_arg4 >::take, typename type_trait< T_arg5 >::take >(this, &signal5::emit);
            }
            slot_list_type slots()
            {
                return slot_list_type(impl());
            }
            const slot_list_type slots() const
            {
                return slot_list_type(const_cast<signal5 * >(this)->impl());
            }
            signal5()
            {
            }
            signal5(const signal5 & src)
                : signal_base(src) 
            {
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_accumulator = nil >
    class signal6 : public signal_base
    {
        public :
            typedef internal::signal_emit6< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_accumulator > emitter_type;
            typedef typename emitter_type::result_type result_type;
            typedef slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > slot_type;
            typedef slot_list< slot_type > slot_list_type;
            typedef typename slot_list_type::iterator iterator;
            typedef typename slot_list_type::const_iterator const_iterator;
            typedef typename slot_list_type::reverse_iterator reverse_iterator;
            typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
            iterator connect(const slot_type & slot_)
            {
                return iterator(signal_base::connect(static_cast<const slot_base & >(slot_)));
            }
            result_type emit(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6) const
            {
                return emitter_type::emit(impl_, _A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
            result_type operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6) const
            {
                return emit(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
            bound_const_mem_functor6< result_type, signal6, typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take, typename type_trait< T_arg3 >::take, typename type_trait< T_arg4 >::take, typename type_trait< T_arg5 >::take, typename type_trait< T_arg6 >::take > make_slot() const
            {
                return bound_const_mem_functor6< result_type, signal6, typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take, typename type_trait< T_arg3 >::take, typename type_trait< T_arg4 >::take, typename type_trait< T_arg5 >::take, typename type_trait< T_arg6 >::take >(this, &signal6::emit);
            }
            slot_list_type slots()
            {
                return slot_list_type(impl());
            }
            const slot_list_type slots() const
            {
                return slot_list_type(const_cast<signal6 * >(this)->impl());
            }
            signal6()
            {
            }
            signal6(const signal6 & src)
                : signal_base(src) 
            {
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_accumulator = nil >
    class signal7 : public signal_base
    {
        public :
            typedef internal::signal_emit7< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_accumulator > emitter_type;
            typedef typename emitter_type::result_type result_type;
            typedef slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > slot_type;
            typedef slot_list< slot_type > slot_list_type;
            typedef typename slot_list_type::iterator iterator;
            typedef typename slot_list_type::const_iterator const_iterator;
            typedef typename slot_list_type::reverse_iterator reverse_iterator;
            typedef typename slot_list_type::const_reverse_iterator const_reverse_iterator;
            iterator connect(const slot_type & slot_)
            {
                return iterator(signal_base::connect(static_cast<const slot_base & >(slot_)));
            }
            result_type emit(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7) const
            {
                return emitter_type::emit(impl_, _A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
            result_type operator ()(typename type_trait< T_arg1 >::take _A_a1, typename type_trait< T_arg2 >::take _A_a2, typename type_trait< T_arg3 >::take _A_a3, typename type_trait< T_arg4 >::take _A_a4, typename type_trait< T_arg5 >::take _A_a5, typename type_trait< T_arg6 >::take _A_a6, typename type_trait< T_arg7 >::take _A_a7) const
            {
                return emit(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
            bound_const_mem_functor7< result_type, signal7, typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take, typename type_trait< T_arg3 >::take, typename type_trait< T_arg4 >::take, typename type_trait< T_arg5 >::take, typename type_trait< T_arg6 >::take, typename type_trait< T_arg7 >::take > make_slot() const
            {
                return bound_const_mem_functor7< result_type, signal7, typename type_trait< T_arg1 >::take, typename type_trait< T_arg2 >::take, typename type_trait< T_arg3 >::take, typename type_trait< T_arg4 >::take, typename type_trait< T_arg5 >::take, typename type_trait< T_arg6 >::take, typename type_trait< T_arg7 >::take >(this, &signal7::emit);
            }
            slot_list_type slots()
            {
                return slot_list_type(impl());
            }
            const slot_list_type slots() const
            {
                return slot_list_type(const_cast<signal7 * >(this)->impl());
            }
            signal7()
            {
            }
            signal7(const signal7 & src)
                : signal_base(src) 
            {
            }
    };
    template<class T_return, class T_arg1 = nil, class T_arg2 = nil, class T_arg3 = nil, class T_arg4 = nil, class T_arg5 = nil, class T_arg6 = nil, class T_arg7 = nil >
    class signal : public signal7< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, nil >
    {
        public :
            template<class T_accumulator >
            class accumulated : public signal7< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_accumulator >
            {
                public :
                    accumulated()
                    {
                    }
                    accumulated(const accumulated & src)
                        : signal7< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_accumulator >(src) 
                    {
                    }
            };
            signal()
            {
            }
            signal(const signal & src)
                : signal7< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, nil >(src) 
            {
            }
    };
    template<class T_return >
    class signal< T_return, nil, nil, nil, nil, nil, nil, nil > : public signal0< T_return, nil >
    {
        public :
            template<class T_accumulator >
            class accumulated : public signal0< T_return, T_accumulator >
            {
                public :
                    accumulated()
                    {
                    }
                    accumulated(const accumulated & src)
                        : signal0< T_return, T_accumulator >(src) 
                    {
                    }
            };
            signal()
            {
            }
            signal(const signal & src)
                : signal0< T_return, nil >(src) 
            {
            }
    };
    template<class T_return, class T_arg1 >
    class signal< T_return, T_arg1, nil, nil, nil, nil, nil, nil > : public signal1< T_return, T_arg1, nil >
    {
        public :
            template<class T_accumulator >
            class accumulated : public signal1< T_return, T_arg1, T_accumulator >
            {
                public :
                    accumulated()
                    {
                    }
                    accumulated(const accumulated & src)
                        : signal1< T_return, T_arg1, T_accumulator >(src) 
                    {
                    }
            };
            signal()
            {
            }
            signal(const signal & src)
                : signal1< T_return, T_arg1, nil >(src) 
            {
            }
    };
    template<class T_return, class T_arg1, class T_arg2 >
    class signal< T_return, T_arg1, T_arg2, nil, nil, nil, nil, nil > : public signal2< T_return, T_arg1, T_arg2, nil >
    {
        public :
            template<class T_accumulator >
            class accumulated : public signal2< T_return, T_arg1, T_arg2, T_accumulator >
            {
                public :
                    accumulated()
                    {
                    }
                    accumulated(const accumulated & src)
                        : signal2< T_return, T_arg1, T_arg2, T_accumulator >(src) 
                    {
                    }
            };
            signal()
            {
            }
            signal(const signal & src)
                : signal2< T_return, T_arg1, T_arg2, nil >(src) 
            {
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3 >
    class signal< T_return, T_arg1, T_arg2, T_arg3, nil, nil, nil, nil > : public signal3< T_return, T_arg1, T_arg2, T_arg3, nil >
    {
        public :
            template<class T_accumulator >
            class accumulated : public signal3< T_return, T_arg1, T_arg2, T_arg3, T_accumulator >
            {
                public :
                    accumulated()
                    {
                    }
                    accumulated(const accumulated & src)
                        : signal3< T_return, T_arg1, T_arg2, T_arg3, T_accumulator >(src) 
                    {
                    }
            };
            signal()
            {
            }
            signal(const signal & src)
                : signal3< T_return, T_arg1, T_arg2, T_arg3, nil >(src) 
            {
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    class signal< T_return, T_arg1, T_arg2, T_arg3, T_arg4, nil, nil, nil > : public signal4< T_return, T_arg1, T_arg2, T_arg3, T_arg4, nil >
    {
        public :
            template<class T_accumulator >
            class accumulated : public signal4< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_accumulator >
            {
                public :
                    accumulated()
                    {
                    }
                    accumulated(const accumulated & src)
                        : signal4< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_accumulator >(src) 
                    {
                    }
            };
            signal()
            {
            }
            signal(const signal & src)
                : signal4< T_return, T_arg1, T_arg2, T_arg3, T_arg4, nil >(src) 
            {
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    class signal< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil, nil > : public signal5< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil >
    {
        public :
            template<class T_accumulator >
            class accumulated : public signal5< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_accumulator >
            {
                public :
                    accumulated()
                    {
                    }
                    accumulated(const accumulated & src)
                        : signal5< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_accumulator >(src) 
                    {
                    }
            };
            signal()
            {
            }
            signal(const signal & src)
                : signal5< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil >(src) 
            {
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    class signal< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil > : public signal6< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil >
    {
        public :
            template<class T_accumulator >
            class accumulated : public signal6< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_accumulator >
            {
                public :
                    accumulated()
                    {
                    }
                    accumulated(const accumulated & src)
                        : signal6< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_accumulator >(src) 
                    {
                    }
            };
            signal()
            {
            }
            signal(const signal & src)
                : signal6< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil >(src) 
            {
            }
    };
}
namespace SigC {
    template<class T_return, class T_accumulator = ::sigc::nil >
    class Signal0 : public ::sigc::signal0< T_return, T_accumulator >
    {
        public :
            typedef ::sigc::signal0< T_return, T_accumulator > parent_type;
            typedef typename parent_type::result_type result_type;
            typedef typename parent_type::slot_type slot_type;
            Signal0()
            {
            }
            Signal0(const Signal0 & src)
                : ::sigc::signal0< T_return, T_accumulator >(src) 
            {
            }
            slot_type slot() const
            {
                return ::sigc::bound_const_mem_functor0< result_type, parent_type >(this, &parent_type::emit);
            }
    };
    template<class T_return, class T_arg1, class T_accumulator = ::sigc::nil >
    class Signal1 : public ::sigc::signal1< T_return, T_arg1, T_accumulator >
    {
        public :
            typedef ::sigc::signal1< T_return, T_arg1, T_accumulator > parent_type;
            typedef typename parent_type::result_type result_type;
            typedef typename parent_type::slot_type slot_type;
            Signal1()
            {
            }
            Signal1(const Signal1 & src)
                : ::sigc::signal1< T_return, T_arg1, T_accumulator >(src) 
            {
            }
            slot_type slot() const
            {
                return ::sigc::bound_const_mem_functor1< result_type, parent_type, typename ::sigc::type_trait< T_arg1 >::take >(this, &parent_type::emit);
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_accumulator = ::sigc::nil >
    class Signal2 : public ::sigc::signal2< T_return, T_arg1, T_arg2, T_accumulator >
    {
        public :
            typedef ::sigc::signal2< T_return, T_arg1, T_arg2, T_accumulator > parent_type;
            typedef typename parent_type::result_type result_type;
            typedef typename parent_type::slot_type slot_type;
            Signal2()
            {
            }
            Signal2(const Signal2 & src)
                : ::sigc::signal2< T_return, T_arg1, T_arg2, T_accumulator >(src) 
            {
            }
            slot_type slot() const
            {
                return ::sigc::bound_const_mem_functor2< result_type, parent_type, typename ::sigc::type_trait< T_arg1 >::take, typename ::sigc::type_trait< T_arg2 >::take >(this, &parent_type::emit);
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = ::sigc::nil >
    class Signal3 : public ::sigc::signal3< T_return, T_arg1, T_arg2, T_arg3, T_accumulator >
    {
        public :
            typedef ::sigc::signal3< T_return, T_arg1, T_arg2, T_arg3, T_accumulator > parent_type;
            typedef typename parent_type::result_type result_type;
            typedef typename parent_type::slot_type slot_type;
            Signal3()
            {
            }
            Signal3(const Signal3 & src)
                : ::sigc::signal3< T_return, T_arg1, T_arg2, T_arg3, T_accumulator >(src) 
            {
            }
            slot_type slot() const
            {
                return ::sigc::bound_const_mem_functor3< result_type, parent_type, typename ::sigc::type_trait< T_arg1 >::take, typename ::sigc::type_trait< T_arg2 >::take, typename ::sigc::type_trait< T_arg3 >::take >(this, &parent_type::emit);
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_accumulator = ::sigc::nil >
    class Signal4 : public ::sigc::signal4< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_accumulator >
    {
        public :
            typedef ::sigc::signal4< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_accumulator > parent_type;
            typedef typename parent_type::result_type result_type;
            typedef typename parent_type::slot_type slot_type;
            Signal4()
            {
            }
            Signal4(const Signal4 & src)
                : ::sigc::signal4< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_accumulator >(src) 
            {
            }
            slot_type slot() const
            {
                return ::sigc::bound_const_mem_functor4< result_type, parent_type, typename ::sigc::type_trait< T_arg1 >::take, typename ::sigc::type_trait< T_arg2 >::take, typename ::sigc::type_trait< T_arg3 >::take, typename ::sigc::type_trait< T_arg4 >::take >(this, &parent_type::emit);
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_accumulator = ::sigc::nil >
    class Signal5 : public ::sigc::signal5< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_accumulator >
    {
        public :
            typedef ::sigc::signal5< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_accumulator > parent_type;
            typedef typename parent_type::result_type result_type;
            typedef typename parent_type::slot_type slot_type;
            Signal5()
            {
            }
            Signal5(const Signal5 & src)
                : ::sigc::signal5< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_accumulator >(src) 
            {
            }
            slot_type slot() const
            {
                return ::sigc::bound_const_mem_functor5< result_type, parent_type, typename ::sigc::type_trait< T_arg1 >::take, typename ::sigc::type_trait< T_arg2 >::take, typename ::sigc::type_trait< T_arg3 >::take, typename ::sigc::type_trait< T_arg4 >::take, typename ::sigc::type_trait< T_arg5 >::take >(this, &parent_type::emit);
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_accumulator = ::sigc::nil >
    class Signal6 : public ::sigc::signal6< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_accumulator >
    {
        public :
            typedef ::sigc::signal6< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_accumulator > parent_type;
            typedef typename parent_type::result_type result_type;
            typedef typename parent_type::slot_type slot_type;
            Signal6()
            {
            }
            Signal6(const Signal6 & src)
                : ::sigc::signal6< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_accumulator >(src) 
            {
            }
            slot_type slot() const
            {
                return ::sigc::bound_const_mem_functor6< result_type, parent_type, typename ::sigc::type_trait< T_arg1 >::take, typename ::sigc::type_trait< T_arg2 >::take, typename ::sigc::type_trait< T_arg3 >::take, typename ::sigc::type_trait< T_arg4 >::take, typename ::sigc::type_trait< T_arg5 >::take, typename ::sigc::type_trait< T_arg6 >::take >(this, &parent_type::emit);
            }
    };
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_accumulator = ::sigc::nil >
    class Signal7 : public ::sigc::signal7< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_accumulator >
    {
        public :
            typedef ::sigc::signal7< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_accumulator > parent_type;
            typedef typename parent_type::result_type result_type;
            typedef typename parent_type::slot_type slot_type;
            Signal7()
            {
            }
            Signal7(const Signal7 & src)
                : ::sigc::signal7< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_accumulator >(src) 
            {
            }
            slot_type slot() const
            {
                return ::sigc::bound_const_mem_functor7< result_type, parent_type, typename ::sigc::type_trait< T_arg1 >::take, typename ::sigc::type_trait< T_arg2 >::take, typename ::sigc::type_trait< T_arg3 >::take, typename ::sigc::type_trait< T_arg4 >::take, typename ::sigc::type_trait< T_arg5 >::take, typename ::sigc::type_trait< T_arg6 >::take, typename ::sigc::type_trait< T_arg7 >::take >(this, &parent_type::emit);
            }
    };
}
namespace sigc {
    struct connection
    {
            connection();
            connection(const connection & c);
            template<typename T_slot >
            connection(const slot_iterator< T_slot > & it)
                : slot_(&(*it)) 
            {
                if (slot_)
                    slot_->add_destroy_notify_callback(this, &notify);
            }
            explicit connection(slot_base & sl);
            connection & operator =(const connection & c);
            template<typename T_slot >
            connection & operator =(const slot_iterator< T_slot > & it)
            {
                set_slot(&(*it));
                return *this;
            }
            ~connection();
            bool empty() const;
            bool connected() const;
            bool blocked() const;
            bool block(bool should_block = true);
            bool unblock();
            void disconnect();
            operator bool();
            static void * notify(void * data);
        private :
            void set_slot(slot_base * sl);
            slot_base * slot_;
    };
}
namespace SigC {
    typedef ::sigc::connection Connection;
}
namespace sigc {
    template<class T_type >
    struct reference_wrapper
    {
            explicit reference_wrapper(T_type & v)
                : value_(v) 
            {
            }
            operator T_type &() const
            {
                return value_;
            }
            T_type & value_;
    };
    template<class T_type >
    struct const_reference_wrapper
    {
            explicit const_reference_wrapper(const T_type & v)
                : value_(v) 
            {
            }
            operator const T_type &() const
            {
                return value_;
            }
            const T_type & value_;
    };
    template<class T_type >
    reference_wrapper< T_type > ref(T_type & v)
    {
        return reference_wrapper< T_type >(v);
    }
    template<class T_type >
    const_reference_wrapper< T_type > ref(const T_type & v)
    {
        return const_reference_wrapper< T_type >(v);
    }
    template<class T_type >
    struct unwrap_reference
    {
            typedef T_type type;
    };
    template<class T_type >
    struct unwrap_reference< reference_wrapper< T_type > >
    {
            typedef T_type & type;
    };
    template<class T_type >
    struct unwrap_reference< const_reference_wrapper< T_type > >
    {
            typedef const T_type & type;
    };
    template<class T_type >
    T_type & unwrap(const reference_wrapper< T_type > & v)
    {
        return v;
    }
    template<class T_type >
    const T_type & unwrap(const const_reference_wrapper< T_type > & v)
    {
        return v;
    }
}
namespace sigc {
    template<class T_type >
    class bound_argument
    {
        public :
            bound_argument(const T_type & _A_argument)
                : visited_(_A_argument) 
            {
            }
            inline const T_type & visit() const
            {
                return visited_;
            }
            inline T_type & invoke()
            {
                return visited_;
            }
        private :
            T_type visited_;
    };
    template<class T_wrapped >
    class bound_argument< reference_wrapper< T_wrapped > >
    {
        public :
            bound_argument(const reference_wrapper< T_wrapped > & _A_argument)
                : visited_(unwrap(_A_argument)) 
            {
            }
            inline const limit_reference< T_wrapped > & visit() const
            {
                return visited_;
            }
            inline T_wrapped & invoke()
            {
                return visited_.invoke();
            }
        private :
            limit_reference< T_wrapped > visited_;
    };
    template<class T_wrapped >
    class bound_argument< const_reference_wrapper< T_wrapped > >
    {
        public :
            bound_argument(const const_reference_wrapper< T_wrapped > & _A_argument)
                : visited_(unwrap(_A_argument)) 
            {
            }
            inline const const_limit_reference< T_wrapped > & visit() const
            {
                return visited_;
            }
            inline const T_wrapped & invoke()
            {
                return visited_.invoke();
            }
        private :
            const_limit_reference< T_wrapped > visited_;
    };
    template<class T_action, class T_type >
    void visit_each(const T_action & _A_action, const bound_argument< T_type > & _A_argument)
    {
        visit_each(_A_action, _A_argument.visit());
    }
}
namespace sigc {
    namespace internal {
        template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
        struct count_void
        {
                static const int value = 0;
        };
        template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
        struct count_void< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, void >
        {
                static const int value = 1;
        };
        template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
        struct count_void< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, void, void >
        {
                static const int value = 2;
        };
        template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
        struct count_void< T_arg1, T_arg2, T_arg3, T_arg4, void, void, void >
        {
                static const int value = 3;
        };
        template<class T_arg1, class T_arg2, class T_arg3 >
        struct count_void< T_arg1, T_arg2, T_arg3, void, void, void, void >
        {
                static const int value = 4;
        };
        template<class T_arg1, class T_arg2 >
        struct count_void< T_arg1, T_arg2, void, void, void, void, void >
        {
                static const int value = 5;
        };
        template<class T_arg1 >
        struct count_void< T_arg1, void, void, void, void, void, void >
        {
                static const int value = 6;
        };
        template<>
        struct count_void< void, void, void, void, void, void, void >
        {
                static const int value = 7;
        };
    }
    template<int I_location, class T_functor, class T_type1 = nil, class T_type2 = nil, class T_type3 = nil, class T_type4 = nil, class T_type5 = nil, class T_type6 = nil, class T_type7 = nil >
    struct bind_functor;
    template<class T_functor, class T_bound >
    struct bind_functor< 0, T_functor, T_bound, nil, nil, nil, nil, nil, nil > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            result_type operator ()()
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_bound >::type >::pass >(bound_.invoke());
            }
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_arg1)
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg1 >::pass >(bound_.invoke(), _A_arg1);
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2)
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(bound_.invoke(), _A_arg1, _A_arg2);
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3)
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(bound_.invoke(), _A_arg1, _A_arg2, _A_arg3);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4)
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(bound_.invoke(), _A_arg1, _A_arg2, _A_arg3, _A_arg4);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5)
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(bound_.invoke(), _A_arg1, _A_arg2, _A_arg3, _A_arg4, _A_arg5);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5, T_arg6 _A_arg6)
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(bound_.invoke(), _A_arg1, _A_arg2, _A_arg3, _A_arg4, _A_arg5, _A_arg6);
            }
            bind_functor(typename type_trait< T_functor >::take _A_func, typename type_trait< T_bound >::take _A_bound)
                : adapts< T_functor >(_A_func), bound_(_A_bound) 
            {
            }
            bound_argument< T_bound > bound_;
    };
    template<class T_functor, class T_bound >
    struct bind_functor< 1, T_functor, T_bound, nil, nil, nil, nil, nil, nil > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            result_type operator ()()
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_bound >::type >::pass >(bound_.invoke());
            }
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_arg1)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass >(_A_arg1, bound_.invoke());
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg2 >::pass >(_A_arg1, bound_.invoke(), _A_arg2);
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_arg1, bound_.invoke(), _A_arg2, _A_arg3);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_arg1, bound_.invoke(), _A_arg2, _A_arg3, _A_arg4);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_arg1, bound_.invoke(), _A_arg2, _A_arg3, _A_arg4, _A_arg5);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5, T_arg6 _A_arg6)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_arg1, bound_.invoke(), _A_arg2, _A_arg3, _A_arg4, _A_arg5, _A_arg6);
            }
            bind_functor(typename type_trait< T_functor >::take _A_func, typename type_trait< T_bound >::take _A_bound)
                : adapts< T_functor >(_A_func), bound_(_A_bound) 
            {
            }
            bound_argument< T_bound > bound_;
    };
    template<class T_functor, class T_bound >
    struct bind_functor< 2, T_functor, T_bound, nil, nil, nil, nil, nil, nil > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            result_type operator ()()
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_bound >::type >::pass >(bound_.invoke());
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass >(_A_arg1, _A_arg2, bound_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg3 >::pass >(_A_arg1, _A_arg2, bound_.invoke(), _A_arg3);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_arg1, _A_arg2, bound_.invoke(), _A_arg3, _A_arg4);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_arg1, _A_arg2, bound_.invoke(), _A_arg3, _A_arg4, _A_arg5);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5, T_arg6 _A_arg6)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_arg1, _A_arg2, bound_.invoke(), _A_arg3, _A_arg4, _A_arg5, _A_arg6);
            }
            bind_functor(typename type_trait< T_functor >::take _A_func, typename type_trait< T_bound >::take _A_bound)
                : adapts< T_functor >(_A_func), bound_(_A_bound) 
            {
            }
            bound_argument< T_bound > bound_;
    };
    template<class T_functor, class T_bound >
    struct bind_functor< 3, T_functor, T_bound, nil, nil, nil, nil, nil, nil > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            result_type operator ()()
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_bound >::type >::pass >(bound_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass >(_A_arg1, _A_arg2, _A_arg3, bound_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg4 >::pass >(_A_arg1, _A_arg2, _A_arg3, bound_.invoke(), _A_arg4);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_arg1, _A_arg2, _A_arg3, bound_.invoke(), _A_arg4, _A_arg5);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5, T_arg6 _A_arg6)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_arg1, _A_arg2, _A_arg3, bound_.invoke(), _A_arg4, _A_arg5, _A_arg6);
            }
            bind_functor(typename type_trait< T_functor >::take _A_func, typename type_trait< T_bound >::take _A_bound)
                : adapts< T_functor >(_A_func), bound_(_A_bound) 
            {
            }
            bound_argument< T_bound > bound_;
    };
    template<class T_functor, class T_bound >
    struct bind_functor< 4, T_functor, T_bound, nil, nil, nil, nil, nil, nil > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            result_type operator ()()
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_bound >::type >::pass >(bound_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass >(_A_arg1, _A_arg2, _A_arg3, _A_arg4, bound_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg5 >::pass >(_A_arg1, _A_arg2, _A_arg3, _A_arg4, bound_.invoke(), _A_arg5);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5, T_arg6 _A_arg6)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_arg1, _A_arg2, _A_arg3, _A_arg4, bound_.invoke(), _A_arg5, _A_arg6);
            }
            bind_functor(typename type_trait< T_functor >::take _A_func, typename type_trait< T_bound >::take _A_bound)
                : adapts< T_functor >(_A_func), bound_(_A_bound) 
            {
            }
            bound_argument< T_bound > bound_;
    };
    template<class T_functor, class T_bound >
    struct bind_functor< 5, T_functor, T_bound, nil, nil, nil, nil, nil, nil > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg6 >::pass >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            result_type operator ()()
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_bound >::type >::pass >(bound_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass >(_A_arg1, _A_arg2, _A_arg3, _A_arg4, _A_arg5, bound_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5, T_arg6 _A_arg6)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass, typename type_trait< T_arg6 >::pass >(_A_arg1, _A_arg2, _A_arg3, _A_arg4, _A_arg5, bound_.invoke(), _A_arg6);
            }
            bind_functor(typename type_trait< T_functor >::take _A_func, typename type_trait< T_bound >::take _A_bound)
                : adapts< T_functor >(_A_func), bound_(_A_bound) 
            {
            }
            bound_argument< T_bound > bound_;
    };
    template<class T_functor, class T_bound >
    struct bind_functor< 6, T_functor, T_bound, nil, nil, nil, nil, nil, nil > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            result_type operator ()()
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_bound >::type >::pass >(bound_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5, T_arg6 _A_arg6)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< typename unwrap_reference< T_bound >::type >::pass >(_A_arg1, _A_arg2, _A_arg3, _A_arg4, _A_arg5, _A_arg6, bound_.invoke());
            }
            bind_functor(typename type_trait< T_functor >::take _A_func, typename type_trait< T_bound >::take _A_bound)
                : adapts< T_functor >(_A_func), bound_(_A_bound) 
            {
            }
            bound_argument< T_bound > bound_;
    };
    template<class T_action, int T_loc, class T_functor, class T_bound >
    void visit_each(const T_action & _A_action, const bind_functor< T_loc, T_functor, T_bound > & _A_target)
    {
        visit_each(_A_action, _A_target.functor_);
        visit_each(_A_action, _A_target.bound_);
    }
    template<class T_functor, class T_type1 >
    struct bind_functor< -1, T_functor, T_type1, nil, nil, nil, nil, nil, nil > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<int count, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass >::type type;
            };
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal< 2, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass >::type type;
            };
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal< 3, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass >::type type;
            };
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal< 4, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass >::type type;
            };
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal< 5, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass >::type type;
            };
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal< 6, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass >::type type;
            };
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename deduce_result_type_internal< internal::count_void< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::value, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            result_type operator ()()
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_type1 >::type >::pass >(bound1_.invoke());
            }
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_arg1)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass >(_A_arg1, bound1_.invoke());
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass >(_A_arg1, _A_arg2, bound1_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass >(_A_arg1, _A_arg2, _A_arg3, bound1_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass >(_A_arg1, _A_arg2, _A_arg3, _A_arg4, bound1_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass >(_A_arg1, _A_arg2, _A_arg3, _A_arg4, _A_arg5, bound1_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5, T_arg6 _A_arg6)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass >(_A_arg1, _A_arg2, _A_arg3, _A_arg4, _A_arg5, _A_arg6, bound1_.invoke());
            }
            bind_functor(typename type_trait< T_functor >::take _A_func, typename type_trait< T_type1 >::take _A_bound1)
                : adapts< T_functor >(_A_func), bound1_(_A_bound1) 
            {
            }
            bound_argument< T_type1 > bound1_;
    };
    template<class T_action, class T_functor, class T_type1 >
    void visit_each(const T_action & _A_action, const bind_functor< -1, T_functor, T_type1 > & _A_target)
    {
        visit_each(_A_action, _A_target.functor_);
        visit_each(_A_action, _A_target.bound1_);
    }
    template<class T_functor, class T_type1, class T_type2 >
    struct bind_functor< -1, T_functor, T_type1, T_type2, nil, nil, nil, nil, nil > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<int count, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass >::type type;
            };
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal< 3, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass >::type type;
            };
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal< 4, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass >::type type;
            };
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal< 5, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass >::type type;
            };
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal< 6, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass >::type type;
            };
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename deduce_result_type_internal< internal::count_void< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::value, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            result_type operator ()()
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass >(bound1_.invoke(), bound2_.invoke());
            }
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_arg1)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass >(_A_arg1, bound1_.invoke(), bound2_.invoke());
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass >(_A_arg1, _A_arg2, bound1_.invoke(), bound2_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass >(_A_arg1, _A_arg2, _A_arg3, bound1_.invoke(), bound2_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass >(_A_arg1, _A_arg2, _A_arg3, _A_arg4, bound1_.invoke(), bound2_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4, T_arg5 _A_arg5)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass >(_A_arg1, _A_arg2, _A_arg3, _A_arg4, _A_arg5, bound1_.invoke(), bound2_.invoke());
            }
            bind_functor(typename type_trait< T_functor >::take _A_func, typename type_trait< T_type1 >::take _A_bound1, typename type_trait< T_type2 >::take _A_bound2)
                : adapts< T_functor >(_A_func), bound1_(_A_bound1), bound2_(_A_bound2) 
            {
            }
            bound_argument< T_type1 > bound1_;
            bound_argument< T_type2 > bound2_;
    };
    template<class T_action, class T_functor, class T_type1, class T_type2 >
    void visit_each(const T_action & _A_action, const bind_functor< -1, T_functor, T_type1, T_type2 > & _A_target)
    {
        visit_each(_A_action, _A_target.functor_);
        visit_each(_A_action, _A_target.bound1_);
        visit_each(_A_action, _A_target.bound2_);
    }
    template<class T_functor, class T_type1, class T_type2, class T_type3 >
    struct bind_functor< -1, T_functor, T_type1, T_type2, T_type3, nil, nil, nil, nil > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<int count, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass >::type type;
            };
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal< 4, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass >::type type;
            };
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal< 5, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass >::type type;
            };
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal< 6, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass >::type type;
            };
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename deduce_result_type_internal< internal::count_void< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::value, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            result_type operator ()()
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass >(bound1_.invoke(), bound2_.invoke(), bound3_.invoke());
            }
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_arg1)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass >(_A_arg1, bound1_.invoke(), bound2_.invoke(), bound3_.invoke());
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass >(_A_arg1, _A_arg2, bound1_.invoke(), bound2_.invoke(), bound3_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass >(_A_arg1, _A_arg2, _A_arg3, bound1_.invoke(), bound2_.invoke(), bound3_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3, T_arg4 _A_arg4)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass >(_A_arg1, _A_arg2, _A_arg3, _A_arg4, bound1_.invoke(), bound2_.invoke(), bound3_.invoke());
            }
            bind_functor(typename type_trait< T_functor >::take _A_func, typename type_trait< T_type1 >::take _A_bound1, typename type_trait< T_type2 >::take _A_bound2, typename type_trait< T_type3 >::take _A_bound3)
                : adapts< T_functor >(_A_func), bound1_(_A_bound1), bound2_(_A_bound2), bound3_(_A_bound3) 
            {
            }
            bound_argument< T_type1 > bound1_;
            bound_argument< T_type2 > bound2_;
            bound_argument< T_type3 > bound3_;
    };
    template<class T_action, class T_functor, class T_type1, class T_type2, class T_type3 >
    void visit_each(const T_action & _A_action, const bind_functor< -1, T_functor, T_type1, T_type2, T_type3 > & _A_target)
    {
        visit_each(_A_action, _A_target.functor_);
        visit_each(_A_action, _A_target.bound1_);
        visit_each(_A_action, _A_target.bound2_);
        visit_each(_A_action, _A_target.bound3_);
    }
    template<class T_functor, class T_type1, class T_type2, class T_type3, class T_type4 >
    struct bind_functor< -1, T_functor, T_type1, T_type2, T_type3, T_type4, nil, nil, nil > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<int count, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass, typename type_trait< typename unwrap_reference< T_type4 >::type >::pass >::type type;
            };
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal< 5, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass, typename type_trait< typename unwrap_reference< T_type4 >::type >::pass >::type type;
            };
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal< 6, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass, typename type_trait< typename unwrap_reference< T_type4 >::type >::pass >::type type;
            };
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename deduce_result_type_internal< internal::count_void< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::value, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            result_type operator ()()
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass, typename type_trait< typename unwrap_reference< T_type4 >::type >::pass >(bound1_.invoke(), bound2_.invoke(), bound3_.invoke(), bound4_.invoke());
            }
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_arg1)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass, typename type_trait< typename unwrap_reference< T_type4 >::type >::pass >(_A_arg1, bound1_.invoke(), bound2_.invoke(), bound3_.invoke(), bound4_.invoke());
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass, typename type_trait< typename unwrap_reference< T_type4 >::type >::pass >(_A_arg1, _A_arg2, bound1_.invoke(), bound2_.invoke(), bound3_.invoke(), bound4_.invoke());
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2, T_arg3 _A_arg3)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass, typename type_trait< typename unwrap_reference< T_type4 >::type >::pass >(_A_arg1, _A_arg2, _A_arg3, bound1_.invoke(), bound2_.invoke(), bound3_.invoke(), bound4_.invoke());
            }
            bind_functor(typename type_trait< T_functor >::take _A_func, typename type_trait< T_type1 >::take _A_bound1, typename type_trait< T_type2 >::take _A_bound2, typename type_trait< T_type3 >::take _A_bound3, typename type_trait< T_type4 >::take _A_bound4)
                : adapts< T_functor >(_A_func), bound1_(_A_bound1), bound2_(_A_bound2), bound3_(_A_bound3), bound4_(_A_bound4) 
            {
            }
            bound_argument< T_type1 > bound1_;
            bound_argument< T_type2 > bound2_;
            bound_argument< T_type3 > bound3_;
            bound_argument< T_type4 > bound4_;
    };
    template<class T_action, class T_functor, class T_type1, class T_type2, class T_type3, class T_type4 >
    void visit_each(const T_action & _A_action, const bind_functor< -1, T_functor, T_type1, T_type2, T_type3, T_type4 > & _A_target)
    {
        visit_each(_A_action, _A_target.functor_);
        visit_each(_A_action, _A_target.bound1_);
        visit_each(_A_action, _A_target.bound2_);
        visit_each(_A_action, _A_target.bound3_);
        visit_each(_A_action, _A_target.bound4_);
    }
    template<class T_functor, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5 >
    struct bind_functor< -1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, nil, nil > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<int count, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass, typename type_trait< typename unwrap_reference< T_type4 >::type >::pass, typename type_trait< typename unwrap_reference< T_type5 >::type >::pass >::type type;
            };
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal< 6, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass, typename type_trait< typename unwrap_reference< T_type4 >::type >::pass, typename type_trait< typename unwrap_reference< T_type5 >::type >::pass >::type type;
            };
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename deduce_result_type_internal< internal::count_void< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::value, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            result_type operator ()()
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass, typename type_trait< typename unwrap_reference< T_type4 >::type >::pass, typename type_trait< typename unwrap_reference< T_type5 >::type >::pass >(bound1_.invoke(), bound2_.invoke(), bound3_.invoke(), bound4_.invoke(), bound5_.invoke());
            }
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_arg1)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass, typename type_trait< typename unwrap_reference< T_type4 >::type >::pass, typename type_trait< typename unwrap_reference< T_type5 >::type >::pass >(_A_arg1, bound1_.invoke(), bound2_.invoke(), bound3_.invoke(), bound4_.invoke(), bound5_.invoke());
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_arg1, T_arg2 _A_arg2)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass, typename type_trait< typename unwrap_reference< T_type4 >::type >::pass, typename type_trait< typename unwrap_reference< T_type5 >::type >::pass >(_A_arg1, _A_arg2, bound1_.invoke(), bound2_.invoke(), bound3_.invoke(), bound4_.invoke(), bound5_.invoke());
            }
            bind_functor(typename type_trait< T_functor >::take _A_func, typename type_trait< T_type1 >::take _A_bound1, typename type_trait< T_type2 >::take _A_bound2, typename type_trait< T_type3 >::take _A_bound3, typename type_trait< T_type4 >::take _A_bound4, typename type_trait< T_type5 >::take _A_bound5)
                : adapts< T_functor >(_A_func), bound1_(_A_bound1), bound2_(_A_bound2), bound3_(_A_bound3), bound4_(_A_bound4), bound5_(_A_bound5) 
            {
            }
            bound_argument< T_type1 > bound1_;
            bound_argument< T_type2 > bound2_;
            bound_argument< T_type3 > bound3_;
            bound_argument< T_type4 > bound4_;
            bound_argument< T_type5 > bound5_;
    };
    template<class T_action, class T_functor, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5 >
    void visit_each(const T_action & _A_action, const bind_functor< -1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5 > & _A_target)
    {
        visit_each(_A_action, _A_target.functor_);
        visit_each(_A_action, _A_target.bound1_);
        visit_each(_A_action, _A_target.bound2_);
        visit_each(_A_action, _A_target.bound3_);
        visit_each(_A_action, _A_target.bound4_);
        visit_each(_A_action, _A_target.bound5_);
    }
    template<class T_functor, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6 >
    struct bind_functor< -1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, nil > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<int count, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass, typename type_trait< typename unwrap_reference< T_type4 >::type >::pass, typename type_trait< typename unwrap_reference< T_type5 >::type >::pass, typename type_trait< typename unwrap_reference< T_type6 >::type >::pass >::type type;
            };
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename deduce_result_type_internal< internal::count_void< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::value, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            result_type operator ()()
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass, typename type_trait< typename unwrap_reference< T_type4 >::type >::pass, typename type_trait< typename unwrap_reference< T_type5 >::type >::pass, typename type_trait< typename unwrap_reference< T_type6 >::type >::pass >(bound1_.invoke(), bound2_.invoke(), bound3_.invoke(), bound4_.invoke(), bound5_.invoke(), bound6_.invoke());
            }
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_arg1)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass, typename type_trait< typename unwrap_reference< T_type4 >::type >::pass, typename type_trait< typename unwrap_reference< T_type5 >::type >::pass, typename type_trait< typename unwrap_reference< T_type6 >::type >::pass >(_A_arg1, bound1_.invoke(), bound2_.invoke(), bound3_.invoke(), bound4_.invoke(), bound5_.invoke(), bound6_.invoke());
            }
            bind_functor(typename type_trait< T_functor >::take _A_func, typename type_trait< T_type1 >::take _A_bound1, typename type_trait< T_type2 >::take _A_bound2, typename type_trait< T_type3 >::take _A_bound3, typename type_trait< T_type4 >::take _A_bound4, typename type_trait< T_type5 >::take _A_bound5, typename type_trait< T_type6 >::take _A_bound6)
                : adapts< T_functor >(_A_func), bound1_(_A_bound1), bound2_(_A_bound2), bound3_(_A_bound3), bound4_(_A_bound4), bound5_(_A_bound5), bound6_(_A_bound6) 
            {
            }
            bound_argument< T_type1 > bound1_;
            bound_argument< T_type2 > bound2_;
            bound_argument< T_type3 > bound3_;
            bound_argument< T_type4 > bound4_;
            bound_argument< T_type5 > bound5_;
            bound_argument< T_type6 > bound6_;
    };
    template<class T_action, class T_functor, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6 >
    void visit_each(const T_action & _A_action, const bind_functor< -1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6 > & _A_target)
    {
        visit_each(_A_action, _A_target.functor_);
        visit_each(_A_action, _A_target.bound1_);
        visit_each(_A_action, _A_target.bound2_);
        visit_each(_A_action, _A_target.bound3_);
        visit_each(_A_action, _A_target.bound4_);
        visit_each(_A_action, _A_target.bound5_);
        visit_each(_A_action, _A_target.bound6_);
    }
    template<class T_functor, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_type7 >
    struct bind_functor< -1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<int count, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            struct deduce_result_type_internal
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass, typename type_trait< typename unwrap_reference< T_type4 >::type >::pass, typename type_trait< typename unwrap_reference< T_type5 >::type >::pass, typename type_trait< typename unwrap_reference< T_type6 >::type >::pass, typename type_trait< typename unwrap_reference< T_type7 >::type >::pass >::type type;
            };
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename deduce_result_type_internal< internal::count_void< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::value, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            result_type operator ()()
            {
                return this->functor_.template operator ()<typename type_trait< typename unwrap_reference< T_type1 >::type >::pass, typename type_trait< typename unwrap_reference< T_type2 >::type >::pass, typename type_trait< typename unwrap_reference< T_type3 >::type >::pass, typename type_trait< typename unwrap_reference< T_type4 >::type >::pass, typename type_trait< typename unwrap_reference< T_type5 >::type >::pass, typename type_trait< typename unwrap_reference< T_type6 >::type >::pass, typename type_trait< typename unwrap_reference< T_type7 >::type >::pass >(bound1_.invoke(), bound2_.invoke(), bound3_.invoke(), bound4_.invoke(), bound5_.invoke(), bound6_.invoke(), bound7_.invoke());
            }
            bind_functor(typename type_trait< T_functor >::take _A_func, typename type_trait< T_type1 >::take _A_bound1, typename type_trait< T_type2 >::take _A_bound2, typename type_trait< T_type3 >::take _A_bound3, typename type_trait< T_type4 >::take _A_bound4, typename type_trait< T_type5 >::take _A_bound5, typename type_trait< T_type6 >::take _A_bound6, typename type_trait< T_type7 >::take _A_bound7)
                : adapts< T_functor >(_A_func), bound1_(_A_bound1), bound2_(_A_bound2), bound3_(_A_bound3), bound4_(_A_bound4), bound5_(_A_bound5), bound6_(_A_bound6), bound7_(_A_bound7) 
            {
            }
            bound_argument< T_type1 > bound1_;
            bound_argument< T_type2 > bound2_;
            bound_argument< T_type3 > bound3_;
            bound_argument< T_type4 > bound4_;
            bound_argument< T_type5 > bound5_;
            bound_argument< T_type6 > bound6_;
            bound_argument< T_type7 > bound7_;
    };
    template<class T_action, class T_functor, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_type7 >
    void visit_each(const T_action & _A_action, const bind_functor< -1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 > & _A_target)
    {
        visit_each(_A_action, _A_target.functor_);
        visit_each(_A_action, _A_target.bound1_);
        visit_each(_A_action, _A_target.bound2_);
        visit_each(_A_action, _A_target.bound3_);
        visit_each(_A_action, _A_target.bound4_);
        visit_each(_A_action, _A_target.bound5_);
        visit_each(_A_action, _A_target.bound6_);
        visit_each(_A_action, _A_target.bound7_);
    }
    template<int I_location, class T_bound1, class T_functor >
    inline bind_functor< I_location, T_functor, T_bound1 > bind(const T_functor & _A_func, T_bound1 _A_b1)
    {
        return bind_functor< I_location, T_functor, T_bound1 >(_A_func, _A_b1);
    }
    template<class T_type1, class T_functor >
    inline bind_functor< -1, T_functor, T_type1 > bind(const T_functor & _A_func, T_type1 _A_b1)
    {
        return bind_functor< -1, T_functor, T_type1 >(_A_func, _A_b1);
    }
    template<class T_type1, class T_type2, class T_functor >
    inline bind_functor< -1, T_functor, T_type1, T_type2 > bind(const T_functor & _A_func, T_type1 _A_b1, T_type2 _A_b2)
    {
        return bind_functor< -1, T_functor, T_type1, T_type2 >(_A_func, _A_b1, _A_b2);
    }
    template<class T_type1, class T_type2, class T_type3, class T_functor >
    inline bind_functor< -1, T_functor, T_type1, T_type2, T_type3 > bind(const T_functor & _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3)
    {
        return bind_functor< -1, T_functor, T_type1, T_type2, T_type3 >(_A_func, _A_b1, _A_b2, _A_b3);
    }
    template<class T_type1, class T_type2, class T_type3, class T_type4, class T_functor >
    inline bind_functor< -1, T_functor, T_type1, T_type2, T_type3, T_type4 > bind(const T_functor & _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4)
    {
        return bind_functor< -1, T_functor, T_type1, T_type2, T_type3, T_type4 >(_A_func, _A_b1, _A_b2, _A_b3, _A_b4);
    }
    template<class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_functor >
    inline bind_functor< -1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5 > bind(const T_functor & _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5)
    {
        return bind_functor< -1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5 >(_A_func, _A_b1, _A_b2, _A_b3, _A_b4, _A_b5);
    }
    template<class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_functor >
    inline bind_functor< -1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6 > bind(const T_functor & _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5, T_type6 _A_b6)
    {
        return bind_functor< -1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6 >(_A_func, _A_b1, _A_b2, _A_b3, _A_b4, _A_b5, _A_b6);
    }
    template<class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_type7, class T_functor >
    inline bind_functor< -1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 > bind(const T_functor & _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5, T_type6 _A_b6, T_type7 _A_b7)
    {
        return bind_functor< -1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 >(_A_func, _A_b1, _A_b2, _A_b3, _A_b4, _A_b5, _A_b6, _A_b7);
    }
}
namespace sigc {
    template<class T_return, class T_functor >
    struct bind_return_functor : public adapts< T_functor >
    {
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename unwrap_reference< T_return >::type type;
            };
            typedef typename unwrap_reference< T_return >::type result_type;
            typename unwrap_reference< T_return >::type operator ()();
            template<class T_arg1 >
            inline typename unwrap_reference< T_return >::type operator ()(T_arg1 _A_a1)
            {
                this->functor_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_a1);
                return ret_value_.invoke();
            }
            template<class T_arg1, class T_arg2 >
            inline typename unwrap_reference< T_return >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2)
            {
                this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_a1, _A_a2);
                return ret_value_.invoke();
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            inline typename unwrap_reference< T_return >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3)
            {
                this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_a1, _A_a2, _A_a3);
                return ret_value_.invoke();
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            inline typename unwrap_reference< T_return >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4)
            {
                this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4);
                return ret_value_.invoke();
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            inline typename unwrap_reference< T_return >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5)
            {
                this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
                return ret_value_.invoke();
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            inline typename unwrap_reference< T_return >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
            {
                this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
                return ret_value_.invoke();
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            inline typename unwrap_reference< T_return >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
            {
                this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
                return ret_value_.invoke();
            }
            bind_return_functor(typename type_trait< T_functor >::take _A_functor, typename type_trait< T_return >::take _A_ret_value)
                : adapts< T_functor >(_A_functor), ret_value_(_A_ret_value) 
            {
            }
            bound_argument< T_return > ret_value_;
    };
    template<class T_return, class T_functor >
    typename unwrap_reference< T_return >::type bind_return_functor< T_return, T_functor >::operator ()()
    {
        this->functor_();
        return ret_value_.invoke();
    }
    template<class T_action, class T_return, class T_functor >
    void visit_each(const T_action & _A_action, const bind_return_functor< T_return, T_functor > & _A_target)
    {
        visit_each(_A_action, _A_target.ret_value_);
        visit_each(_A_action, _A_target.functor_);
    }
    template<class T_return, class T_functor >
    inline bind_return_functor< T_return, T_functor > bind_return(const T_functor & _A_functor, T_return _A_ret_value)
    {
        return bind_return_functor< T_return, T_functor >(_A_functor, _A_ret_value);
    }
}
namespace sigc {
    template<int I_location, class T_functor >
    struct hide_functor;
    template<class T_functor >
    struct hide_functor< -1, T_functor > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1)
            {
                return this->functor_();
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_a1, T_arg2)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_a1);
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_a1, _A_a2);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_a1, _A_a2, _A_a3);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
            explicit hide_functor(const T_functor & _A_func)
                : adapts< T_functor >(_A_func) 
            {
            }
    };
    template<class T_functor >
    struct hide_functor< 0, T_functor > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1)
            {
                return this->functor_();
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1, T_arg2 _A_a2)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg2 >::pass >(_A_a2);
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_a2, _A_a3);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_a2, _A_a3, _A_a4);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_a2, _A_a3, _A_a4, _A_a5);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
            explicit hide_functor(const T_functor & _A_func)
                : adapts< T_functor >(_A_func) 
            {
            }
    };
    template<class T_functor >
    struct hide_functor< 1, T_functor > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_a1, T_arg2)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_a1);
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg3 >::pass >(_A_a1, _A_a3);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3, T_arg4 _A_a4)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_a1, _A_a3, _A_a4);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_a1, _A_a3, _A_a4, _A_a5);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_a1, _A_a3, _A_a4, _A_a5, _A_a6);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_a1, T_arg2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_a1, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
            explicit hide_functor(const T_functor & _A_func)
                : adapts< T_functor >(_A_func) 
            {
            }
    };
    template<class T_functor >
    struct hide_functor< 2, T_functor > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_a1, _A_a2);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3, T_arg4 _A_a4)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg4 >::pass >(_A_a1, _A_a2, _A_a4);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3, T_arg4 _A_a4, T_arg5 _A_a5)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_a1, _A_a2, _A_a4, _A_a5);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_a1, _A_a2, _A_a4, _A_a5, _A_a6);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_a1, _A_a2, _A_a4, _A_a5, _A_a6, _A_a7);
            }
            explicit hide_functor(const T_functor & _A_func)
                : adapts< T_functor >(_A_func) 
            {
            }
    };
    template<class T_functor >
    struct hide_functor< 3, T_functor > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_a1, _A_a2, _A_a3);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4, T_arg5 _A_a5)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg5 >::pass >(_A_a1, _A_a2, _A_a3, _A_a5);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4, T_arg5 _A_a5, T_arg6 _A_a6)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_a1, _A_a2, _A_a3, _A_a5, _A_a6);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_a1, _A_a2, _A_a3, _A_a5, _A_a6, _A_a7);
            }
            explicit hide_functor(const T_functor & _A_func)
                : adapts< T_functor >(_A_func) 
            {
            }
    };
    template<class T_functor >
    struct hide_functor< 4, T_functor > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5, T_arg6 _A_a6)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg6 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a6);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5, T_arg6 _A_a6, T_arg7 _A_a7)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a6, _A_a7);
            }
            explicit hide_functor(const T_functor & _A_func)
                : adapts< T_functor >(_A_func) 
            {
            }
    };
    template<class T_functor >
    struct hide_functor< 5, T_functor > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg7 >::pass >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6, T_arg7 _A_a7)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg7 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a7);
            }
            explicit hide_functor(const T_functor & _A_func)
                : adapts< T_functor >(_A_func) 
            {
            }
    };
    template<class T_functor >
    struct hide_functor< 6, T_functor > : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7)
            {
                return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
            explicit hide_functor(const T_functor & _A_func)
                : adapts< T_functor >(_A_func) 
            {
            }
    };
    template<class T_action, int I_location, class T_functor >
    void visit_each(const T_action & _A_action, const hide_functor< I_location, T_functor > & _A_target)
    {
        visit_each(_A_action, _A_target.functor_);
    }
    template<int I_location, class T_functor >
    inline hide_functor< I_location, T_functor > hide(const T_functor & _A_func)
    {
        return hide_functor< I_location, T_functor >(_A_func);
    }
    template<class T_functor >
    inline hide_functor< -1, T_functor > hide(const T_functor & _A_func)
    {
        return hide_functor< -1, T_functor >(_A_func);
    }
}
namespace sigc {
    template<class T_return, class T_functor >
    struct retype_return_functor : public adapts< T_functor >
    {
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef T_return type;
            };
            typedef T_return result_type;
            T_return operator ()();
            template<class T_arg1 >
            inline T_return operator ()(T_arg1 _A_a1)
            {
                return T_return(this->functor_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_a1));
            }
            template<class T_arg1, class T_arg2 >
            inline T_return operator ()(T_arg1 _A_a1, T_arg2 _A_a2)
            {
                return T_return(this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_a1, _A_a2));
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            inline T_return operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3)
            {
                return T_return(this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_a1, _A_a2, _A_a3));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            inline T_return operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4)
            {
                return T_return(this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            inline T_return operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5)
            {
                return T_return(this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            inline T_return operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
            {
                return T_return(this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            inline T_return operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
            {
                return T_return(this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7));
            }
            retype_return_functor()
            {
            }
            explicit retype_return_functor(typename type_trait< T_functor >::take _A_functor)
                : adapts< T_functor >(_A_functor) 
            {
            }
    };
    template<class T_return, class T_functor >
    T_return retype_return_functor< T_return, T_functor >::operator ()()
    {
        return T_return(this->functor_());
    }
    template<class T_functor >
    struct retype_return_functor< void, T_functor > : public adapts< T_functor >
    {
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef void type;
            };
            typedef void result_type;
            void operator ()();
            template<class T_arg1 >
            inline void operator ()(T_arg1 _A_a1)
            {
                this->functor_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_a1);
            }
            template<class T_arg1, class T_arg2 >
            inline void operator ()(T_arg1 _A_a1, T_arg2 _A_a2)
            {
                this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_a1, _A_a2);
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            inline void operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3)
            {
                this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_a1, _A_a2, _A_a3);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            inline void operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4)
            {
                this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            inline void operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5)
            {
                this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            inline void operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
            {
                this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            inline void operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
            {
                this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
            }
            retype_return_functor()
            {
            }
            retype_return_functor(typename type_trait< T_functor >::take _A_functor)
                : adapts< T_functor >(_A_functor) 
            {
            }
    };
    template<class T_functor >
    void retype_return_functor< void, T_functor >::operator ()()
    {
        this->functor_();
    }
    template<class T_action, class T_return, class T_functor >
    void visit_each(const T_action & _A_action, const retype_return_functor< T_return, T_functor > & _A_target)
    {
        visit_each(_A_action, _A_target.functor_);
    }
    template<class T_return, class T_functor >
    inline retype_return_functor< T_return, T_functor > retype_return(const T_functor & _A_functor)
    {
        return retype_return_functor< T_return, T_functor >(_A_functor);
    }
    template<class T_functor >
    inline retype_return_functor< void, T_functor > hide_return(const T_functor & _A_functor)
    {
        return retype_return_functor< void, T_functor >(_A_functor);
    }
}
namespace sigc {
    template<class T_functor, class T_type1 = nil, class T_type2 = nil, class T_type3 = nil, class T_type4 = nil, class T_type5 = nil, class T_type6 = nil, class T_type7 = nil >
    struct retype_functor : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type type;
            };
            typedef typename adapts< T_functor >::result_type result_type;
            result_type operator ()();
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_a1)
            {
                return this->functor_.template operator ()<typename type_trait< T_type1 >::take >(static_cast<T_type1 >(_A_a1));
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2)
            {
                return this->functor_.template operator ()<typename type_trait< T_type1 >::take, typename type_trait< T_type2 >::take >(static_cast<T_type1 >(_A_a1), static_cast<T_type2 >(_A_a2));
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3)
            {
                return this->functor_.template operator ()<typename type_trait< T_type1 >::take, typename type_trait< T_type2 >::take, typename type_trait< T_type3 >::take >(static_cast<T_type1 >(_A_a1), static_cast<T_type2 >(_A_a2), static_cast<T_type3 >(_A_a3));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4)
            {
                return this->functor_.template operator ()<typename type_trait< T_type1 >::take, typename type_trait< T_type2 >::take, typename type_trait< T_type3 >::take, typename type_trait< T_type4 >::take >(static_cast<T_type1 >(_A_a1), static_cast<T_type2 >(_A_a2), static_cast<T_type3 >(_A_a3), static_cast<T_type4 >(_A_a4));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5)
            {
                return this->functor_.template operator ()<typename type_trait< T_type1 >::take, typename type_trait< T_type2 >::take, typename type_trait< T_type3 >::take, typename type_trait< T_type4 >::take, typename type_trait< T_type5 >::take >(static_cast<T_type1 >(_A_a1), static_cast<T_type2 >(_A_a2), static_cast<T_type3 >(_A_a3), static_cast<T_type4 >(_A_a4), static_cast<T_type5 >(_A_a5));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
            {
                return this->functor_.template operator ()<typename type_trait< T_type1 >::take, typename type_trait< T_type2 >::take, typename type_trait< T_type3 >::take, typename type_trait< T_type4 >::take, typename type_trait< T_type5 >::take, typename type_trait< T_type6 >::take >(static_cast<T_type1 >(_A_a1), static_cast<T_type2 >(_A_a2), static_cast<T_type3 >(_A_a3), static_cast<T_type4 >(_A_a4), static_cast<T_type5 >(_A_a5), static_cast<T_type6 >(_A_a6));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
            {
                return this->functor_.template operator ()<typename type_trait< T_type1 >::take, typename type_trait< T_type2 >::take, typename type_trait< T_type3 >::take, typename type_trait< T_type4 >::take, typename type_trait< T_type5 >::take, typename type_trait< T_type6 >::take, typename type_trait< T_type7 >::take >(static_cast<T_type1 >(_A_a1), static_cast<T_type2 >(_A_a2), static_cast<T_type3 >(_A_a3), static_cast<T_type4 >(_A_a4), static_cast<T_type5 >(_A_a5), static_cast<T_type6 >(_A_a6), static_cast<T_type7 >(_A_a7));
            }
            explicit retype_functor(typename type_trait< T_functor >::take _A_functor)
                : adapts< T_functor >(_A_functor) 
            {
            }
    };
    template<class T_functor, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_type7 >
    typename retype_functor< T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 >::result_type retype_functor< T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 >::operator ()()
    {
        return this->functor_();
    }
    template<class T_action, class T_functor, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_type7 >
    void visit_each(const T_action & _A_action, const retype_functor< T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 > & _A_target)
    {
        visit_each(_A_action, _A_target.functor_);
    }
    template<class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    inline retype_functor< slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > retype(const slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > & _A_functor)
    {
        return retype_functor< slot< T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_functor);
    }
    template<class T_return >
    inline retype_functor< pointer_functor0< T_return > > retype(const pointer_functor0< T_return > & _A_functor)
    {
        return retype_functor< pointer_functor0< T_return > >(_A_functor);
    }
    template<class T_arg1, class T_return >
    inline retype_functor< pointer_functor1< T_arg1, T_return >, T_arg1 > retype(const pointer_functor1< T_arg1, T_return > & _A_functor)
    {
        return retype_functor< pointer_functor1< T_arg1, T_return >, T_arg1 >(_A_functor);
    }
    template<class T_arg1, class T_arg2, class T_return >
    inline retype_functor< pointer_functor2< T_arg1, T_arg2, T_return >, T_arg1, T_arg2 > retype(const pointer_functor2< T_arg1, T_arg2, T_return > & _A_functor)
    {
        return retype_functor< pointer_functor2< T_arg1, T_arg2, T_return >, T_arg1, T_arg2 >(_A_functor);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_return >
    inline retype_functor< pointer_functor3< T_arg1, T_arg2, T_arg3, T_return >, T_arg1, T_arg2, T_arg3 > retype(const pointer_functor3< T_arg1, T_arg2, T_arg3, T_return > & _A_functor)
    {
        return retype_functor< pointer_functor3< T_arg1, T_arg2, T_arg3, T_return >, T_arg1, T_arg2, T_arg3 >(_A_functor);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return >
    inline retype_functor< pointer_functor4< T_arg1, T_arg2, T_arg3, T_arg4, T_return >, T_arg1, T_arg2, T_arg3, T_arg4 > retype(const pointer_functor4< T_arg1, T_arg2, T_arg3, T_arg4, T_return > & _A_functor)
    {
        return retype_functor< pointer_functor4< T_arg1, T_arg2, T_arg3, T_arg4, T_return >, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_functor);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return >
    inline retype_functor< pointer_functor5< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > retype(const pointer_functor5< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return > & _A_functor)
    {
        return retype_functor< pointer_functor5< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_functor);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return >
    inline retype_functor< pointer_functor6< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > retype(const pointer_functor6< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return > & _A_functor)
    {
        return retype_functor< pointer_functor6< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_functor);
    }
    template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return >
    inline retype_functor< pointer_functor7< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > retype(const pointer_functor7< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return > & _A_functor)
    {
        return retype_functor< pointer_functor7< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_functor);
    }
    template<class T_return, class T_obj >
    inline retype_functor< mem_functor0< T_return, T_obj > > retype(const mem_functor0< T_return, T_obj > & _A_functor)
    {
        return retype_functor< mem_functor0< T_return, T_obj > >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1 >
    inline retype_functor< mem_functor1< T_return, T_obj, T_arg1 >, T_arg1 > retype(const mem_functor1< T_return, T_obj, T_arg1 > & _A_functor)
    {
        return retype_functor< mem_functor1< T_return, T_obj, T_arg1 >, T_arg1 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2 >
    inline retype_functor< mem_functor2< T_return, T_obj, T_arg1, T_arg2 >, T_arg1, T_arg2 > retype(const mem_functor2< T_return, T_obj, T_arg1, T_arg2 > & _A_functor)
    {
        return retype_functor< mem_functor2< T_return, T_obj, T_arg1, T_arg2 >, T_arg1, T_arg2 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    inline retype_functor< mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >, T_arg1, T_arg2, T_arg3 > retype(const mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > & _A_functor)
    {
        return retype_functor< mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >, T_arg1, T_arg2, T_arg3 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    inline retype_functor< mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >, T_arg1, T_arg2, T_arg3, T_arg4 > retype(const mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > & _A_functor)
    {
        return retype_functor< mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    inline retype_functor< mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > retype(const mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > & _A_functor)
    {
        return retype_functor< mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    inline retype_functor< mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > retype(const mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > & _A_functor)
    {
        return retype_functor< mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    inline retype_functor< mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > retype(const mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > & _A_functor)
    {
        return retype_functor< mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_functor);
    }
    template<class T_return, class T_obj >
    inline retype_functor< const_mem_functor0< T_return, T_obj > > retype(const const_mem_functor0< T_return, T_obj > & _A_functor)
    {
        return retype_functor< const_mem_functor0< T_return, T_obj > >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1 >
    inline retype_functor< const_mem_functor1< T_return, T_obj, T_arg1 >, T_arg1 > retype(const const_mem_functor1< T_return, T_obj, T_arg1 > & _A_functor)
    {
        return retype_functor< const_mem_functor1< T_return, T_obj, T_arg1 >, T_arg1 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2 >
    inline retype_functor< const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >, T_arg1, T_arg2 > retype(const const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > & _A_functor)
    {
        return retype_functor< const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >, T_arg1, T_arg2 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    inline retype_functor< const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >, T_arg1, T_arg2, T_arg3 > retype(const const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > & _A_functor)
    {
        return retype_functor< const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >, T_arg1, T_arg2, T_arg3 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    inline retype_functor< const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >, T_arg1, T_arg2, T_arg3, T_arg4 > retype(const const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > & _A_functor)
    {
        return retype_functor< const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    inline retype_functor< const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > retype(const const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > & _A_functor)
    {
        return retype_functor< const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    inline retype_functor< const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > retype(const const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > & _A_functor)
    {
        return retype_functor< const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    inline retype_functor< const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > retype(const const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > & _A_functor)
    {
        return retype_functor< const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_functor);
    }
    template<class T_return, class T_obj >
    inline retype_functor< volatile_mem_functor0< T_return, T_obj > > retype(const volatile_mem_functor0< T_return, T_obj > & _A_functor)
    {
        return retype_functor< volatile_mem_functor0< T_return, T_obj > >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1 >
    inline retype_functor< volatile_mem_functor1< T_return, T_obj, T_arg1 >, T_arg1 > retype(const volatile_mem_functor1< T_return, T_obj, T_arg1 > & _A_functor)
    {
        return retype_functor< volatile_mem_functor1< T_return, T_obj, T_arg1 >, T_arg1 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2 >
    inline retype_functor< volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >, T_arg1, T_arg2 > retype(const volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > & _A_functor)
    {
        return retype_functor< volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >, T_arg1, T_arg2 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    inline retype_functor< volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >, T_arg1, T_arg2, T_arg3 > retype(const volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > & _A_functor)
    {
        return retype_functor< volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >, T_arg1, T_arg2, T_arg3 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    inline retype_functor< volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >, T_arg1, T_arg2, T_arg3, T_arg4 > retype(const volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > & _A_functor)
    {
        return retype_functor< volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    inline retype_functor< volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > retype(const volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > & _A_functor)
    {
        return retype_functor< volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    inline retype_functor< volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > retype(const volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > & _A_functor)
    {
        return retype_functor< volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    inline retype_functor< volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > retype(const volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > & _A_functor)
    {
        return retype_functor< volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_functor);
    }
    template<class T_return, class T_obj >
    inline retype_functor< const_volatile_mem_functor0< T_return, T_obj > > retype(const const_volatile_mem_functor0< T_return, T_obj > & _A_functor)
    {
        return retype_functor< const_volatile_mem_functor0< T_return, T_obj > >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1 >
    inline retype_functor< const_volatile_mem_functor1< T_return, T_obj, T_arg1 >, T_arg1 > retype(const const_volatile_mem_functor1< T_return, T_obj, T_arg1 > & _A_functor)
    {
        return retype_functor< const_volatile_mem_functor1< T_return, T_obj, T_arg1 >, T_arg1 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2 >
    inline retype_functor< const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >, T_arg1, T_arg2 > retype(const const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > & _A_functor)
    {
        return retype_functor< const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >, T_arg1, T_arg2 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    inline retype_functor< const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >, T_arg1, T_arg2, T_arg3 > retype(const const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > & _A_functor)
    {
        return retype_functor< const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >, T_arg1, T_arg2, T_arg3 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    inline retype_functor< const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >, T_arg1, T_arg2, T_arg3, T_arg4 > retype(const const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > & _A_functor)
    {
        return retype_functor< const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    inline retype_functor< const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > retype(const const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > & _A_functor)
    {
        return retype_functor< const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    inline retype_functor< const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > retype(const const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > & _A_functor)
    {
        return retype_functor< const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    inline retype_functor< const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > retype(const const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > & _A_functor)
    {
        return retype_functor< const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_functor);
    }
    template<class T_return, class T_obj >
    inline retype_functor< bound_mem_functor0< T_return, T_obj > > retype(const bound_mem_functor0< T_return, T_obj > & _A_functor)
    {
        return retype_functor< bound_mem_functor0< T_return, T_obj > >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1 >
    inline retype_functor< bound_mem_functor1< T_return, T_obj, T_arg1 >, T_arg1 > retype(const bound_mem_functor1< T_return, T_obj, T_arg1 > & _A_functor)
    {
        return retype_functor< bound_mem_functor1< T_return, T_obj, T_arg1 >, T_arg1 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2 >
    inline retype_functor< bound_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >, T_arg1, T_arg2 > retype(const bound_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > & _A_functor)
    {
        return retype_functor< bound_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >, T_arg1, T_arg2 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    inline retype_functor< bound_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >, T_arg1, T_arg2, T_arg3 > retype(const bound_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > & _A_functor)
    {
        return retype_functor< bound_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >, T_arg1, T_arg2, T_arg3 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    inline retype_functor< bound_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >, T_arg1, T_arg2, T_arg3, T_arg4 > retype(const bound_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > & _A_functor)
    {
        return retype_functor< bound_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    inline retype_functor< bound_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > retype(const bound_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > & _A_functor)
    {
        return retype_functor< bound_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    inline retype_functor< bound_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > retype(const bound_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > & _A_functor)
    {
        return retype_functor< bound_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    inline retype_functor< bound_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > retype(const bound_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > & _A_functor)
    {
        return retype_functor< bound_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_functor);
    }
    template<class T_return, class T_obj >
    inline retype_functor< bound_const_mem_functor0< T_return, T_obj > > retype(const bound_const_mem_functor0< T_return, T_obj > & _A_functor)
    {
        return retype_functor< bound_const_mem_functor0< T_return, T_obj > >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1 >
    inline retype_functor< bound_const_mem_functor1< T_return, T_obj, T_arg1 >, T_arg1 > retype(const bound_const_mem_functor1< T_return, T_obj, T_arg1 > & _A_functor)
    {
        return retype_functor< bound_const_mem_functor1< T_return, T_obj, T_arg1 >, T_arg1 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2 >
    inline retype_functor< bound_const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >, T_arg1, T_arg2 > retype(const bound_const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > & _A_functor)
    {
        return retype_functor< bound_const_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >, T_arg1, T_arg2 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    inline retype_functor< bound_const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >, T_arg1, T_arg2, T_arg3 > retype(const bound_const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > & _A_functor)
    {
        return retype_functor< bound_const_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >, T_arg1, T_arg2, T_arg3 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    inline retype_functor< bound_const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >, T_arg1, T_arg2, T_arg3, T_arg4 > retype(const bound_const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > & _A_functor)
    {
        return retype_functor< bound_const_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    inline retype_functor< bound_const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > retype(const bound_const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > & _A_functor)
    {
        return retype_functor< bound_const_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    inline retype_functor< bound_const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > retype(const bound_const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > & _A_functor)
    {
        return retype_functor< bound_const_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    inline retype_functor< bound_const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > retype(const bound_const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > & _A_functor)
    {
        return retype_functor< bound_const_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_functor);
    }
    template<class T_return, class T_obj >
    inline retype_functor< bound_volatile_mem_functor0< T_return, T_obj > > retype(const bound_volatile_mem_functor0< T_return, T_obj > & _A_functor)
    {
        return retype_functor< bound_volatile_mem_functor0< T_return, T_obj > >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1 >
    inline retype_functor< bound_volatile_mem_functor1< T_return, T_obj, T_arg1 >, T_arg1 > retype(const bound_volatile_mem_functor1< T_return, T_obj, T_arg1 > & _A_functor)
    {
        return retype_functor< bound_volatile_mem_functor1< T_return, T_obj, T_arg1 >, T_arg1 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2 >
    inline retype_functor< bound_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >, T_arg1, T_arg2 > retype(const bound_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > & _A_functor)
    {
        return retype_functor< bound_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >, T_arg1, T_arg2 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    inline retype_functor< bound_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >, T_arg1, T_arg2, T_arg3 > retype(const bound_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > & _A_functor)
    {
        return retype_functor< bound_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >, T_arg1, T_arg2, T_arg3 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    inline retype_functor< bound_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >, T_arg1, T_arg2, T_arg3, T_arg4 > retype(const bound_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > & _A_functor)
    {
        return retype_functor< bound_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    inline retype_functor< bound_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > retype(const bound_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > & _A_functor)
    {
        return retype_functor< bound_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    inline retype_functor< bound_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > retype(const bound_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > & _A_functor)
    {
        return retype_functor< bound_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    inline retype_functor< bound_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > retype(const bound_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > & _A_functor)
    {
        return retype_functor< bound_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_functor);
    }
    template<class T_return, class T_obj >
    inline retype_functor< bound_const_volatile_mem_functor0< T_return, T_obj > > retype(const bound_const_volatile_mem_functor0< T_return, T_obj > & _A_functor)
    {
        return retype_functor< bound_const_volatile_mem_functor0< T_return, T_obj > >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1 >
    inline retype_functor< bound_const_volatile_mem_functor1< T_return, T_obj, T_arg1 >, T_arg1 > retype(const bound_const_volatile_mem_functor1< T_return, T_obj, T_arg1 > & _A_functor)
    {
        return retype_functor< bound_const_volatile_mem_functor1< T_return, T_obj, T_arg1 >, T_arg1 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2 >
    inline retype_functor< bound_const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >, T_arg1, T_arg2 > retype(const bound_const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 > & _A_functor)
    {
        return retype_functor< bound_const_volatile_mem_functor2< T_return, T_obj, T_arg1, T_arg2 >, T_arg1, T_arg2 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3 >
    inline retype_functor< bound_const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >, T_arg1, T_arg2, T_arg3 > retype(const bound_const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 > & _A_functor)
    {
        return retype_functor< bound_const_volatile_mem_functor3< T_return, T_obj, T_arg1, T_arg2, T_arg3 >, T_arg1, T_arg2, T_arg3 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
    inline retype_functor< bound_const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >, T_arg1, T_arg2, T_arg3, T_arg4 > retype(const bound_const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 > & _A_functor)
    {
        return retype_functor< bound_const_volatile_mem_functor4< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 >, T_arg1, T_arg2, T_arg3, T_arg4 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
    inline retype_functor< bound_const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > retype(const bound_const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 > & _A_functor)
    {
        return retype_functor< bound_const_volatile_mem_functor5< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
    inline retype_functor< bound_const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > retype(const bound_const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 > & _A_functor)
    {
        return retype_functor< bound_const_volatile_mem_functor6< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >(_A_functor);
    }
    template<class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
    inline retype_functor< bound_const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > retype(const bound_const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 > & _A_functor)
    {
        return retype_functor< bound_const_volatile_mem_functor7< T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >(_A_functor);
    }
}
namespace sigc {
    template<class T_setter, class T_getter >
    struct compose1_functor : public adapts< T_setter >
    {
            typedef typename adapts< T_setter >::adaptor_type adaptor_type;
            typedef T_setter setter_type;
            typedef T_getter getter_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename sigc::deduce_result_type< T_getter, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type >::type type;
            };
            typedef typename adaptor_type::result_type result_type;
            result_type operator ()();
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_a1)
            {
                return this->functor_.template operator ()<typename sigc::deduce_result_type< T_getter, T_arg1 >::type >(get_(_A_a1));
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2)
            {
                return this->functor_.template operator ()<typename sigc::deduce_result_type< T_getter, T_arg1, T_arg2 >::type >(get_(_A_a1, _A_a2));
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3)
            {
                return this->functor_.template operator ()<typename sigc::deduce_result_type< T_getter, T_arg1, T_arg2, T_arg3 >::type >(get_(_A_a1, _A_a2, _A_a3));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4)
            {
                return this->functor_.template operator ()<typename sigc::deduce_result_type< T_getter, T_arg1, T_arg2, T_arg3, T_arg4 >::type >(get_(_A_a1, _A_a2, _A_a3, _A_a4));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5)
            {
                return this->functor_.template operator ()<typename sigc::deduce_result_type< T_getter, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type >(get_(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
            {
                return this->functor_.template operator ()<typename sigc::deduce_result_type< T_getter, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type >(get_(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
            {
                return this->functor_.template operator ()<typename sigc::deduce_result_type< T_getter, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type >(get_(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7));
            }
            compose1_functor(const T_setter & _A_setter, const T_getter & _A_getter)
                : adapts< T_setter >(_A_setter), get_(_A_getter) 
            {
            }
            getter_type get_;
    };
    template<class T_setter, class T_getter >
    typename compose1_functor< T_setter, T_getter >::result_type compose1_functor< T_setter, T_getter >::operator ()()
    {
        return this->functor_(get_());
    }
    template<class T_setter, class T_getter1, class T_getter2 >
    struct compose2_functor : public adapts< T_setter >
    {
            typedef typename adapts< T_setter >::adaptor_type adaptor_type;
            typedef T_setter setter_type;
            typedef T_getter1 getter1_type;
            typedef T_getter2 getter2_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename sigc::deduce_result_type< T_getter1, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type, typename sigc::deduce_result_type< T_getter2, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type >::type result_type;
            };
            typedef typename adaptor_type::result_type result_type;
            result_type operator ()();
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_a1)
            {
                return this->functor_.template operator ()<typename sigc::deduce_result_type< T_getter1, T_arg1 >::type, typename sigc::deduce_result_type< T_getter2, T_arg1 >::type >(get1_(_A_a1), get2_(_A_a1));
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2)
            {
                return this->functor_.template operator ()<typename sigc::deduce_result_type< T_getter1, T_arg1, T_arg2 >::type, typename sigc::deduce_result_type< T_getter2, T_arg1, T_arg2 >::type >(get1_(_A_a1, _A_a2), get2_(_A_a1, _A_a2));
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3)
            {
                return this->functor_.template operator ()<typename sigc::deduce_result_type< T_getter1, T_arg1, T_arg2, T_arg3 >::type, typename sigc::deduce_result_type< T_getter2, T_arg1, T_arg2, T_arg3 >::type >(get1_(_A_a1, _A_a2, _A_a3), get2_(_A_a1, _A_a2, _A_a3));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4)
            {
                return this->functor_.template operator ()<typename sigc::deduce_result_type< T_getter1, T_arg1, T_arg2, T_arg3, T_arg4 >::type, typename sigc::deduce_result_type< T_getter2, T_arg1, T_arg2, T_arg3, T_arg4 >::type >(get1_(_A_a1, _A_a2, _A_a3, _A_a4), get2_(_A_a1, _A_a2, _A_a3, _A_a4));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5)
            {
                return this->functor_.template operator ()<typename sigc::deduce_result_type< T_getter1, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type, typename sigc::deduce_result_type< T_getter2, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type >(get1_(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5), get2_(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
            {
                return this->functor_.template operator ()<typename sigc::deduce_result_type< T_getter1, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type, typename sigc::deduce_result_type< T_getter2, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type >(get1_(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6), get2_(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
            {
                return this->functor_.template operator ()<typename sigc::deduce_result_type< T_getter1, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type, typename sigc::deduce_result_type< T_getter2, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type >(get1_(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7), get2_(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7));
            }
            compose2_functor(const T_setter & _A_setter, const T_getter1 & _A_getter1, const T_getter2 & _A_getter2)
                : adapts< T_setter >(_A_setter), get1_(_A_getter1), get2_(_A_getter2) 
            {
            }
            getter1_type get1_;
            getter2_type get2_;
    };
    template<class T_setter, class T_getter1, class T_getter2 >
    typename compose2_functor< T_setter, T_getter1, T_getter2 >::result_type compose2_functor< T_setter, T_getter1, T_getter2 >::operator ()()
    {
        return this->functor_(get1_(), get2_());
    }
    template<class T_action, class T_setter, class T_getter >
    void visit_each(const T_action & _A_action, const compose1_functor< T_setter, T_getter > & _A_target)
    {
        typedef compose1_functor< T_setter, T_getter > type_functor;
        typedef typename type_functor::setter_type type_functor1;
        visit_each< T_action, type_functor1 >(_A_action, _A_target.functor_);
        typedef typename type_functor::getter_type type_functor_getter;
        visit_each< T_action, type_functor_getter >(_A_action, _A_target.get_);
    }
    template<class T_action, class T_setter, class T_getter1, class T_getter2 >
    void visit_each(const T_action & _A_action, const compose2_functor< T_setter, T_getter1, T_getter2 > & _A_target)
    {
        typedef compose2_functor< T_setter, T_getter1, T_getter2 > type_functor;
        typedef typename type_functor::setter_type type_functor1;
        visit_each< T_action, type_functor1 >(_A_action, _A_target.functor_);
        typedef typename type_functor::getter1_type type_functor_getter1;
        visit_each< T_action, type_functor_getter1 >(_A_action, _A_target.get1_);
        typedef typename type_functor::getter2_type type_functor_getter2;
        visit_each< T_action, type_functor_getter2 >(_A_action, _A_target.get2_);
    }
    template<class T_setter, class T_getter >
    inline compose1_functor< T_setter, T_getter > compose(const T_setter & _A_setter, const T_getter & _A_getter)
    {
        return compose1_functor< T_setter, T_getter >(_A_setter, _A_getter);
    }
    template<class T_setter, class T_getter1, class T_getter2 >
    inline compose2_functor< T_setter, T_getter1, T_getter2 > compose(const T_setter & _A_setter, const T_getter1 & _A_getter1, const T_getter2 & _A_getter2)
    {
        return compose2_functor< T_setter, T_getter1, T_getter2 >(_A_setter, _A_getter1, _A_getter2);
    }
}
namespace sigc {
    template<class T_functor, class T_catcher, class T_return = typename adapts< T_functor >::result_type >
    struct exception_catch_functor : public adapts< T_functor >
    {
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename adaptor_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type type;
            };
            typedef T_return result_type;
            result_type operator ()();
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_a1)
            {
                try
                {
                    return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_a1);
                }
                catch (...)
                {
                    return catcher_();
                }
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2)
            {
                try
                {
                    return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_a1, _A_a2);
                }
                catch (...)
                {
                    return catcher_();
                }
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3)
            {
                try
                {
                    return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_a1, _A_a2, _A_a3);
                }
                catch (...)
                {
                    return catcher_();
                }
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4)
            {
                try
                {
                    return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4);
                }
                catch (...)
                {
                    return catcher_();
                }
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5)
            {
                try
                {
                    return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
                }
                catch (...)
                {
                    return catcher_();
                }
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
            {
                try
                {
                    return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
                }
                catch (...)
                {
                    return catcher_();
                }
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
            {
                try
                {
                    return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
                }
                catch (...)
                {
                    return catcher_();
                }
            }
            exception_catch_functor(const T_functor & _A_func, const T_catcher & _A_catcher)
                : adapts< T_functor >(_A_func), catcher_(_A_catcher) 
            {
            }
            T_catcher catcher_;
    };
    template<class T_functor, class T_catcher, class T_return >
    typename exception_catch_functor< T_functor, T_catcher, T_return >::result_type exception_catch_functor< T_functor, T_catcher, T_return >::operator ()()
    {
        try
        {
            return this->functor_();
        }
        catch (...)
        {
            return catcher_();
        }
    }
    template<class T_functor, class T_catcher >
    struct exception_catch_functor< T_functor, T_catcher, void > : public adapts< T_functor >
    {
            typedef void result_type;
            typedef typename adapts< T_functor >::adaptor_type adaptor_type;
            void operator ()();
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_a1)
            {
                try
                {
                    return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_a1);
                }
                catch (...)
                {
                    return catcher_();
                }
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2)
            {
                try
                {
                    return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_a1, _A_a2);
                }
                catch (...)
                {
                    return catcher_();
                }
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3)
            {
                try
                {
                    return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_a1, _A_a2, _A_a3);
                }
                catch (...)
                {
                    return catcher_();
                }
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4)
            {
                try
                {
                    return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4);
                }
                catch (...)
                {
                    return catcher_();
                }
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5)
            {
                try
                {
                    return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5);
                }
                catch (...)
                {
                    return catcher_();
                }
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6)
            {
                try
                {
                    return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6);
                }
                catch (...)
                {
                    return catcher_();
                }
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_a1, T_arg2 _A_a2, T_arg3 _A_a3, T_arg4 _A_a4, T_arg5 _A_a5, T_arg6 _A_a6, T_arg7 _A_a7)
            {
                try
                {
                    return this->functor_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_a1, _A_a2, _A_a3, _A_a4, _A_a5, _A_a6, _A_a7);
                }
                catch (...)
                {
                    return catcher_();
                }
            }
            exception_catch_functor()
            {
            }
            exception_catch_functor(const T_functor & _A_func, const T_catcher & _A_catcher)
                : adapts< T_functor >(_A_func), catcher_(_A_catcher) 
            {
            }
            ~exception_catch_functor()
            {
            }
            T_catcher catcher_;
    };
    template<class T_functor, class T_catcher >
    void exception_catch_functor< T_functor, T_catcher, void >::operator ()()
    {
        try
        {
            this->functor_();
        }
        catch (...)
        {
            this->catcher_();
        }
    }
    template<class T_action, class T_functor, class T_catcher, class T_return >
    void visit_each(const T_action & _A_action, const exception_catch_functor< T_functor, T_catcher, T_return > & _A_target)
    {
        visit_each(_A_action, _A_target.functor_);
        visit_each(_A_action, _A_target.catcher_);
    }
    template<class T_functor, class T_catcher >
    inline exception_catch_functor< T_functor, T_catcher > exception_catch(const T_functor & _A_func, const T_catcher & _A_catcher)
    {
        return exception_catch_functor< T_functor, T_catcher >(_A_func, _A_catcher);
    }
}
namespace sigc {
    struct lambda_base : public adaptor_base
    {
    };
    template<class T_type >
    struct lambda;
    namespace internal {
        template<class T_type, bool I_islambda = is_base_and_derived< lambda_base, T_type >::value >
        struct lambda_core;
        template<class T_type >
        struct lambda_core< T_type, true > : public lambda_base
        {
                template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
                struct deduce_result_type
                {
                        typedef typename T_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type type;
                };
                typedef typename T_type::result_type result_type;
                typedef T_type lambda_type;
                result_type operator ()() const;
                template<class T_arg1 >
                typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_1) const
                {
                    return value_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_1);
                }
                template<class T_arg1, class T_arg2 >
                typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2) const
                {
                    return value_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_1, _A_2);
                }
                template<class T_arg1, class T_arg2, class T_arg3 >
                typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3) const
                {
                    return value_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_1, _A_2, _A_3);
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
                typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4) const
                {
                    return value_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_1, _A_2, _A_3, _A_4);
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
                typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5) const
                {
                    return value_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5);
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
                typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5, T_arg6 _A_6) const
                {
                    return value_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6);
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
                typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5, T_arg6 _A_6, T_arg7 _A_7) const
                {
                    return value_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6, _A_7);
                }
                lambda_core()
                {
                }
                explicit lambda_core(const T_type & v)
                    : value_(v) 
                {
                }
                T_type value_;
        };
        template<class T_type >
        typename lambda_core< T_type, true >::result_type lambda_core< T_type, true >::operator ()() const
        {
            return value_();
        }
        template<class T_type >
        struct lambda_core< T_type, false > : public lambda_base
        {
                template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
                struct deduce_result_type
                {
                        typedef T_type type;
                };
                typedef T_type result_type;
                typedef lambda< T_type > lambda_type;
                result_type operator ()() const;
                template<class T_arg1 >
                result_type operator ()(T_arg1) const
                {
                    return value_;
                }
                template<class T_arg1, class T_arg2 >
                result_type operator ()(T_arg1, T_arg2) const
                {
                    return value_;
                }
                template<class T_arg1, class T_arg2, class T_arg3 >
                result_type operator ()(T_arg1, T_arg2, T_arg3) const
                {
                    return value_;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
                result_type operator ()(T_arg1, T_arg2, T_arg3, T_arg4) const
                {
                    return value_;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
                result_type operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const
                {
                    return value_;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
                result_type operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const
                {
                    return value_;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
                result_type operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const
                {
                    return value_;
                }
                explicit lambda_core(typename type_trait< T_type >::take v)
                    : value_(v) 
                {
                }
                T_type value_;
        };
        template<class T_type >
        typename lambda_core< T_type, false >::result_type lambda_core< T_type, false >::operator ()() const
        {
            return value_;
        }
    }
    template<class T_action, class T_functor, bool I_islambda >
    void visit_each(const T_action & _A_action, const internal::lambda_core< T_functor, I_islambda > & _A_target)
    {
        visit_each(_A_action, _A_target.value_);
    }
    template<class T_type >
    struct other;
    struct subscript;
    struct assign;
    template<class T_action, class T_type1, class T_type2 >
    struct lambda_operator;
    template<class T_type >
    struct unwrap_lambda_type;
    template<class T_type >
    struct lambda : public internal::lambda_core< T_type >
    {
            typedef lambda< T_type > self;
            lambda()
            {
            }
            lambda(typename type_trait< T_type >::take v)
                : internal::lambda_core< T_type >(v) 
            {
            }
            template<class T_arg >
            lambda< lambda_operator< other< subscript >, self, typename unwrap_lambda_type< T_arg >::type > > operator [](const T_arg & a) const
            {
                typedef lambda_operator< other< subscript >, self, typename unwrap_lambda_type< T_arg >::type > lambda_operator_type;
                return lambda< lambda_operator_type >(lambda_operator_type(this->value_, unwrap_lambda_value(a)));
            }
            template<class T_arg >
            lambda< lambda_operator< other< assign >, self, typename unwrap_lambda_type< T_arg >::type > > operator =(const T_arg & a) const
            {
                typedef lambda_operator< other< assign >, self, typename unwrap_lambda_type< T_arg >::type > lambda_operator_type;
                return lambda< lambda_operator_type >(lambda_operator_type(this->value_, unwrap_lambda_value(a)));
            }
    };
    template<class T_action, class T_type >
    void visit_each(const T_action & _A_action, const lambda< T_type > & _A_target)
    {
        visit_each(_A_action, _A_target.value_);
    }
    template<class T_type >
    lambda< T_type & > var(T_type & v)
    {
        return lambda< T_type & >(v);
    }
    template<class T_type >
    lambda< const T_type & > var(const T_type & v)
    {
        return lambda< const T_type & >(v);
    }
    template<class T_type >
    struct unwrap_lambda_type
    {
            typedef typename unwrap_reference< T_type >::type type;
    };
    template<class T_type >
    struct unwrap_lambda_type< lambda< T_type > >
    {
            typedef T_type type;
    };
    template<class T_type >
    T_type & unwrap_lambda_value(T_type & a)
    {
        return a;
    }
    template<class T_type >
    const T_type & unwrap_lambda_value(const T_type & a)
    {
        return a;
    }
    template<class T_type >
    const T_type & unwrap_lambda_value(const lambda< T_type > & a)
    {
        return a.value_;
    }
}
namespace sigc {
    namespace internal {
        struct lambda_select1 : public lambda_base
        {
                template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
                struct deduce_result_type
                {
                        typedef T_arg1 type;
                };
                typedef void result_type;
                void operator ()() const;
                template<class T_arg1 >
                T_arg1 operator ()(T_arg1 _A_1) const
                {
                    return _A_1;
                }
                template<class T_arg1, class T_arg2 >
                T_arg1 operator ()(T_arg1 _A_1, T_arg2) const
                {
                    return _A_1;
                }
                template<class T_arg1, class T_arg2, class T_arg3 >
                T_arg1 operator ()(T_arg1 _A_1, T_arg2, T_arg3) const
                {
                    return _A_1;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
                T_arg1 operator ()(T_arg1 _A_1, T_arg2, T_arg3, T_arg4) const
                {
                    return _A_1;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
                T_arg1 operator ()(T_arg1 _A_1, T_arg2, T_arg3, T_arg4, T_arg5) const
                {
                    return _A_1;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
                T_arg1 operator ()(T_arg1 _A_1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const
                {
                    return _A_1;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
                T_arg1 operator ()(T_arg1 _A_1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const
                {
                    return _A_1;
                }
        };
        struct lambda_select2 : public lambda_base
        {
                template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
                struct deduce_result_type
                {
                        typedef T_arg2 type;
                };
                typedef void result_type;
                void operator ()() const;
                template<class T_arg1, class T_arg2 >
                T_arg2 operator ()(T_arg1, T_arg2 _A_2) const
                {
                    return _A_2;
                }
                template<class T_arg1, class T_arg2, class T_arg3 >
                T_arg2 operator ()(T_arg1, T_arg2 _A_2, T_arg3) const
                {
                    return _A_2;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
                T_arg2 operator ()(T_arg1, T_arg2 _A_2, T_arg3, T_arg4) const
                {
                    return _A_2;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
                T_arg2 operator ()(T_arg1, T_arg2 _A_2, T_arg3, T_arg4, T_arg5) const
                {
                    return _A_2;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
                T_arg2 operator ()(T_arg1, T_arg2 _A_2, T_arg3, T_arg4, T_arg5, T_arg6) const
                {
                    return _A_2;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
                T_arg2 operator ()(T_arg1, T_arg2 _A_2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const
                {
                    return _A_2;
                }
        };
        struct lambda_select3 : public lambda_base
        {
                template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
                struct deduce_result_type
                {
                        typedef T_arg3 type;
                };
                typedef void result_type;
                void operator ()() const;
                template<class T_arg1, class T_arg2, class T_arg3 >
                T_arg3 operator ()(T_arg1, T_arg2, T_arg3 _A_3) const
                {
                    return _A_3;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
                T_arg3 operator ()(T_arg1, T_arg2, T_arg3 _A_3, T_arg4) const
                {
                    return _A_3;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
                T_arg3 operator ()(T_arg1, T_arg2, T_arg3 _A_3, T_arg4, T_arg5) const
                {
                    return _A_3;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
                T_arg3 operator ()(T_arg1, T_arg2, T_arg3 _A_3, T_arg4, T_arg5, T_arg6) const
                {
                    return _A_3;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
                T_arg3 operator ()(T_arg1, T_arg2, T_arg3 _A_3, T_arg4, T_arg5, T_arg6, T_arg7) const
                {
                    return _A_3;
                }
        };
        struct lambda_select4 : public lambda_base
        {
                template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
                struct deduce_result_type
                {
                        typedef T_arg4 type;
                };
                typedef void result_type;
                void operator ()() const;
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
                T_arg4 operator ()(T_arg1, T_arg2, T_arg3, T_arg4 _A_4) const
                {
                    return _A_4;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
                T_arg4 operator ()(T_arg1, T_arg2, T_arg3, T_arg4 _A_4, T_arg5) const
                {
                    return _A_4;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
                T_arg4 operator ()(T_arg1, T_arg2, T_arg3, T_arg4 _A_4, T_arg5, T_arg6) const
                {
                    return _A_4;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
                T_arg4 operator ()(T_arg1, T_arg2, T_arg3, T_arg4 _A_4, T_arg5, T_arg6, T_arg7) const
                {
                    return _A_4;
                }
        };
        struct lambda_select5 : public lambda_base
        {
                template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
                struct deduce_result_type
                {
                        typedef T_arg5 type;
                };
                typedef void result_type;
                void operator ()() const;
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
                T_arg5 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 _A_5) const
                {
                    return _A_5;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
                T_arg5 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 _A_5, T_arg6) const
                {
                    return _A_5;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
                T_arg5 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 _A_5, T_arg6, T_arg7) const
                {
                    return _A_5;
                }
        };
        struct lambda_select6 : public lambda_base
        {
                template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
                struct deduce_result_type
                {
                        typedef T_arg6 type;
                };
                typedef void result_type;
                void operator ()() const;
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
                T_arg6 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 _A_6) const
                {
                    return _A_6;
                }
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
                T_arg6 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 _A_6, T_arg7) const
                {
                    return _A_6;
                }
        };
        struct lambda_select7 : public lambda_base
        {
                template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
                struct deduce_result_type
                {
                        typedef T_arg7 type;
                };
                typedef void result_type;
                void operator ()() const;
                template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
                T_arg7 operator ()(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 _A_7) const
                {
                    return _A_7;
                }
        };
    }
    extern const lambda< internal::lambda_select1 > _1;
    extern const lambda< internal::lambda_select2 > _2;
    extern const lambda< internal::lambda_select3 > _3;
    extern const lambda< internal::lambda_select4 > _4;
    extern const lambda< internal::lambda_select5 > _5;
    extern const lambda< internal::lambda_select6 > _6;
    extern const lambda< internal::lambda_select7 > _7;
}
namespace sigc {
    template<class T_type >
    struct dereference_trait
    {
            typedef void type;
    };
    template<class T_type >
    struct dereference_trait< T_type * >
    {
            typedef T_type type;
    };
    template<class T_type >
    struct dereference_trait< const T_type * >
    {
            typedef const T_type type;
    };
    template<class T_type >
    struct dereference_trait< T_type *& >
    {
            typedef T_type type;
    };
    template<class T_type >
    struct dereference_trait< const T_type *& >
    {
            typedef const T_type type;
    };
    template<class T_type >
    struct dereference_trait< T_type *const& >
    {
            typedef T_type type;
    };
    template<class T_type >
    struct dereference_trait< const T_type *const& >
    {
            typedef const T_type type;
    };
    template<class T_type >
    struct arithmetic
    {
    };
    template<class T_type >
    struct bitwise
    {
    };
    template<class T_type >
    struct logical
    {
    };
    template<class T_type >
    struct relational
    {
    };
    template<class T_type >
    struct arithmetic_assign
    {
    };
    template<class T_type >
    struct bitwise_assign
    {
    };
    template<class T_type >
    struct other
    {
    };
    template<class T_type >
    struct unary_arithmetic
    {
    };
    template<class T_type >
    struct unary_bitwise
    {
    };
    template<class T_type >
    struct unary_logical
    {
    };
    template<class T_type >
    struct unary_other
    {
    };
    template<class T_type >
    struct cast_
    {
    };
    struct plus
    {
    };
    struct minus
    {
    };
    struct multiplies
    {
    };
    struct divides
    {
    };
    struct modulus
    {
    };
    struct leftshift
    {
    };
    struct rightshift
    {
    };
    struct and_
    {
    };
    struct or_
    {
    };
    struct xor_
    {
    };
    struct less
    {
    };
    struct greater
    {
    };
    struct less_equal
    {
    };
    struct greater_equal
    {
    };
    struct equal_to
    {
    };
    struct not_equal_to
    {
    };
    struct subscript
    {
    };
    struct assign
    {
    };
    struct pre_increment
    {
    };
    struct pre_decrement
    {
    };
    struct negate
    {
    };
    struct not_
    {
    };
    struct address
    {
    };
    struct dereference
    {
    };
    struct reinterpret_
    {
    };
    struct static_
    {
    };
    struct dynamic_
    {
    };
    template<class T_action, class T_test1, class T_test2 >
    struct lambda_action_deduce_result_type
    {
            typedef typename type_trait< T_test1 >::type type;
    };
    template<class T_action, class T_test1, class T_test2 >
    struct lambda_action_deduce_result_type< logical< T_action >, T_test1, T_test2 >
    {
            typedef bool type;
    };
    template<class T_action, class T_test1, class T_test2 >
    struct lambda_action_deduce_result_type< relational< T_action >, T_test1, T_test2 >
    {
            typedef bool type;
    };
    template<class T_action, class T_test1, class T_test2 >
    struct lambda_action_deduce_result_type< arithmetic_assign< T_action >, T_test1, T_test2 >
    {
            typedef T_test1 type;
    };
    template<class T_action, class T_test1, class T_test2 >
    struct lambda_action_deduce_result_type< bitwise_assign< T_action >, T_test1, T_test2 >
    {
            typedef T_test1 type;
    };
    template<class T_test1, class T_test2 >
    struct lambda_action_deduce_result_type< other< subscript >, T_test1, T_test2 >
    {
            typedef typename type_trait< typename dereference_trait< T_test1 >::type >::pass type;
    };
    template<class T_action, class T_test >
    struct lambda_action_unary_deduce_result_type
    {
            typedef typename type_trait< T_test >::type type;
    };
    template<class T_action, class T_type, class T_test >
    struct lambda_action_convert_deduce_result_type
    {
            typedef typename type_trait< T_type >::type type;
    };
    template<class T_action, class T_test >
    struct lambda_action_unary_deduce_result_type< unary_logical< T_action >, T_test >
    {
            typedef bool type;
    };
    template<class T_test >
    struct lambda_action_unary_deduce_result_type< unary_other< address >, T_test >
    {
            typedef typename type_trait< T_test >::pointer type;
    };
    template<class T_test >
    struct lambda_action_unary_deduce_result_type< unary_other< dereference >, T_test >
    {
            typedef typename type_trait< typename dereference_trait< T_test >::type >::pass type;
    };
    template<class T_action >
    struct lambda_action
    {
    };
    template<class T_action >
    struct lambda_action_unary
    {
    };
    template<class T_action, class T_type >
    struct lambda_action_convert
    {
    };
    template<>
    struct lambda_action< arithmetic< plus > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< arithmetic< plus >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 + _A_2;
            }
    };
    template<>
    struct lambda_action< arithmetic< minus > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< arithmetic< minus >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 - _A_2;
            }
    };
    template<>
    struct lambda_action< arithmetic< multiplies > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< arithmetic< multiplies >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 * _A_2;
            }
    };
    template<>
    struct lambda_action< arithmetic< divides > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< arithmetic< divides >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 / _A_2;
            }
    };
    template<>
    struct lambda_action< arithmetic< modulus > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< arithmetic< modulus >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 % _A_2;
            }
    };
    template<>
    struct lambda_action< bitwise< leftshift > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< bitwise< leftshift >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 << _A_2;
            }
    };
    template<>
    struct lambda_action< bitwise< rightshift > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< bitwise< rightshift >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 >> _A_2;
            }
    };
    template<>
    struct lambda_action< bitwise< and_ > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< bitwise< and_ >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 & _A_2;
            }
    };
    template<>
    struct lambda_action< bitwise< or_ > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< bitwise< or_ >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 | _A_2;
            }
    };
    template<>
    struct lambda_action< bitwise< xor_ > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< bitwise< xor_ >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 ^ _A_2;
            }
    };
    template<>
    struct lambda_action< logical< and_ > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< logical< and_ >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 && _A_2;
            }
    };
    template<>
    struct lambda_action< logical< or_ > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< logical< or_ >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 || _A_2;
            }
    };
    template<>
    struct lambda_action< relational< less > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< relational< less >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 < _A_2;
            }
    };
    template<>
    struct lambda_action< relational< greater > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< relational< greater >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 > _A_2;
            }
    };
    template<>
    struct lambda_action< relational< less_equal > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< relational< less_equal >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 <= _A_2;
            }
    };
    template<>
    struct lambda_action< relational< greater_equal > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< relational< greater_equal >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 >= _A_2;
            }
    };
    template<>
    struct lambda_action< relational< equal_to > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< relational< equal_to >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 == _A_2;
            }
    };
    template<>
    struct lambda_action< relational< not_equal_to > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< relational< not_equal_to >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 != _A_2;
            }
    };
    template<>
    struct lambda_action< arithmetic_assign< plus > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< arithmetic_assign< plus >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 += _A_2;
            }
    };
    template<>
    struct lambda_action< arithmetic_assign< minus > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< arithmetic_assign< minus >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 -= _A_2;
            }
    };
    template<>
    struct lambda_action< arithmetic_assign< multiplies > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< arithmetic_assign< multiplies >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 *= _A_2;
            }
    };
    template<>
    struct lambda_action< arithmetic_assign< divides > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< arithmetic_assign< divides >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 /= _A_2;
            }
    };
    template<>
    struct lambda_action< arithmetic_assign< modulus > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< arithmetic_assign< modulus >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 %= _A_2;
            }
    };
    template<>
    struct lambda_action< bitwise_assign< leftshift > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< bitwise_assign< leftshift >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 <<= _A_2;
            }
    };
    template<>
    struct lambda_action< bitwise_assign< rightshift > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< bitwise_assign< rightshift >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 >>= _A_2;
            }
    };
    template<>
    struct lambda_action< bitwise_assign< and_ > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< bitwise_assign< and_ >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 &= _A_2;
            }
    };
    template<>
    struct lambda_action< bitwise_assign< or_ > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< bitwise_assign< or_ >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 |= _A_2;
            }
    };
    template<>
    struct lambda_action< bitwise_assign< xor_ > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< bitwise_assign< xor_ >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 ^= _A_2;
            }
    };
    template<>
    struct lambda_action< other< subscript > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< other< subscript >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1[_A_2];
            }
    };
    template<>
    struct lambda_action< other< assign > >
    {
            template<class T_arg1, class T_arg2 >
            static typename lambda_action_deduce_result_type< other< assign >, T_arg1, T_arg2 >::type do_action(T_arg1 _A_1, T_arg2 _A_2)
            {
                return _A_1 = _A_2;
            }
    };
    template<>
    struct lambda_action_unary< unary_arithmetic< pre_increment > >
    {
            template<class T_arg >
            static typename lambda_action_unary_deduce_result_type< unary_arithmetic< pre_increment >, T_arg >::type do_action(T_arg _Aa)
            {
                return ++_Aa;
            }
    };
    template<>
    struct lambda_action_unary< unary_arithmetic< pre_decrement > >
    {
            template<class T_arg >
            static typename lambda_action_unary_deduce_result_type< unary_arithmetic< pre_decrement >, T_arg >::type do_action(T_arg _Aa)
            {
                return --_Aa;
            }
    };
    template<>
    struct lambda_action_unary< unary_arithmetic< negate > >
    {
            template<class T_arg >
            static typename lambda_action_unary_deduce_result_type< unary_arithmetic< negate >, T_arg >::type do_action(T_arg _Aa)
            {
                return -_Aa;
            }
    };
    template<>
    struct lambda_action_unary< unary_bitwise< not_ > >
    {
            template<class T_arg >
            static typename lambda_action_unary_deduce_result_type< unary_bitwise< not_ >, T_arg >::type do_action(T_arg _Aa)
            {
                return ~_Aa;
            }
    };
    template<>
    struct lambda_action_unary< unary_logical< not_ > >
    {
            template<class T_arg >
            static typename lambda_action_unary_deduce_result_type< unary_logical< not_ >, T_arg >::type do_action(T_arg _Aa)
            {
                return !_Aa;
            }
    };
    template<>
    struct lambda_action_unary< unary_other< address > >
    {
            template<class T_arg >
            static typename lambda_action_unary_deduce_result_type< unary_other< address >, T_arg >::type do_action(T_arg _Aa)
            {
                return &_Aa;
            }
    };
    template<>
    struct lambda_action_unary< unary_other< dereference > >
    {
            template<class T_arg >
            static typename lambda_action_unary_deduce_result_type< unary_other< dereference >, T_arg >::type do_action(T_arg _Aa)
            {
                return *_Aa;
            }
    };
    template<class T_type >
    struct lambda_action_convert< cast_< reinterpret_ >, T_type >
    {
            template<class T_arg >
            static typename lambda_action_convert_deduce_result_type< cast_< reinterpret_ >, T_type, T_arg >::type do_action(T_arg _Aa)
            {
                return reinterpret_cast<T_type >(_Aa);
            }
    };
    template<class T_type >
    struct lambda_action_convert< cast_< static_ >, T_type >
    {
            template<class T_arg >
            static typename lambda_action_convert_deduce_result_type< cast_< static_ >, T_type, T_arg >::type do_action(T_arg _Aa)
            {
                return static_cast<T_type >(_Aa);
            }
    };
    template<class T_type >
    struct lambda_action_convert< cast_< dynamic_ >, T_type >
    {
            template<class T_arg >
            static typename lambda_action_convert_deduce_result_type< cast_< dynamic_ >, T_type, T_arg >::type do_action(T_arg _Aa)
            {
                return dynamic_cast<T_type >(_Aa);
            }
    };
    template<class T_action, class T_type1, class T_type2 >
    struct lambda_operator : public lambda_base
    {
            typedef typename lambda< T_type1 >::lambda_type arg1_type;
            typedef typename lambda< T_type2 >::lambda_type arg2_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename arg1_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type left_type;
                    typedef typename arg2_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type right_type;
                    typedef typename lambda_action_deduce_result_type< T_action, left_type, right_type >::type type;
            };
            typedef typename lambda_action_deduce_result_type< T_action, typename arg1_type::result_type, typename arg2_type::result_type >::type result_type;
            result_type operator ()() const;
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_1) const
            {
                return lambda_action< T_action >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass >::left_type, typename deduce_result_type< typename type_trait< T_arg1 >::pass >::right_type >(arg1_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_1), arg2_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_1));
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2) const
            {
                return lambda_action< T_action >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >::left_type, typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >::right_type >(arg1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_1, _A_2), arg2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_1, _A_2));
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3) const
            {
                return lambda_action< T_action >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >::left_type, typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >::right_type >(arg1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_1, _A_2, _A_3), arg2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_1, _A_2, _A_3));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4) const
            {
                return lambda_action< T_action >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >::left_type, typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >::right_type >(arg1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_1, _A_2, _A_3, _A_4), arg2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_1, _A_2, _A_3, _A_4));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5) const
            {
                return lambda_action< T_action >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >::left_type, typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >::right_type >(arg1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5), arg2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5, T_arg6 _A_6) const
            {
                return lambda_action< T_action >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >::left_type, typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >::right_type >(arg1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6), arg2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5, T_arg6 _A_6, T_arg7 _A_7) const
            {
                return lambda_action< T_action >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::left_type, typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::right_type >(arg1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6, _A_7), arg2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6, _A_7));
            }
            lambda_operator(typename type_trait< T_type1 >::take a1, typename type_trait< T_type2 >::take a2)
                : arg1_(a1), arg2_(a2) 
            {
            }
            arg1_type arg1_;
            arg2_type arg2_;
    };
    template<class T_action, class T_type1, class T_type2 >
    typename lambda_operator< T_action, T_type1, T_type2 >::result_type lambda_operator< T_action, T_type1, T_type2 >::operator ()() const
    {
        return lambda_action< T_action >::template do_action< typename arg1_type::result_type, typename arg2_type::result_type >(arg1_(), arg2_());
    }
    template<class T_action, class T_lambda_action, class T_arg1, class T_arg2 >
    void visit_each(const T_action & _A_action, const lambda_operator< T_lambda_action, T_arg1, T_arg2 > & _A_target)
    {
        visit_each(_A_action, _A_target.arg1_);
        visit_each(_A_action, _A_target.arg2_);
    }
    template<class T_action, class T_type >
    struct lambda_operator_unary : public lambda_base
    {
            typedef typename lambda< T_type >::lambda_type arg_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename arg_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type operand_type;
                    typedef typename lambda_action_unary_deduce_result_type< T_action, operand_type >::type type;
            };
            typedef typename lambda_action_unary_deduce_result_type< T_action, typename arg_type::result_type >::type result_type;
            result_type operator ()() const;
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_1) const
            {
                return lambda_action_unary< T_action >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass >::operand_type >(arg_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_1));
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2) const
            {
                return lambda_action_unary< T_action >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >::operand_type >(arg_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_1, _A_2));
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3) const
            {
                return lambda_action_unary< T_action >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >::operand_type >(arg_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_1, _A_2, _A_3));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4) const
            {
                return lambda_action_unary< T_action >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >::operand_type >(arg_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_1, _A_2, _A_3, _A_4));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5) const
            {
                return lambda_action_unary< T_action >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >::operand_type >(arg_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5, T_arg6 _A_6) const
            {
                return lambda_action_unary< T_action >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >::operand_type >(arg_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5, T_arg6 _A_6, T_arg7 _A_7) const
            {
                return lambda_action_unary< T_action >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::operand_type >(arg_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6, _A_7));
            }
            lambda_operator_unary(typename type_trait< T_type >::take a)
                : arg_(a) 
            {
            }
            arg_type arg_;
    };
    template<class T_action, class T_type >
    typename lambda_operator_unary< T_action, T_type >::result_type lambda_operator_unary< T_action, T_type >::operator ()() const
    {
        return lambda_action_unary< T_action >::template do_action< typename arg_type::result_type >(arg_());
    }
    template<class T_action, class T_lambda_action, class T_arg >
    void visit_each(const T_action & _A_action, const lambda_operator_unary< T_lambda_action, T_arg > & _A_target)
    {
        visit_each(_A_action, _A_target.arg_);
    }
    template<class T_action, class T_type, class T_arg >
    struct lambda_operator_convert : public lambda_base
    {
            typedef typename lambda< T_arg >::lambda_type arg_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename arg_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type operand_type;
                    typedef typename lambda_action_convert_deduce_result_type< T_action, T_type, operand_type >::type type;
            };
            typedef typename lambda_action_convert_deduce_result_type< T_action, T_type, typename arg_type::result_type >::type result_type;
            result_type operator ()() const;
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_1) const
            {
                return lambda_action_convert< T_action, T_type >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass >::operand_type >(arg_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_1));
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2) const
            {
                return lambda_action_convert< T_action, T_type >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >::operand_type >(arg_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_1, _A_2));
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3) const
            {
                return lambda_action_convert< T_action, T_type >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >::operand_type >(arg_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_1, _A_2, _A_3));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4) const
            {
                return lambda_action_convert< T_action, T_type >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >::operand_type >(arg_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_1, _A_2, _A_3, _A_4));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5) const
            {
                return lambda_action_convert< T_action, T_type >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >::operand_type >(arg_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5, T_arg6 _A_6) const
            {
                return lambda_action_convert< T_action, T_type >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >::operand_type >(arg_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5, T_arg6 _A_6, T_arg7 _A_7) const
            {
                return lambda_action_convert< T_action, T_type >::template do_action< typename deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::operand_type >(arg_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6, _A_7));
            }
            lambda_operator_convert(typename type_trait< T_arg >::take a)
                : arg_(a) 
            {
            }
            arg_type arg_;
    };
    template<class T_action, class T_type, class T_arg >
    typename lambda_operator_convert< T_action, T_type, T_arg >::result_type lambda_operator_convert< T_action, T_type, T_arg >::operator ()() const
    {
        return lambda_action_convert< T_action, T_type >::template do_action< typename arg_type::result_type >(arg_());
    }
    template<class T_action, class T_lambda_action, class T_type, class T_arg >
    void visit_each(const T_action & _A_action, const lambda_operator_convert< T_lambda_action, T_type, T_arg > & _A_target)
    {
        visit_each(_A_action, _A_target.arg_);
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic< plus >, T_arg1, T_arg2 > > operator +(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic< plus >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic< plus >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator +(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< arithmetic< plus >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic< plus >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator +(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic< plus >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic< minus >, T_arg1, T_arg2 > > operator -(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic< minus >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic< minus >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator -(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< arithmetic< minus >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic< minus >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator -(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic< minus >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic< multiplies >, T_arg1, T_arg2 > > operator *(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic< multiplies >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic< multiplies >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator *(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< arithmetic< multiplies >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic< multiplies >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator *(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic< multiplies >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic< divides >, T_arg1, T_arg2 > > operator /(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic< divides >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic< divides >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator /(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< arithmetic< divides >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic< divides >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator /(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic< divides >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic< modulus >, T_arg1, T_arg2 > > operator %(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic< modulus >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic< modulus >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator %(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< arithmetic< modulus >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic< modulus >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator %(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic< modulus >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise< leftshift >, T_arg1, T_arg2 > > operator <<(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise< leftshift >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise< leftshift >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator <<(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< bitwise< leftshift >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise< leftshift >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator <<(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise< leftshift >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise< rightshift >, T_arg1, T_arg2 > > operator >>(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise< rightshift >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise< rightshift >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator >>(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< bitwise< rightshift >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise< rightshift >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator >>(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise< rightshift >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise< and_ >, T_arg1, T_arg2 > > operator &(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise< and_ >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise< and_ >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator &(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< bitwise< and_ >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise< and_ >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator &(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise< and_ >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise< or_ >, T_arg1, T_arg2 > > operator |(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise< or_ >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise< or_ >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator |(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< bitwise< or_ >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise< or_ >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator |(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise< or_ >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise< xor_ >, T_arg1, T_arg2 > > operator ^(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise< xor_ >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise< xor_ >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator ^(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< bitwise< xor_ >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise< xor_ >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator ^(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise< xor_ >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< logical< and_ >, T_arg1, T_arg2 > > operator &&(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< logical< and_ >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< logical< and_ >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator &&(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< logical< and_ >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< logical< and_ >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator &&(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< logical< and_ >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< logical< or_ >, T_arg1, T_arg2 > > operator ||(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< logical< or_ >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< logical< or_ >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator ||(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< logical< or_ >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< logical< or_ >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator ||(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< logical< or_ >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< less >, T_arg1, T_arg2 > > operator <(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< relational< less >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< less >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator <(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< relational< less >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< less >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator <(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< relational< less >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< greater >, T_arg1, T_arg2 > > operator >(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< relational< greater >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< greater >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator >(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< relational< greater >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< greater >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator >(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< relational< greater >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< less_equal >, T_arg1, T_arg2 > > operator <=(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< relational< less_equal >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< less_equal >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator <=(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< relational< less_equal >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< less_equal >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator <=(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< relational< less_equal >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< greater_equal >, T_arg1, T_arg2 > > operator >=(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< relational< greater_equal >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< greater_equal >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator >=(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< relational< greater_equal >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< greater_equal >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator >=(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< relational< greater_equal >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< equal_to >, T_arg1, T_arg2 > > operator ==(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< relational< equal_to >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< equal_to >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator ==(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< relational< equal_to >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< equal_to >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator ==(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< relational< equal_to >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< not_equal_to >, T_arg1, T_arg2 > > operator !=(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< relational< not_equal_to >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< not_equal_to >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator !=(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< relational< not_equal_to >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< relational< not_equal_to >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator !=(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< relational< not_equal_to >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic_assign< plus >, T_arg1, T_arg2 > > operator +=(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic_assign< plus >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic_assign< plus >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator +=(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< arithmetic_assign< plus >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic_assign< plus >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator +=(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic_assign< plus >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic_assign< minus >, T_arg1, T_arg2 > > operator -=(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic_assign< minus >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic_assign< minus >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator -=(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< arithmetic_assign< minus >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic_assign< minus >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator -=(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic_assign< minus >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic_assign< multiplies >, T_arg1, T_arg2 > > operator *=(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic_assign< multiplies >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic_assign< multiplies >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator *=(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< arithmetic_assign< multiplies >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic_assign< multiplies >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator *=(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic_assign< multiplies >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic_assign< divides >, T_arg1, T_arg2 > > operator /=(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic_assign< divides >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic_assign< divides >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator /=(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< arithmetic_assign< divides >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic_assign< divides >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator /=(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic_assign< divides >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic_assign< modulus >, T_arg1, T_arg2 > > operator %=(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic_assign< modulus >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic_assign< modulus >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator %=(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< arithmetic_assign< modulus >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< arithmetic_assign< modulus >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator %=(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< arithmetic_assign< modulus >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise_assign< leftshift >, T_arg1, T_arg2 > > operator <<=(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise_assign< leftshift >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise_assign< leftshift >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator <<=(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< bitwise_assign< leftshift >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise_assign< leftshift >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator <<=(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise_assign< leftshift >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise_assign< rightshift >, T_arg1, T_arg2 > > operator >>=(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise_assign< rightshift >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise_assign< rightshift >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator >>=(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< bitwise_assign< rightshift >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise_assign< rightshift >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator >>=(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise_assign< rightshift >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise_assign< and_ >, T_arg1, T_arg2 > > operator &=(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise_assign< and_ >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise_assign< and_ >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator &=(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< bitwise_assign< and_ >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise_assign< and_ >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator &=(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise_assign< and_ >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise_assign< or_ >, T_arg1, T_arg2 > > operator |=(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise_assign< or_ >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise_assign< or_ >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator |=(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< bitwise_assign< or_ >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise_assign< or_ >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator |=(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise_assign< or_ >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise_assign< xor_ >, T_arg1, T_arg2 > > operator ^=(const lambda< T_arg1 > & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise_assign< xor_ >, T_arg1, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2.value_));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise_assign< xor_ >, T_arg1, typename unwrap_reference< T_arg2 >::type > > operator ^=(const lambda< T_arg1 > & a1, const T_arg2 & a2)
    {
        typedef lambda_operator< bitwise_assign< xor_ >, T_arg1, typename unwrap_reference< T_arg2 >::type > operator_type;
        return lambda< operator_type >(operator_type(a1.value_, a2));
    }
    template<class T_arg1, class T_arg2 >
    lambda< lambda_operator< bitwise_assign< xor_ >, typename unwrap_reference< T_arg1 >::type, T_arg2 > > operator ^=(const T_arg1 & a1, const lambda< T_arg2 > & a2)
    {
        typedef lambda_operator< bitwise_assign< xor_ >, typename unwrap_reference< T_arg1 >::type, T_arg2 > operator_type;
        return lambda< operator_type >(operator_type(a1, a2.value_));
    }
    template<class T_arg >
    lambda< lambda_operator_unary< unary_arithmetic< pre_increment >, T_arg > > operator ++(const lambda< T_arg > & a)
    {
        typedef lambda_operator_unary< unary_arithmetic< pre_increment >, T_arg > operator_type;
        return lambda< operator_type >(operator_type(a.value_));
    }
    template<class T_arg >
    lambda< lambda_operator_unary< unary_arithmetic< pre_decrement >, T_arg > > operator --(const lambda< T_arg > & a)
    {
        typedef lambda_operator_unary< unary_arithmetic< pre_decrement >, T_arg > operator_type;
        return lambda< operator_type >(operator_type(a.value_));
    }
    template<class T_arg >
    lambda< lambda_operator_unary< unary_arithmetic< negate >, T_arg > > operator -(const lambda< T_arg > & a)
    {
        typedef lambda_operator_unary< unary_arithmetic< negate >, T_arg > operator_type;
        return lambda< operator_type >(operator_type(a.value_));
    }
    template<class T_arg >
    lambda< lambda_operator_unary< unary_bitwise< not_ >, T_arg > > operator ~(const lambda< T_arg > & a)
    {
        typedef lambda_operator_unary< unary_bitwise< not_ >, T_arg > operator_type;
        return lambda< operator_type >(operator_type(a.value_));
    }
    template<class T_arg >
    lambda< lambda_operator_unary< unary_logical< not_ >, T_arg > > operator !(const lambda< T_arg > & a)
    {
        typedef lambda_operator_unary< unary_logical< not_ >, T_arg > operator_type;
        return lambda< operator_type >(operator_type(a.value_));
    }
    template<class T_arg >
    lambda< lambda_operator_unary< unary_other< address >, T_arg > > operator &(const lambda< T_arg > & a)
    {
        typedef lambda_operator_unary< unary_other< address >, T_arg > operator_type;
        return lambda< operator_type >(operator_type(a.value_));
    }
    template<class T_arg >
    lambda< lambda_operator_unary< unary_other< dereference >, T_arg > > operator *(const lambda< T_arg > & a)
    {
        typedef lambda_operator_unary< unary_other< dereference >, T_arg > operator_type;
        return lambda< operator_type >(operator_type(a.value_));
    }
    template<class T_type, class T_arg >
    lambda< lambda_operator_convert< cast_< reinterpret_ >, T_type, typename unwrap_lambda_type< T_arg >::type > > reinterpret_cast_(const T_arg & a)
    {
        typedef lambda_operator_convert< cast_< reinterpret_ >, T_type, typename unwrap_lambda_type< T_arg >::type > operator_type;
        return lambda< operator_type >(operator_type(unwrap_lambda_value(a)));
    }
    template<class T_type, class T_arg >
    lambda< lambda_operator_convert< cast_< static_ >, T_type, typename unwrap_lambda_type< T_arg >::type > > static_cast_(const T_arg & a)
    {
        typedef lambda_operator_convert< cast_< static_ >, T_type, typename unwrap_lambda_type< T_arg >::type > operator_type;
        return lambda< operator_type >(operator_type(unwrap_lambda_value(a)));
    }
    template<class T_type, class T_arg >
    lambda< lambda_operator_convert< cast_< dynamic_ >, T_type, typename unwrap_lambda_type< T_arg >::type > > dynamic_cast_(const T_arg & a)
    {
        typedef lambda_operator_convert< cast_< dynamic_ >, T_type, typename unwrap_lambda_type< T_arg >::type > operator_type;
        return lambda< operator_type >(operator_type(unwrap_lambda_value(a)));
    }
}
namespace sigc {
    template<class T_functor, class T_type1 >
    struct lambda_group1 : public lambda_base
    {
            typedef typename functor_trait< T_functor >::result_type result_type;
            typedef typename lambda< T_type1 >::lambda_type value1_type;
            typedef typename adaptor_trait< T_functor >::adaptor_type functor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename functor_type::template deduce_result_type< typename value1_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type >::type type;
            };
            result_type operator ()() const;
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_1) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_1));
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_1, _A_2));
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2, T_arg3 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_1, _A_2, _A_3));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_1, _A_2, _A_3, _A_4));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5, T_arg6 _A_6) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5, T_arg6 _A_6, T_arg7 _A_7) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6, _A_7));
            }
            lambda_group1(typename type_trait< T_functor >::take _A_func, typename type_trait< T_type1 >::take _A_1)
                : value1_(_A_1), func_(_A_func) 
            {
            }
            value1_type value1_;
            mutable functor_type func_;
    };
    template<class T_functor, class T_type1 >
    typename lambda_group1< T_functor, T_type1 >::result_type lambda_group1< T_functor, T_type1 >::operator ()() const
    {
        return func_(value1_());
    }
    template<class T_action, class T_functor, class T_type1 >
    void visit_each(const T_action & _A_action, const lambda_group1< T_functor, T_type1 > & _A_target)
    {
        visit_each(_A_action, _A_target.value1_);
        visit_each(_A_action, _A_target.func_);
    }
    template<class T_functor, class T_type1, class T_type2 >
    struct lambda_group2 : public lambda_base
    {
            typedef typename functor_trait< T_functor >::result_type result_type;
            typedef typename lambda< T_type1 >::lambda_type value1_type;
            typedef typename lambda< T_type2 >::lambda_type value2_type;
            typedef typename adaptor_trait< T_functor >::adaptor_type functor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename functor_type::template deduce_result_type< typename value1_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type, typename value2_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type >::type type;
            };
            result_type operator ()() const;
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_1) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1 >::type, typename value2_type::template deduce_result_type< T_arg1 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_1), this->value2_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_1));
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2 >::type, typename value2_type::template deduce_result_type< T_arg1, T_arg2 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_1, _A_2), this->value2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_1, _A_2));
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2, T_arg3 >::type, typename value2_type::template deduce_result_type< T_arg1, T_arg2, T_arg3 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_1, _A_2, _A_3), this->value2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_1, _A_2, _A_3));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type, typename value2_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_1, _A_2, _A_3, _A_4), this->value2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_1, _A_2, _A_3, _A_4));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type, typename value2_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5), this->value2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5, T_arg6 _A_6) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type, typename value2_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6), this->value2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5, T_arg6 _A_6, T_arg7 _A_7) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type, typename value2_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6, _A_7), this->value2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6, _A_7));
            }
            lambda_group2(typename type_trait< T_functor >::take _A_func, typename type_trait< T_type1 >::take _A_1, typename type_trait< T_type2 >::take _A_2)
                : value1_(_A_1), value2_(_A_2), func_(_A_func) 
            {
            }
            value1_type value1_;
            value2_type value2_;
            mutable functor_type func_;
    };
    template<class T_functor, class T_type1, class T_type2 >
    typename lambda_group2< T_functor, T_type1, T_type2 >::result_type lambda_group2< T_functor, T_type1, T_type2 >::operator ()() const
    {
        return func_(value1_(), value2_());
    }
    template<class T_action, class T_functor, class T_type1, class T_type2 >
    void visit_each(const T_action & _A_action, const lambda_group2< T_functor, T_type1, T_type2 > & _A_target)
    {
        visit_each(_A_action, _A_target.value1_);
        visit_each(_A_action, _A_target.value2_);
        visit_each(_A_action, _A_target.func_);
    }
    template<class T_functor, class T_type1, class T_type2, class T_type3 >
    struct lambda_group3 : public lambda_base
    {
            typedef typename functor_trait< T_functor >::result_type result_type;
            typedef typename lambda< T_type1 >::lambda_type value1_type;
            typedef typename lambda< T_type2 >::lambda_type value2_type;
            typedef typename lambda< T_type3 >::lambda_type value3_type;
            typedef typename adaptor_trait< T_functor >::adaptor_type functor_type;
            template<class T_arg1 = void, class T_arg2 = void, class T_arg3 = void, class T_arg4 = void, class T_arg5 = void, class T_arg6 = void, class T_arg7 = void >
            struct deduce_result_type
            {
                    typedef typename functor_type::template deduce_result_type< typename value1_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type, typename value2_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type, typename value3_type::template deduce_result_type< typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >::type >::type type;
            };
            result_type operator ()() const;
            template<class T_arg1 >
            typename deduce_result_type< T_arg1 >::type operator ()(T_arg1 _A_1) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1 >::type, typename value2_type::template deduce_result_type< T_arg1 >::type, typename value3_type::template deduce_result_type< T_arg1 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_1), this->value2_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_1), this->value3_.template operator ()<typename type_trait< T_arg1 >::pass >(_A_1));
            }
            template<class T_arg1, class T_arg2 >
            typename deduce_result_type< T_arg1, T_arg2 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2 >::type, typename value2_type::template deduce_result_type< T_arg1, T_arg2 >::type, typename value3_type::template deduce_result_type< T_arg1, T_arg2 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_1, _A_2), this->value2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_1, _A_2), this->value3_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass >(_A_1, _A_2));
            }
            template<class T_arg1, class T_arg2, class T_arg3 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2, T_arg3 >::type, typename value2_type::template deduce_result_type< T_arg1, T_arg2, T_arg3 >::type, typename value3_type::template deduce_result_type< T_arg1, T_arg2, T_arg3 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_1, _A_2, _A_3), this->value2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_1, _A_2, _A_3), this->value3_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass >(_A_1, _A_2, _A_3));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type, typename value2_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type, typename value3_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_1, _A_2, _A_3, _A_4), this->value2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_1, _A_2, _A_3, _A_4), this->value3_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass >(_A_1, _A_2, _A_3, _A_4));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type, typename value2_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type, typename value3_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5), this->value2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5), this->value3_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5, T_arg6 _A_6) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type, typename value2_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type, typename value3_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6), this->value2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6), this->value3_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6));
            }
            template<class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7 >
            typename deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type operator ()(T_arg1 _A_1, T_arg2 _A_2, T_arg3 _A_3, T_arg4 _A_4, T_arg5 _A_5, T_arg6 _A_6, T_arg7 _A_7) const
            {
                return this->func_.template operator ()<typename value1_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type, typename value2_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type, typename value3_type::template deduce_result_type< T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 >::type >(this->value1_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6, _A_7), this->value2_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6, _A_7), this->value3_.template operator ()<typename type_trait< T_arg1 >::pass, typename type_trait< T_arg2 >::pass, typename type_trait< T_arg3 >::pass, typename type_trait< T_arg4 >::pass, typename type_trait< T_arg5 >::pass, typename type_trait< T_arg6 >::pass, typename type_trait< T_arg7 >::pass >(_A_1, _A_2, _A_3, _A_4, _A_5, _A_6, _A_7));
            }
            lambda_group3(typename type_trait< T_functor >::take _A_func, typename type_trait< T_type1 >::take _A_1, typename type_trait< T_type2 >::take _A_2, typename type_trait< T_type3 >::take _A_3)
                : value1_(_A_1), value2_(_A_2), value3_(_A_3), func_(_A_func) 
            {
            }
            value1_type value1_;
            value2_type value2_;
            value3_type value3_;
            mutable functor_type func_;
    };
    template<class T_functor, class T_type1, class T_type2, class T_type3 >
    typename lambda_group3< T_functor, T_type1, T_type2, T_type3 >::result_type lambda_group3< T_functor, T_type1, T_type2, T_type3 >::operator ()() const
    {
        return func_(value1_(), value2_(), value3_());
    }
    template<class T_action, class T_functor, class T_type1, class T_type2, class T_type3 >
    void visit_each(const T_action & _A_action, const lambda_group3< T_functor, T_type1, T_type2, T_type3 > & _A_target)
    {
        visit_each(_A_action, _A_target.value1_);
        visit_each(_A_action, _A_target.value2_);
        visit_each(_A_action, _A_target.value3_);
        visit_each(_A_action, _A_target.func_);
    }
    template<class T_functor, class T_type1 >
    lambda< lambda_group1< T_functor, typename unwrap_reference< T_type1 >::type > > group(const T_functor & _A_func, T_type1 _A_1)
    {
        typedef lambda_group1< T_functor, typename unwrap_reference< T_type1 >::type > T_lambda;
        return lambda< T_lambda >(T_lambda(_A_func, _A_1));
    }
    template<class T_functor, class T_type1, class T_type2 >
    lambda< lambda_group2< T_functor, typename unwrap_reference< T_type1 >::type, typename unwrap_reference< T_type2 >::type > > group(const T_functor & _A_func, T_type1 _A_1, T_type2 _A_2)
    {
        typedef lambda_group2< T_functor, typename unwrap_reference< T_type1 >::type, typename unwrap_reference< T_type2 >::type > T_lambda;
        return lambda< T_lambda >(T_lambda(_A_func, _A_1, _A_2));
    }
    template<class T_functor, class T_type1, class T_type2, class T_type3 >
    lambda< lambda_group3< T_functor, typename unwrap_reference< T_type1 >::type, typename unwrap_reference< T_type2 >::type, typename unwrap_reference< T_type3 >::type > > group(const T_functor & _A_func, T_type1 _A_1, T_type2 _A_2, T_type3 _A_3)
    {
        typedef lambda_group3< T_functor, typename unwrap_reference< T_type1 >::type, typename unwrap_reference< T_type2 >::type, typename unwrap_reference< T_type3 >::type > T_lambda;
        return lambda< T_lambda >(T_lambda(_A_func, _A_1, _A_2, _A_3));
    }
}
typedef struct _GObject GObject;
typedef struct _GClosure GClosure;
namespace Glib {
    class SignalProxyConnectionNode
    {
        public :
            SignalProxyConnectionNode(const sigc::slot_base & slot, GObject * gobject);
            static void * notify(void * data);
            static void destroy_notify_handler(gpointer data, GClosure * closure);
            gulong connection_id_;
            sigc::slot_base slot_;
        protected :
            GObject * object_;
    };
}
namespace Glib {
    class ObjectBase;
    struct SignalProxyInfo
    {
            const char * signal_name;
            GCallback callback;
            GCallback notify_callback;
    };
    class SignalProxyBase
    {
        public :
            SignalProxyBase(Glib::ObjectBase * obj);
            static inline sigc::slot_base * data_to_slot(void * data)
            {
                SignalProxyConnectionNode *const pConnectionNode = static_cast<SignalProxyConnectionNode * >(data);
                return (!pConnectionNode->slot_.blocked()) ? &pConnectionNode->slot_ : 0;
            }
        protected :
            ObjectBase * obj_;
        private :
            SignalProxyBase & operator =(const SignalProxyBase &);
    };
    class SignalProxyNormal : public SignalProxyBase
    {
        public :
            ~SignalProxyNormal();
            void emission_stop();
            static void slot0_void_callback(GObject *, void * data);
        protected :
            SignalProxyNormal(Glib::ObjectBase * obj, const SignalProxyInfo * info);
            sigc::slot_base & connect_(const sigc::slot_base & slot, bool after);
            sigc::slot_base & connect_notify_(const sigc::slot_base & slot, bool after);
        private :
            const SignalProxyInfo * info_;
            sigc::slot_base & connect_impl_(GCallback callback, const sigc::slot_base & slot, bool after);
            SignalProxyNormal & operator =(const SignalProxyNormal &);
    };
    template<class R >
    class SignalProxy0 : public SignalProxyNormal
    {
        public :
            typedef sigc::slot< R > SlotType;
            typedef sigc::slot< void > VoidSlotType;
            SignalProxy0(ObjectBase * obj, const SignalProxyInfo * info)
                : SignalProxyNormal(obj, info) 
            {
            }
            sigc::connection connect(const SlotType & slot, bool after = true)
            {
                return sigc::connection(connect_(slot, after));
            }
            sigc::connection connect_notify(const VoidSlotType & slot, bool after = false)
            {
                return sigc::connection(connect_notify_(slot, after));
            }
    };
    template<class R, class P1 >
    class SignalProxy1 : public SignalProxyNormal
    {
        public :
            typedef sigc::slot< R, P1 > SlotType;
            typedef sigc::slot< void, P1 > VoidSlotType;
            SignalProxy1(ObjectBase * obj, const SignalProxyInfo * info)
                : SignalProxyNormal(obj, info) 
            {
            }
            sigc::connection connect(const SlotType & slot, bool after = true)
            {
                return sigc::connection(connect_(slot, after));
            }
            sigc::connection connect_notify(const VoidSlotType & slot, bool after = false)
            {
                return sigc::connection(connect_notify_(slot, after));
            }
    };
    template<class R, class P1, class P2 >
    class SignalProxy2 : public SignalProxyNormal
    {
        public :
            typedef sigc::slot< R, P1, P2 > SlotType;
            typedef sigc::slot< void, P1, P2 > VoidSlotType;
            SignalProxy2(ObjectBase * obj, const SignalProxyInfo * info)
                : SignalProxyNormal(obj, info) 
            {
            }
            sigc::connection connect(const SlotType & slot, bool after = true)
            {
                return sigc::connection(connect_(slot, after));
            }
            sigc::connection connect_notify(const VoidSlotType & slot, bool after = false)
            {
                return sigc::connection(connect_notify_(slot, after));
            }
    };
    template<class R, class P1, class P2, class P3 >
    class SignalProxy3 : public SignalProxyNormal
    {
        public :
            typedef sigc::slot< R, P1, P2, P3 > SlotType;
            typedef sigc::slot< void, P1, P2, P3 > VoidSlotType;
            SignalProxy3(ObjectBase * obj, const SignalProxyInfo * info)
                : SignalProxyNormal(obj, info) 
            {
            }
            sigc::connection connect(const SlotType & slot, bool after = true)
            {
                return sigc::connection(connect_(slot, after));
            }
            sigc::connection connect_notify(const VoidSlotType & slot, bool after = false)
            {
                return sigc::connection(connect_notify_(slot, after));
            }
    };
    template<class R, class P1, class P2, class P3, class P4 >
    class SignalProxy4 : public SignalProxyNormal
    {
        public :
            typedef sigc::slot< R, P1, P2, P3, P4 > SlotType;
            typedef sigc::slot< void, P1, P2, P3, P4 > VoidSlotType;
            SignalProxy4(ObjectBase * obj, const SignalProxyInfo * info)
                : SignalProxyNormal(obj, info) 
            {
            }
            sigc::connection connect(const SlotType & slot, bool after = true)
            {
                return sigc::connection(connect_(slot, after));
            }
            sigc::connection connect_notify(const VoidSlotType & slot, bool after = false)
            {
                return sigc::connection(connect_notify_(slot, after));
            }
    };
    template<class R, class P1, class P2, class P3, class P4, class P5 >
    class SignalProxy5 : public SignalProxyNormal
    {
        public :
            typedef sigc::slot< R, P1, P2, P3, P4, P5 > SlotType;
            typedef sigc::slot< void, P1, P2, P3, P4, P5 > VoidSlotType;
            SignalProxy5(ObjectBase * obj, const SignalProxyInfo * info)
                : SignalProxyNormal(obj, info) 
            {
            }
            sigc::connection connect(const SlotType & slot, bool after = true)
            {
                return sigc::connection(connect_(slot, after));
            }
            sigc::connection connect_notify(const VoidSlotType & slot, bool after = false)
            {
                return sigc::connection(connect_notify_(slot, after));
            }
    };
    template<class R, class P1, class P2, class P3, class P4, class P5, class P6 >
    class SignalProxy6 : public SignalProxyNormal
    {
        public :
            typedef sigc::slot< R, P1, P2, P3, P4, P5, P6 > SlotType;
            typedef sigc::slot< void, P1, P2, P3, P4, P5, P6 > VoidSlotType;
            SignalProxy6(ObjectBase * obj, const SignalProxyInfo * info)
                : SignalProxyNormal(obj, info) 
            {
            }
            sigc::connection connect(const SlotType & slot, bool after = true)
            {
                return sigc::connection(connect_(slot, after));
            }
            sigc::connection connect_notify(const VoidSlotType & slot, bool after = false)
            {
                return sigc::connection(connect_notify_(slot, after));
            }
    };
}
namespace Glib {
    class ObjectBase;
    class Object;
    class ValueBase
    {
        public :
            ValueBase();
            ValueBase(const ValueBase & other);
            ValueBase & operator =(const ValueBase & other);
            ~ValueBase();
            void init(GType type);
            void init(const GValue * value);
            void reset();
            GValue * gobj()
            {
                return &gobject_;
            }
            const GValue * gobj() const
            {
                return &gobject_;
            }
        protected :
            GValue gobject_;
    };
    class ValueBase_Boxed : public ValueBase
    {
        public :
            static GType value_type() __attribute__((__const__));
            GParamSpec * create_param_spec(const Glib::ustring & name) const;
        protected :
            void set_boxed(const void * data);
            void * get_boxed() const;
    };
    class ValueBase_Object : public ValueBase
    {
        public :
            static GType value_type() __attribute__((__const__));
            GParamSpec * create_param_spec(const Glib::ustring & name) const;
        protected :
            void set_object(Glib::ObjectBase * data);
            Glib::ObjectBase * get_object() const;
            Glib::RefPtr< Glib::ObjectBase > get_object_copy() const;
    };
    class ValueBase_Enum : public ValueBase
    {
        public :
            typedef gint CType;
            static GType value_type() __attribute__((__const__));
            GParamSpec * create_param_spec(const Glib::ustring & name) const;
        protected :
            void set_enum(int data);
            int get_enum() const;
    };
    class ValueBase_Flags : public ValueBase
    {
        public :
            typedef guint CType;
            static GType value_type() __attribute__((__const__));
            GParamSpec * create_param_spec(const Glib::ustring & name) const;
        protected :
            void set_flags(unsigned int data);
            unsigned int get_flags() const;
    };
    class ValueBase_String : public ValueBase
    {
        public :
            typedef const gchar * CType;
            static GType value_type() __attribute__((__const__));
            GParamSpec * create_param_spec(const Glib::ustring & name) const;
        protected :
            void set_cstring(const char * data);
            const char * get_cstring() const;
    };
}
#pragma GCC visibility push(default)
extern "C++"
{
    namespace __cxxabiv1 {
        class __class_type_info;
    }
    namespace std {
        class type_info
        {
            public :
                virtual ~type_info();
                const char * name() const
                {
                    return __name;
                }
                bool before(const type_info & __arg) const
                {
                    return __name < __arg.__name;
                }
                bool operator ==(const type_info & __arg) const
                {
                    return __name == __arg.__name;
                }
                bool operator !=(const type_info & __arg) const
                {
                    return !operator ==(__arg);
                }
                virtual bool __is_pointer_p() const;
                virtual bool __is_function_p() const;
                virtual bool __do_catch(const type_info * __thr_type, void * * __thr_obj, unsigned __outer) const;
                virtual bool __do_upcast(const __cxxabiv1::__class_type_info * __target, void * * __obj_ptr) const;
            protected :
                const char * __name;
                explicit type_info(const char * __n)
                    : __name(__n) 
                {
                }
            private :
                type_info & operator =(const type_info &);
                type_info(const type_info &);
        };
        class bad_cast : public exception
        {
            public :
                bad_cast() throw ()
                {
                }
                virtual ~bad_cast() throw ();
                virtual const char * what() const throw ();
        };
        class bad_typeid : public exception
        {
            public :
                bad_typeid() throw ()
                {
                }
                virtual ~bad_typeid() throw ();
                virtual const char * what() const throw ();
        };
    }
#pragma GCC visibility pop
}
namespace Glib {
    extern "C"
    {
        typedef void (* ValueInitFunc)(GValue *);
        typedef void (* ValueFreeFunc)(GValue *);
        typedef void (* ValueCopyFunc)(const GValue *, GValue *);
    }
    GType custom_boxed_type_register(const char * type_name, ValueInitFunc init_func, ValueFreeFunc free_func, ValueCopyFunc copy_func);
    GType custom_pointer_type_register(const char * type_name);
    template<class T, class PtrT >
    class Value_Pointer : public ValueBase_Object
    {
        public :
            typedef PtrT CppType;
            typedef void * CType;
            static inline GType value_type() __attribute__((__const__));
            inline void set(CppType data);
            inline CppType get() const;
        private :
            inline static GType value_type_(Glib::Object *);
            static GType value_type_(void *);
            inline void set_(CppType data, Glib::Object *);
            inline void set_(CppType data, void *);
            inline CppType get_(Glib::Object *) const;
            inline CppType get_(void *) const;
    };
    template<class T >
    class Value : public ValueBase_Boxed
    {
        public :
            typedef T CppType;
            typedef T * CType;
            static GType value_type() __attribute__((__const__));
            inline void set(const CppType & data);
            inline CppType get() const;
        private :
            static GType custom_type_;
            static void value_init_func(GValue * value);
            static void value_free_func(GValue * value);
            static void value_copy_func(const GValue * src_value, GValue * dest_value);
    };
    template<class T >
    class Value< T * > : public Value_Pointer< T, T * >
    {
    };
    template<class T >
    class Value< const T * > : public Value_Pointer< T, const T * >
    {
    };
    template<class T, class PtrT >
    inline GType Value_Pointer< T, PtrT >::value_type_(Glib::Object *)
    {
        return T::get_base_type();
    }
    template<class T, class PtrT >
    inline void Value_Pointer< T, PtrT >::set_(PtrT data, Glib::Object *)
    {
        set_object(const_cast<T * >(data));
    }
    template<class T, class PtrT >
    inline PtrT Value_Pointer< T, PtrT >::get_(Glib::Object *) const
    {
        return dynamic_cast<T * >(get_object());
    }
    template<class T, class PtrT >
    GType Value_Pointer< T, PtrT >::value_type_(void *)
    {
        static GType custom_type = 0;
        if (!custom_type)
            custom_type = Glib::custom_pointer_type_register(typeid(PtrT).name());
        return custom_type;
    }
    template<class T, class PtrT >
    inline void Value_Pointer< T, PtrT >::set_(PtrT data, void *)
    {
        gobject_.data[0].v_pointer = const_cast<T * >(data);
    }
    template<class T, class PtrT >
    inline PtrT Value_Pointer< T, PtrT >::get_(void *) const
    {
        return static_cast<T * >(gobject_.data[0].v_pointer);
    }
    template<class T, class PtrT >
    inline GType Value_Pointer< T, PtrT >::value_type()
    {
        return Value_Pointer< T, PtrT >::value_type_(static_cast<T * >(0));
    }
    template<class T, class PtrT >
    inline void Value_Pointer< T, PtrT >::set(PtrT data)
    {
        this->set_(data, static_cast<T * >(0));
    }
    template<class T, class PtrT >
    inline PtrT Value_Pointer< T, PtrT >::get() const
    {
        return this->get_(static_cast<T * >(0));
    }
    template<class T >
    GType Value< T >::custom_type_ = 0;
    template<class T >
    inline void Value< T >::set(const typename Value< T >::CppType & data)
    {
        *static_cast<T * >(gobject_.data[0].v_pointer) = data;
    }
    template<class T >
    inline typename Value< T >::CppType Value< T >::get() const
    {
        return *static_cast<T * >(gobject_.data[0].v_pointer);
    }
    template<class T >
    GType Value< T >::value_type()
    {
        if (!custom_type_)
        {
            custom_type_ = Glib::custom_boxed_type_register(typeid(CppType).name(), &Value< T >::value_init_func, &Value< T >::value_free_func, &Value< T >::value_copy_func);
        }
        return custom_type_;
    }
    template<class T >
    void Value< T >::value_init_func(GValue * value)
    {
        value->data[0].v_pointer = new (std::nothrow) T ();
    }
    template<class T >
    void Value< T >::value_free_func(GValue * value)
    {
        delete static_cast<T * >(value->data[0].v_pointer);
    }
    template<class T >
    void Value< T >::value_copy_func(const GValue * src_value, GValue * dest_value)
    {
        const T & source = *static_cast<T * >(src_value->data[0].v_pointer);
        dest_value->data[0].v_pointer = new (std::nothrow) T (source);
    }
}
namespace Glib {
    template<class T >
    class Value_Boxed : public ValueBase_Boxed
    {
        public :
            typedef T CppType;
            typedef typename T::BaseObjectType * CType;
            static GType value_type()
            {
                return T::get_type();
            }
            void set(const CppType & data)
            {
                set_boxed(data.gobj());
            }
            CppType get() const
            {
                return CppType(static_cast<CType >(get_boxed()));
            }
    };
    template<class T >
    class Value< Glib::RefPtr< T > > : public ValueBase_Object
    {
        public :
            typedef Glib::RefPtr< T > CppType;
            typedef typename T::BaseObjectType * CType;
            static GType value_type()
            {
                return T::get_base_type();
            }
            void set(const CppType & data)
            {
                set_object(data.operator ->());
            }
            CppType get() const
            {
                return Glib::RefPtr< T >::cast_dynamic(get_object_copy());
            }
    };
    template<class T >
    class Value< Glib::RefPtr< const T > > : public ValueBase_Object
    {
        public :
            typedef Glib::RefPtr< const T > CppType;
            typedef typename T::BaseObjectType * CType;
            static GType value_type()
            {
                return T::get_base_type();
            }
            void set(const CppType & data)
            {
                set_object(const_cast<T * >(data.operator ->()));
            }
            CppType get() const
            {
                return Glib::RefPtr< T >::cast_dynamic(get_object_copy());
            }
    };
}
namespace Glib {
    template<>
    class Value< bool > : public ValueBase
    {
        public :
            typedef bool CppType;
            typedef gboolean CType;
            static GType value_type() __attribute__((__const__));
            void set(bool data);
            bool get() const;
            GParamSpec * create_param_spec(const Glib::ustring & name) const;
    };
    template<>
    class Value< char > : public ValueBase
    {
        public :
            typedef char CppType;
            typedef gchar CType;
            static GType value_type() __attribute__((__const__));
            void set(char data);
            char get() const;
            GParamSpec * create_param_spec(const Glib::ustring & name) const;
    };
    template<>
    class Value< unsigned char > : public ValueBase
    {
        public :
            typedef unsigned char CppType;
            typedef guchar CType;
            static GType value_type() __attribute__((__const__));
            void set(unsigned char data);
            unsigned char get() const;
            GParamSpec * create_param_spec(const Glib::ustring & name) const;
    };
    template<>
    class Value< int > : public ValueBase
    {
        public :
            typedef int CppType;
            typedef gint CType;
            static GType value_type() __attribute__((__const__));
            void set(int data);
            int get() const;
            GParamSpec * create_param_spec(const Glib::ustring & name) const;
    };
    template<>
    class Value< unsigned int > : public ValueBase
    {
        public :
            typedef unsigned int CppType;
            typedef guint CType;
            static GType value_type() __attribute__((__const__));
            void set(unsigned int data);
            unsigned int get() const;
            GParamSpec * create_param_spec(const Glib::ustring & name) const;
    };
    template<>
    class Value< long > : public ValueBase
    {
        public :
            typedef long CppType;
            typedef glong CType;
            static GType value_type() __attribute__((__const__));
            void set(long data);
            long get() const;
            GParamSpec * create_param_spec(const Glib::ustring & name) const;
    };
    template<>
    class Value< unsigned long > : public ValueBase
    {
        public :
            typedef unsigned long CppType;
            typedef gulong CType;
            static GType value_type() __attribute__((__const__));
            void set(unsigned long data);
            unsigned long get() const;
            GParamSpec * create_param_spec(const Glib::ustring & name) const;
    };
    template<>
    class Value< long long > : public ValueBase
    {
        public :
            typedef long long CppType;
            typedef gint64 CType;
            static GType value_type() __attribute__((__const__));
            void set(long long data);
            long long get() const;
            GParamSpec * create_param_spec(const Glib::ustring & name) const;
    };
    template<>
    class Value< unsigned long long > : public ValueBase
    {
        public :
            typedef unsigned long long CppType;
            typedef guint64 CType;
            static GType value_type() __attribute__((__const__));
            void set(unsigned long long data);
            unsigned long long get() const;
            GParamSpec * create_param_spec(const Glib::ustring & name) const;
    };
    template<>
    class Value< float > : public ValueBase
    {
        public :
            typedef float CppType;
            typedef gfloat CType;
            static GType value_type() __attribute__((__const__));
            void set(float data);
            float get() const;
            GParamSpec * create_param_spec(const Glib::ustring & name) const;
    };
    template<>
    class Value< double > : public ValueBase
    {
        public :
            typedef double CppType;
            typedef gdouble CType;
            static GType value_type() __attribute__((__const__));
            void set(double data);
            double get() const;
            GParamSpec * create_param_spec(const Glib::ustring & name) const;
    };
    template<>
    class Value< void * > : public ValueBase
    {
        public :
            typedef void * CppType;
            typedef gpointer CType;
            static GType value_type() __attribute__((__const__));
            void set(void * data);
            void * get() const;
            GParamSpec * create_param_spec(const Glib::ustring & name) const;
    };
}
namespace Glib {
    template<>
    class Value< std::string > : public ValueBase_String
    {
        public :
            typedef std::string CppType;
            void set(const std::string & data);
            std::string get() const
            {
                return get_cstring();
            }
    };
    template<>
    class Value< Glib::ustring > : public ValueBase_String
    {
        public :
            typedef Glib::ustring CppType;
            void set(const Glib::ustring & data);
            Glib::ustring get() const
            {
                return get_cstring();
            }
    };
    template<class T >
    class Value_Enum : public ValueBase_Enum
    {
        public :
            typedef T CppType;
            void set(CppType data)
            {
                set_enum(data);
            }
            CppType get() const
            {
                return CppType(get_enum());
            }
    };
    template<class T >
    class Value_Flags : public ValueBase_Flags
    {
        public :
            typedef T CppType;
            void set(CppType data)
            {
                set_flags(data);
            }
            CppType get() const
            {
                return CppType(get_flags());
            }
    };
}
namespace Glib {
    class ObjectBase;
    class SignalProxyProperty : public SignalProxyBase
    {
        public :
            friend class PropertyProxy_Base;
            SignalProxyProperty(Glib::ObjectBase * obj, const gchar * property_name);
            ~SignalProxyProperty();
            typedef sigc::slot< void > SlotType;
            sigc::connection connect(const SlotType & sl);
        protected :
            const char * property_name_;
        private :
            SignalProxyProperty & operator =(const SignalProxyProperty &);
    };
    class PropertyProxy_Base
    {
        public :
            PropertyProxy_Base(ObjectBase * obj, const char * property_name);
            PropertyProxy_Base(const PropertyProxy_Base & other);
            SignalProxyProperty signal_changed();
            ObjectBase * get_object() const
            {
                return obj_;
            }
            const char * get_name() const
            {
                return property_name_;
            }
        protected :
            void set_property_(const Glib::ValueBase & value);
            void get_property_(Glib::ValueBase & value) const;
            void reset_property_();
            ObjectBase * obj_;
            const char * property_name_;
        private :
            PropertyProxy_Base & operator =(const PropertyProxy_Base &);
    };
    class SignalProxyProperty;
    class PropertyProxyConnectionNode : public SignalProxyConnectionNode
    {
        public :
            friend class SignalProxyProperty;
            PropertyProxyConnectionNode(const sigc::slot_base & slot, GObject * gobject);
            static void callback(GObject * object, GParamSpec * pspec, gpointer data);
    };
}
namespace Glib {
    template<class T >
    class PropertyProxy : public PropertyProxy_Base
    {
        public :
            typedef T PropertyType;
            PropertyProxy(ObjectBase * obj, const char * name)
                : PropertyProxy_Base(obj, name) 
            {
            }
            void set_value(const PropertyType & data);
            PropertyType get_value() const;
            void reset_value()
            {
                reset_property_();
            }
            PropertyProxy< T > & operator =(const PropertyType & data)
            {
                this->set_value(data);
                return *this;
            }
            operator PropertyType() const
            {
                return this->get_value();
            }
    };
    template<class T >
    class PropertyProxy_WriteOnly : public PropertyProxy_Base
    {
        public :
            typedef T PropertyType;
            PropertyProxy_WriteOnly(ObjectBase * obj, const char * name)
                : PropertyProxy_Base(obj, name) 
            {
            }
            void set_value(const PropertyType & data);
            void reset_value()
            {
                reset_property_();
            }
            PropertyProxy_WriteOnly< T > & operator =(const PropertyType & data)
            {
                this->set_value(data);
                return *this;
            }
    };
    template<class T >
    class PropertyProxy_ReadOnly : public PropertyProxy_Base
    {
        public :
            typedef T PropertyType;
            PropertyProxy_ReadOnly(const ObjectBase * obj, const char * name)
                : PropertyProxy_Base(const_cast<ObjectBase * >(obj), name) 
            {
            }
            PropertyType get_value() const;
            operator PropertyType() const
            {
                return this->get_value();
            }
    };
    template<class T >
    void PropertyProxy< T >::set_value(const T & data)
    {
        Glib::Value< T > value;
        value.init(Glib::Value< T >::value_type());
        value.set(data);
        set_property_(value);
    }
    template<class T >
    T PropertyProxy< T >::get_value() const
    {
        Glib::Value< T > value;
        value.init(Glib::Value< T >::value_type());
        get_property_(value);
        return value.get();
    }
    template<class T >
    void PropertyProxy_WriteOnly< T >::set_value(const T & data)
    {
        Glib::Value< T > value;
        value.init(Glib::Value< T >::value_type());
        value.set(data);
        set_property_(value);
    }
    template<class T >
    T PropertyProxy_ReadOnly< T >::get_value() const
    {
        Glib::Value< T > value;
        value.init(Glib::Value< T >::value_type());
        get_property_(value);
        return value.get();
    }
}
namespace Glib {
    class QueryQuark
    {
        public :
            QueryQuark(const GQuark & q);
            QueryQuark(const ustring & s);
            QueryQuark(const char * s);
            ~QueryQuark()
            {
            }
            QueryQuark & operator =(const QueryQuark & q);
            operator ustring() const;
            operator GQuark() const
            {
                return quark_;
            }
            GQuark id() const
            {
                return quark_;
            }
        private :
            GQuark quark_;
    };
    class Quark : public QueryQuark
    {
        public :
            Quark(const ustring & s);
            Quark(const char * s);
            ~Quark();
    };
    inline bool operator ==(const QueryQuark & a, const QueryQuark & b)
    {
        return a.id() == b.id();
    }
    inline bool operator !=(const QueryQuark & a, const QueryQuark & b)
    {
        return a.id() != b.id();
    }
    extern GQuark quark_;
    extern GQuark quark_cpp_wrapper_deleted_;
}
extern "C"
{
    typedef struct _GObject GObject;
}
namespace Glib {
    class GSigConnectionNode;
    class ObjectBase : virtual public sigc::trackable
    {
        protected :
            ObjectBase();
            explicit ObjectBase(const char * custom_type_name);
            explicit ObjectBase(const std::type_info & custom_type_info);
            virtual ~ObjectBase() = 0;
            void initialize(GObject * castitem);
        public :
            void set_property_value(const Glib::ustring & property_name, const Glib::ValueBase & value);
            void get_property_value(const Glib::ustring & property_name, Glib::ValueBase & value) const;
            template<class PropertyType >
            void set_property(const Glib::ustring & property_name, const PropertyType & value);
            template<class PropertyType >
            void get_property(const Glib::ustring & property_name, PropertyType & value) const;
            void connect_property_changed(const Glib::ustring & property_name, const sigc::slot< void > & slot);
            sigc::connection connect_property_changed_with_return(const Glib::ustring & property_name, const sigc::slot< void > & slot);
            virtual void reference() const;
            virtual void unreference() const;
            inline GObject * gobj()
            {
                return gobject_;
            }
            inline const GObject * gobj() const
            {
                return gobject_;
            }
            GObject * gobj_copy() const;
            static ObjectBase * _get_current_wrapper(GObject * object);
            bool _cpp_destruction_is_in_progress() const;
        protected :
            GObject * gobject_;
            const char * custom_type_name_;
            bool cpp_destruction_in_progress_;
            bool is_anonymous_custom_() const;
        public :
            bool is_derived_() const;
        protected :
            static void destroy_notify_callback_(void * data);
            virtual void destroy_notify_();
            void _set_current_wrapper(GObject * object);
        private :
            ObjectBase(const ObjectBase &);
            ObjectBase & operator =(const ObjectBase &);
            virtual void set_manage();
            friend class Glib::GSigConnectionNode;
    };
    template<class PropertyType >
    inline void ObjectBase::set_property(const Glib::ustring & property_name, const PropertyType & value)
    {
        Glib::Value< PropertyType > property_value;
        property_value.init(Glib::Value< PropertyType >::value_type());
        property_value.set(value);
        this->set_property_value(property_name, property_value);
    }
    template<class PropertyType >
    inline void ObjectBase::get_property(const Glib::ustring & property_name, PropertyType & value) const
    {
        Glib::Value< PropertyType > property_value;
        property_value.init(Glib::Value< PropertyType >::value_type());
        this->get_property_value(property_name, property_value);
        value = property_value.get();
    }
    bool _gobject_cppinstance_already_deleted(GObject * gobject);
}
namespace Glib {
    class ObjectBase;
    class Object;
    typedef Glib::ObjectBase * (* WrapNewFunction)(GObject *);
    void wrap_register_init();
    void wrap_register_cleanup();
    void wrap_register(GType type, WrapNewFunction func);
    Glib::ObjectBase * wrap_auto(GObject * object, bool take_copy = false);
    Glib::ObjectBase * wrap_create_new_wrapper_for_interface(GObject * object, GType interface_gtype);
    template<class TInterface >
    TInterface * wrap_auto_interface(GObject * object, bool take_copy = false)
    {
        if (!object)
            return 0;
        ObjectBase * pCppObject = ObjectBase::_get_current_wrapper(object);
        if (!pCppObject)
        {
            pCppObject = wrap_create_new_wrapper_for_interface(object, TInterface::get_base_type());
        }
        TInterface * result = 0;
        if (pCppObject)
            result = dynamic_cast<TInterface * >(pCppObject);
        else
            result = new TInterface ((typename TInterface::BaseObjectType *) object);
        if (take_copy && result)
            result->reference();
        return result;
    }
    Glib::RefPtr< Glib::Object > wrap(GObject * object, bool take_copy = false);
    template<class T >
    inline typename T::BaseObjectType * unwrap(T * ptr)
    {
        return (ptr) ? ptr->gobj() : 0;
    }
    template<class T >
    inline const typename T::BaseObjectType * unwrap(const T * ptr)
    {
        return (ptr) ? ptr->gobj() : 0;
    }
    template<class T >
    inline typename T::BaseObjectType * unwrap(const Glib::RefPtr< T > & ptr)
    {
        return (ptr) ? ptr->gobj() : 0;
    }
    template<class T >
    inline const typename T::BaseObjectType * unwrap(const Glib::RefPtr< const T > & ptr)
    {
        return (ptr) ? ptr->gobj() : 0;
    }
    template<class T >
    inline typename T::BaseObjectType * unwrap_copy(const Glib::RefPtr< T > & ptr)
    {
        return (ptr) ? ptr->gobj_copy() : 0;
    }
    template<class T >
    inline const typename T::BaseObjectType * unwrap_copy(const Glib::RefPtr< const T > & ptr)
    {
        return (ptr) ? ptr->gobj_copy() : 0;
    }
}
namespace Glib {
    enum OwnershipType
    {
        OWNERSHIP_NONE = 0, 
        OWNERSHIP_SHALLOW, 
        OWNERSHIP_DEEP
    };
    template<class Iterator >
    class Sequence
    {
        private :
            Iterator pbegin_;
            Iterator pend_;
        public :
            Sequence(Iterator pbegin, Iterator pend)
                : pbegin_(pbegin), pend_(pend) 
            {
            }
            Iterator begin() const
            {
                return pbegin_;
            }
            Iterator end() const
            {
                return pend_;
            }
            size_t size() const
            {
                return std::distance(pbegin_, pend_);
            }
    };
    template<class Iterator >
    inline Sequence< Iterator > sequence(Iterator pbegin, Iterator pend)
    {
        return Sequence< Iterator >(pbegin, pend);
    }
    namespace Container_Helpers {
        template<class T >
        struct TypeTraits
        {
                typedef T CppType;
                typedef T CType;
                typedef T CTypeNonConst;
                static CType to_c_type(const CppType & item)
                {
                    return item;
                }
                static CppType to_cpp_type(const CType & item)
                {
                    return item;
                }
                static void release_c_type(const CType &)
                {
                }
        };
        template<class T >
        struct TypeTraits< T * >
        {
                typedef T * CppType;
                typedef typename T::BaseObjectType * CType;
                typedef typename T::BaseObjectType * CTypeNonConst;
                static CType to_c_type(CppType ptr)
                {
                    return Glib::unwrap(ptr);
                }
                static CType to_c_type(CType ptr)
                {
                    return ptr;
                }
                static CppType to_cpp_type(CType ptr)
                {
                    GObject * cobj = (GObject *) ptr;
                    return dynamic_cast<CppType >(Glib::wrap_auto(cobj, false));
                }
                static void release_c_type(CType ptr)
                {
                    if (1)
                    {
                        (void) 0;
                    }
                    else
                        (void) 0;
                    g_object_unref(ptr);
                }
        };
        template<class T >
        struct TypeTraits< const T * >
        {
                typedef const T * CppType;
                typedef const typename T::BaseObjectType * CType;
                typedef typename T::BaseObjectType * CTypeNonConst;
                static CType to_c_type(CppType ptr)
                {
                    return Glib::unwrap(ptr);
                }
                static CType to_c_type(CType ptr)
                {
                    return ptr;
                }
                static CppType to_cpp_type(CType ptr)
                {
                    GObject * cobj = (GObject *) const_cast<CTypeNonConst >(ptr);
                    return dynamic_cast<CppType >(Glib::wrap_auto(cobj, false));
                }
                static void release_c_type(CType ptr)
                {
                    if (1)
                    {
                        (void) 0;
                    }
                    else
                        (void) 0;
                    g_object_unref(const_cast<CTypeNonConst >(ptr));
                }
        };
        template<class T >
        struct TypeTraits< Glib::RefPtr< T > >
        {
                typedef Glib::RefPtr< T > CppType;
                typedef typename T::BaseObjectType * CType;
                typedef typename T::BaseObjectType * CTypeNonConst;
                static CType to_c_type(const CppType & ptr)
                {
                    return Glib::unwrap(ptr);
                }
                static CType to_c_type(CType ptr)
                {
                    return ptr;
                }
                static CppType to_cpp_type(CType ptr)
                {
                    GObject * cobj = (GObject *) const_cast<CTypeNonConst >(ptr);
                    return Glib::RefPtr< T >(dynamic_cast<T * >(Glib::wrap_auto(cobj, true)));
                }
                static void release_c_type(CType ptr)
                {
                    if (1)
                    {
                        (void) 0;
                    }
                    else
                        (void) 0;
                    g_object_unref(ptr);
                }
        };
        template<class T >
        struct TypeTraits< Glib::RefPtr< const T > >
        {
                typedef Glib::RefPtr< const T > CppType;
                typedef const typename T::BaseObjectType * CType;
                typedef typename T::BaseObjectType * CTypeNonConst;
                static CType to_c_type(const CppType & ptr)
                {
                    return Glib::unwrap(ptr);
                }
                static CType to_c_type(CType ptr)
                {
                    return ptr;
                }
                static CppType to_cpp_type(CType ptr)
                {
                    GObject * cobj = (GObject *) (ptr);
                    return Glib::RefPtr< const T >(dynamic_cast<const T * >(Glib::wrap_auto(cobj, true)));
                }
                static void release_c_type(CType ptr)
                {
                    if (1)
                    {
                        (void) 0;
                    }
                    else
                        (void) 0;
                    g_object_unref(const_cast<CTypeNonConst >(ptr));
                }
        };
        template<>
        struct TypeTraits< Glib::ustring >
        {
                typedef Glib::ustring CppType;
                typedef const char * CType;
                typedef char * CTypeNonConst;
                static CType to_c_type(const Glib::ustring & str)
                {
                    return str.c_str();
                }
                static CType to_c_type(const std::string & str)
                {
                    return str.c_str();
                }
                static CType to_c_type(CType str)
                {
                    return str;
                }
                static CppType to_cpp_type(CType str)
                {
                    return (str) ? Glib::ustring(str) : Glib::ustring();
                }
                static void release_c_type(CType str)
                {
                    g_free(const_cast<CTypeNonConst >(str));
                }
        };
        template<>
        struct TypeTraits< std::string >
        {
                typedef std::string CppType;
                typedef const char * CType;
                typedef char * CTypeNonConst;
                static CType to_c_type(const std::string & str)
                {
                    return str.c_str();
                }
                static CType to_c_type(const Glib::ustring & str)
                {
                    return str.c_str();
                }
                static CType to_c_type(CType str)
                {
                    return str;
                }
                static CppType to_cpp_type(CType str)
                {
                    return (str) ? std::string(str) : std::string();
                }
                static void release_c_type(CType str)
                {
                    g_free(const_cast<CTypeNonConst >(str));
                }
        };
        template<>
        struct TypeTraits< bool >
        {
                typedef bool CppType;
                typedef gboolean CType;
                typedef gboolean CTypeNonConst;
                static CType to_c_type(CppType item)
                {
                    return static_cast<CType >(item);
                }
                static CType to_c_type(CType item)
                {
                    return item;
                }
                static CppType to_cpp_type(CType item)
                {
                    return (item != 0);
                }
                static void release_c_type(CType)
                {
                }
        };
    }
}
namespace Glib {
    namespace Container_Helpers {
        template<class T >
        inline size_t compute_array_size(const T * array)
        {
            const T * pend = array;
            while (*pend)
                ++pend;
            return (pend - array);
        }
        template<class For, class Tr >
        typename Tr::CType * create_array(For pbegin, size_t size, Tr)
        {
            typedef typename Tr::CType CType;
            CType *const array = static_cast<CType * >(g_malloc((size + 1) * sizeof(CType)));
            CType *const array_end = array + size;
            for (CType * pdest = array;
                pdest != array_end;
                ++pdest)
            {
                *pdest = Tr::to_c_type(*&*pbegin);
                ++pbegin;
            }
            *array_end = CType();
            return array;
        }
        template<class Tr, class Cont >
        struct ArraySourceTraits
        {
                typedef typename Tr::CType CType;
                static size_t get_size(const Cont & cont)
                {
                    return cont.size();
                }
                static const CType * get_data(const Cont & cont, size_t size)
                {
                    return Glib::Container_Helpers::create_array(cont.begin(), size, Tr());
                }
                static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_SHALLOW;
        };
        template<class Tr, class Cont >
        struct ArraySourceTraits< Tr, Cont * >
        {
                typedef typename Tr::CType CType;
                static size_t get_size(const CType * array)
                {
                    return (array) ? Glib::Container_Helpers::compute_array_size(array) : 0;
                }
                static const CType * get_data(const CType * array, size_t)
                {
                    return array;
                }
                static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_NONE;
        };
        template<class Tr, class Cont >
        struct ArraySourceTraits< Tr, const Cont * > : ArraySourceTraits< Tr, Cont * >
        {
        };
        template<class Tr, class Cont, size_t N >
        struct ArraySourceTraits< Tr, Cont [N] >
        {
                typedef typename Tr::CType CType;
                static size_t get_size(const CType *)
                {
                    return (N - 1);
                }
                static const CType * get_data(const CType * array, size_t)
                {
                    return array;
                }
                static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_NONE;
        };
        template<class Tr, class Cont, size_t N >
        struct ArraySourceTraits< Tr, const Cont [N] > : ArraySourceTraits< Tr, Cont [N] >
        {
        };
        template<class Tr >
        class ArrayHandleIterator
        {
            public :
                typedef typename Tr::CppType CppType;
                typedef typename Tr::CType CType;
                typedef std::random_access_iterator_tag iterator_category;
                typedef CppType value_type;
                typedef ptrdiff_t difference_type;
                typedef value_type reference;
                typedef void pointer;
                explicit inline ArrayHandleIterator(const CType * pos);
                inline value_type operator *() const;
                inline value_type operator [](difference_type offset) const;
                inline ArrayHandleIterator< Tr > & operator ++();
                inline const ArrayHandleIterator< Tr > operator ++(int);
                inline ArrayHandleIterator< Tr > & operator +=(difference_type rhs);
                inline ArrayHandleIterator< Tr > & operator -=(difference_type rhs);
                inline const ArrayHandleIterator< Tr > operator +(difference_type rhs) const;
                inline const ArrayHandleIterator< Tr > operator -(difference_type rhs) const;
                inline difference_type operator -(const ArrayHandleIterator< Tr > & rhs) const;
                inline bool operator ==(const ArrayHandleIterator< Tr > & rhs) const;
                inline bool operator !=(const ArrayHandleIterator< Tr > & rhs) const;
                inline bool operator <(const ArrayHandleIterator< Tr > & rhs) const;
                inline bool operator >(const ArrayHandleIterator< Tr > & rhs) const;
                inline bool operator <=(const ArrayHandleIterator< Tr > & rhs) const;
                inline bool operator >=(const ArrayHandleIterator< Tr > & rhs) const;
            private :
                const CType * pos_;
        };
    }
    template<class T, class Tr = Glib::Container_Helpers::TypeTraits< T > >
    class ArrayHandle
    {
        public :
            typedef typename Tr::CppType CppType;
            typedef typename Tr::CType CType;
            typedef CppType value_type;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef Glib::Container_Helpers::ArrayHandleIterator< Tr > const_iterator;
            typedef Glib::Container_Helpers::ArrayHandleIterator< Tr > iterator;
            template<class Cont >
            inline ArrayHandle(const Cont & container);
            inline ArrayHandle(const CType * array, size_t array_size, Glib::OwnershipType ownership);
            inline ArrayHandle(const CType * array, Glib::OwnershipType ownership);
            inline ArrayHandle(const ArrayHandle< T, Tr > & other);
            ~ArrayHandle();
            inline const_iterator begin() const;
            inline const_iterator end() const;
            template<class U >
            inline operator std::vector< U >() const;
            template<class U >
            inline operator std::deque< U >() const;
            template<class U >
            inline operator std::list< U >() const;
            template<class Cont >
            inline void assign_to(Cont & container) const;
            template<class Out >
            inline void copy(Out pdest) const;
            inline const CType * data() const;
            inline size_t size() const;
            inline bool empty() const;
        private :
            size_t size_;
            const CType * parray_;
            mutable Glib::OwnershipType ownership_;
            ArrayHandle< T, Tr > & operator =(const ArrayHandle< T, Tr > &);
    };
    typedef ArrayHandle< Glib::ustring > StringArrayHandle;
    namespace Container_Helpers {
        template<class Tr >
        inline ArrayHandleIterator< Tr >::ArrayHandleIterator(const CType * pos)
            : pos_(pos) 
        {
        }
        template<class Tr >
        inline typename ArrayHandleIterator< Tr >::value_type ArrayHandleIterator< Tr >::operator *() const
        {
            return Tr::to_cpp_type(*pos_);
        }
        template<class Tr >
        inline typename ArrayHandleIterator< Tr >::value_type ArrayHandleIterator< Tr >::operator [](difference_type offset) const
        {
            return Tr::to_cpp_type(pos_[offset]);
        }
        template<class Tr >
        inline ArrayHandleIterator< Tr > & ArrayHandleIterator< Tr >::operator ++()
        {
            ++pos_;
            return *this;
        }
        template<class Tr >
        inline const ArrayHandleIterator< Tr > ArrayHandleIterator< Tr >::operator ++(int)
        {
            return ArrayHandleIterator< Tr >(pos_++);
        }
        template<class Tr >
        inline ArrayHandleIterator< Tr > & ArrayHandleIterator< Tr >::operator +=(typename ArrayHandleIterator< Tr >::difference_type rhs)
        {
            pos_ += rhs;
            return *this;
        }
        template<class Tr >
        inline ArrayHandleIterator< Tr > & ArrayHandleIterator< Tr >::operator -=(typename ArrayHandleIterator< Tr >::difference_type rhs)
        {
            pos_ -= rhs;
            return *this;
        }
        template<class Tr >
        inline const ArrayHandleIterator< Tr > ArrayHandleIterator< Tr >::operator +(typename ArrayHandleIterator< Tr >::difference_type rhs) const
        {
            return ArrayHandleIterator< Tr >(pos_ + rhs);
        }
        template<class Tr >
        inline const ArrayHandleIterator< Tr > ArrayHandleIterator< Tr >::operator -(typename ArrayHandleIterator< Tr >::difference_type rhs) const
        {
            return ArrayHandleIterator< Tr >(pos_ - rhs);
        }
        template<class Tr >
        inline typename ArrayHandleIterator< Tr >::difference_type ArrayHandleIterator< Tr >::operator -(const ArrayHandleIterator< Tr > & rhs) const
        {
            return (pos_ - rhs.pos_);
        }
        template<class Tr >
        inline bool ArrayHandleIterator< Tr >::operator ==(const ArrayHandleIterator< Tr > & rhs) const
        {
            return (pos_ == rhs.pos_);
        }
        template<class Tr >
        inline bool ArrayHandleIterator< Tr >::operator !=(const ArrayHandleIterator< Tr > & rhs) const
        {
            return (pos_ != rhs.pos_);
        }
        template<class Tr >
        inline bool ArrayHandleIterator< Tr >::operator <(const ArrayHandleIterator< Tr > & rhs) const
        {
            return (pos_ < rhs.pos_);
        }
        template<class Tr >
        inline bool ArrayHandleIterator< Tr >::operator >(const ArrayHandleIterator< Tr > & rhs) const
        {
            return (pos_ > rhs.pos_);
        }
        template<class Tr >
        inline bool ArrayHandleIterator< Tr >::operator <=(const ArrayHandleIterator< Tr > & rhs) const
        {
            return (pos_ <= rhs.pos_);
        }
        template<class Tr >
        inline bool ArrayHandleIterator< Tr >::operator >=(const ArrayHandleIterator< Tr > & rhs) const
        {
            return (pos_ >= rhs.pos_);
        }
    }
    template<class T, class Tr >
    template<class Cont >
    inline ArrayHandle< T, Tr >::ArrayHandle(const Cont & container)
        : size_(Glib::Container_Helpers::ArraySourceTraits< Tr, Cont >::get_size(container)), parray_(Glib::Container_Helpers::ArraySourceTraits< Tr, Cont >::get_data(container, size_)), ownership_(Glib::Container_Helpers::ArraySourceTraits< Tr, Cont >::initial_ownership) 
    {
    }
    template<class T, class Tr >
    inline ArrayHandle< T, Tr >::ArrayHandle(const typename ArrayHandle< T, Tr >::CType * array, size_t array_size, Glib::OwnershipType ownership)
        : size_(array_size), parray_(array), ownership_(ownership) 
    {
    }
    template<class T, class Tr >
    inline ArrayHandle< T, Tr >::ArrayHandle(const typename ArrayHandle< T, Tr >::CType * array, Glib::OwnershipType ownership)
        : size_((array) ? Glib::Container_Helpers::compute_array_size(array) : 0), parray_(array), ownership_(ownership) 
    {
    }
    template<class T, class Tr >
    inline ArrayHandle< T, Tr >::ArrayHandle(const ArrayHandle< T, Tr > & other)
        : size_(other.size_), parray_(other.parray_), ownership_(other.ownership_) 
    {
        other.ownership_ = Glib::OWNERSHIP_NONE;
    }
    template<class T, class Tr >
    ArrayHandle< T, Tr >::~ArrayHandle()
    {
        if (ownership_ != Glib::OWNERSHIP_NONE)
        {
            if (ownership_ != Glib::OWNERSHIP_SHALLOW)
            {
                const CType *const pend = parray_ + size_;
                for (const CType * p = parray_;
                    p != pend;
                    ++p)
                Tr::release_c_type(*p);
            }
            g_free(const_cast<CType * >(parray_));
        }
    }
    template<class T, class Tr >
    inline typename ArrayHandle< T, Tr >::const_iterator ArrayHandle< T, Tr >::begin() const
    {
        return Glib::Container_Helpers::ArrayHandleIterator< Tr >(parray_);
    }
    template<class T, class Tr >
    inline typename ArrayHandle< T, Tr >::const_iterator ArrayHandle< T, Tr >::end() const
    {
        return Glib::Container_Helpers::ArrayHandleIterator< Tr >(parray_ + size_);
    }
    template<class T, class Tr >
    template<class U >
    inline ArrayHandle< T, Tr >::operator std::vector< U >() const
    {
        return std::vector< U >(this->begin(), this->end());
    }
    template<class T, class Tr >
    template<class U >
    inline ArrayHandle< T, Tr >::operator std::deque< U >() const
    {
        return std::deque< U >(this->begin(), this->end());
    }
    template<class T, class Tr >
    template<class U >
    inline ArrayHandle< T, Tr >::operator std::list< U >() const
    {
        return std::list< U >(this->begin(), this->end());
    }
    template<class T, class Tr >
    template<class Cont >
    inline void ArrayHandle< T, Tr >::assign_to(Cont & container) const
    {
        container.assign(this->begin(), this->end());
    }
    template<class T, class Tr >
    template<class Out >
    inline void ArrayHandle< T, Tr >::copy(Out pdest) const
    {
        std::copy(this->begin(), this->end(), pdest);
    }
    template<class T, class Tr >
    inline const typename ArrayHandle< T, Tr >::CType * ArrayHandle< T, Tr >::data() const
    {
        return parray_;
    }
    template<class T, class Tr >
    inline size_t ArrayHandle< T, Tr >::size() const
    {
        return size_;
    }
    template<class T, class Tr >
    inline bool ArrayHandle< T, Tr >::empty() const
    {
        return (size_ == 0);
    }
}
extern "C"
{
    typedef struct _GChecksum GChecksum;
}
namespace Glib {
    class Checksum
    {
        public :
            typedef Checksum CppObjectType;
            typedef GChecksum BaseObjectType;
            Checksum();
            explicit Checksum(GChecksum * castitem, bool make_a_copy = false);
            Checksum(const Checksum & src);
            Checksum & operator =(const Checksum & src);
            ~Checksum();
            GChecksum * gobj()
            {
                return gobject_;
            }
            const GChecksum * gobj() const
            {
                return gobject_;
            }
            GChecksum * gobj_copy() const;
        protected :
            GChecksum * gobject_;
        private :
        public :
            enum ChecksumType
            {
                CHECKSUM_MD5, 
                CHECKSUM_SHA1, 
                CHECKSUM_SHA256
            };
            explicit Checksum(ChecksumType checksum_type);
            operator bool() const;
            void update(const guchar * data, gsize length);
            void update(const std::string & data);
            void get_digest(guint8 * buffer, gsize * digest_len) const;
            std::string get_string() const;
            static std::string compute_checksum(ChecksumType type, const guchar * data, gsize length);
            static std::string compute_checksum(ChecksumType type, const std::string & str);
            static gssize get_length(ChecksumType checksum_type);
    };
}
namespace Glib {
    Glib::Checksum wrap(GChecksum * object, bool take_copy = false);
}
namespace Glib {
    class Class
    {
        public :
            inline GType get_type() const;
            GType clone_custom_type(const char * custom_type_name) const;
        protected :
            GType gtype_;
            GClassInitFunc class_init_func_;
            void register_derived_type(GType base_type);
        private :
            static void custom_class_init_function(void * g_class, void * class_data);
    };
    inline GType Class::get_type() const
    {
        return gtype_;
    }
}
extern "C"
{
    typedef struct _GError GError;
}
namespace Glib {
    class Exception
    {
        public :
            virtual ~Exception() throw () = 0;
            virtual Glib::ustring what() const = 0;
    };
}
namespace Glib {
    class Error : public Glib::Exception
    {
        public :
            Error();
            Error(GQuark domain, int code, const Glib::ustring & message);
            explicit Error(GError * gobject, bool take_copy = false);
            Error(const Error & other);
            Error & operator =(const Error & other);
            virtual ~Error() throw ();
            GQuark domain() const;
            int code() const;
            virtual Glib::ustring what() const;
            bool matches(GQuark domain, int code) const;
            GError * gobj();
            const GError * gobj() const;
            void propagate(GError * * dest);
            typedef void (* ThrowFunc)(GError *);
            static void register_init();
            static void register_cleanup();
            static void register_domain(GQuark domain, ThrowFunc throw_func);
            static void throw_exception(GError * gobject) __attribute__((__noreturn__));
        protected :
            GError * gobject_;
    };
}
extern "C"
{
    typedef struct _GIConv * GIConv;
}
namespace Glib {
    class ConvertError : public Glib::Error
    {
        public :
            enum Code
            {
                NO_CONVERSION, 
                ILLEGAL_SEQUENCE, 
                FAILED, 
                PARTIAL_INPUT, 
                BAD_URI, 
                NOT_ABSOLUTE_PATH
            };
            ConvertError(Code error_code, const Glib::ustring & error_message);
            explicit ConvertError(GError * gobject);
            Code code() const;
        private :
            static void throw_func(GError * gobject);
            friend void wrap_init();
    };
    class IConv
    {
        public :
            IConv(const std::string & to_codeset, const std::string & from_codeset);
            explicit IConv(GIConv gobject);
            ~IConv();
            size_t iconv(char * * inbuf, gsize * inbytes_left, char * * outbuf, gsize * outbytes_left);
            void reset();
            std::string convert(const std::string & str);
            GIConv gobj()
            {
                return gobject_;
            }
        private :
            GIConv gobject_;
            IConv(const IConv &);
            IConv & operator =(const IConv &);
    };
    bool get_charset();
    bool get_charset(std::string & charset);
    std::string convert(const std::string & str, const std::string & to_codeset, const std::string & from_codeset);
    std::string convert_with_fallback(const std::string & str, const std::string & to_codeset, const std::string & from_codeset);
    std::string convert_with_fallback(const std::string & str, const std::string & to_codeset, const std::string & from_codeset, const Glib::ustring & fallback);
    Glib::ustring locale_to_utf8(const std::string & opsys_string);
    std::string locale_from_utf8(const Glib::ustring & utf8_string);
    Glib::ustring filename_to_utf8(const std::string & opsys_string);
    std::string filename_from_utf8(const Glib::ustring & utf8_string);
    std::string filename_from_uri(const Glib::ustring & uri, Glib::ustring & hostname);
    std::string filename_from_uri(const Glib::ustring & uri);
    Glib::ustring filename_to_uri(const std::string & filename, const Glib::ustring & hostname);
    Glib::ustring filename_to_uri(const std::string & filename);
    Glib::ustring filename_display_basename(const std::string & filename);
    Glib::ustring filename_display_name(const std::string & filename);
}
extern "C"
{
    struct tm;
}
namespace Glib {
    class Date
    {
        public :
            typedef guint8 Day;
            typedef guint16 Year;
            enum Month
            {
                BAD_MONTH, 
                JANUARY, 
                FEBRUARY, 
                MARCH, 
                APRIL, 
                MAY, 
                JUNE, 
                JULY, 
                AUGUST, 
                SEPTEMBER, 
                OCTOBER, 
                NOVEMBER, 
                DECEMBER
            };
            enum Weekday
            {
                BAD_WEEKDAY, 
                MONDAY, 
                TUESDAY, 
                WEDNESDAY, 
                THURSDAY, 
                FRIDAY, 
                SATURDAY, 
                SUNDAY
            };
            enum DMY
            {
                DAY, 
                MONTH, 
                YEAR
            };
            static const Day BAD_DAY = 0;
            static const Year BAD_YEAR = 0;
            static const guint32 BAD_JULIAN = 0;
            Date();
            Date(Day day, Month month, Year year);
            explicit Date(guint32 julian_day);
            explicit Date(const GDate & castitem);
            void clear();
            void set_parse(const Glib::ustring & str);
            void set_time(GTime time);
            void set_time(time_t timet);
            void set_time(const GTimeVal & timeval);
            void set_time_current();
            void set_month(Month month);
            void set_day(Day day);
            void set_year(Year year);
            void set_dmy(Day day, Month month, Year year);
            void set_julian(guint32 julian_day);
            Date & add_days(int n_days);
            Date & subtract_days(int n_days);
            Date & add_months(int n_months);
            Date & subtract_months(int n_months);
            Date & add_years(int n_years);
            Date & subtract_years(int n_years);
            int days_between(const Date & rhs) const;
            int compare(const Date & rhs) const;
            Date & clamp(const Date & min_date, const Date & max_date);
            Date & clamp_min(const Date & min_date);
            Date & clamp_max(const Date & max_date);
            void order(Date & other);
            Weekday get_weekday() const;
            Month get_month() const;
            Year get_year() const;
            Day get_day() const;
            guint32 get_julian() const;
            unsigned int get_day_of_year() const;
            unsigned int get_monday_week_of_year() const;
            unsigned int get_sunday_week_of_year() const;
            bool is_first_of_month() const;
            bool is_last_of_month() const;
            static guint8 get_days_in_month(Month month, Year year);
            static guint8 get_monday_weeks_in_year(Year year);
            static guint8 get_sunday_weeks_in_year(Year year);
            static bool is_leap_year(Year year);
            Glib::ustring format_string(const Glib::ustring & format) const;
            void to_struct_tm(struct tm & dest) const;
            bool valid() const;
            static bool valid_day(Day day);
            static bool valid_month(Month month);
            static bool valid_year(Year year);
            static bool valid_weekday(Weekday weekday);
            static bool valid_julian(guint32 julian_day);
            static bool valid_dmy(Day day, Month month, Year year);
            GDate * gobj()
            {
                return &gobject_;
            }
            const GDate * gobj() const
            {
                return &gobject_;
            }
        private :
            GDate gobject_;
    };
    inline bool operator ==(const Date & lhs, const Date & rhs)
    {
        return (lhs.compare(rhs) == 0);
    }
    inline bool operator !=(const Date & lhs, const Date & rhs)
    {
        return (lhs.compare(rhs) != 0);
    }
    inline bool operator <(const Date & lhs, const Date & rhs)
    {
        return (lhs.compare(rhs) < 0);
    }
    inline bool operator >(const Date & lhs, const Date & rhs)
    {
        return (lhs.compare(rhs) > 0);
    }
    inline bool operator <=(const Date & lhs, const Date & rhs)
    {
        return (lhs.compare(rhs) <= 0);
    }
    inline bool operator >=(const Date & lhs, const Date & rhs)
    {
        return (lhs.compare(rhs) >= 0);
    }
}
namespace Glib {
    struct TimeVal : public GTimeVal
    {
            inline TimeVal();
            inline TimeVal(long seconds, long microseconds);
            inline TimeVal(const GTimeVal & gtimeval);
            inline TimeVal & operator =(const GTimeVal & gtimeval);
            void assign_current_time();
            void add(const TimeVal & rhs);
            void subtract(const TimeVal & rhs);
            void add_seconds(long seconds);
            void subtract_seconds(long seconds);
            void add_milliseconds(long milliseconds);
            void subtract_milliseconds(long milliseconds);
            void add_microseconds(long microseconds);
            void subtract_microseconds(long microseconds);
            inline TimeVal & operator +=(const TimeVal & gtimeval);
            inline TimeVal & operator -=(const TimeVal & gtimeval);
            inline TimeVal & operator +=(long seconds);
            inline TimeVal & operator -=(long seconds);
            inline double as_double() const;
            inline bool negative() const;
            inline bool valid() const;
    };
    inline TimeVal::TimeVal()
    {
        tv_sec = 0;
        tv_usec = 0;
    }
    inline TimeVal::TimeVal(long seconds, long microseconds)
    {
        tv_sec = seconds;
        tv_usec = microseconds;
    }
    inline TimeVal::TimeVal(const GTimeVal & gtimeval)
    {
        tv_sec = gtimeval.tv_sec;
        tv_usec = gtimeval.tv_usec;
    }
    inline TimeVal & TimeVal::operator =(const GTimeVal & gtimeval)
    {
        tv_sec = gtimeval.tv_sec;
        tv_usec = gtimeval.tv_usec;
        return *this;
    }
    inline TimeVal & TimeVal::operator +=(const TimeVal & gtimeval)
    {
        add(gtimeval);
        return *this;
    }
    inline TimeVal & TimeVal::operator -=(const TimeVal & gtimeval)
    {
        subtract(gtimeval);
        return *this;
    }
    inline TimeVal & TimeVal::operator +=(long seconds)
    {
        add_seconds(seconds);
        return *this;
    }
    inline TimeVal & TimeVal::operator -=(long seconds)
    {
        subtract_seconds(seconds);
        return *this;
    }
    inline double TimeVal::as_double() const
    {
        return tv_sec + ((double) tv_usec / (double) 1000000);
    }
    inline bool TimeVal::negative() const
    {
        return (tv_sec < 0);
    }
    inline bool TimeVal::valid() const
    {
        return (tv_usec >= 0 && tv_usec < 1000000);
    }
    inline TimeVal operator +(const TimeVal & lhs, const TimeVal & rhs)
    {
        return TimeVal(lhs) += rhs;
    }
    inline TimeVal operator +(const TimeVal & lhs, long seconds)
    {
        return TimeVal(lhs) += seconds;
    }
    inline TimeVal operator -(const TimeVal & lhs, const TimeVal & rhs)
    {
        return TimeVal(lhs) -= rhs;
    }
    inline TimeVal operator -(const TimeVal & lhs, long seconds)
    {
        return TimeVal(lhs) -= seconds;
    }
    inline bool operator ==(const TimeVal & lhs, const TimeVal & rhs)
    {
        return (lhs.tv_sec == rhs.tv_sec && lhs.tv_usec == rhs.tv_usec);
    }
    inline bool operator !=(const TimeVal & lhs, const TimeVal & rhs)
    {
        return (lhs.tv_sec != rhs.tv_sec || lhs.tv_usec != rhs.tv_usec);
    }
    inline bool operator <(const TimeVal & lhs, const TimeVal & rhs)
    {
        return ((lhs.tv_sec < rhs.tv_sec) || (lhs.tv_sec == rhs.tv_sec && lhs.tv_usec < rhs.tv_usec));
    }
    inline bool operator >(const TimeVal & lhs, const TimeVal & rhs)
    {
        return ((lhs.tv_sec > rhs.tv_sec) || (lhs.tv_sec == rhs.tv_sec && lhs.tv_usec > rhs.tv_usec));
    }
    inline bool operator <=(const TimeVal & lhs, const TimeVal & rhs)
    {
        return ((lhs.tv_sec < rhs.tv_sec) || (lhs.tv_sec == rhs.tv_sec && lhs.tv_usec <= rhs.tv_usec));
    }
    inline bool operator >=(const TimeVal & lhs, const TimeVal & rhs)
    {
        return ((lhs.tv_sec > rhs.tv_sec) || (lhs.tv_sec == rhs.tv_sec && lhs.tv_usec >= rhs.tv_usec));
    }
}
namespace Glib {
    enum 
    {
        PRIORITY_HIGH = -100, 
        PRIORITY_DEFAULT = 0, 
        PRIORITY_HIGH_IDLE = 100, 
        PRIORITY_DEFAULT_IDLE = 200, 
        PRIORITY_LOW = 300
    };
}
namespace Glib {
    class Cond;
    class Mutex;
    class IOChannel;
    enum IOCondition
    {
        IO_IN = G_IO_IN, 
        IO_OUT = G_IO_OUT, 
        IO_PRI = G_IO_PRI, 
        IO_ERR = G_IO_ERR, 
        IO_HUP = G_IO_HUP, 
        IO_NVAL = G_IO_NVAL
    };
    inline IOCondition operator |(IOCondition lhs, IOCondition rhs)
    {
        return static_cast<IOCondition >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline IOCondition operator &(IOCondition lhs, IOCondition rhs)
    {
        return static_cast<IOCondition >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline IOCondition operator ^(IOCondition lhs, IOCondition rhs)
    {
        return static_cast<IOCondition >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline IOCondition operator ~(IOCondition flags)
    {
        return static_cast<IOCondition >(~static_cast<unsigned >(flags));
    }
    inline IOCondition & operator |=(IOCondition & lhs, IOCondition rhs)
    {
        return (lhs = static_cast<IOCondition >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline IOCondition & operator &=(IOCondition & lhs, IOCondition rhs)
    {
        return (lhs = static_cast<IOCondition >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline IOCondition & operator ^=(IOCondition & lhs, IOCondition rhs)
    {
        return (lhs = static_cast<IOCondition >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
    class PollFD
    {
        public :
            PollFD();
            explicit PollFD(int fd);
            PollFD(int fd, IOCondition events);
            void set_fd(int fd)
            {
                gobject_.fd = fd;
            }
            int get_fd() const
            {
                return gobject_.fd;
            }
            void set_events(IOCondition events)
            {
                gobject_.events = events;
            }
            IOCondition get_events() const
            {
                return static_cast<IOCondition >(gobject_.events);
            }
            void set_revents(IOCondition revents)
            {
                gobject_.revents = revents;
            }
            IOCondition get_revents() const
            {
                return static_cast<IOCondition >(gobject_.revents);
            }
            GPollFD * gobj()
            {
                return &gobject_;
            }
            const GPollFD * gobj() const
            {
                return &gobject_;
            }
        private :
            GPollFD gobject_;
    };
    class SignalTimeout
    {
        public :
            explicit inline SignalTimeout(GMainContext * context);
            sigc::connection connect(const sigc::slot< bool > & slot, unsigned int interval, int priority = PRIORITY_DEFAULT);
            sigc::connection connect_seconds(const sigc::slot< bool > & slot, unsigned int interval, int priority = PRIORITY_DEFAULT);
        private :
            GMainContext * context_;
            SignalTimeout & operator =(const SignalTimeout &);
    };
    class SignalIdle
    {
        public :
            explicit inline SignalIdle(GMainContext * context);
            sigc::connection connect(const sigc::slot< bool > & slot, int priority = PRIORITY_DEFAULT_IDLE);
        private :
            GMainContext * context_;
            SignalIdle & operator =(const SignalIdle &);
    };
    class SignalIO
    {
        public :
            explicit inline SignalIO(GMainContext * context);
            sigc::connection connect(const sigc::slot< bool, IOCondition > & slot, int fd, IOCondition condition, int priority = PRIORITY_DEFAULT);
            sigc::connection connect(const sigc::slot< bool, IOCondition > & slot, const Glib::RefPtr< IOChannel > & channel, IOCondition condition, int priority = PRIORITY_DEFAULT);
        private :
            GMainContext * context_;
            SignalIO & operator =(const SignalIO &);
    };
    class SignalChildWatch
    {
        public :
            explicit inline SignalChildWatch(GMainContext * context);
            sigc::connection connect(const sigc::slot< void, GPid, int > & slot, GPid pid, int priority = PRIORITY_DEFAULT);
        private :
            GMainContext * context_;
            SignalChildWatch & operator =(const SignalChildWatch &);
    };
    SignalTimeout signal_timeout();
    SignalIdle signal_idle();
    SignalIO signal_io();
    SignalChildWatch signal_child_watch();
    class MainContext
    {
        public :
            typedef Glib::MainContext CppObjectType;
            typedef GMainContext BaseObjectType;
            static Glib::RefPtr< MainContext > create();
            static Glib::RefPtr< MainContext > get_default();
            bool iteration(bool may_block);
            bool pending();
            void wakeup();
            bool acquire();
            bool wait(Glib::Cond & cond, Glib::Mutex & mutex);
            void release();
            bool prepare(int & priority);
            bool prepare();
            void query(int max_priority, int & timeout, std::vector< PollFD > & fds);
            bool check(int max_priority, std::vector< PollFD > & fds);
            void dispatch();
            void set_poll_func(GPollFunc poll_func);
            GPollFunc get_poll_func();
            void add_poll(PollFD & fd, int priority);
            void remove_poll(PollFD & fd);
            SignalTimeout signal_timeout();
            SignalIdle signal_idle();
            SignalIO signal_io();
            SignalChildWatch signal_child_watch();
            void reference() const;
            void unreference() const;
            GMainContext * gobj();
            const GMainContext * gobj() const;
            GMainContext * gobj_copy() const;
        private :
            MainContext();
            void operator delete(void *, size_t);
            MainContext(const MainContext & other);
            MainContext & operator =(const MainContext & other);
    };
    Glib::RefPtr< MainContext > wrap(GMainContext * gobject, bool take_copy = false);
    class MainLoop
    {
        public :
            typedef Glib::MainLoop CppObjectType;
            typedef GMainLoop BaseObjectType;
            static Glib::RefPtr< MainLoop > create(bool is_running = false);
            static Glib::RefPtr< MainLoop > create(const Glib::RefPtr< MainContext > & context, bool is_running = false);
            void run();
            void quit();
            bool is_running();
            Glib::RefPtr< MainContext > get_context();
            static int depth();
            void reference() const;
            void unreference() const;
            GMainLoop * gobj();
            const GMainLoop * gobj() const;
            GMainLoop * gobj_copy() const;
        private :
            MainLoop();
            void operator delete(void *, size_t);
            MainLoop(const MainLoop &);
            MainLoop & operator =(const MainLoop &);
    };
    Glib::RefPtr< MainLoop > wrap(GMainLoop * gobject, bool take_copy = false);
    class Source
    {
        public :
            typedef Glib::Source CppObjectType;
            typedef GSource BaseObjectType;
            static Glib::RefPtr< Source > create();
            unsigned int attach(const Glib::RefPtr< MainContext > & context);
            unsigned int attach();
            void destroy();
            void set_priority(int priority);
            int get_priority() const;
            void set_can_recurse(bool can_recurse);
            bool get_can_recurse() const;
            unsigned int get_id() const;
            Glib::RefPtr< MainContext > get_context();
            GSource * gobj()
            {
                return gobject_;
            }
            const GSource * gobj() const
            {
                return gobject_;
            }
            GSource * gobj_copy() const;
            void reference() const;
            void unreference() const;
        protected :
            Source();
            Source(GSource * cast_item, GSourceFunc callback_func);
            virtual ~Source();
            sigc::connection connect_generic(const sigc::slot_base & slot);
            void add_poll(PollFD & poll_fd);
            void remove_poll(PollFD & poll_fd);
            void get_current_time(Glib::TimeVal & current_time);
            virtual bool prepare(int & timeout) = 0;
            virtual bool check() = 0;
            virtual bool dispatch(sigc::slot_base * slot) = 0;
        private :
            GSource * gobject_;
            static inline Source * get_wrapper(GSource * source);
            static const GSourceFuncs vfunc_table_;
            static gboolean prepare_vfunc(GSource * source, int * timeout);
            static gboolean check_vfunc(GSource * source);
            static gboolean dispatch_vfunc(GSource * source, GSourceFunc callback, void * user_data);
        public :
            static void destroy_notify_callback(void * data);
        private :
            Source(const Source &);
            Source & operator =(const Source &);
    };
    class TimeoutSource : public Glib::Source
    {
        public :
            typedef Glib::TimeoutSource CppObjectType;
            static Glib::RefPtr< TimeoutSource > create(unsigned int interval);
            sigc::connection connect(const sigc::slot< bool > & slot);
        protected :
            explicit TimeoutSource(unsigned int interval);
            virtual ~TimeoutSource();
            virtual bool prepare(int & timeout);
            virtual bool check();
            virtual bool dispatch(sigc::slot_base * slot);
        private :
            Glib::TimeVal expiration_;
            unsigned int interval_;
    };
    class IdleSource : public Glib::Source
    {
        public :
            typedef Glib::IdleSource CppObjectType;
            static Glib::RefPtr< IdleSource > create();
            sigc::connection connect(const sigc::slot< bool > & slot);
        protected :
            IdleSource();
            virtual ~IdleSource();
            virtual bool prepare(int & timeout);
            virtual bool check();
            virtual bool dispatch(sigc::slot_base * slot_data);
    };
    class IOSource : public Glib::Source
    {
        public :
            typedef Glib::IOSource CppObjectType;
            static Glib::RefPtr< IOSource > create(int fd, IOCondition condition);
            static Glib::RefPtr< IOSource > create(const Glib::RefPtr< IOChannel > & channel, IOCondition condition);
            sigc::connection connect(const sigc::slot< bool, IOCondition > & slot);
        protected :
            IOSource(int fd, IOCondition condition);
            IOSource(const Glib::RefPtr< IOChannel > & channel, IOCondition condition);
            virtual ~IOSource();
            virtual bool prepare(int & timeout);
            virtual bool check();
            virtual bool dispatch(sigc::slot_base * slot);
        private :
            PollFD poll_fd_;
    };
}
namespace Glib {
    class DispatchNotifier;
    class Dispatcher
    {
        public :
            Dispatcher();
            explicit Dispatcher(const Glib::RefPtr< MainContext > & context);
            ~Dispatcher();
            void emit();
            void operator ()();
            sigc::connection connect(const sigc::slot< void > & slot);
        private :
            sigc::signal< void > signal_;
            DispatchNotifier * notifier_;
            Dispatcher(const Dispatcher &);
            Dispatcher & operator =(const Dispatcher &);
            friend class Glib::DispatchNotifier;
    };
}
namespace Glib {
    sigc::connection add_exception_handler(const sigc::slot< void > & slot);
    void exception_handlers_invoke() throw ();
}
extern "C"
{
    typedef struct _GDir GDir;
}
namespace Glib {
    enum FileTest
    {
        FILE_TEST_IS_REGULAR = 1 << 0, 
        FILE_TEST_IS_SYMLINK = 1 << 1, 
        FILE_TEST_IS_DIR = 1 << 2, 
        FILE_TEST_IS_EXECUTABLE = 1 << 3, 
        FILE_TEST_EXISTS = 1 << 4
    };
    inline FileTest operator |(FileTest lhs, FileTest rhs)
    {
        return static_cast<FileTest >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline FileTest operator &(FileTest lhs, FileTest rhs)
    {
        return static_cast<FileTest >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline FileTest operator ^(FileTest lhs, FileTest rhs)
    {
        return static_cast<FileTest >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline FileTest operator ~(FileTest flags)
    {
        return static_cast<FileTest >(~static_cast<unsigned >(flags));
    }
    inline FileTest & operator |=(FileTest & lhs, FileTest rhs)
    {
        return (lhs = static_cast<FileTest >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline FileTest & operator &=(FileTest & lhs, FileTest rhs)
    {
        return (lhs = static_cast<FileTest >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline FileTest & operator ^=(FileTest & lhs, FileTest rhs)
    {
        return (lhs = static_cast<FileTest >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
    class FileError : public Glib::Error
    {
        public :
            enum Code
            {
                EXISTS, 
                IS_DIRECTORY, 
                ACCESS_DENIED, 
                NAME_TOO_LONG, 
                NO_SUCH_ENTITY, 
                NOT_DIRECTORY, 
                NO_SUCH_DEVICE, 
                NOT_DEVICE, 
                READONLY_FILESYSTEM, 
                TEXT_FILE_BUSY, 
                FAULTY_ADDRESS, 
                SYMLINK_LOOP, 
                NO_SPACE_LEFT, 
                NOT_ENOUGH_MEMORY, 
                TOO_MANY_OPEN_FILES, 
                FILE_TABLE_OVERFLOW, 
                BAD_FILE_DESCRIPTOR, 
                INVALID_ARGUMENT, 
                BROKEN_PIPE, 
                TRYAGAIN, 
                INTERRUPTED, 
                IO_ERROR, 
                NOT_OWNER, 
                NOSYS, 
                FAILED
            };
            FileError(Code error_code, const Glib::ustring & error_message);
            explicit FileError(GError * gobject);
            Code code() const;
        private :
            static void throw_func(GError * gobject);
            friend void wrap_init();
    };
    class Dir;
    class DirIterator
    {
        public :
            typedef std::input_iterator_tag iterator_category;
            typedef std::string value_type;
            typedef int difference_type;
            typedef value_type reference;
            typedef void pointer;
            DirIterator();
            DirIterator(GDir * gobject, const char * current);
            std::string operator *() const;
            DirIterator & operator ++();
            void operator ++(int);
            bool operator ==(const DirIterator & rhs) const;
            bool operator !=(const DirIterator & rhs) const;
        private :
            GDir * gobject_;
            const char * current_;
    };
    class Dir
    {
        public :
            typedef DirIterator iterator;
            typedef DirIterator const_iterator;
            explicit Dir(const std::string & path);
            explicit Dir(GDir * gobject);
            ~Dir();
            std::string read_name();
            void rewind();
            void close();
            DirIterator begin();
            DirIterator end();
        private :
            GDir * gobject_;
            Dir(const Dir &);
            Dir & operator =(const Dir &);
    };
    bool file_test(const std::string & filename, FileTest test);
    int mkstemp(std::string & filename_template);
    int file_open_tmp(std::string & name_used, const std::string & prefix);
    int file_open_tmp(std::string & name_used);
    std::string file_get_contents(const std::string & filename);
}
namespace Glib {
    typedef Glib::ArrayHandle< Glib::ustring > SArray;
}
namespace Glib {
    template<class T >
    class List_Iterator;
    template<class T >
    class List_ConstIterator;
    template<class T >
    class List_ReverseIterator;
    extern gpointer glibmm_null_pointer;
    template<class T >
    class List_Iterator_Base
    {
        public :
            typedef T value_type;
            typedef T * pointer;
            typedef T & reference;
    };
    template<class T >
    class List_Iterator : public List_Iterator_Base< T >
    {
        public :
            typedef std::bidirectional_iterator_tag iterator_category;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef typename List_Iterator_Base< T >::pointer pointer;
            typedef typename List_Iterator_Base< T >::reference reference;
            GList *const * head_;
            GList * node_;
            typedef List_Iterator< T > Self;
            List_Iterator(GList *const & head, GList * node)
                : head_(&head), node_(node) 
            {
            }
            List_Iterator()
                : head_(0), node_(0) 
            {
            }
            List_Iterator(const Self & src)
                : head_(src.head_), node_(src.node_) 
            {
            }
            bool operator ==(const Self & src) const
            {
                return node_ == src.node_;
            }
            bool operator !=(const Self & src) const
            {
                return node_ != src.node_;
            }
            Self & operator ++()
            {
                if (!node_)
                    node_ = g_list_first(*head_);
                else
                    node_ = (GList *) ((node_) ? (((GList *) (node_))->next) : __null);
                return *this;
            }
            Self operator ++(int)
            {
                Self tmp = *this;
                ++*this;
                return tmp;
            }
            Self & operator --()
            {
                if (!node_)
                    node_ = g_list_last(*head_);
                else
                    node_ = (GList *) ((node_) ? (((GList *) (node_))->prev) : __null);
                return *this;
            }
            Self operator --(int)
            {
                Self tmp = *this;
                --*this;
                return tmp;
            }
            reference operator *() const
            {
                return *(pointer) (node_ ? node_->data : glibmm_null_pointer);
            }
            pointer operator ->() const
            {
                return &operator *();
            }
    };
    template<class T >
    class SList_Iterator : public List_Iterator_Base< T >
    {
        public :
            typedef std::forward_iterator_tag iterator_category;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef typename List_Iterator_Base< T >::pointer pointer;
            typedef typename List_Iterator_Base< T >::reference reference;
            GSList * node_;
            typedef SList_Iterator< T > Self;
            SList_Iterator(GSList * node)
                : node_(node) 
            {
            }
            SList_Iterator()
                : node_(0) 
            {
            }
            SList_Iterator(const Self & src)
                : node_(src.node_) 
            {
            }
            bool operator ==(const Self & src) const
            {
                return node_ == src.node_;
            }
            bool operator !=(const Self & src) const
            {
                return node_ != src.node_;
            }
            Self & operator ++()
            {
                node_ = ((node_) ? (((GSList *) (node_))->next) : __null);
                return *this;
            }
            Self operator ++(int)
            {
                Self tmp = *this;
                ++*this;
                return tmp;
            }
            reference operator *() const
            {
                return reinterpret_cast<T & >(node_ ? node_->data : glibmm_null_pointer);
            }
            pointer operator ->() const
            {
                return &operator *();
            }
    };
    template<class T_Impl, class T_IFace >
    class List_Cpp_Iterator : public List_Iterator_Base< T_IFace >
    {
        public :
            typedef std::bidirectional_iterator_tag iterator_category;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef typename List_Iterator_Base< T_IFace >::pointer pointer;
            typedef typename List_Iterator_Base< T_IFace >::reference reference;
            typedef List_Cpp_Iterator< T_Impl, T_IFace > Self;
            GList * * head_;
            GList * node_;
            bool operator ==(const Self & src) const
            {
                return node_ == src.node_;
            }
            bool operator !=(const Self & src) const
            {
                return node_ != src.node_;
            }
            List_Cpp_Iterator(GList * & head, GList * node)
                : head_(&head), node_(node) 
            {
            }
            List_Cpp_Iterator()
                : head_(0), node_(0) 
            {
            }
            List_Cpp_Iterator(const Self & src)
                : head_(src.head_), node_(src.node_) 
            {
            }
            reference operator *() const
            {
                if (node_ && node_->data)
                {
                    GObject * cobj = static_cast<GObject * >((*node_).data);
                    return *(dynamic_cast<pointer >(Glib::wrap_auto(cobj, false)));
                }
                return *(pointer) glibmm_null_pointer;
            }
            pointer operator ->() const
            {
                return &operator *();
            }
            Self & operator ++()
            {
                if (!node_)
                    node_ = g_list_first(*head_);
                else
                    node_ = (GList *) ((node_) ? (((GList *) (node_))->next) : __null);
                return *this;
            }
            Self operator ++(int)
            {
                Self tmp = *this;
                ++*this;
                return tmp;
            }
            Self & operator --()
            {
                if (!node_)
                    node_ = g_list_last(*head_);
                else
                    node_ = (GList *) ((node_) ? (((GList *) (node_))->prev) : __null);
                return *this;
            }
            Self operator --(int)
            {
                Self tmp = *this;
                --*this;
                return tmp;
            }
    };
    template<class T_Base >
    class List_ReverseIterator : private T_Base
    {
        public :
            typedef typename T_Base::iterator_category iterator_category;
            typedef typename T_Base::size_type size_type;
            typedef typename T_Base::difference_type difference_type;
            typedef typename T_Base::value_type value_type;
            typedef typename T_Base::pointer pointer;
            typedef typename T_Base::reference reference;
            typedef List_ReverseIterator< T_Base > Self;
            bool operator ==(const Self & src) const
            {
                return T_Base::operator ==(src);
            }
            bool operator !=(const Self & src) const
            {
                return T_Base::operator !=(src);
            }
            List_ReverseIterator(GList *const & head, GList * node)
                : T_Base(head, node) 
            {
            }
            List_ReverseIterator()
                : T_Base() 
            {
            }
            List_ReverseIterator(const Self & src)
                : T_Base(src) 
            {
            }
            List_ReverseIterator(const T_Base & src)
                : T_Base(src) 
            {
                ++(*this);
            }
            Self & operator ++()
            {
                T_Base::operator --();
                return *this;
            }
            Self & operator --()
            {
                T_Base::operator ++();
                return *this;
            }
            Self operator ++(int)
            {
                Self src = *this;
                T_Base::operator --();
                return src;
            }
            Self operator --(int)
            {
                Self src = *this;
                T_Base::operator ++();
                return src;
            }
            reference operator *() const
            {
                return T_Base::operator *();
            }
            pointer operator ->() const
            {
                return T_Base::operator ->();
            }
    };
    template<class T_Base >
    class List_ConstIterator : public T_Base
    {
        public :
            typedef typename T_Base::iterator_category iterator_category;
            typedef typename T_Base::size_type size_type;
            typedef typename T_Base::difference_type difference_type;
            typedef const typename T_Base::value_type value_type;
            typedef const typename T_Base::pointer pointer;
            typedef const typename T_Base::reference reference;
            typedef List_ConstIterator< T_Base > Self;
            bool operator ==(const Self & src) const
            {
                return T_Base::operator ==(src);
            }
            bool operator !=(const Self & src) const
            {
                return T_Base::operator !=(src);
            }
            List_ConstIterator(GList *const & head, GList * node)
                : T_Base(head, node) 
            {
            }
            List_ConstIterator()
                : T_Base() 
            {
            }
            List_ConstIterator(const Self & src)
                : T_Base(src) 
            {
            }
            List_ConstIterator(const T_Base & src)
                : T_Base(src) 
            {
            }
            Self & operator ++()
            {
                T_Base::operator ++();
                return *this;
            }
            Self & operator --()
            {
                T_Base::operator --();
                return *this;
            }
            Self operator ++(int)
            {
                Self src = *this;
                T_Base::operator ++();
                return src;
            }
            Self operator --(int)
            {
                Self src = *this;
                T_Base::operator --();
                return src;
            }
            reference operator *() const
            {
                return T_Base::operator *();
            }
            pointer operator ->() const
            {
                return T_Base::operator ->();
            }
    };
}
namespace Glib {
    template<typename T_Child, typename T_CppElement, typename T_Iterator >
    class HelperList
    {
        public :
            HelperList()
                : gparent_(0) 
            {
            }
            HelperList(GObject * gp)
                : gparent_(gp) 
            {
            }
            virtual ~HelperList()
            {
            }
            typedef T_Child value_type;
            typedef value_type & reference;
            typedef const value_type & const_reference;
            typedef T_Iterator iterator;
            typedef List_ConstIterator< iterator > const_iterator;
            typedef List_ReverseIterator< iterator > reverse_iterator;
            typedef List_ConstIterator< reverse_iterator > const_reverse_iterator;
            typedef T_CppElement element_type;
            typedef size_t difference_type;
            typedef size_t size_type;
            virtual iterator erase(iterator) = 0;
            virtual void erase(iterator start, iterator stop)
            {
                while (start != stop)
                    start = erase(start);
            }
            virtual void remove(const_reference) = 0;
            size_type size() const
            {
                return g_list_length(glist());
            }
            inline size_type max_size()
            {
                return size_type(-1);
            }
            inline bool empty()
            {
                return glist() == 0;
            }
            inline iterator begin()
            {
                return begin_();
            }
            inline iterator end()
            {
                return end_();
            }
            inline const_iterator begin() const
            {
                return const_iterator(begin_());
            }
            inline const_iterator end() const
            {
                return const_iterator(end_());
            }
            inline reverse_iterator rbegin()
            {
                return reverse_iterator(end_());
            }
            inline reverse_iterator rend()
            {
                return reverse_iterator(begin_());
            }
            inline const_reverse_iterator rbegin() const
            {
                return const_reverse_iterator(reverse_iterator(end_()));
            }
            inline const_reverse_iterator rend() const
            {
                return const_reverse_iterator(reverse_iterator(begin_()));
            }
            reference front() const
            {
                return *begin();
            }
            reference back() const
            {
                return *(--end());
            }
            reference operator [](size_type l) const
            {
                size_type j = 0;
                iterator i;
                for (i = begin() , j = 0;
                    i != end() , j < l;
                    ++i , ++j)
                ;
                return (*i);
            }
            inline void pop_front()
            {
                erase(begin());
            }
            inline void pop_back()
            {
                erase(--end());
            }
            void clear()
            {
                erase(begin(), end());
            }
            GObject * gparent()
            {
                return gparent_;
            }
            ;
            const GObject * gparent() const
            {
                return gparent_;
            }
            ;
        protected :
            virtual GList * & glist() const = 0;
            iterator begin_() const
            {
                return iterator(glist(), glist());
            }
            iterator end_() const
            {
                return iterator(glist(), (GList *) 0);
            }
            GObject * gparent_;
    };
}
namespace Glib {
    template<typename T >
    class ScopedPtr
    {
        private :
            T * ptr_;
            ScopedPtr(const ScopedPtr< T > &);
            ScopedPtr< T > & operator =(const ScopedPtr< T > &);
        public :
            ScopedPtr()
                : ptr_(0) 
            {
            }
            explicit ScopedPtr(T * ptr)
                : ptr_(ptr) 
            {
            }
            ~ScopedPtr()
            {
                g_free(ptr_);
            }
            T * get() const
            {
                return ptr_;
            }
            T * * addr()
            {
                return &ptr_;
            }
    };
    template<class T >
    inline T * unconst(const T * t)
    {
        return const_cast<T * >(t);
    }
    inline Glib::ustring convert_const_gchar_ptr_to_ustring(const char * str)
    {
        return (str) ? Glib::ustring(str) : Glib::ustring();
    }
    inline std::string convert_const_gchar_ptr_to_stdstring(const char * str)
    {
        return (str) ? std::string(str) : std::string();
    }
    inline Glib::ustring convert_return_gchar_ptr_to_ustring(char * str)
    {
        return (str) ? Glib::ustring(Glib::ScopedPtr< char >(str).get()) : Glib::ustring();
    }
    inline std::string convert_return_gchar_ptr_to_stdstring(char * str)
    {
        return (str) ? std::string(Glib::ScopedPtr< char >(str).get()) : std::string();
    }
    void append_canonical_typename(std::string & dest, const char * type_name);
}
extern "C"
{
    typedef struct _GObject GObject;
    typedef struct _GObjectClass GObjectClass;
}
namespace Glib {
    class Class;
    class Object_Class;
    class GSigConnectionNode;
    class ConstructParams
    {
        public :
            const Glib::Class & glibmm_class;
            unsigned int n_parameters;
            GParameter * parameters;
            explicit ConstructParams(const Glib::Class & glibmm_class_);
            ConstructParams(const Glib::Class & glibmm_class_, const char * first_property_name, ...) __attribute__((__sentinel__));
            ~ConstructParams();
            ConstructParams(const ConstructParams & other);
        private :
            ConstructParams & operator =(const ConstructParams &);
    };
    class Object : virtual public ObjectBase
    {
        public :
            typedef Object CppObjectType;
            typedef Object_Class CppClassType;
            typedef GObject BaseObjectType;
            typedef GObjectClass BaseClassType;
        protected :
            Object();
            explicit Object(const Glib::ConstructParams & construct_params);
            explicit Object(GObject * castitem);
            virtual ~Object();
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            void * get_data(const QueryQuark & key);
            void set_data(const Quark & key, void * data);
            typedef void (* DestroyNotify)(gpointer data);
            void set_data(const Quark & key, void * data, DestroyNotify notify);
            void remove_data(const QueryQuark & quark);
            void * steal_data(const QueryQuark & quark);
        private :
            friend class Glib::Object_Class;
            static CppClassType object_class_;
            Object(const Object &);
            Object & operator =(const Object &);
    };
}
namespace Glib {
    class Interface_Class;
    class Interface : virtual public Glib::ObjectBase
    {
        public :
            typedef Interface CppObjectType;
            typedef Interface_Class CppClassType;
            typedef GTypeInterface BaseClassType;
            explicit Interface(const Glib::Interface_Class & interface_class);
            explicit Interface(GObject * castitem);
            virtual ~Interface();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            inline GObject * gobj()
            {
                return gobject_;
            }
            inline const GObject * gobj() const
            {
                return gobject_;
            }
        private :
            Interface(const Interface &);
            Interface & operator =(const Interface &);
    };
    RefPtr< ObjectBase > wrap_interface(GObject * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GIOChannel GIOChannel;
}
namespace Glib {
    class Source;
    class IOSource;
    enum SeekType
    {
        SEEK_TYPE_CUR, 
        SEEK_TYPE_SET, 
        SEEK_TYPE_END
    };
    enum IOStatus
    {
        IO_STATUS_ERROR, 
        IO_STATUS_NORMAL, 
        IO_STATUS_EOF, 
        IO_STATUS_AGAIN
    };
    enum IOFlags
    {
        IO_FLAG_APPEND = 1 << 0, 
        IO_FLAG_NONBLOCK = 1 << 1, 
        IO_FLAG_IS_READABLE = 1 << 2, 
        IO_FLAG_IS_WRITEABLE = 1 << 3, 
        IO_FLAG_IS_SEEKABLE = 1 << 4, 
        IO_FLAG_GET_MASK = 0x0, 
        IO_FLAG_SET_MASK = 0x1
    };
    inline IOFlags operator |(IOFlags lhs, IOFlags rhs)
    {
        return static_cast<IOFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline IOFlags operator &(IOFlags lhs, IOFlags rhs)
    {
        return static_cast<IOFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline IOFlags operator ^(IOFlags lhs, IOFlags rhs)
    {
        return static_cast<IOFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline IOFlags operator ~(IOFlags flags)
    {
        return static_cast<IOFlags >(~static_cast<unsigned >(flags));
    }
    inline IOFlags & operator |=(IOFlags & lhs, IOFlags rhs)
    {
        return (lhs = static_cast<IOFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline IOFlags & operator &=(IOFlags & lhs, IOFlags rhs)
    {
        return (lhs = static_cast<IOFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline IOFlags & operator ^=(IOFlags & lhs, IOFlags rhs)
    {
        return (lhs = static_cast<IOFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
    class IOChannelError : public Glib::Error
    {
        public :
            enum Code
            {
                FILE_TOO_BIG, 
                INVALID_ARGUMENT, 
                IO_ERROR, 
                IS_DIRECTORY, 
                NO_SPACE_LEFT, 
                NO_SUCH_DEVICE, 
                OVERFLOWN, 
                BROKEN_PIPE, 
                FAILED
            };
            IOChannelError(Code error_code, const Glib::ustring & error_message);
            explicit IOChannelError(GError * gobject);
            Code code() const;
        private :
            static void throw_func(GError * gobject);
            friend void wrap_init();
    };
    class GlibmmIOChannel;
    class IOChannel : public sigc::trackable
    {
        public :
            typedef IOChannel CppObjectType;
            typedef GIOChannel BaseObjectType;
        private :
        public :
            virtual ~IOChannel();
            static Glib::RefPtr< IOChannel > create_from_file(const std::string & filename, const std::string & mode);
            static Glib::RefPtr< IOChannel > create_from_fd(int fd);
            IOStatus read(gunichar & thechar);
            IOStatus read(char * buf, gsize count, gsize & bytes_read);
            IOStatus read(Glib::ustring & str, gsize count);
            IOStatus read_line(Glib::ustring & line);
            IOStatus read_to_end(Glib::ustring & str);
            IOStatus write(const Glib::ustring & str);
            IOStatus write(const char * buf, gssize count, gsize & bytes_written);
            IOStatus write(gunichar unichar);
            IOStatus seek(gint64 offset, SeekType type = SEEK_TYPE_SET);
            IOStatus flush();
            IOStatus close(bool flush = true);
            gsize get_buffer_size() const;
            void set_buffer_size(gsize size);
            IOFlags get_flags() const;
            IOStatus set_flags(IOFlags flags);
            void set_buffered(bool buffered);
            bool get_buffered() const;
            IOCondition get_buffer_condition() const;
            bool get_close_on_unref() const;
            void set_close_on_unref(bool do_close);
            IOStatus set_encoding(const std::string & encoding = std::string());
            std::string get_encoding() const;
            void set_line_term(const std::string & term = std::string());
            std::string get_line_term() const;
            Glib::RefPtr< IOSource > create_watch(IOCondition condition);
            virtual void reference() const;
            virtual void unreference() const;
            GIOChannel * gobj()
            {
                return gobject_;
            }
            const GIOChannel * gobj() const
            {
                return gobject_;
            }
        protected :
            GIOChannel * gobject_;
            IOChannel();
            IOChannel(GIOChannel * gobject, bool take_copy);
            virtual IOStatus read_vfunc(char * buf, gsize count, gsize & bytes_read);
            virtual IOStatus write_vfunc(const char * buf, gsize count, gsize & bytes_written);
            virtual IOStatus seek_vfunc(gint64 offset, SeekType type);
            virtual IOStatus close_vfunc();
            virtual IOStatus set_flags_vfunc(IOFlags flags);
            virtual IOFlags get_flags_vfunc();
            virtual Glib::RefPtr< Glib::Source > create_watch_vfunc(IOCondition cond);
            friend class Glib::GlibmmIOChannel;
    };
    Glib::RefPtr< IOChannel > wrap(GIOChannel * gobject, bool take_copy = false);
}
namespace Glib {
    void init();
}
extern "C"
{
    typedef struct _GKeyFile GKeyFile;
}
namespace Glib {
    enum KeyFileFlags
    {
        KEY_FILE_NONE = 0, 
        KEY_FILE_KEEP_COMMENTS = 1 << 0, 
        KEY_FILE_KEEP_TRANSLATIONS = 1 << 1
    };
    inline KeyFileFlags operator |(KeyFileFlags lhs, KeyFileFlags rhs)
    {
        return static_cast<KeyFileFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline KeyFileFlags operator &(KeyFileFlags lhs, KeyFileFlags rhs)
    {
        return static_cast<KeyFileFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline KeyFileFlags operator ^(KeyFileFlags lhs, KeyFileFlags rhs)
    {
        return static_cast<KeyFileFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline KeyFileFlags operator ~(KeyFileFlags flags)
    {
        return static_cast<KeyFileFlags >(~static_cast<unsigned >(flags));
    }
    inline KeyFileFlags & operator |=(KeyFileFlags & lhs, KeyFileFlags rhs)
    {
        return (lhs = static_cast<KeyFileFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline KeyFileFlags & operator &=(KeyFileFlags & lhs, KeyFileFlags rhs)
    {
        return (lhs = static_cast<KeyFileFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline KeyFileFlags & operator ^=(KeyFileFlags & lhs, KeyFileFlags rhs)
    {
        return (lhs = static_cast<KeyFileFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
    class KeyFileError : public Glib::Error
    {
        public :
            enum Code
            {
                UNKNOWN_ENCODING, 
                PARSE, 
                NOT_FOUND, 
                KEY_NOT_FOUND, 
                GROUP_NOT_FOUND, 
                INVALID_VALUE
            };
            KeyFileError(Code error_code, const Glib::ustring & error_message);
            explicit KeyFileError(GError * gobject);
            Code code() const;
        private :
            static void throw_func(GError * gobject);
            friend void wrap_init();
    };
    class KeyFile
    {
        public :
            typedef KeyFile CppObjectType;
            typedef GKeyFile BaseObjectType;
        private :
        public :
            KeyFile();
            ~KeyFile();
            KeyFile(GKeyFile * castitem, bool takes_ownership = false);
        public :
            bool load_from_file(const std::string & filename, KeyFileFlags flags = Glib::KEY_FILE_NONE);
            bool load_from_data(const Glib::ustring & data, KeyFileFlags flags = Glib::KEY_FILE_NONE);
            bool load_from_data_dirs(const std::string & file, std::string & full_path, KeyFileFlags flags = Glib::KEY_FILE_NONE);
            Glib::ustring to_data();
            Glib::ustring get_start_group() const;
            Glib::ArrayHandle< Glib::ustring > get_groups() const;
            Glib::ArrayHandle< Glib::ustring > get_keys(const Glib::ustring & group_name) const;
            bool has_group(const Glib::ustring & group_name) const;
            bool has_key(const Glib::ustring & group_name, const Glib::ustring & key) const;
            Glib::ustring get_value(const Glib::ustring & group_name, const Glib::ustring & key) const;
            Glib::ustring get_string(const Glib::ustring & group_name, const Glib::ustring & key) const;
            Glib::ustring get_locale_string(const Glib::ustring & group_name, const Glib::ustring & key) const;
            Glib::ustring get_locale_string(const Glib::ustring & group_name, const Glib::ustring & key, const Glib::ustring & locale) const;
            bool get_boolean(const Glib::ustring & group_name, const Glib::ustring & key) const;
            int get_integer(const Glib::ustring & key) const;
            int get_integer(const Glib::ustring & group_name, const Glib::ustring & key) const;
            double get_double(const Glib::ustring & key) const;
            double get_double(const Glib::ustring & group_name, const Glib::ustring & key) const;
            void set_double(const Glib::ustring & group_name, const Glib::ustring & key, double value);
            void set_double(const Glib::ustring & key, double value);
            Glib::ArrayHandle< Glib::ustring > get_string_list(const Glib::ustring & group_name, const Glib::ustring & key) const;
            Glib::ArrayHandle< Glib::ustring > get_locale_string_list(const Glib::ustring & group_name, const Glib::ustring & key) const;
            Glib::ArrayHandle< Glib::ustring > get_locale_string_list(const Glib::ustring & group_name, const Glib::ustring & key, const Glib::ustring & locale) const;
            Glib::ArrayHandle< bool > get_boolean_list(const Glib::ustring & group_name, const Glib::ustring & key) const;
            Glib::ArrayHandle< int > get_integer_list(const Glib::ustring & group_name, const Glib::ustring & key) const;
            Glib::ArrayHandle< double > get_double_list(const Glib::ustring & group_name, const Glib::ustring & key) const;
            Glib::ustring get_comment() const;
            Glib::ustring get_comment(const Glib::ustring & group_name) const;
            Glib::ustring get_comment(const Glib::ustring & group_name, const Glib::ustring & key) const;
            void set_list_separator(gchar separator);
            void set_value(const Glib::ustring & group_name, const Glib::ustring & key, const Glib::ustring & value);
            void set_string(const Glib::ustring & group_name, const Glib::ustring & key, const Glib::ustring & string);
            void set_locale_string(const Glib::ustring & group_name, const Glib::ustring & key, const Glib::ustring & locale, const Glib::ustring & string);
            void set_boolean(const Glib::ustring & group_name, const Glib::ustring & key, bool value);
            void set_integer(const Glib::ustring & group_name, const Glib::ustring & key, int value);
            void set_string_list(const Glib::ustring & group_name, const Glib::ustring & key, const Glib::ArrayHandle< Glib::ustring > & list);
            void set_locale_string_list(const Glib::ustring & group_name, const Glib::ustring & key, const Glib::ustring & locale, const Glib::ArrayHandle< Glib::ustring > & list);
            void set_boolean_list(const Glib::ustring & group_name, const Glib::ustring & key, const Glib::ArrayHandle< bool > & list);
            void set_integer_list(const Glib::ustring & group_name, const Glib::ustring & key, const Glib::ArrayHandle< int > & list);
            void set_double_list(const Glib::ustring & group_name, const Glib::ustring & key, const Glib::ArrayHandle< double > & list);
            void set_comment(const Glib::ustring & comment);
            void set_comment(const Glib::ustring & group_name, const Glib::ustring & comment);
            void set_comment(const Glib::ustring & group_name, const Glib::ustring & key, const Glib::ustring & comment);
            void remove_comment(const Glib::ustring & group_name, const Glib::ustring & key);
            void remove_key(const Glib::ustring & group_name, const Glib::ustring & key);
            void remove_group(const Glib::ustring & group_name);
            GKeyFile * gobj()
            {
                return gobject_;
            }
            const GKeyFile * gobj() const
            {
                return gobject_;
            }
        protected :
            GKeyFile * gobject_;
            bool owns_gobject_;
        private :
            KeyFile(const KeyFile &);
            KeyFile & operator =(const KeyFile &);
    };
}
namespace Glib {
    class StreamIOChannel : public Glib::IOChannel
    {
        public :
            virtual ~StreamIOChannel();
            static Glib::RefPtr< StreamIOChannel > create(std::istream & stream);
            static Glib::RefPtr< StreamIOChannel > create(std::ostream & stream);
            static Glib::RefPtr< StreamIOChannel > create(std::iostream & stream);
        protected :
            std::istream * stream_in_;
            std::ostream * stream_out_;
            StreamIOChannel(std::istream * stream_in, std::ostream * stream_out);
            virtual IOStatus read_vfunc(char * buf, gsize count, gsize & bytes_read);
            virtual IOStatus write_vfunc(const char * buf, gsize count, gsize & bytes_written);
            virtual IOStatus seek_vfunc(gint64 offset, SeekType type);
            virtual IOStatus close_vfunc();
            virtual IOStatus set_flags_vfunc(IOFlags flags);
            virtual IOFlags get_flags_vfunc();
            virtual Glib::RefPtr< Glib::Source > create_watch_vfunc(IOCondition cond);
    };
}
namespace Glib {
    namespace Container_Helpers {
        template<class Bi, class Tr >
        GList * create_list(Bi pbegin, Bi pend, Tr)
        {
            GList * head = 0;
            while (pend != pbegin)
            {
                const void *const item = Tr::to_c_type(*&*--pend);
                head = g_list_prepend(head, const_cast<void * >(item));
            }
            return head;
        }
        template<class For, class Tr >
        GList * create_list(For pbegin, Tr)
        {
            GList * head = 0;
            while (*pbegin)
            {
                const void *const item = Tr::to_c_type(*&*pbegin);
                head = g_list_prepend(head, const_cast<void * >(item));
                ++pbegin;
            }
            return g_list_reverse(head);
        }
        template<class Tr, class Cont >
        struct ListSourceTraits
        {
                static GList * get_data(const Cont & cont)
                {
                    return Glib::Container_Helpers::create_list(cont.begin(), cont.end(), Tr());
                }
                static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_SHALLOW;
        };
        template<class Tr, class Cont >
        struct ListSourceTraits< Tr, Cont * >
        {
                static GList * get_data(const Cont * array)
                {
                    return (array) ? Glib::Container_Helpers::create_list(array, Tr()) : 0;
                }
                static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_SHALLOW;
        };
        template<class Tr, class Cont >
        struct ListSourceTraits< Tr, const Cont * > : ListSourceTraits< Tr, Cont * >
        {
        };
        template<class Tr, class Cont, size_t N >
        struct ListSourceTraits< Tr, Cont [N] >
        {
                static GList * get_data(const Cont * array)
                {
                    return Glib::Container_Helpers::create_list(array, array + (N - 1), Tr());
                }
                static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_SHALLOW;
        };
        template<class Tr, class Cont, size_t N >
        struct ListSourceTraits< Tr, const Cont [N] > : ListSourceTraits< Tr, Cont [N] >
        {
        };
        template<class Tr >
        class ListHandleIterator
        {
            public :
                typedef typename Tr::CppType CppType;
                typedef typename Tr::CType CType;
                typedef std::forward_iterator_tag iterator_category;
                typedef CppType value_type;
                typedef ptrdiff_t difference_type;
                typedef value_type reference;
                typedef void pointer;
                explicit inline ListHandleIterator(const GList * node);
                inline value_type operator *() const;
                inline ListHandleIterator< Tr > & operator ++();
                inline const ListHandleIterator< Tr > operator ++(int);
                inline bool operator ==(const ListHandleIterator< Tr > & rhs) const;
                inline bool operator !=(const ListHandleIterator< Tr > & rhs) const;
            private :
                const GList * node_;
        };
    }
    template<class T, class Tr = Glib::Container_Helpers::TypeTraits< T > >
    class ListHandle
    {
        public :
            typedef typename Tr::CppType CppType;
            typedef typename Tr::CType CType;
            typedef CppType value_type;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef Glib::Container_Helpers::ListHandleIterator< Tr > const_iterator;
            typedef Glib::Container_Helpers::ListHandleIterator< Tr > iterator;
            template<class Cont >
            inline ListHandle(const Cont & container);
            inline ListHandle(GList * glist, Glib::OwnershipType ownership);
            inline ListHandle(const ListHandle< T, Tr > & other);
            ~ListHandle();
            inline const_iterator begin() const;
            inline const_iterator end() const;
            template<class U >
            inline operator std::vector< U >() const;
            template<class U >
            inline operator std::deque< U >() const;
            template<class U >
            inline operator std::list< U >() const;
            template<class Cont >
            inline void assign_to(Cont & container) const;
            template<class Out >
            inline void copy(Out pdest) const;
            inline GList * data() const;
            inline size_t size() const;
            inline bool empty() const;
        private :
            GList * plist_;
            mutable Glib::OwnershipType ownership_;
            ListHandle< T, Tr > & operator =(const ListHandle< T, Tr > &);
    };
    namespace Container_Helpers {
        template<class Tr >
        inline ListHandleIterator< Tr >::ListHandleIterator(const GList * node)
            : node_(node) 
        {
        }
        template<class Tr >
        inline typename ListHandleIterator< Tr >::value_type ListHandleIterator< Tr >::operator *() const
        {
            return Tr::to_cpp_type(static_cast<typename Tr::CTypeNonConst >(node_->data));
        }
        template<class Tr >
        inline ListHandleIterator< Tr > & ListHandleIterator< Tr >::operator ++()
        {
            node_ = node_->next;
            return *this;
        }
        template<class Tr >
        inline const ListHandleIterator< Tr > ListHandleIterator< Tr >::operator ++(int)
        {
            const ListHandleIterator< Tr > tmp(*this);
            node_ = node_->next;
            return tmp;
        }
        template<class Tr >
        inline bool ListHandleIterator< Tr >::operator ==(const ListHandleIterator< Tr > & rhs) const
        {
            return (node_ == rhs.node_);
        }
        template<class Tr >
        inline bool ListHandleIterator< Tr >::operator !=(const ListHandleIterator< Tr > & rhs) const
        {
            return (node_ != rhs.node_);
        }
    }
    template<class T, class Tr >
    template<class Cont >
    inline ListHandle< T, Tr >::ListHandle(const Cont & container)
        : plist_(Glib::Container_Helpers::ListSourceTraits< Tr, Cont >::get_data(container)), ownership_(Glib::Container_Helpers::ListSourceTraits< Tr, Cont >::initial_ownership) 
    {
    }
    template<class T, class Tr >
    inline ListHandle< T, Tr >::ListHandle(GList * glist, Glib::OwnershipType ownership)
        : plist_(glist), ownership_(ownership) 
    {
    }
    template<class T, class Tr >
    inline ListHandle< T, Tr >::ListHandle(const ListHandle< T, Tr > & other)
        : plist_(other.plist_), ownership_(other.ownership_) 
    {
        other.ownership_ = Glib::OWNERSHIP_NONE;
    }
    template<class T, class Tr >
    ListHandle< T, Tr >::~ListHandle()
    {
        if (ownership_ != Glib::OWNERSHIP_NONE)
        {
            if (ownership_ != Glib::OWNERSHIP_SHALLOW)
            {
                for (GList * node = plist_;
                    node != 0;
                    node = node->next)
                Tr::release_c_type(static_cast<typename Tr::CTypeNonConst >(node->data));
            }
            g_list_free(plist_);
        }
    }
    template<class T, class Tr >
    inline typename ListHandle< T, Tr >::const_iterator ListHandle< T, Tr >::begin() const
    {
        return Glib::Container_Helpers::ListHandleIterator< Tr >(plist_);
    }
    template<class T, class Tr >
    inline typename ListHandle< T, Tr >::const_iterator ListHandle< T, Tr >::end() const
    {
        return Glib::Container_Helpers::ListHandleIterator< Tr >(0);
    }
    template<class T, class Tr >
    template<class U >
    inline ListHandle< T, Tr >::operator std::vector< U >() const
    {
        return std::vector< U >(this->begin(), this->end());
    }
    template<class T, class Tr >
    template<class U >
    inline ListHandle< T, Tr >::operator std::deque< U >() const
    {
        return std::deque< U >(this->begin(), this->end());
    }
    template<class T, class Tr >
    template<class U >
    inline ListHandle< T, Tr >::operator std::list< U >() const
    {
        return std::list< U >(this->begin(), this->end());
    }
    template<class T, class Tr >
    template<class Cont >
    inline void ListHandle< T, Tr >::assign_to(Cont & container) const
    {
        container.assign(this->begin(), this->end());
    }
    template<class T, class Tr >
    template<class Out >
    inline void ListHandle< T, Tr >::copy(Out pdest) const
    {
        std::copy(this->begin(), this->end(), pdest);
    }
    template<class T, class Tr >
    inline GList * ListHandle< T, Tr >::data() const
    {
        return plist_;
    }
    template<class T, class Tr >
    inline size_t ListHandle< T, Tr >::size() const
    {
        return g_list_length(plist_);
    }
    template<class T, class Tr >
    inline bool ListHandle< T, Tr >::empty() const
    {
        return (plist_ == 0);
    }
}
namespace std __attribute__((__visibility__("default"))) {
    enum _Rb_tree_color
    {
        _S_red = false, 
        _S_black = true
    };
    struct _Rb_tree_node_base
    {
            typedef _Rb_tree_node_base * _Base_ptr;
            typedef const _Rb_tree_node_base * _Const_Base_ptr;
            _Rb_tree_color _M_color;
            _Base_ptr _M_parent;
            _Base_ptr _M_left;
            _Base_ptr _M_right;
            static _Base_ptr _S_minimum(_Base_ptr __x)
            {
                while (__x->_M_left != 0)
                    __x = __x->_M_left;
                return __x;
            }
            static _Const_Base_ptr _S_minimum(_Const_Base_ptr __x)
            {
                while (__x->_M_left != 0)
                    __x = __x->_M_left;
                return __x;
            }
            static _Base_ptr _S_maximum(_Base_ptr __x)
            {
                while (__x->_M_right != 0)
                    __x = __x->_M_right;
                return __x;
            }
            static _Const_Base_ptr _S_maximum(_Const_Base_ptr __x)
            {
                while (__x->_M_right != 0)
                    __x = __x->_M_right;
                return __x;
            }
    };
    template<typename _Val >
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
            typedef _Rb_tree_node< _Val > * _Link_type;
            _Val _M_value_field;
    };
    _Rb_tree_node_base * _Rb_tree_increment(_Rb_tree_node_base * __x);
    const _Rb_tree_node_base * _Rb_tree_increment(const _Rb_tree_node_base * __x);
    _Rb_tree_node_base * _Rb_tree_decrement(_Rb_tree_node_base * __x);
    const _Rb_tree_node_base * _Rb_tree_decrement(const _Rb_tree_node_base * __x);
    template<typename _Tp >
    struct _Rb_tree_iterator
    {
            typedef _Tp value_type;
            typedef _Tp & reference;
            typedef _Tp * pointer;
            typedef bidirectional_iterator_tag iterator_category;
            typedef ptrdiff_t difference_type;
            typedef _Rb_tree_iterator< _Tp > _Self;
            typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
            typedef _Rb_tree_node< _Tp > * _Link_type;
            _Rb_tree_iterator()
                : _M_node() 
            {
            }
            explicit _Rb_tree_iterator(_Link_type __x)
                : _M_node(__x) 
            {
            }
            reference operator *() const
            {
                return static_cast<_Link_type >(_M_node)->_M_value_field;
            }
            pointer operator ->() const
            {
                return &static_cast<_Link_type >(_M_node)->_M_value_field;
            }
            _Self & operator ++()
            {
                _M_node = _Rb_tree_increment(_M_node);
                return *this;
            }
            _Self operator ++(int)
            {
                _Self __tmp = *this;
                _M_node = _Rb_tree_increment(_M_node);
                return __tmp;
            }
            _Self & operator --()
            {
                _M_node = _Rb_tree_decrement(_M_node);
                return *this;
            }
            _Self operator --(int)
            {
                _Self __tmp = *this;
                _M_node = _Rb_tree_decrement(_M_node);
                return __tmp;
            }
            bool operator ==(const _Self & __x) const
            {
                return _M_node == __x._M_node;
            }
            bool operator !=(const _Self & __x) const
            {
                return _M_node != __x._M_node;
            }
            _Base_ptr _M_node;
    };
    template<typename _Tp >
    struct _Rb_tree_const_iterator
    {
            typedef _Tp value_type;
            typedef const _Tp & reference;
            typedef const _Tp * pointer;
            typedef _Rb_tree_iterator< _Tp > iterator;
            typedef bidirectional_iterator_tag iterator_category;
            typedef ptrdiff_t difference_type;
            typedef _Rb_tree_const_iterator< _Tp > _Self;
            typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
            typedef const _Rb_tree_node< _Tp > * _Link_type;
            _Rb_tree_const_iterator()
                : _M_node() 
            {
            }
            explicit _Rb_tree_const_iterator(_Link_type __x)
                : _M_node(__x) 
            {
            }
            _Rb_tree_const_iterator(const iterator & __it)
                : _M_node(__it._M_node) 
            {
            }
            reference operator *() const
            {
                return static_cast<_Link_type >(_M_node)->_M_value_field;
            }
            pointer operator ->() const
            {
                return &static_cast<_Link_type >(_M_node)->_M_value_field;
            }
            _Self & operator ++()
            {
                _M_node = _Rb_tree_increment(_M_node);
                return *this;
            }
            _Self operator ++(int)
            {
                _Self __tmp = *this;
                _M_node = _Rb_tree_increment(_M_node);
                return __tmp;
            }
            _Self & operator --()
            {
                _M_node = _Rb_tree_decrement(_M_node);
                return *this;
            }
            _Self operator --(int)
            {
                _Self __tmp = *this;
                _M_node = _Rb_tree_decrement(_M_node);
                return __tmp;
            }
            bool operator ==(const _Self & __x) const
            {
                return _M_node == __x._M_node;
            }
            bool operator !=(const _Self & __x) const
            {
                return _M_node != __x._M_node;
            }
            _Base_ptr _M_node;
    };
    template<typename _Val >
    inline bool operator ==(const _Rb_tree_iterator< _Val > & __x, const _Rb_tree_const_iterator< _Val > & __y)
    {
        return __x._M_node == __y._M_node;
    }
    template<typename _Val >
    inline bool operator !=(const _Rb_tree_iterator< _Val > & __x, const _Rb_tree_const_iterator< _Val > & __y)
    {
        return __x._M_node != __y._M_node;
    }
    void _Rb_tree_insert_and_rebalance(const bool __insert_left, _Rb_tree_node_base * __x, _Rb_tree_node_base * __p, _Rb_tree_node_base & __header);
    _Rb_tree_node_base * _Rb_tree_rebalance_for_erase(_Rb_tree_node_base *const __z, _Rb_tree_node_base & __header);
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc = allocator< _Val > >
    class _Rb_tree
    {
            typedef typename _Alloc::template rebind< _Rb_tree_node< _Val > >::other _Node_allocator;
        protected :
            typedef _Rb_tree_node_base * _Base_ptr;
            typedef const _Rb_tree_node_base * _Const_Base_ptr;
        public :
            typedef _Key key_type;
            typedef _Val value_type;
            typedef value_type * pointer;
            typedef const value_type * const_pointer;
            typedef value_type & reference;
            typedef const value_type & const_reference;
            typedef _Rb_tree_node< _Val > * _Link_type;
            typedef const _Rb_tree_node< _Val > * _Const_Link_type;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef _Alloc allocator_type;
            _Node_allocator & _M_get_Node_allocator()
            {
                return *static_cast<_Node_allocator * >(&this->_M_impl);
            }
            const _Node_allocator & _M_get_Node_allocator() const
            {
                return *static_cast<const _Node_allocator * >(&this->_M_impl);
            }
            allocator_type get_allocator() const
            {
                return allocator_type(_M_get_Node_allocator());
            }
        protected :
            _Link_type _M_get_node()
            {
                return _M_impl._Node_allocator::allocate(1);
            }
            void _M_put_node(_Link_type __p)
            {
                _M_impl._Node_allocator::deallocate(__p, 1);
            }
            _Link_type _M_create_node(const value_type & __x)
            {
                _Link_type __tmp = _M_get_node();
                try
                {
                    get_allocator().construct(&__tmp->_M_value_field, __x);
                }
                catch (...)
                {
                    _M_put_node(__tmp);
                    throw;
                }
                return __tmp;
            }
            _Link_type _M_clone_node(_Const_Link_type __x)
            {
                _Link_type __tmp = _M_create_node(__x->_M_value_field);
                __tmp->_M_color = __x->_M_color;
                __tmp->_M_left = 0;
                __tmp->_M_right = 0;
                return __tmp;
            }
            void _M_destroy_node(_Link_type __p)
            {
                get_allocator().destroy(&__p->_M_value_field);
                _M_put_node(__p);
            }
        protected :
            template<typename _Key_compare, bool _Is_pod_comparator = __is_pod(_Key_compare) >
            struct _Rb_tree_impl : public _Node_allocator
            {
                    _Key_compare _M_key_compare;
                    _Rb_tree_node_base _M_header;
                    size_type _M_node_count;
                    _Rb_tree_impl()
                        : _Node_allocator(), _M_key_compare(), _M_header(), _M_node_count(0) 
                    {
                        _M_initialize();
                    }
                    _Rb_tree_impl(const _Key_compare & __comp, const _Node_allocator & __a)
                        : _Node_allocator(__a), _M_key_compare(__comp), _M_header(), _M_node_count(0) 
                    {
                        _M_initialize();
                    }
                private :
                    void _M_initialize()
                    {
                        this->_M_header._M_color = _S_red;
                        this->_M_header._M_parent = 0;
                        this->_M_header._M_left = &this->_M_header;
                        this->_M_header._M_right = &this->_M_header;
                    }
            };
            _Rb_tree_impl< _Compare > _M_impl;
        protected :
            _Base_ptr & _M_root()
            {
                return this->_M_impl._M_header._M_parent;
            }
            _Const_Base_ptr _M_root() const
            {
                return this->_M_impl._M_header._M_parent;
            }
            _Base_ptr & _M_leftmost()
            {
                return this->_M_impl._M_header._M_left;
            }
            _Const_Base_ptr _M_leftmost() const
            {
                return this->_M_impl._M_header._M_left;
            }
            _Base_ptr & _M_rightmost()
            {
                return this->_M_impl._M_header._M_right;
            }
            _Const_Base_ptr _M_rightmost() const
            {
                return this->_M_impl._M_header._M_right;
            }
            _Link_type _M_begin()
            {
                return static_cast<_Link_type >(this->_M_impl._M_header._M_parent);
            }
            _Const_Link_type _M_begin() const
            {
                return static_cast<_Const_Link_type >(this->_M_impl._M_header._M_parent);
            }
            _Link_type _M_end()
            {
                return static_cast<_Link_type >(&this->_M_impl._M_header);
            }
            _Const_Link_type _M_end() const
            {
                return static_cast<_Const_Link_type >(&this->_M_impl._M_header);
            }
            static const_reference _S_value(_Const_Link_type __x)
            {
                return __x->_M_value_field;
            }
            static const _Key & _S_key(_Const_Link_type __x)
            {
                return _KeyOfValue()(_S_value(__x));
            }
            static _Link_type _S_left(_Base_ptr __x)
            {
                return static_cast<_Link_type >(__x->_M_left);
            }
            static _Const_Link_type _S_left(_Const_Base_ptr __x)
            {
                return static_cast<_Const_Link_type >(__x->_M_left);
            }
            static _Link_type _S_right(_Base_ptr __x)
            {
                return static_cast<_Link_type >(__x->_M_right);
            }
            static _Const_Link_type _S_right(_Const_Base_ptr __x)
            {
                return static_cast<_Const_Link_type >(__x->_M_right);
            }
            static const_reference _S_value(_Const_Base_ptr __x)
            {
                return static_cast<_Const_Link_type >(__x)->_M_value_field;
            }
            static const _Key & _S_key(_Const_Base_ptr __x)
            {
                return _KeyOfValue()(_S_value(__x));
            }
            static _Base_ptr _S_minimum(_Base_ptr __x)
            {
                return _Rb_tree_node_base::_S_minimum(__x);
            }
            static _Const_Base_ptr _S_minimum(_Const_Base_ptr __x)
            {
                return _Rb_tree_node_base::_S_minimum(__x);
            }
            static _Base_ptr _S_maximum(_Base_ptr __x)
            {
                return _Rb_tree_node_base::_S_maximum(__x);
            }
            static _Const_Base_ptr _S_maximum(_Const_Base_ptr __x)
            {
                return _Rb_tree_node_base::_S_maximum(__x);
            }
        public :
            typedef _Rb_tree_iterator< value_type > iterator;
            typedef _Rb_tree_const_iterator< value_type > const_iterator;
            typedef std::reverse_iterator< iterator > reverse_iterator;
            typedef std::reverse_iterator< const_iterator > const_reverse_iterator;
        private :
            iterator _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y, const value_type & __v);
            iterator _M_insert_lower(_Base_ptr __x, _Base_ptr __y, const value_type & __v);
            iterator _M_insert_equal_lower(const value_type & __x);
            _Link_type _M_copy(_Const_Link_type __x, _Link_type __p);
            void _M_erase(_Link_type __x);
            iterator _M_lower_bound(_Link_type __x, _Link_type __y, const _Key & __k);
            const_iterator _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y, const _Key & __k) const;
            iterator _M_upper_bound(_Link_type __x, _Link_type __y, const _Key & __k);
            const_iterator _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y, const _Key & __k) const;
        public :
            _Rb_tree()
            {
            }
            _Rb_tree(const _Compare & __comp, const allocator_type & __a = allocator_type())
                : _M_impl(__comp, __a) 
            {
            }
            _Rb_tree(const _Rb_tree & __x)
                : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator()) 
            {
                if (__x._M_root() != 0)
                {
                    _M_root() = _M_copy(__x._M_begin(), _M_end());
                    _M_leftmost() = _S_minimum(_M_root());
                    _M_rightmost() = _S_maximum(_M_root());
                    _M_impl._M_node_count = __x._M_impl._M_node_count;
                }
            }
            ~_Rb_tree()
            {
                _M_erase(_M_begin());
            }
            _Rb_tree & operator =(const _Rb_tree & __x);
            _Compare key_comp() const
            {
                return _M_impl._M_key_compare;
            }
            iterator begin()
            {
                return iterator(static_cast<_Link_type >(this->_M_impl._M_header._M_left));
            }
            const_iterator begin() const
            {
                return const_iterator(static_cast<_Const_Link_type >(this->_M_impl._M_header._M_left));
            }
            iterator end()
            {
                return iterator(static_cast<_Link_type >(&this->_M_impl._M_header));
            }
            const_iterator end() const
            {
                return const_iterator(static_cast<_Const_Link_type >(&this->_M_impl._M_header));
            }
            reverse_iterator rbegin()
            {
                return reverse_iterator(end());
            }
            const_reverse_iterator rbegin() const
            {
                return const_reverse_iterator(end());
            }
            reverse_iterator rend()
            {
                return reverse_iterator(begin());
            }
            const_reverse_iterator rend() const
            {
                return const_reverse_iterator(begin());
            }
            bool empty() const
            {
                return _M_impl._M_node_count == 0;
            }
            size_type size() const
            {
                return _M_impl._M_node_count;
            }
            size_type max_size() const
            {
                return get_allocator().max_size();
            }
            void swap(_Rb_tree & __t);
            pair< iterator, bool > _M_insert_unique(const value_type & __x);
            iterator _M_insert_equal(const value_type & __x);
            iterator _M_insert_unique_(const_iterator __position, const value_type & __x);
            iterator _M_insert_equal_(const_iterator __position, const value_type & __x);
            template<typename _InputIterator >
            void _M_insert_unique(_InputIterator __first, _InputIterator __last);
            template<typename _InputIterator >
            void _M_insert_equal(_InputIterator __first, _InputIterator __last);
            void erase(iterator __position);
            void erase(const_iterator __position);
            size_type erase(const key_type & __x);
            void erase(iterator __first, iterator __last);
            void erase(const_iterator __first, const_iterator __last);
            void erase(const key_type * __first, const key_type * __last);
            void clear()
            {
                _M_erase(_M_begin());
                _M_leftmost() = _M_end();
                _M_root() = 0;
                _M_rightmost() = _M_end();
                _M_impl._M_node_count = 0;
            }
            iterator find(const key_type & __k);
            const_iterator find(const key_type & __k) const;
            size_type count(const key_type & __k) const;
            iterator lower_bound(const key_type & __k)
            {
                return _M_lower_bound(_M_begin(), _M_end(), __k);
            }
            const_iterator lower_bound(const key_type & __k) const
            {
                return _M_lower_bound(_M_begin(), _M_end(), __k);
            }
            iterator upper_bound(const key_type & __k)
            {
                return _M_upper_bound(_M_begin(), _M_end(), __k);
            }
            const_iterator upper_bound(const key_type & __k) const
            {
                return _M_upper_bound(_M_begin(), _M_end(), __k);
            }
            pair< iterator, iterator > equal_range(const key_type & __k);
            pair< const_iterator, const_iterator > equal_range(const key_type & __k) const;
            bool __rb_verify() const;
    };
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    inline bool operator ==(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __y)
    {
        return __x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    inline bool operator <(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __y)
    {
        return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    inline bool operator !=(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __y)
    {
        return !(__x == __y);
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    inline bool operator >(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __y)
    {
        return __y < __x;
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    inline bool operator <=(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __y)
    {
        return !(__y < __x);
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    inline bool operator >=(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __y)
    {
        return !(__x < __y);
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    inline void swap(_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __x, _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __y)
    {
        __x.swap(__y);
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > & _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::operator =(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __x)
    {
        if (this != &__x)
        {
            clear();
            _M_impl._M_key_compare = __x._M_impl._M_key_compare;
            if (__x._M_root() != 0)
            {
                _M_root() = _M_copy(__x._M_begin(), _M_end());
                _M_leftmost() = _S_minimum(_M_root());
                _M_rightmost() = _S_maximum(_M_root());
                _M_impl._M_node_count = __x._M_impl._M_node_count;
            }
        }
        return *this;
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::iterator _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::_M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val & __v)
    {
        bool __insert_left = (__x != 0 || __p == _M_end() || _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__p)));
        _Link_type __z = _M_create_node(__v);
        _Rb_tree_insert_and_rebalance(__insert_left, __z, const_cast<_Base_ptr >(__p), this->_M_impl._M_header);
        ++_M_impl._M_node_count;
        return iterator(__z);
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::iterator _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::_M_insert_lower(_Base_ptr __x, _Base_ptr __p, const _Val & __v)
    {
        bool __insert_left = (__x != 0 || __p == _M_end() || !_M_impl._M_key_compare(_S_key(__p), _KeyOfValue()(__v)));
        _Link_type __z = _M_create_node(__v);
        _Rb_tree_insert_and_rebalance(__insert_left, __z, __p, this->_M_impl._M_header);
        ++_M_impl._M_node_count;
        return iterator(__z);
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::iterator _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::_M_insert_equal_lower(const _Val & __v)
    {
        _Link_type __x = _M_begin();
        _Link_type __y = _M_end();
        while (__x != 0)
        {
            __y = __x;
            __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ? _S_left(__x) : _S_right(__x);
        }
        return _M_insert_lower(__x, __y, __v);
    }
    template<typename _Key, typename _Val, typename _KoV, typename _Compare, typename _Alloc >
    typename _Rb_tree< _Key, _Val, _KoV, _Compare, _Alloc >::_Link_type _Rb_tree< _Key, _Val, _KoV, _Compare, _Alloc >::_M_copy(_Const_Link_type __x, _Link_type __p)
    {
        _Link_type __top = _M_clone_node(__x);
        __top->_M_parent = __p;
        try
        {
            if (__x->_M_right)
                __top->_M_right = _M_copy(_S_right(__x), __top);
            __p = __top;
            __x = _S_left(__x);
            while (__x != 0)
            {
                _Link_type __y = _M_clone_node(__x);
                __p->_M_left = __y;
                __y->_M_parent = __p;
                if (__x->_M_right)
                    __y->_M_right = _M_copy(_S_right(__x), __y);
                __p = __y;
                __x = _S_left(__x);
            }
        }
        catch (...)
        {
            _M_erase(__top);
            throw;
        }
        return __top;
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    void _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::_M_erase(_Link_type __x)
    {
        while (__x != 0)
        {
            _M_erase(_S_right(__x));
            _Link_type __y = _S_left(__x);
            _M_destroy_node(__x);
            __x = __y;
        }
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::iterator _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::_M_lower_bound(_Link_type __x, _Link_type __y, const _Key & __k)
    {
        while (__x != 0)
            if (!_M_impl._M_key_compare(_S_key(__x), __k))
                __y = __x , __x = _S_left(__x);
            else
                __x = _S_right(__x);
        return iterator(__y);
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::const_iterator _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::_M_lower_bound(_Const_Link_type __x, _Const_Link_type __y, const _Key & __k) const
    {
        while (__x != 0)
            if (!_M_impl._M_key_compare(_S_key(__x), __k))
                __y = __x , __x = _S_left(__x);
            else
                __x = _S_right(__x);
        return const_iterator(__y);
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::iterator _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::_M_upper_bound(_Link_type __x, _Link_type __y, const _Key & __k)
    {
        while (__x != 0)
            if (_M_impl._M_key_compare(__k, _S_key(__x)))
                __y = __x , __x = _S_left(__x);
            else
                __x = _S_right(__x);
        return iterator(__y);
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::const_iterator _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::_M_upper_bound(_Const_Link_type __x, _Const_Link_type __y, const _Key & __k) const
    {
        while (__x != 0)
            if (_M_impl._M_key_compare(__k, _S_key(__x)))
                __y = __x , __x = _S_left(__x);
            else
                __x = _S_right(__x);
        return const_iterator(__y);
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    pair< typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::iterator, typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::iterator > _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::equal_range(const _Key & __k)
    {
        _Link_type __x = _M_begin();
        _Link_type __y = _M_end();
        while (__x != 0)
        {
            if (_M_impl._M_key_compare(_S_key(__x), __k))
                __x = _S_right(__x);
            else
                if (_M_impl._M_key_compare(__k, _S_key(__x)))
                    __y = __x , __x = _S_left(__x);
                else
                {
                    _Link_type __xu(__x), __yu(__y);
                    __y = __x , __x = _S_left(__x);
                    __xu = _S_right(__xu);
                    return pair< iterator, iterator >(_M_lower_bound(__x, __y, __k), _M_upper_bound(__xu, __yu, __k));
                }
        }
        return pair< iterator, iterator >(iterator(__y), iterator(__y));
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    pair< typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::const_iterator, typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::const_iterator > _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::equal_range(const _Key & __k) const
    {
        _Const_Link_type __x = _M_begin();
        _Const_Link_type __y = _M_end();
        while (__x != 0)
        {
            if (_M_impl._M_key_compare(_S_key(__x), __k))
                __x = _S_right(__x);
            else
                if (_M_impl._M_key_compare(__k, _S_key(__x)))
                    __y = __x , __x = _S_left(__x);
                else
                {
                    _Const_Link_type __xu(__x), __yu(__y);
                    __y = __x , __x = _S_left(__x);
                    __xu = _S_right(__xu);
                    return pair< const_iterator, const_iterator >(_M_lower_bound(__x, __y, __k), _M_upper_bound(__xu, __yu, __k));
                }
        }
        return pair< const_iterator, const_iterator >(const_iterator(__y), const_iterator(__y));
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    void _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::swap(_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > & __t)
    {
        if (_M_root() == 0)
        {
            if (__t._M_root() != 0)
            {
                _M_root() = __t._M_root();
                _M_leftmost() = __t._M_leftmost();
                _M_rightmost() = __t._M_rightmost();
                _M_root()->_M_parent = _M_end();
                __t._M_root() = 0;
                __t._M_leftmost() = __t._M_end();
                __t._M_rightmost() = __t._M_end();
            }
        }
        else
            if (__t._M_root() == 0)
            {
                __t._M_root() = _M_root();
                __t._M_leftmost() = _M_leftmost();
                __t._M_rightmost() = _M_rightmost();
                __t._M_root()->_M_parent = __t._M_end();
                _M_root() = 0;
                _M_leftmost() = _M_end();
                _M_rightmost() = _M_end();
            }
            else
            {
                std::swap(_M_root(), __t._M_root());
                std::swap(_M_leftmost(), __t._M_leftmost());
                std::swap(_M_rightmost(), __t._M_rightmost());
                _M_root()->_M_parent = _M_end();
                __t._M_root()->_M_parent = __t._M_end();
            }
        std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
        std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);
        std::__alloc_swap< _Node_allocator >::_S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    pair< typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::iterator, bool > _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::_M_insert_unique(const _Val & __v)
    {
        _Link_type __x = _M_begin();
        _Link_type __y = _M_end();
        bool __comp = true;
        while (__x != 0)
        {
            __y = __x;
            __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));
            __x = __comp ? _S_left(__x) : _S_right(__x);
        }
        iterator __j = iterator(__y);
        if (__comp)
        {
            if (__j == begin())
                return pair< iterator, bool >(_M_insert_(__x, __y, __v), true);
            else
                --__j;
        }
        if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
            return pair< iterator, bool >(_M_insert_(__x, __y, __v), true);
        return pair< iterator, bool >(__j, false);
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::iterator _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::_M_insert_equal(const _Val & __v)
    {
        _Link_type __x = _M_begin();
        _Link_type __y = _M_end();
        while (__x != 0)
        {
            __y = __x;
            __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ? _S_left(__x) : _S_right(__x);
        }
        return _M_insert_(__x, __y, __v);
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::iterator _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::_M_insert_unique_(const_iterator __position, const _Val & __v)
    {
        if (__position._M_node == _M_end())
        {
            if (size() > 0 && _M_impl._M_key_compare(_S_key(_M_rightmost()), _KeyOfValue()(__v)))
                return _M_insert_(0, _M_rightmost(), __v);
            else
                return _M_insert_unique(__v).first;
        }
        else
            if (_M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__position._M_node)))
            {
                const_iterator __before = __position;
                if (__position._M_node == _M_leftmost())
                    return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
                else
                    if (_M_impl._M_key_compare(_S_key((--__before)._M_node), _KeyOfValue()(__v)))
                    {
                        if (_S_right(__before._M_node) == 0)
                            return _M_insert_(0, __before._M_node, __v);
                        else
                            return _M_insert_(__position._M_node, __position._M_node, __v);
                    }
                    else
                        return _M_insert_unique(__v).first;
            }
            else
                if (_M_impl._M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__v)))
                {
                    const_iterator __after = __position;
                    if (__position._M_node == _M_rightmost())
                        return _M_insert_(0, _M_rightmost(), __v);
                    else
                        if (_M_impl._M_key_compare(_KeyOfValue()(__v), _S_key((++__after)._M_node)))
                        {
                            if (_S_right(__position._M_node) == 0)
                                return _M_insert_(0, __position._M_node, __v);
                            else
                                return _M_insert_(__after._M_node, __after._M_node, __v);
                        }
                        else
                            return _M_insert_unique(__v).first;
                }
                else
                    return iterator(static_cast<_Link_type >(const_cast<_Base_ptr >(__position._M_node)));
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::iterator _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::_M_insert_equal_(const_iterator __position, const _Val & __v)
    {
        if (__position._M_node == _M_end())
        {
            if (size() > 0 && !_M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(_M_rightmost())))
                return _M_insert_(0, _M_rightmost(), __v);
            else
                return _M_insert_equal(__v);
        }
        else
            if (!_M_impl._M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__v)))
            {
                const_iterator __before = __position;
                if (__position._M_node == _M_leftmost())
                    return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
                else
                    if (!_M_impl._M_key_compare(_KeyOfValue()(__v), _S_key((--__before)._M_node)))
                    {
                        if (_S_right(__before._M_node) == 0)
                            return _M_insert_(0, __before._M_node, __v);
                        else
                            return _M_insert_(__position._M_node, __position._M_node, __v);
                    }
                    else
                        return _M_insert_equal(__v);
            }
            else
            {
                const_iterator __after = __position;
                if (__position._M_node == _M_rightmost())
                    return _M_insert_(0, _M_rightmost(), __v);
                else
                    if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), _KeyOfValue()(__v)))
                    {
                        if (_S_right(__position._M_node) == 0)
                            return _M_insert_(0, __position._M_node, __v);
                        else
                            return _M_insert_(__after._M_node, __after._M_node, __v);
                    }
                    else
                        return _M_insert_equal_lower(__v);
            }
    }
    template<typename _Key, typename _Val, typename _KoV, typename _Cmp, typename _Alloc >
    template<class _II >
    void _Rb_tree< _Key, _Val, _KoV, _Cmp, _Alloc >::_M_insert_unique(_II __first, _II __last)
    {
        for (;
            __first != __last;
            ++__first)
        _M_insert_unique_(end(), *__first);
    }
    template<typename _Key, typename _Val, typename _KoV, typename _Cmp, typename _Alloc >
    template<class _II >
    void _Rb_tree< _Key, _Val, _KoV, _Cmp, _Alloc >::_M_insert_equal(_II __first, _II __last)
    {
        for (;
            __first != __last;
            ++__first)
        _M_insert_equal_(end(), *__first);
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    inline void _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::erase(iterator __position)
    {
        _Link_type __y = static_cast<_Link_type >(_Rb_tree_rebalance_for_erase(__position._M_node, this->_M_impl._M_header));
        _M_destroy_node(__y);
        --_M_impl._M_node_count;
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    inline void _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::erase(const_iterator __position)
    {
        _Link_type __y = static_cast<_Link_type >(_Rb_tree_rebalance_for_erase(const_cast<_Base_ptr >(__position._M_node), this->_M_impl._M_header));
        _M_destroy_node(__y);
        --_M_impl._M_node_count;
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::size_type _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::erase(const _Key & __x)
    {
        pair< iterator, iterator > __p = equal_range(__x);
        const size_type __old_size = size();
        erase(__p.first, __p.second);
        return __old_size - size();
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    void _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::erase(iterator __first, iterator __last)
    {
        if (__first == begin() && __last == end())
            clear();
        else
            while (__first != __last)
                erase(__first++);
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    void _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::erase(const_iterator __first, const_iterator __last)
    {
        if (__first == begin() && __last == end())
            clear();
        else
            while (__first != __last)
                erase(__first++);
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    void _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::erase(const _Key * __first, const _Key * __last)
    {
        while (__first != __last)
            erase(*__first++);
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::iterator _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::find(const _Key & __k)
    {
        iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
        return (__j == end() || _M_impl._M_key_compare(__k, _S_key(__j._M_node))) ? end() : __j;
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::const_iterator _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::find(const _Key & __k) const
    {
        const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
        return (__j == end() || _M_impl._M_key_compare(__k, _S_key(__j._M_node))) ? end() : __j;
    }
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::size_type _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::count(const _Key & __k) const
    {
        pair< const_iterator, const_iterator > __p = equal_range(__k);
        const size_type __n = std::distance(__p.first, __p.second);
        return __n;
    }
    unsigned int _Rb_tree_black_count(const _Rb_tree_node_base * __node, const _Rb_tree_node_base * __root);
    template<typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc >
    bool _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >::__rb_verify() const
    {
        if (_M_impl._M_node_count == 0 || begin() == end())
            return _M_impl._M_node_count == 0 && begin() == end() && this->_M_impl._M_header._M_left == _M_end() && this->_M_impl._M_header._M_right == _M_end();
        unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
        for (const_iterator __it = begin();
            __it != end();
            ++__it)
        {
            _Const_Link_type __x = static_cast<_Const_Link_type >(__it._M_node);
            _Const_Link_type __L = _S_left(__x);
            _Const_Link_type __R = _S_right(__x);
            if (__x->_M_color == _S_red)
                if ((__L && __L->_M_color == _S_red) || (__R && __R->_M_color == _S_red))
                    return false;
            if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
                return false;
            if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
                return false;
            if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
                return false;
        }
        if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
            return false;
        if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
            return false;
        return true;
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Key, typename _Tp, typename _Compare = std::less< _Key >, typename _Alloc = std::allocator< std::pair< const _Key, _Tp > > >
    class map
    {
        public :
            typedef _Key key_type;
            typedef _Tp mapped_type;
            typedef std::pair< const _Key, _Tp > value_type;
            typedef _Compare key_compare;
            typedef _Alloc allocator_type;
        private :
            typedef typename _Alloc::value_type _Alloc_value_type;
        public :
            class value_compare : public std::binary_function< value_type, value_type, bool >
            {
                    friend class map< _Key, _Tp, _Compare, _Alloc >;
                protected :
                    _Compare comp;
                    value_compare(_Compare __c)
                        : comp(__c) 
                    {
                    }
                public :
                    bool operator ()(const value_type & __x, const value_type & __y) const
                    {
                        return comp(__x.first, __y.first);
                    }
            };
        private :
            typedef typename _Alloc::template rebind< value_type >::other _Pair_alloc_type;
            typedef _Rb_tree< key_type, value_type, _Select1st< value_type >, key_compare, _Pair_alloc_type > _Rep_type;
            _Rep_type _M_t;
        public :
            typedef typename _Pair_alloc_type::pointer pointer;
            typedef typename _Pair_alloc_type::const_pointer const_pointer;
            typedef typename _Pair_alloc_type::reference reference;
            typedef typename _Pair_alloc_type::const_reference const_reference;
            typedef typename _Rep_type::iterator iterator;
            typedef typename _Rep_type::const_iterator const_iterator;
            typedef typename _Rep_type::size_type size_type;
            typedef typename _Rep_type::difference_type difference_type;
            typedef typename _Rep_type::reverse_iterator reverse_iterator;
            typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
            map()
                : _M_t() 
            {
            }
            explicit map(const _Compare & __comp, const allocator_type & __a = allocator_type())
                : _M_t(__comp, __a) 
            {
            }
            map(const map & __x)
                : _M_t(__x._M_t) 
            {
            }
            template<typename _InputIterator >
            map(_InputIterator __first, _InputIterator __last)
                : _M_t() 
            {
                _M_t._M_insert_unique(__first, __last);
            }
            template<typename _InputIterator >
            map(_InputIterator __first, _InputIterator __last, const _Compare & __comp, const allocator_type & __a = allocator_type())
                : _M_t(__comp, __a) 
            {
                _M_t._M_insert_unique(__first, __last);
            }
            map & operator =(const map & __x)
            {
                _M_t = __x._M_t;
                return *this;
            }
            allocator_type get_allocator() const
            {
                return _M_t.get_allocator();
            }
            iterator begin()
            {
                return _M_t.begin();
            }
            const_iterator begin() const
            {
                return _M_t.begin();
            }
            iterator end()
            {
                return _M_t.end();
            }
            const_iterator end() const
            {
                return _M_t.end();
            }
            reverse_iterator rbegin()
            {
                return _M_t.rbegin();
            }
            const_reverse_iterator rbegin() const
            {
                return _M_t.rbegin();
            }
            reverse_iterator rend()
            {
                return _M_t.rend();
            }
            const_reverse_iterator rend() const
            {
                return _M_t.rend();
            }
            bool empty() const
            {
                return _M_t.empty();
            }
            size_type size() const
            {
                return _M_t.size();
            }
            size_type max_size() const
            {
                return _M_t.max_size();
            }
            mapped_type & operator [](const key_type & __k)
            {
                iterator __i = lower_bound(__k);
                if (__i == end() || key_comp()(__k, (*__i).first))
                    __i = insert(__i, value_type(__k, mapped_type()));
                return (*__i).second;
            }
            mapped_type & at(const key_type & __k)
            {
                iterator __i = lower_bound(__k);
                if (__i == end() || key_comp()(__k, (*__i).first))
                    __throw_out_of_range(("map::at"));
                return (*__i).second;
            }
            const mapped_type & at(const key_type & __k) const
            {
                const_iterator __i = lower_bound(__k);
                if (__i == end() || key_comp()(__k, (*__i).first))
                    __throw_out_of_range(("map::at"));
                return (*__i).second;
            }
            std::pair< iterator, bool > insert(const value_type & __x)
            {
                return _M_t._M_insert_unique(__x);
            }
            iterator insert(iterator __position, const value_type & __x)
            {
                return _M_t._M_insert_unique_(__position, __x);
            }
            template<typename _InputIterator >
            void insert(_InputIterator __first, _InputIterator __last)
            {
                _M_t._M_insert_unique(__first, __last);
            }
            void erase(iterator __position)
            {
                _M_t.erase(__position);
            }
            size_type erase(const key_type & __x)
            {
                return _M_t.erase(__x);
            }
            void erase(iterator __first, iterator __last)
            {
                _M_t.erase(__first, __last);
            }
            void swap(map & __x)
            {
                _M_t.swap(__x._M_t);
            }
            void clear()
            {
                _M_t.clear();
            }
            key_compare key_comp() const
            {
                return _M_t.key_comp();
            }
            value_compare value_comp() const
            {
                return value_compare(_M_t.key_comp());
            }
            iterator find(const key_type & __x)
            {
                return _M_t.find(__x);
            }
            const_iterator find(const key_type & __x) const
            {
                return _M_t.find(__x);
            }
            size_type count(const key_type & __x) const
            {
                return _M_t.find(__x) == _M_t.end() ? 0 : 1;
            }
            iterator lower_bound(const key_type & __x)
            {
                return _M_t.lower_bound(__x);
            }
            const_iterator lower_bound(const key_type & __x) const
            {
                return _M_t.lower_bound(__x);
            }
            iterator upper_bound(const key_type & __x)
            {
                return _M_t.upper_bound(__x);
            }
            const_iterator upper_bound(const key_type & __x) const
            {
                return _M_t.upper_bound(__x);
            }
            std::pair< iterator, iterator > equal_range(const key_type & __x)
            {
                return _M_t.equal_range(__x);
            }
            std::pair< const_iterator, const_iterator > equal_range(const key_type & __x) const
            {
                return _M_t.equal_range(__x);
            }
            template<typename _K1, typename _T1, typename _C1, typename _A1 >
            friend bool operator ==(const map< _K1, _T1, _C1, _A1 > &, const map< _K1, _T1, _C1, _A1 > &);
            template<typename _K1, typename _T1, typename _C1, typename _A1 >
            friend bool operator <(const map< _K1, _T1, _C1, _A1 > &, const map< _K1, _T1, _C1, _A1 > &);
    };
    template<typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool operator ==(const map< _Key, _Tp, _Compare, _Alloc > & __x, const map< _Key, _Tp, _Compare, _Alloc > & __y)
    {
        return __x._M_t == __y._M_t;
    }
    template<typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool operator <(const map< _Key, _Tp, _Compare, _Alloc > & __x, const map< _Key, _Tp, _Compare, _Alloc > & __y)
    {
        return __x._M_t < __y._M_t;
    }
    template<typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool operator !=(const map< _Key, _Tp, _Compare, _Alloc > & __x, const map< _Key, _Tp, _Compare, _Alloc > & __y)
    {
        return !(__x == __y);
    }
    template<typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool operator >(const map< _Key, _Tp, _Compare, _Alloc > & __x, const map< _Key, _Tp, _Compare, _Alloc > & __y)
    {
        return __y < __x;
    }
    template<typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool operator <=(const map< _Key, _Tp, _Compare, _Alloc > & __x, const map< _Key, _Tp, _Compare, _Alloc > & __y)
    {
        return !(__y < __x);
    }
    template<typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool operator >=(const map< _Key, _Tp, _Compare, _Alloc > & __x, const map< _Key, _Tp, _Compare, _Alloc > & __y)
    {
        return !(__x < __y);
    }
    template<typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline void swap(map< _Key, _Tp, _Compare, _Alloc > & __x, map< _Key, _Tp, _Compare, _Alloc > & __y)
    {
        __x.swap(__y);
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Key, typename _Tp, typename _Compare = std::less< _Key >, typename _Alloc = std::allocator< std::pair< const _Key, _Tp > > >
    class multimap
    {
        public :
            typedef _Key key_type;
            typedef _Tp mapped_type;
            typedef std::pair< const _Key, _Tp > value_type;
            typedef _Compare key_compare;
            typedef _Alloc allocator_type;
        private :
            typedef typename _Alloc::value_type _Alloc_value_type;
        public :
            class value_compare : public std::binary_function< value_type, value_type, bool >
            {
                    friend class multimap< _Key, _Tp, _Compare, _Alloc >;
                protected :
                    _Compare comp;
                    value_compare(_Compare __c)
                        : comp(__c) 
                    {
                    }
                public :
                    bool operator ()(const value_type & __x, const value_type & __y) const
                    {
                        return comp(__x.first, __y.first);
                    }
            };
        private :
            typedef typename _Alloc::template rebind< value_type >::other _Pair_alloc_type;
            typedef _Rb_tree< key_type, value_type, _Select1st< value_type >, key_compare, _Pair_alloc_type > _Rep_type;
            _Rep_type _M_t;
        public :
            typedef typename _Pair_alloc_type::pointer pointer;
            typedef typename _Pair_alloc_type::const_pointer const_pointer;
            typedef typename _Pair_alloc_type::reference reference;
            typedef typename _Pair_alloc_type::const_reference const_reference;
            typedef typename _Rep_type::iterator iterator;
            typedef typename _Rep_type::const_iterator const_iterator;
            typedef typename _Rep_type::size_type size_type;
            typedef typename _Rep_type::difference_type difference_type;
            typedef typename _Rep_type::reverse_iterator reverse_iterator;
            typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
            multimap()
                : _M_t() 
            {
            }
            explicit multimap(const _Compare & __comp, const allocator_type & __a = allocator_type())
                : _M_t(__comp, __a) 
            {
            }
            multimap(const multimap & __x)
                : _M_t(__x._M_t) 
            {
            }
            template<typename _InputIterator >
            multimap(_InputIterator __first, _InputIterator __last)
                : _M_t() 
            {
                _M_t._M_insert_equal(__first, __last);
            }
            template<typename _InputIterator >
            multimap(_InputIterator __first, _InputIterator __last, const _Compare & __comp, const allocator_type & __a = allocator_type())
                : _M_t(__comp, __a) 
            {
                _M_t._M_insert_equal(__first, __last);
            }
            multimap & operator =(const multimap & __x)
            {
                _M_t = __x._M_t;
                return *this;
            }
            allocator_type get_allocator() const
            {
                return _M_t.get_allocator();
            }
            iterator begin()
            {
                return _M_t.begin();
            }
            const_iterator begin() const
            {
                return _M_t.begin();
            }
            iterator end()
            {
                return _M_t.end();
            }
            const_iterator end() const
            {
                return _M_t.end();
            }
            reverse_iterator rbegin()
            {
                return _M_t.rbegin();
            }
            const_reverse_iterator rbegin() const
            {
                return _M_t.rbegin();
            }
            reverse_iterator rend()
            {
                return _M_t.rend();
            }
            const_reverse_iterator rend() const
            {
                return _M_t.rend();
            }
            bool empty() const
            {
                return _M_t.empty();
            }
            size_type size() const
            {
                return _M_t.size();
            }
            size_type max_size() const
            {
                return _M_t.max_size();
            }
            iterator insert(const value_type & __x)
            {
                return _M_t._M_insert_equal(__x);
            }
            iterator insert(iterator __position, const value_type & __x)
            {
                return _M_t._M_insert_equal_(__position, __x);
            }
            template<typename _InputIterator >
            void insert(_InputIterator __first, _InputIterator __last)
            {
                _M_t._M_insert_equal(__first, __last);
            }
            void erase(iterator __position)
            {
                _M_t.erase(__position);
            }
            size_type erase(const key_type & __x)
            {
                return _M_t.erase(__x);
            }
            void erase(iterator __first, iterator __last)
            {
                _M_t.erase(__first, __last);
            }
            void swap(multimap & __x)
            {
                _M_t.swap(__x._M_t);
            }
            void clear()
            {
                _M_t.clear();
            }
            key_compare key_comp() const
            {
                return _M_t.key_comp();
            }
            value_compare value_comp() const
            {
                return value_compare(_M_t.key_comp());
            }
            iterator find(const key_type & __x)
            {
                return _M_t.find(__x);
            }
            const_iterator find(const key_type & __x) const
            {
                return _M_t.find(__x);
            }
            size_type count(const key_type & __x) const
            {
                return _M_t.count(__x);
            }
            iterator lower_bound(const key_type & __x)
            {
                return _M_t.lower_bound(__x);
            }
            const_iterator lower_bound(const key_type & __x) const
            {
                return _M_t.lower_bound(__x);
            }
            iterator upper_bound(const key_type & __x)
            {
                return _M_t.upper_bound(__x);
            }
            const_iterator upper_bound(const key_type & __x) const
            {
                return _M_t.upper_bound(__x);
            }
            std::pair< iterator, iterator > equal_range(const key_type & __x)
            {
                return _M_t.equal_range(__x);
            }
            std::pair< const_iterator, const_iterator > equal_range(const key_type & __x) const
            {
                return _M_t.equal_range(__x);
            }
            template<typename _K1, typename _T1, typename _C1, typename _A1 >
            friend bool operator ==(const multimap< _K1, _T1, _C1, _A1 > &, const multimap< _K1, _T1, _C1, _A1 > &);
            template<typename _K1, typename _T1, typename _C1, typename _A1 >
            friend bool operator <(const multimap< _K1, _T1, _C1, _A1 > &, const multimap< _K1, _T1, _C1, _A1 > &);
    };
    template<typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool operator ==(const multimap< _Key, _Tp, _Compare, _Alloc > & __x, const multimap< _Key, _Tp, _Compare, _Alloc > & __y)
    {
        return __x._M_t == __y._M_t;
    }
    template<typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool operator <(const multimap< _Key, _Tp, _Compare, _Alloc > & __x, const multimap< _Key, _Tp, _Compare, _Alloc > & __y)
    {
        return __x._M_t < __y._M_t;
    }
    template<typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool operator !=(const multimap< _Key, _Tp, _Compare, _Alloc > & __x, const multimap< _Key, _Tp, _Compare, _Alloc > & __y)
    {
        return !(__x == __y);
    }
    template<typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool operator >(const multimap< _Key, _Tp, _Compare, _Alloc > & __x, const multimap< _Key, _Tp, _Compare, _Alloc > & __y)
    {
        return __y < __x;
    }
    template<typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool operator <=(const multimap< _Key, _Tp, _Compare, _Alloc > & __x, const multimap< _Key, _Tp, _Compare, _Alloc > & __y)
    {
        return !(__y < __x);
    }
    template<typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline bool operator >=(const multimap< _Key, _Tp, _Compare, _Alloc > & __x, const multimap< _Key, _Tp, _Compare, _Alloc > & __y)
    {
        return !(__x < __y);
    }
    template<typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    inline void swap(multimap< _Key, _Tp, _Compare, _Alloc > & __x, multimap< _Key, _Tp, _Compare, _Alloc > & __y)
    {
        __x.swap(__y);
    }
}
extern "C"
{
    typedef struct _GMarkupParseContext GMarkupParseContext;
}
namespace Glib {
    class MarkupError : public Glib::Error
    {
        public :
            enum Code
            {
                BAD_UTF8, 
                EMPTY, 
                PARSE, 
                UNKNOWN_ELEMENT, 
                UNKNOWN_ATTRIBUTE, 
                INVALID_CONTENT
            };
            MarkupError(Code error_code, const Glib::ustring & error_message);
            explicit MarkupError(GError * gobject);
            Code code() const;
        private :
            static void throw_func(GError * gobject);
            friend void wrap_init();
    };
    namespace Markup {
        class ParseContext;
        typedef Glib::MarkupError Error;
        Glib::ustring escape_text(const Glib::ustring & text);
        enum ParseFlags
        {
            DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1 << 0, 
            TREAT_CDATA_AS_TEXT = 1 << 1
        };
        inline ParseFlags operator |(ParseFlags lhs, ParseFlags rhs)
        {
            return static_cast<ParseFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
        }
        inline ParseFlags operator &(ParseFlags lhs, ParseFlags rhs)
        {
            return static_cast<ParseFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
        }
        inline ParseFlags operator ^(ParseFlags lhs, ParseFlags rhs)
        {
            return static_cast<ParseFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
        }
        inline ParseFlags operator ~(ParseFlags flags)
        {
            return static_cast<ParseFlags >(~static_cast<unsigned >(flags));
        }
        inline ParseFlags & operator |=(ParseFlags & lhs, ParseFlags rhs)
        {
            return (lhs = static_cast<ParseFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
        }
        inline ParseFlags & operator &=(ParseFlags & lhs, ParseFlags rhs)
        {
            return (lhs = static_cast<ParseFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
        }
        inline ParseFlags & operator ^=(ParseFlags & lhs, ParseFlags rhs)
        {
            return (lhs = static_cast<ParseFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
        }
        class AttributeKeyLess
        {
            public :
                typedef Glib::ustring first_argument_type;
                typedef Glib::ustring second_argument_type;
                typedef bool result_type;
                bool operator ()(const Glib::ustring & lhs, const Glib::ustring & rhs) const;
        };
        class ParserCallbacks;
        class Parser : public sigc::trackable
        {
            public :
                typedef std::map< Glib::ustring, Glib::ustring, Glib::Markup::AttributeKeyLess > AttributeMap;
                virtual ~Parser() = 0;
            protected :
                Parser();
                virtual void on_start_element(ParseContext & context, const Glib::ustring & element_name, const AttributeMap & attributes);
                virtual void on_end_element(ParseContext & context, const Glib::ustring & element_name);
                virtual void on_text(ParseContext & context, const Glib::ustring & text);
                virtual void on_passthrough(ParseContext & context, const Glib::ustring & passthrough_text);
                virtual void on_error(ParseContext & context, const MarkupError & error);
            private :
                Parser(const Parser &);
                Parser & operator =(const Parser &);
                friend class Glib::Markup::ParserCallbacks;
        };
        class ParseContext : public sigc::trackable
        {
            public :
                explicit ParseContext(Parser & parser, ParseFlags flags = ParseFlags(0));
                virtual ~ParseContext();
                void parse(const Glib::ustring & text);
                void parse(const char * text_begin, const char * text_end);
                void end_parse();
                Glib::ustring get_element() const;
                int get_line_number() const;
                int get_char_number() const;
                Parser * get_parser()
                {
                    return parser_;
                }
                const Parser * get_parser() const
                {
                    return parser_;
                }
                GMarkupParseContext * gobj()
                {
                    return gobject_;
                }
                const GMarkupParseContext * gobj() const
                {
                    return gobject_;
                }
            private :
                Markup::Parser * parser_;
                GMarkupParseContext * gobject_;
                ParseContext(const ParseContext &);
                ParseContext & operator =(const ParseContext &);
                static void destroy_notify_callback(void * data);
        };
    }
}
namespace Glib {
    Glib::ustring get_application_name();
    void set_application_name(const Glib::ustring & application_name);
    std::string get_prgname();
    void set_prgname(const std::string & prgname);
    std::string getenv(const std::string & variable, bool & found);
    std::string getenv(const std::string & variable);
    bool setenv(const std::string & variable, const std::string & value, bool overwrite = true);
    void unsetenv(const std::string & variable);
    std::string get_user_name();
    std::string get_real_name();
    std::string get_home_dir();
    std::string get_tmp_dir();
    std::string get_current_dir();
    std::string get_user_special_dir(GUserDirectory directory);
    std::string get_user_data_dir();
    std::string get_user_config_dir();
    std::string get_user_cache_dir();
    bool path_is_absolute(const std::string & filename);
    std::string path_skip_root(const std::string & filename);
    std::string path_get_basename(const std::string & filename);
    std::string path_get_dirname(const std::string & filename);
    std::string build_filename(const Glib::ArrayHandle< std::string > & elements);
    std::string build_filename(const std::string & elem1, const std::string & elem2);
    std::string build_path(const std::string & separator, const Glib::ArrayHandle< std::string > & elements);
    std::string find_program_in_path(const std::string & program);
}
extern "C"
{
    typedef struct _GModule GModule;
}
namespace Glib {
    enum ModuleFlags
    {
        MODULE_BIND_LAZY = 1 << 0, 
        MODULE_BIND_LOCAL = 1 << 1, 
        MODULE_BIND_MASK = 0x03
    };
    inline ModuleFlags operator |(ModuleFlags lhs, ModuleFlags rhs)
    {
        return static_cast<ModuleFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline ModuleFlags operator &(ModuleFlags lhs, ModuleFlags rhs)
    {
        return static_cast<ModuleFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline ModuleFlags operator ^(ModuleFlags lhs, ModuleFlags rhs)
    {
        return static_cast<ModuleFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline ModuleFlags operator ~(ModuleFlags flags)
    {
        return static_cast<ModuleFlags >(~static_cast<unsigned >(flags));
    }
    inline ModuleFlags & operator |=(ModuleFlags & lhs, ModuleFlags rhs)
    {
        return (lhs = static_cast<ModuleFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline ModuleFlags & operator &=(ModuleFlags & lhs, ModuleFlags rhs)
    {
        return (lhs = static_cast<ModuleFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline ModuleFlags & operator ^=(ModuleFlags & lhs, ModuleFlags rhs)
    {
        return (lhs = static_cast<ModuleFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
    class Module
    {
        public :
            typedef Module CppObjectType;
            typedef GModule BaseObjectType;
        private :
        public :
            explicit Module(const std::string & file_name, ModuleFlags flags = ModuleFlags(0));
            virtual ~Module();
            operator bool() const;
            static bool get_supported();
            void make_resident();
            static std::string get_last_error();
            bool get_symbol(const std::string & symbol_name, void * & symbol) const;
            std::string get_name() const;
            static std::string build_path(const std::string & directory, const std::string & module_name);
            GModule * gobj()
            {
                return gobject_;
            }
            const GModule * gobj() const
            {
                return gobject_;
            }
        protected :
            GModule * gobject_;
        private :
            Module(const Module &);
            Module & operator =(const Module &);
    };
}
extern "C"
{
    typedef struct _GOptionEntry GOptionEntry;
}
namespace Glib {
    class OptionEntry
    {
        public :
            typedef OptionEntry CppObjectType;
            typedef GOptionEntry BaseObjectType;
        private :
        public :
            enum Flags
            {
                FLAG_HIDDEN = 1 << 0, 
                FLAG_IN_MAIN = 1 << 1, 
                FLAG_REVERSE = 1 << 2, 
                FLAG_NO_ARG = 1 << 3, 
                FLAG_FILENAME = 1 << 4, 
                FLAG_OPTIONAL_ARG = 1 << 5, 
                FLAG_NOALIAS = 1 << 6
            } GOptionFlags;
            OptionEntry();
            OptionEntry(const OptionEntry & src);
            virtual ~OptionEntry();
            OptionEntry & operator =(const OptionEntry & src);
            Glib::ustring get_long_name() const;
            void set_long_name(const Glib::ustring & value);
            gchar get_short_name() const;
            void set_short_name(const gchar & value);
            int get_flags() const;
            void set_flags(const int & value);
            Glib::ustring get_description() const;
            void set_description(const Glib::ustring & value);
            Glib::ustring get_arg_description() const;
            void set_arg_description(const Glib::ustring & value);
            GOptionEntry * gobj()
            {
                return gobject_;
            }
            const GOptionEntry * gobj() const
            {
                return gobject_;
            }
        protected :
            GOptionEntry * gobject_;
    };
}
extern "C"
{
    typedef struct _GOptionGroup GOptionGroup;
}
namespace Glib {
    class OptionEntry;
    class OptionContext;
    class OptionGroup
    {
        public :
            typedef OptionGroup CppObjectType;
            typedef GOptionGroup BaseObjectType;
        private :
        public :
            OptionGroup(const Glib::ustring & name, const Glib::ustring & description, const Glib::ustring & help_description = Glib::ustring());
            explicit OptionGroup(GOptionGroup * castitem);
            virtual ~OptionGroup();
            virtual bool on_pre_parse(OptionContext & context, OptionGroup & group);
            virtual bool on_post_parse(OptionContext & context, OptionGroup & group);
            virtual void on_error(OptionContext & context, OptionGroup & group);
            void add_entry(const OptionEntry & entry);
            typedef std::vector< Glib::ustring > vecustrings;
            typedef std::vector< std::string > vecstrings;
            void add_entry(const OptionEntry & entry, bool & arg);
            void add_entry(const OptionEntry & entry, int & arg);
            void add_entry(const OptionEntry & entry, Glib::ustring & arg);
            void add_entry_filename(const OptionEntry & entry, std::string & arg);
            void add_entry(const OptionEntry & entry, vecustrings & arg);
            void add_entry_filename(const OptionEntry & entry, vecstrings & arg);
            void set_translation_domain(const Glib::ustring & domain);
            GOptionGroup * gobj()
            {
                return gobject_;
            }
            const GOptionGroup * gobj() const
            {
                return gobject_;
            }
            GOptionGroup * gobj_give_ownership();
        protected :
            class CppOptionEntry
            {
                public :
                    CppOptionEntry();
                    void allocate_c_arg();
                    void set_c_arg_default(void * cpp_arg);
                    void convert_c_to_cpp();
                    void release_c_arg();
                    GOptionArg carg_type_;
                    void * carg_;
                    void * cpparg_;
                    OptionEntry * entry_;
            };
            void add_entry_with_wrapper(const OptionEntry & entry, GOptionArg arg_type, void * cpp_arg);
            typedef std::map< Glib::ustring, CppOptionEntry > type_map_entries;
            type_map_entries map_entries_;
            GOptionGroup * gobject_;
            bool has_ownership_;
    };
}
extern "C"
{
    typedef struct _GOptionContext GOptionContext;
}
namespace Glib {
    class OptionError : public Glib::Error
    {
        public :
            enum Code
            {
                UNKNOWN_OPTION, 
                BAD_VALUE, 
                FAILED
            };
            OptionError(Code error_code, const Glib::ustring & error_message);
            explicit OptionError(GError * gobject);
            Code code() const;
        private :
            static void throw_func(GError * gobject);
            friend void wrap_init();
    };
    class OptionContext
    {
        public :
            typedef OptionContext CppObjectType;
            typedef GOptionContext BaseObjectType;
        private :
        public :
            explicit OptionContext(const Glib::ustring & parameter_string = Glib::ustring());
            explicit OptionContext(GOptionContext * castitem, bool take_ownership = false);
            virtual ~OptionContext();
            void set_help_enabled(bool help_enabled = true);
            bool get_help_enabled() const;
            void set_ignore_unknown_options(bool ignore_unknown = true);
            bool get_ignore_unknown_options() const;
            bool parse(int & argc, char * * & argv);
            void add_group(OptionGroup & group);
            void set_main_group(OptionGroup & group);
            Glib::ustring get_help(bool main_help, const OptionGroup & group) const;
            Glib::ustring get_help(bool main_help = true) const;
            GOptionContext * gobj()
            {
                return gobject_;
            }
            const GOptionContext * gobj() const
            {
                return gobject_;
            }
            void set_summary(const Glib::ustring & summary);
            Glib::ustring get_summary() const;
            void set_description(const Glib::ustring & description);
            Glib::ustring get_description() const;
            void set_translation_domain(const Glib::ustring & domain);
            typedef sigc::slot< Glib::ustring, const Glib::ustring & > SlotTranslate;
            void set_translate_func(const SlotTranslate & slot);
        protected :
            GOptionContext * gobject_;
            bool has_ownership_;
    };
}
extern "C"
{
    typedef struct _GPatternSpec GPatternSpec;
}
namespace Glib {
    class PatternSpec
    {
        public :
            explicit PatternSpec(const Glib::ustring & pattern);
            explicit PatternSpec(GPatternSpec * gobject);
            ~PatternSpec();
            bool match(const Glib::ustring & str) const;
            bool match(const Glib::ustring & str, const Glib::ustring & str_reversed) const;
            bool operator ==(const PatternSpec & rhs) const;
            bool operator !=(const PatternSpec & rhs) const;
            GPatternSpec * gobj()
            {
                return gobject_;
            }
            const GPatternSpec * gobj() const
            {
                return gobject_;
            }
        private :
            GPatternSpec * gobject_;
            PatternSpec(const PatternSpec &);
            PatternSpec & operator =(const PatternSpec &);
    };
}
namespace Glib {
    void custom_get_property_callback(GObject * object, unsigned int property_id, GValue * value, GParamSpec * param_spec);
    void custom_set_property_callback(GObject * object, unsigned int property_id, const GValue * value, GParamSpec * param_spec);
    class PropertyBase
    {
        public :
            Glib::ustring get_name() const;
            void notify();
        protected :
            Glib::Object * object_;
            Glib::ValueBase value_;
            GParamSpec * param_spec_;
            PropertyBase(Glib::Object & object, GType value_type);
            ~PropertyBase();
            bool lookup_property(const Glib::ustring & name);
            void install_property(GParamSpec * param_spec);
            const char * get_name_internal() const;
        private :
            PropertyBase(const PropertyBase &);
            PropertyBase & operator =(const PropertyBase &);
            friend void Glib::custom_get_property_callback(GObject * object, unsigned int property_id, GValue * value, GParamSpec * param_spec);
            friend void Glib::custom_set_property_callback(GObject * object, unsigned int property_id, const GValue * value, GParamSpec * param_spec);
    };
    template<class T >
    class Property : public PropertyBase
    {
        public :
            typedef T PropertyType;
            typedef Glib::Value< T > ValueType;
            Property(Glib::Object & object, const Glib::ustring & name);
            Property(Glib::Object & object, const Glib::ustring & name, const PropertyType & default_value);
            inline void set_value(const PropertyType & data);
            inline PropertyType get_value() const;
            inline Property< T > & operator =(const PropertyType & data);
            inline operator PropertyType() const;
            inline Glib::PropertyProxy< T > get_proxy();
    };
    template<class T >
    Property< T >::Property(Glib::Object & object, const Glib::ustring & name)
        : PropertyBase(object, ValueType::value_type()) 
    {
        if (!lookup_property(name))
            install_property(static_cast<ValueType & >(value_).create_param_spec(name));
    }
    template<class T >
    Property< T >::Property(Glib::Object & object, const Glib::ustring & name, const typename Property< T >::PropertyType & default_value)
        : PropertyBase(object, ValueType::value_type()) 
    {
        static_cast<ValueType & >(value_).set(default_value);
        if (!lookup_property(name))
            install_property(static_cast<ValueType & >(value_).create_param_spec(name));
    }
    template<class T >
    inline void Property< T >::set_value(const typename Property< T >::PropertyType & data)
    {
        static_cast<ValueType & >(value_).set(data);
        this->notify();
    }
    template<class T >
    inline typename Property< T >::PropertyType Property< T >::get_value() const
    {
        return static_cast<const ValueType & >(value_).get();
    }
    template<class T >
    inline Property< T > & Property< T >::operator =(const typename Property< T >::PropertyType & data)
    {
        static_cast<ValueType & >(value_).set(data);
        this->notify();
        return *this;
    }
    template<class T >
    inline Property< T >::operator T() const
    {
        return static_cast<const ValueType & >(value_).get();
    }
    template<class T >
    inline Glib::PropertyProxy< T > Property< T >::get_proxy()
    {
        return Glib::PropertyProxy< T >(object_, get_name_internal());
    }
}
extern "C"
{
    typedef struct _GRand GRand;
}
namespace Glib {
    class Rand
    {
        public :
            Rand();
            explicit Rand(guint32 seed);
            ~Rand();
            void set_seed(guint32 seed);
            bool get_bool();
            guint32 get_int();
            gint32 get_int_range(gint32 begin, gint32 end);
            double get_double();
            double get_double_range(double begin, double end);
            GRand * gobj()
            {
                return gobject_;
            }
            const GRand * gobj() const
            {
                return gobject_;
            }
        private :
            GRand * gobject_;
            Rand(const Rand &);
            Rand & operator =(const Rand &);
    };
}
typedef struct _GRegex GRegex;
namespace Glib {
    enum RegexCompileFlags
    {
        REGEX_CASELESS = 1 << 0, 
        REGEX_MULTILINE = 1 << 1, 
        REGEX_DOTALL = 1 << 2, 
        REGEX_EXTENDED = 1 << 3, 
        REGEX_ANCHORED = 1 << 4, 
        REGEX_DOLLAR_ENDONLY = 1 << 5, 
        REGEX_UNGREEDY = 1 << 9, 
        REGEX_RAW = 1 << 11, 
        REGEX_NO_AUTO_CAPTURE = 1 << 12, 
        REGEX_OPTIMIZE = 1 << 13, 
        REGEX_DUPNAMES = 1 << 19, 
        REGEX_NEWLINE_CR = 1 << 20, 
        REGEX_NEWLINE_LF = 1 << 21, 
        REGEX_NEWLINE_CRLF = 0x100000
    };
    inline RegexCompileFlags operator |(RegexCompileFlags lhs, RegexCompileFlags rhs)
    {
        return static_cast<RegexCompileFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline RegexCompileFlags operator &(RegexCompileFlags lhs, RegexCompileFlags rhs)
    {
        return static_cast<RegexCompileFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline RegexCompileFlags operator ^(RegexCompileFlags lhs, RegexCompileFlags rhs)
    {
        return static_cast<RegexCompileFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline RegexCompileFlags operator ~(RegexCompileFlags flags)
    {
        return static_cast<RegexCompileFlags >(~static_cast<unsigned >(flags));
    }
    inline RegexCompileFlags & operator |=(RegexCompileFlags & lhs, RegexCompileFlags rhs)
    {
        return (lhs = static_cast<RegexCompileFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline RegexCompileFlags & operator &=(RegexCompileFlags & lhs, RegexCompileFlags rhs)
    {
        return (lhs = static_cast<RegexCompileFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline RegexCompileFlags & operator ^=(RegexCompileFlags & lhs, RegexCompileFlags rhs)
    {
        return (lhs = static_cast<RegexCompileFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
    enum RegexMatchFlags
    {
        REGEX_MATCH_ANCHORED = 1 << 4, 
        REGEX_MATCH_NOTBOL = 1 << 7, 
        REGEX_MATCH_NOTEOL = 1 << 8, 
        REGEX_MATCH_NOTEMPTY = 1 << 10, 
        REGEX_MATCH_PARTIAL = 1 << 15, 
        REGEX_MATCH_NEWLINE_CR = 1 << 20, 
        REGEX_MATCH_NEWLINE_LF = 1 << 21, 
        REGEX_MATCH_NEWLINE_CRLF = 0x100000, 
        REGEX_MATCH_NEWLINE_ANY = 1 << 22
    };
    inline RegexMatchFlags operator |(RegexMatchFlags lhs, RegexMatchFlags rhs)
    {
        return static_cast<RegexMatchFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline RegexMatchFlags operator &(RegexMatchFlags lhs, RegexMatchFlags rhs)
    {
        return static_cast<RegexMatchFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline RegexMatchFlags operator ^(RegexMatchFlags lhs, RegexMatchFlags rhs)
    {
        return static_cast<RegexMatchFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline RegexMatchFlags operator ~(RegexMatchFlags flags)
    {
        return static_cast<RegexMatchFlags >(~static_cast<unsigned >(flags));
    }
    inline RegexMatchFlags & operator |=(RegexMatchFlags & lhs, RegexMatchFlags rhs)
    {
        return (lhs = static_cast<RegexMatchFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline RegexMatchFlags & operator &=(RegexMatchFlags & lhs, RegexMatchFlags rhs)
    {
        return (lhs = static_cast<RegexMatchFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline RegexMatchFlags & operator ^=(RegexMatchFlags & lhs, RegexMatchFlags rhs)
    {
        return (lhs = static_cast<RegexMatchFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
    class RegexError : public Glib::Error
    {
        public :
            enum Code
            {
                COMPILE, 
                OPTIMIZE, 
                REPLACE, 
                MATCH
            };
            RegexError(Code error_code, const Glib::ustring & error_message);
            explicit RegexError(GError * gobject);
            Code code() const;
        private :
            static void throw_func(GError * gobject);
            friend void wrap_init();
    };
    class Regex
    {
        public :
            typedef Regex CppObjectType;
            typedef GRegex BaseObjectType;
            void reference() const;
            void unreference() const;
            GRegex * gobj();
            const GRegex * gobj() const;
            GRegex * gobj_copy() const;
        protected :
            Regex();
            void operator delete(void *, size_t);
        private :
            Regex(const Regex &);
            Regex & operator =(const Regex &);
        public :
            static Glib::RefPtr< Glib::Regex > create(const Glib::ustring & pattern, RegexCompileFlags compile_options = static_cast<RegexCompileFlags >(0), RegexMatchFlags match_options = static_cast<RegexMatchFlags >(0));
            Glib::ustring get_pattern() const;
            int get_max_backref() const;
            int get_capture_count() const;
            int get_string_number(const Glib::ustring & name) const;
            static Glib::ustring escape_string(const Glib::ustring & string);
            static bool match_simple(const Glib::ustring & pattern, const Glib::ustring & string, RegexCompileFlags compile_options = static_cast<RegexCompileFlags >(0), RegexMatchFlags match_options = static_cast<RegexMatchFlags >(0));
            bool match(const Glib::ustring & string, RegexMatchFlags match_options = static_cast<RegexMatchFlags >(0));
            bool match(const Glib::ustring & string, int start_position, RegexMatchFlags match_options);
            bool match(const Glib::ustring & string, gssize string_len, int start_position, RegexMatchFlags match_options);
            bool match_all(const Glib::ustring & string, RegexMatchFlags match_options = static_cast<RegexMatchFlags >(0));
            bool match_all(const Glib::ustring & string, int start_position, RegexMatchFlags match_options);
            bool match_all(const Glib::ustring & string, gssize string_len, int start_position, RegexMatchFlags match_options);
            static Glib::StringArrayHandle split_simple(const Glib::ustring & pattern, const Glib::ustring & string, RegexCompileFlags compile_options = static_cast<RegexCompileFlags >(0), RegexMatchFlags match_options = static_cast<RegexMatchFlags >(0));
            Glib::StringArrayHandle split(const Glib::ustring & string, RegexMatchFlags match_options = static_cast<RegexMatchFlags >(0));
            Glib::StringArrayHandle split(const gchar * string, gssize string_len, int start_position, RegexMatchFlags match_options = static_cast<RegexMatchFlags >(0), int max_tokens = 0) const;
            Glib::StringArrayHandle split(const Glib::ustring & string, int start_position, RegexMatchFlags match_options, int max_tokens) const;
            Glib::ustring replace(const gchar * string, gssize string_len, int start_position, const Glib::ustring & replacement, RegexMatchFlags match_options = static_cast<RegexMatchFlags >(0));
            Glib::ustring replace(const Glib::ustring & string, int start_position, const Glib::ustring & replacement, RegexMatchFlags match_options);
            Glib::ustring replace_literal(const gchar * string, gssize string_len, int start_position, const Glib::ustring & replacement, RegexMatchFlags match_options = static_cast<RegexMatchFlags >(0));
            Glib::ustring replace_literal(const Glib::ustring & string, int start_position, const Glib::ustring & replacement, RegexMatchFlags match_options);
            Glib::ustring replace_eval(const Glib::ustring & string, gssize string_len, int start_position, RegexMatchFlags match_options, GRegexEvalCallback eval, gpointer user_data);
            static bool check_replacement(const Glib::ustring & replacement, gboolean * has_references);
    };
}
namespace Glib {
    Glib::RefPtr< Glib::Regex > wrap(GRegex * object, bool take_copy = false);
}
namespace Glib {
    class ShellError : public Glib::Error
    {
        public :
            enum Code
            {
                BAD_QUOTING, 
                EMPTY_STRING, 
                FAILED
            };
            ShellError(Code error_code, const Glib::ustring & error_message);
            explicit ShellError(GError * gobject);
            Code code() const;
        private :
            static void throw_func(GError * gobject);
            friend void wrap_init();
    };
    Glib::ArrayHandle< std::string > shell_parse_argv(const std::string & command_line);
    std::string shell_quote(const std::string & unquoted_string);
    std::string shell_unquote(const std::string & quoted_string);
}
namespace Glib {
    namespace Container_Helpers {
        template<class Bi, class Tr >
        GSList * create_slist(Bi pbegin, Bi pend, Tr)
        {
            GSList * head = 0;
            while (pend != pbegin)
            {
                const void *const item = Tr::to_c_type(*&*--pend);
                head = g_slist_prepend(head, const_cast<void * >(item));
            }
            return head;
        }
        template<class For, class Tr >
        GSList * create_slist(For pbegin, Tr)
        {
            GSList * head = 0;
            while (*pbegin)
            {
                const void *const item = Tr::to_c_type(*&*pbegin);
                head = g_slist_prepend(head, const_cast<void * >(item));
                ++pbegin;
            }
            return g_slist_reverse(head);
        }
        template<class Tr, class Cont >
        struct SListSourceTraits
        {
                static GSList * get_data(const Cont & cont)
                {
                    return Glib::Container_Helpers::create_slist(cont.begin(), cont.end(), Tr());
                }
                static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_SHALLOW;
        };
        template<class Tr, class Cont >
        struct SListSourceTraits< Tr, Cont * >
        {
                static GSList * get_data(const Cont * array)
                {
                    return (array) ? Glib::Container_Helpers::create_slist(array, Tr()) : 0;
                }
                static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_SHALLOW;
        };
        template<class Tr, class Cont >
        struct SListSourceTraits< Tr, const Cont * > : SListSourceTraits< Tr, Cont * >
        {
        };
        template<class Tr, class Cont, size_t N >
        struct SListSourceTraits< Tr, Cont [N] >
        {
                static GSList * get_data(const Cont * array)
                {
                    return Glib::Container_Helpers::create_slist(array, array + (N - 1), Tr());
                }
                static const Glib::OwnershipType initial_ownership = Glib::OWNERSHIP_SHALLOW;
        };
        template<class Tr, class Cont, size_t N >
        struct SListSourceTraits< Tr, const Cont [N] > : SListSourceTraits< Tr, Cont [N] >
        {
        };
        template<class Tr >
        class SListHandleIterator
        {
            public :
                typedef typename Tr::CppType CppType;
                typedef typename Tr::CType CType;
                typedef std::forward_iterator_tag iterator_category;
                typedef CppType value_type;
                typedef ptrdiff_t difference_type;
                typedef value_type reference;
                typedef void pointer;
                explicit inline SListHandleIterator(const GSList * node);
                inline value_type operator *() const;
                inline SListHandleIterator< Tr > & operator ++();
                inline const SListHandleIterator< Tr > operator ++(int);
                inline bool operator ==(const SListHandleIterator< Tr > & rhs) const;
                inline bool operator !=(const SListHandleIterator< Tr > & rhs) const;
            private :
                const GSList * node_;
        };
    }
    template<class T, class Tr = Glib::Container_Helpers::TypeTraits< T > >
    class SListHandle
    {
        public :
            typedef typename Tr::CppType CppType;
            typedef typename Tr::CType CType;
            typedef CppType value_type;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef Glib::Container_Helpers::SListHandleIterator< Tr > const_iterator;
            typedef Glib::Container_Helpers::SListHandleIterator< Tr > iterator;
            template<class Cont >
            inline SListHandle(const Cont & container);
            inline SListHandle(GSList * glist, Glib::OwnershipType ownership);
            inline SListHandle(const SListHandle< T, Tr > & other);
            ~SListHandle();
            inline const_iterator begin() const;
            inline const_iterator end() const;
            template<class U >
            inline operator std::vector< U >() const;
            template<class U >
            inline operator std::deque< U >() const;
            template<class U >
            inline operator std::list< U >() const;
            template<class Cont >
            inline void assign_to(Cont & container) const;
            template<class Out >
            inline void copy(Out pdest) const;
            inline GSList * data() const;
            inline size_t size() const;
            inline bool empty() const;
        private :
            GSList * pslist_;
            mutable Glib::OwnershipType ownership_;
            SListHandle< T, Tr > & operator =(const SListHandle< T, Tr > &);
    };
    namespace Container_Helpers {
        template<class Tr >
        inline SListHandleIterator< Tr >::SListHandleIterator(const GSList * node)
            : node_(node) 
        {
        }
        template<class Tr >
        inline typename SListHandleIterator< Tr >::value_type SListHandleIterator< Tr >::operator *() const
        {
            return Tr::to_cpp_type(static_cast<typename Tr::CTypeNonConst >(node_->data));
        }
        template<class Tr >
        inline SListHandleIterator< Tr > & SListHandleIterator< Tr >::operator ++()
        {
            node_ = node_->next;
            return *this;
        }
        template<class Tr >
        inline const SListHandleIterator< Tr > SListHandleIterator< Tr >::operator ++(int)
        {
            const SListHandleIterator< Tr > tmp(*this);
            node_ = node_->next;
            return tmp;
        }
        template<class Tr >
        inline bool SListHandleIterator< Tr >::operator ==(const SListHandleIterator< Tr > & rhs) const
        {
            return (node_ == rhs.node_);
        }
        template<class Tr >
        inline bool SListHandleIterator< Tr >::operator !=(const SListHandleIterator< Tr > & rhs) const
        {
            return (node_ != rhs.node_);
        }
    }
    template<class T, class Tr >
    template<class Cont >
    inline SListHandle< T, Tr >::SListHandle(const Cont & container)
        : pslist_(Glib::Container_Helpers::SListSourceTraits< Tr, Cont >::get_data(container)), ownership_(Glib::Container_Helpers::SListSourceTraits< Tr, Cont >::initial_ownership) 
    {
    }
    template<class T, class Tr >
    inline SListHandle< T, Tr >::SListHandle(GSList * gslist, Glib::OwnershipType ownership)
        : pslist_(gslist), ownership_(ownership) 
    {
    }
    template<class T, class Tr >
    inline SListHandle< T, Tr >::SListHandle(const SListHandle< T, Tr > & other)
        : pslist_(other.pslist_), ownership_(other.ownership_) 
    {
        other.ownership_ = Glib::OWNERSHIP_NONE;
    }
    template<class T, class Tr >
    SListHandle< T, Tr >::~SListHandle()
    {
        if (ownership_ != Glib::OWNERSHIP_NONE)
        {
            if (ownership_ != Glib::OWNERSHIP_SHALLOW)
            {
                for (GSList * node = pslist_;
                    node != 0;
                    node = node->next)
                Tr::release_c_type(static_cast<typename Tr::CTypeNonConst >(node->data));
            }
            g_slist_free(pslist_);
        }
    }
    template<class T, class Tr >
    inline typename SListHandle< T, Tr >::const_iterator SListHandle< T, Tr >::begin() const
    {
        return Glib::Container_Helpers::SListHandleIterator< Tr >(pslist_);
    }
    template<class T, class Tr >
    inline typename SListHandle< T, Tr >::const_iterator SListHandle< T, Tr >::end() const
    {
        return Glib::Container_Helpers::SListHandleIterator< Tr >(0);
    }
    template<class T, class Tr >
    template<class U >
    inline SListHandle< T, Tr >::operator std::vector< U >() const
    {
        return std::vector< U >(this->begin(), this->end());
    }
    template<class T, class Tr >
    template<class U >
    inline SListHandle< T, Tr >::operator std::deque< U >() const
    {
        return std::deque< U >(this->begin(), this->end());
    }
    template<class T, class Tr >
    template<class U >
    inline SListHandle< T, Tr >::operator std::list< U >() const
    {
        return std::list< U >(this->begin(), this->end());
    }
    template<class T, class Tr >
    template<class Cont >
    inline void SListHandle< T, Tr >::assign_to(Cont & container) const
    {
        container.assign(this->begin(), this->end());
    }
    template<class T, class Tr >
    template<class Out >
    inline void SListHandle< T, Tr >::copy(Out pdest) const
    {
        std::copy(this->begin(), this->end(), pdest);
    }
    template<class T, class Tr >
    inline GSList * SListHandle< T, Tr >::data() const
    {
        return pslist_;
    }
    template<class T, class Tr >
    inline size_t SListHandle< T, Tr >::size() const
    {
        return g_slist_length(pslist_);
    }
    template<class T, class Tr >
    inline bool SListHandle< T, Tr >::empty() const
    {
        return (pslist_ == 0);
    }
}
namespace Glib {
    typedef GPid Pid;
    enum SpawnFlags
    {
        SPAWN_LEAVE_DESCRIPTORS_OPEN = 1 << 0, 
        SPAWN_DO_NOT_REAP_CHILD = 1 << 1, 
        SPAWN_SEARCH_PATH = 1 << 2, 
        SPAWN_STDOUT_TO_DEV_NULL = 1 << 3, 
        SPAWN_STDERR_TO_DEV_NULL = 1 << 4, 
        SPAWN_CHILD_INHERITS_STDIN = 1 << 5, 
        SPAWN_FILE_AND_ARGV_ZERO = 1 << 6
    };
    inline SpawnFlags operator |(SpawnFlags lhs, SpawnFlags rhs)
    {
        return static_cast<SpawnFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline SpawnFlags operator &(SpawnFlags lhs, SpawnFlags rhs)
    {
        return static_cast<SpawnFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline SpawnFlags operator ^(SpawnFlags lhs, SpawnFlags rhs)
    {
        return static_cast<SpawnFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline SpawnFlags operator ~(SpawnFlags flags)
    {
        return static_cast<SpawnFlags >(~static_cast<unsigned >(flags));
    }
    inline SpawnFlags & operator |=(SpawnFlags & lhs, SpawnFlags rhs)
    {
        return (lhs = static_cast<SpawnFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline SpawnFlags & operator &=(SpawnFlags & lhs, SpawnFlags rhs)
    {
        return (lhs = static_cast<SpawnFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline SpawnFlags & operator ^=(SpawnFlags & lhs, SpawnFlags rhs)
    {
        return (lhs = static_cast<SpawnFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
    class SpawnError : public Glib::Error
    {
        public :
            enum Code
            {
                FORK, 
                READ, 
                CHDIR, 
                ACCES, 
                PERM, 
                TOOBIG, 
                NOEXEC, 
                NAMETOOLONG, 
                NOENT, 
                NOMEM, 
                NOTDIR, 
                LOOP, 
                TXTBUSY, 
                IO, 
                NFILE, 
                MFILE, 
                INVAL, 
                ISDIR, 
                LIBBAD
            };
            SpawnError(Code error_code, const Glib::ustring & error_message);
            explicit SpawnError(GError * gobject);
            Code code() const;
        private :
            static void throw_func(GError * gobject);
            friend void wrap_init();
    };
    void spawn_async_with_pipes(const std::string & working_directory, const Glib::ArrayHandle< std::string > & argv, const Glib::ArrayHandle< std::string > & envp, SpawnFlags flags = SpawnFlags(0), const sigc::slot< void > & child_setup = sigc::slot< void >(), Pid * child_pid = 0, int * standard_input = 0, int * standard_output = 0, int * standard_error = 0);
    void spawn_async_with_pipes(const std::string & working_directory, const Glib::ArrayHandle< std::string > & argv, SpawnFlags flags = SpawnFlags(0), const sigc::slot< void > & child_setup = sigc::slot< void >(), Pid * child_pid = 0, int * standard_input = 0, int * standard_output = 0, int * standard_error = 0);
    void spawn_async(const std::string & working_directory, const Glib::ArrayHandle< std::string > & argv, const Glib::ArrayHandle< std::string > & envp, SpawnFlags flags = SpawnFlags(0), const sigc::slot< void > & child_setup = sigc::slot< void >(), Pid * child_pid = 0);
    void spawn_async(const std::string & working_directory, const Glib::ArrayHandle< std::string > & argv, SpawnFlags flags = SpawnFlags(0), const sigc::slot< void > & child_setup = sigc::slot< void >(), Pid * child_pid = 0);
    void spawn_sync(const std::string & working_directory, const Glib::ArrayHandle< std::string > & argv, const Glib::ArrayHandle< std::string > & envp, SpawnFlags flags = SpawnFlags(0), const sigc::slot< void > & child_setup = sigc::slot< void >(), std::string * standard_output = 0, std::string * standard_error = 0, int * exit_status = 0);
    void spawn_sync(const std::string & working_directory, const Glib::ArrayHandle< std::string > & argv, SpawnFlags flags = SpawnFlags(0), const sigc::slot< void > & child_setup = sigc::slot< void >(), std::string * standard_output = 0, std::string * standard_error = 0, int * exit_status = 0);
    void spawn_command_line_async(const std::string & command_line);
    void spawn_command_line_sync(const std::string & command_line, std::string * standard_output = 0, std::string * standard_error = 0, int * exit_status = 0);
    void spawn_close_pid(Pid pid);
}
namespace Glib {
    bool str_has_prefix(const std::string & str, const std::string & prefix);
    bool str_has_suffix(const std::string & str, const std::string & suffix);
    namespace Ascii {
        double strtod(const std::string & str);
        double strtod(const std::string & str, std::string::size_type & end_index, std::string::size_type start_index = 0);
        std::string dtostr(double d);
    }
    std::string strescape(const std::string & source);
    std::string strescape(const std::string & source, const std::string & exceptions);
    std::string strcompress(const std::string & source);
    Glib::ustring strerror(int errnum);
    Glib::ustring strsignal(int signum);
}
namespace Glib {
    enum ThreadPriority
    {
        THREAD_PRIORITY_LOW, 
        THREAD_PRIORITY_NORMAL, 
        THREAD_PRIORITY_HIGH, 
        THREAD_PRIORITY_URGENT
    };
    enum NotLock
    {
        NOT_LOCK
    };
    enum TryLock
    {
        TRY_LOCK
    };
    inline void thread_init(GThreadFunctions * vtable = 0);
    inline bool thread_supported();
    class Mutex;
    class RecMutex;
    class RWLock;
    struct StaticMutex;
    struct StaticRecMutex;
    struct StaticRWLock;
    class ThreadError : public Glib::Error
    {
        public :
            enum Code
            {
                AGAIN
            };
            ThreadError(Code error_code, const Glib::ustring & error_message);
            explicit ThreadError(GError * gobject);
            Code code() const;
        private :
            static void throw_func(GError * gobject);
            friend void wrap_init();
    };
    class Thread
    {
        public :
            class Exit;
            static Thread * create(const sigc::slot< void > & slot, bool joinable);
            static Thread * create(const sigc::slot< void > & slot, unsigned long stack_size, bool joinable, bool bound, ThreadPriority priority);
            static Thread * self();
            bool joinable() const;
            void join();
            void set_priority(ThreadPriority priority);
            ThreadPriority get_priority() const;
            static void yield();
            GThread * gobj()
            {
                return &gobject_;
            }
            const GThread * gobj() const
            {
                return &gobject_;
            }
        private :
            GThread gobject_;
            Thread();
            void operator delete(void *, size_t);
            Thread(const Thread &);
            Thread & operator =(const Thread &);
    };
    class Thread::Exit
    {
    };
    Thread * wrap(GThread * gobject);
    struct StaticMutex
    {
            void lock();
            bool trylock();
            void unlock();
            operator Mutex &();
            GStaticMutex * gobj()
            {
                return &gobject_;
            }
            GStaticMutex gobject_;
    };
    class Mutex
    {
        public :
            class Lock;
            Mutex();
            ~Mutex();
            void lock();
            bool trylock();
            void unlock();
            GMutex * gobj()
            {
                return gobject_;
            }
        private :
            GMutex * gobject_;
            Mutex(const Mutex &);
            Mutex & operator =(const Mutex &);
    };
    class Mutex::Lock
    {
        public :
            explicit inline Lock(Mutex & mutex);
            inline Lock(Mutex & mutex, NotLock);
            inline Lock(Mutex & mutex, TryLock);
            inline ~Lock();
            inline void acquire();
            inline bool try_acquire();
            inline void release();
            inline bool locked() const;
        private :
            Mutex & mutex_;
            bool locked_;
            Lock(const Mutex::Lock &);
            Mutex::Lock & operator =(const Mutex::Lock &);
    };
    struct StaticRecMutex
    {
            void lock();
            bool trylock();
            void unlock();
            void lock_full(unsigned int depth);
            unsigned int unlock_full();
            operator RecMutex &();
            GStaticRecMutex * gobj()
            {
                return &gobject_;
            }
            GStaticRecMutex gobject_;
    };
    class RecMutex : public StaticRecMutex
    {
        public :
            class Lock;
            RecMutex();
            ~RecMutex();
        private :
            RecMutex(const RecMutex &);
            RecMutex & operator =(const RecMutex &);
    };
    class RecMutex::Lock
    {
        public :
            explicit inline Lock(RecMutex & mutex);
            inline Lock(RecMutex & mutex, NotLock);
            inline Lock(RecMutex & mutex, TryLock);
            inline ~Lock();
            inline void acquire();
            inline bool try_acquire();
            inline void release();
            inline bool locked() const;
        private :
            RecMutex & mutex_;
            bool locked_;
            Lock(const RecMutex::Lock &);
            RecMutex::Lock & operator =(const RecMutex::Lock &);
    };
    struct StaticRWLock
    {
            void reader_lock();
            bool reader_trylock();
            void reader_unlock();
            void writer_lock();
            bool writer_trylock();
            void writer_unlock();
            operator RWLock &();
            GStaticRWLock * gobj()
            {
                return &gobject_;
            }
            GStaticRWLock gobject_;
    };
    class RWLock : public StaticRWLock
    {
        public :
            class ReaderLock;
            class WriterLock;
            RWLock();
            ~RWLock();
        private :
            RWLock(const RWLock &);
            RWLock & operator =(const RWLock &);
    };
    class RWLock::ReaderLock
    {
        public :
            explicit inline ReaderLock(RWLock & rwlock);
            inline ReaderLock(RWLock & rwlock, NotLock);
            inline ReaderLock(RWLock & rwlock, TryLock);
            inline ~ReaderLock();
            inline void acquire();
            inline bool try_acquire();
            inline void release();
            inline bool locked() const;
        private :
            RWLock & rwlock_;
            bool locked_;
            ReaderLock(const RWLock::ReaderLock &);
            RWLock::ReaderLock & operator =(const RWLock::ReaderLock &);
    };
    class RWLock::WriterLock
    {
        public :
            explicit inline WriterLock(RWLock & rwlock);
            inline WriterLock(RWLock & rwlock, NotLock);
            inline WriterLock(RWLock & rwlock, TryLock);
            inline ~WriterLock();
            inline void acquire();
            inline bool try_acquire();
            inline void release();
            inline bool locked() const;
        private :
            RWLock & rwlock_;
            bool locked_;
            WriterLock(const RWLock::WriterLock &);
            RWLock::WriterLock & operator =(const RWLock::WriterLock &);
    };
    class Cond
    {
        public :
            Cond();
            ~Cond();
            void signal();
            void broadcast();
            void wait(Mutex & mutex);
            bool timed_wait(Mutex & mutex, const Glib::TimeVal & abs_time);
            GCond * gobj()
            {
                return gobject_;
            }
        private :
            GCond * gobject_;
            Cond(const Cond &);
            Cond & operator =(const Cond &);
    };
    template<class T >
    struct StaticPrivate
    {
            typedef void (* DestroyNotifyFunc)(void *);
            static void delete_ptr(void * data);
            inline T * get();
            inline void set(T * data, DestroyNotifyFunc notify_func = &StaticPrivate< T >::delete_ptr);
            GStaticPrivate * gobj()
            {
                return &gobject_;
            }
            GStaticPrivate gobject_;
    };
    template<class T >
    class Private
    {
        public :
            typedef void (* DestructorFunc)(void *);
            static void delete_ptr(void * data);
            explicit inline Private(DestructorFunc destructor_func = &Private< T >::delete_ptr);
            inline T * get();
            inline void set(T * data);
            GPrivate * gobj()
            {
                return gobject_;
            }
        private :
            GPrivate * gobject_;
            Private(const Private< T > &);
            Private< T > & operator =(const Private< T > &);
    };
    void thread_init_impl();
    inline void thread_init(GThreadFunctions * vtable)
    {
        g_thread_init(vtable);
        Glib::thread_init_impl();
    }
    inline bool thread_supported()
    {
        return ((g_threads_got_initialized) != 0);
    }
    inline Mutex::Lock::Lock(Mutex & mutex)
        : mutex_(mutex), locked_(true) 
    {
        mutex_.lock();
    }
    inline Mutex::Lock::Lock(Mutex & mutex, NotLock)
        : mutex_(mutex), locked_(false) 
    {
    }
    inline Mutex::Lock::Lock(Mutex & mutex, TryLock)
        : mutex_(mutex), locked_(mutex.trylock()) 
    {
    }
    inline Mutex::Lock::~Lock()
    {
        if (locked_)
            mutex_.unlock();
    }
    inline void Mutex::Lock::acquire()
    {
        mutex_.lock();
        locked_ = true;
    }
    inline bool Mutex::Lock::try_acquire()
    {
        locked_ = mutex_.trylock();
        return locked_;
    }
    inline void Mutex::Lock::release()
    {
        mutex_.unlock();
        locked_ = false;
    }
    inline bool Mutex::Lock::locked() const
    {
        return locked_;
    }
    inline RecMutex::Lock::Lock(RecMutex & mutex)
        : mutex_(mutex), locked_(true) 
    {
        mutex_.lock();
    }
    inline RecMutex::Lock::Lock(RecMutex & mutex, NotLock)
        : mutex_(mutex), locked_(false) 
    {
    }
    inline RecMutex::Lock::Lock(RecMutex & mutex, TryLock)
        : mutex_(mutex), locked_(mutex.trylock()) 
    {
    }
    inline RecMutex::Lock::~Lock()
    {
        if (locked_)
            mutex_.unlock();
    }
    inline void RecMutex::Lock::acquire()
    {
        mutex_.lock();
        locked_ = true;
    }
    inline bool RecMutex::Lock::try_acquire()
    {
        locked_ = mutex_.trylock();
        return locked_;
    }
    inline void RecMutex::Lock::release()
    {
        mutex_.unlock();
        locked_ = false;
    }
    inline bool RecMutex::Lock::locked() const
    {
        return locked_;
    }
    inline RWLock::ReaderLock::ReaderLock(RWLock & rwlock)
        : rwlock_(rwlock), locked_(true) 
    {
        rwlock_.reader_lock();
    }
    inline RWLock::ReaderLock::ReaderLock(RWLock & rwlock, NotLock)
        : rwlock_(rwlock), locked_(false) 
    {
    }
    inline RWLock::ReaderLock::ReaderLock(RWLock & rwlock, TryLock)
        : rwlock_(rwlock), locked_(rwlock.reader_trylock()) 
    {
    }
    inline RWLock::ReaderLock::~ReaderLock()
    {
        if (locked_)
            rwlock_.reader_unlock();
    }
    inline void RWLock::ReaderLock::acquire()
    {
        rwlock_.reader_lock();
        locked_ = true;
    }
    inline bool RWLock::ReaderLock::try_acquire()
    {
        locked_ = rwlock_.reader_trylock();
        return locked_;
    }
    inline void RWLock::ReaderLock::release()
    {
        rwlock_.reader_unlock();
        locked_ = false;
    }
    inline bool RWLock::ReaderLock::locked() const
    {
        return locked_;
    }
    inline RWLock::WriterLock::WriterLock(RWLock & rwlock)
        : rwlock_(rwlock), locked_(true) 
    {
        rwlock_.writer_lock();
    }
    inline RWLock::WriterLock::WriterLock(RWLock & rwlock, NotLock)
        : rwlock_(rwlock), locked_(false) 
    {
    }
    inline RWLock::WriterLock::WriterLock(RWLock & rwlock, TryLock)
        : rwlock_(rwlock), locked_(rwlock.writer_trylock()) 
    {
    }
    inline RWLock::WriterLock::~WriterLock()
    {
        if (locked_)
            rwlock_.writer_unlock();
    }
    inline void RWLock::WriterLock::acquire()
    {
        rwlock_.writer_lock();
        locked_ = true;
    }
    inline bool RWLock::WriterLock::try_acquire()
    {
        locked_ = rwlock_.writer_trylock();
        return locked_;
    }
    inline void RWLock::WriterLock::release()
    {
        rwlock_.writer_unlock();
        locked_ = false;
    }
    inline bool RWLock::WriterLock::locked() const
    {
        return locked_;
    }
    template<class T >
    void StaticPrivate< T >::delete_ptr(void * data)
    {
        delete static_cast<T * >(data);
    }
    template<class T >
    inline T * StaticPrivate< T >::get()
    {
        return static_cast<T * >(g_static_private_get(&gobject_));
    }
    template<class T >
    inline void StaticPrivate< T >::set(T * data, typename StaticPrivate< T >::DestroyNotifyFunc notify_func)
    {
        g_static_private_set(&gobject_, data, notify_func);
    }
    template<class T >
    void Private< T >::delete_ptr(void * data)
    {
        delete static_cast<T * >(data);
    }
    template<class T >
    inline Private< T >::Private(typename Private< T >::DestructorFunc destructor_func)
        : gobject_((*g_thread_functions_for_glib_use.private_new)(destructor_func)) 
    {
    }
    template<class T >
    inline T * Private< T >::get()
    {
        return static_cast<T * >(((g_threads_got_initialized) ? (*g_thread_functions_for_glib_use.private_get)(gobject_) : (((gpointer) gobject_))));
    }
    template<class T >
    inline void Private< T >::set(T * data)
    {
        ((g_threads_got_initialized) ? (*g_thread_functions_for_glib_use.private_set)(gobject_, data) : ((void) (gobject_ = (GPrivate *) (data))));
    }
}
extern "C"
{
    typedef struct _GThreadPool GThreadPool;
}
namespace Glib {
    class ThreadPool
    {
        public :
            explicit ThreadPool(int max_threads = -1, bool exclusive = false);
            virtual ~ThreadPool();
            void push(const sigc::slot< void > & slot);
            void set_max_threads(int max_threads);
            int get_max_threads() const;
            unsigned int get_num_threads() const;
            unsigned int unprocessed() const;
            bool get_exclusive() const;
            void shutdown(bool immediately = false);
            static void set_max_unused_threads(int max_threads);
            static int get_max_unused_threads();
            static unsigned int get_num_unused_threads();
            static void stop_unused_threads();
            GThreadPool * gobj()
            {
                return gobject_;
            }
            const GThreadPool * gobj() const
            {
                return gobject_;
            }
            class SlotList;
        private :
            GThreadPool * gobject_;
            SlotList * slot_list_;
            ThreadPool(const ThreadPool &);
            ThreadPool & operator =(const ThreadPool &);
    };
}
extern "C"
{
    typedef struct _GTimer GTimer;
}
namespace Glib {
    class Timer
    {
        public :
            Timer();
            ~Timer();
            void start();
            void stop();
            void reset();
            double elapsed() const;
            double elapsed(unsigned long & microseconds) const;
            GTimer * gobj()
            {
                return gobject_;
            }
            const GTimer * gobj() const
            {
                return gobject_;
            }
        private :
            GTimer * gobject_;
            Timer(const Timer &);
            Timer & operator =(const Timer &);
    };
    void usleep(unsigned long microseconds);
}
namespace Glib {
    std::string uri_unescape_string(const std::string & escaped_string, const std::string & illegal_characters = std::string());
    std::string uri_parse_scheme(const std::string & uri);
    std::string uri_escape_string(const std::string & unescaped, const std::string & reserved_chars_allowed = std::string(), bool allow_utf8 = true);
}
extern "C"
{
    int cairo_version(void);
    const char * cairo_version_string(void);
    typedef int cairo_bool_t;
    typedef struct _cairo cairo_t;
    typedef struct _cairo_surface cairo_surface_t;
    typedef struct _cairo_matrix
    {
            double xx;
            double yx;
            double xy;
            double yy;
            double x0;
            double y0;
    } cairo_matrix_t;
    typedef struct _cairo_pattern cairo_pattern_t;
    typedef void (* cairo_destroy_func_t)(void * data);
    typedef struct _cairo_user_data_key
    {
            int unused;
    } cairo_user_data_key_t;
    typedef enum _cairo_status
    {
        CAIRO_STATUS_SUCCESS = 0, 
        CAIRO_STATUS_NO_MEMORY, 
        CAIRO_STATUS_INVALID_RESTORE, 
        CAIRO_STATUS_INVALID_POP_GROUP, 
        CAIRO_STATUS_NO_CURRENT_POINT, 
        CAIRO_STATUS_INVALID_MATRIX, 
        CAIRO_STATUS_INVALID_STATUS, 
        CAIRO_STATUS_NULL_POINTER, 
        CAIRO_STATUS_INVALID_STRING, 
        CAIRO_STATUS_INVALID_PATH_DATA, 
        CAIRO_STATUS_READ_ERROR, 
        CAIRO_STATUS_WRITE_ERROR, 
        CAIRO_STATUS_SURFACE_FINISHED, 
        CAIRO_STATUS_SURFACE_TYPE_MISMATCH, 
        CAIRO_STATUS_PATTERN_TYPE_MISMATCH, 
        CAIRO_STATUS_INVALID_CONTENT, 
        CAIRO_STATUS_INVALID_FORMAT, 
        CAIRO_STATUS_INVALID_VISUAL, 
        CAIRO_STATUS_FILE_NOT_FOUND, 
        CAIRO_STATUS_INVALID_DASH, 
        CAIRO_STATUS_INVALID_DSC_COMMENT, 
        CAIRO_STATUS_INVALID_INDEX, 
        CAIRO_STATUS_CLIP_NOT_REPRESENTABLE, 
        CAIRO_STATUS_TEMP_FILE_ERROR, 
        CAIRO_STATUS_INVALID_STRIDE
    } cairo_status_t;
    typedef enum _cairo_content
    {
        CAIRO_CONTENT_COLOR = 0x1000, 
        CAIRO_CONTENT_ALPHA = 0x2000, 
        CAIRO_CONTENT_COLOR_ALPHA = 0x3000
    } cairo_content_t;
    typedef cairo_status_t (* cairo_write_func_t)(void * closure, const unsigned char * data, unsigned int length);
    typedef cairo_status_t (* cairo_read_func_t)(void * closure, unsigned char * data, unsigned int length);
    cairo_t * cairo_create(cairo_surface_t * target);
    cairo_t * cairo_reference(cairo_t * cr);
    void cairo_destroy(cairo_t * cr);
    unsigned int cairo_get_reference_count(cairo_t * cr);
    void * cairo_get_user_data(cairo_t * cr, const cairo_user_data_key_t * key);
    cairo_status_t cairo_set_user_data(cairo_t * cr, const cairo_user_data_key_t * key, void * user_data, cairo_destroy_func_t destroy);
    void cairo_save(cairo_t * cr);
    void cairo_restore(cairo_t * cr);
    void cairo_push_group(cairo_t * cr);
    void cairo_push_group_with_content(cairo_t * cr, cairo_content_t content);
    cairo_pattern_t * cairo_pop_group(cairo_t * cr);
    void cairo_pop_group_to_source(cairo_t * cr);
    typedef enum _cairo_operator
    {
        CAIRO_OPERATOR_CLEAR, 
        CAIRO_OPERATOR_SOURCE, 
        CAIRO_OPERATOR_OVER, 
        CAIRO_OPERATOR_IN, 
        CAIRO_OPERATOR_OUT, 
        CAIRO_OPERATOR_ATOP, 
        CAIRO_OPERATOR_DEST, 
        CAIRO_OPERATOR_DEST_OVER, 
        CAIRO_OPERATOR_DEST_IN, 
        CAIRO_OPERATOR_DEST_OUT, 
        CAIRO_OPERATOR_DEST_ATOP, 
        CAIRO_OPERATOR_XOR, 
        CAIRO_OPERATOR_ADD, 
        CAIRO_OPERATOR_SATURATE
    } cairo_operator_t;
    void cairo_set_operator(cairo_t * cr, cairo_operator_t op);
    void cairo_set_source(cairo_t * cr, cairo_pattern_t * source);
    void cairo_set_source_rgb(cairo_t * cr, double red, double green, double blue);
    void cairo_set_source_rgba(cairo_t * cr, double red, double green, double blue, double alpha);
    void cairo_set_source_surface(cairo_t * cr, cairo_surface_t * surface, double x, double y);
    void cairo_set_tolerance(cairo_t * cr, double tolerance);
    typedef enum _cairo_antialias
    {
        CAIRO_ANTIALIAS_DEFAULT, 
        CAIRO_ANTIALIAS_NONE, 
        CAIRO_ANTIALIAS_GRAY, 
        CAIRO_ANTIALIAS_SUBPIXEL
    } cairo_antialias_t;
    void cairo_set_antialias(cairo_t * cr, cairo_antialias_t antialias);
    typedef enum _cairo_fill_rule
    {
        CAIRO_FILL_RULE_WINDING, 
        CAIRO_FILL_RULE_EVEN_ODD
    } cairo_fill_rule_t;
    void cairo_set_fill_rule(cairo_t * cr, cairo_fill_rule_t fill_rule);
    void cairo_set_line_width(cairo_t * cr, double width);
    typedef enum _cairo_line_cap
    {
        CAIRO_LINE_CAP_BUTT, 
        CAIRO_LINE_CAP_ROUND, 
        CAIRO_LINE_CAP_SQUARE
    } cairo_line_cap_t;
    void cairo_set_line_cap(cairo_t * cr, cairo_line_cap_t line_cap);
    typedef enum _cairo_line_join
    {
        CAIRO_LINE_JOIN_MITER, 
        CAIRO_LINE_JOIN_ROUND, 
        CAIRO_LINE_JOIN_BEVEL
    } cairo_line_join_t;
    void cairo_set_line_join(cairo_t * cr, cairo_line_join_t line_join);
    void cairo_set_dash(cairo_t * cr, const double * dashes, int num_dashes, double offset);
    void cairo_set_miter_limit(cairo_t * cr, double limit);
    void cairo_translate(cairo_t * cr, double tx, double ty);
    void cairo_scale(cairo_t * cr, double sx, double sy);
    void cairo_rotate(cairo_t * cr, double angle);
    void cairo_transform(cairo_t * cr, const cairo_matrix_t * matrix);
    void cairo_set_matrix(cairo_t * cr, const cairo_matrix_t * matrix);
    void cairo_identity_matrix(cairo_t * cr);
    void cairo_user_to_device(cairo_t * cr, double * x, double * y);
    void cairo_user_to_device_distance(cairo_t * cr, double * dx, double * dy);
    void cairo_device_to_user(cairo_t * cr, double * x, double * y);
    void cairo_device_to_user_distance(cairo_t * cr, double * dx, double * dy);
    void cairo_new_path(cairo_t * cr);
    void cairo_move_to(cairo_t * cr, double x, double y);
    void cairo_new_sub_path(cairo_t * cr);
    void cairo_line_to(cairo_t * cr, double x, double y);
    void cairo_curve_to(cairo_t * cr, double x1, double y1, double x2, double y2, double x3, double y3);
    void cairo_arc(cairo_t * cr, double xc, double yc, double radius, double angle1, double angle2);
    void cairo_arc_negative(cairo_t * cr, double xc, double yc, double radius, double angle1, double angle2);
    void cairo_rel_move_to(cairo_t * cr, double dx, double dy);
    void cairo_rel_line_to(cairo_t * cr, double dx, double dy);
    void cairo_rel_curve_to(cairo_t * cr, double dx1, double dy1, double dx2, double dy2, double dx3, double dy3);
    void cairo_rectangle(cairo_t * cr, double x, double y, double width, double height);
    void cairo_close_path(cairo_t * cr);
    void cairo_path_extents(cairo_t * cr, double * x1, double * y1, double * x2, double * y2);
    void cairo_paint(cairo_t * cr);
    void cairo_paint_with_alpha(cairo_t * cr, double alpha);
    void cairo_mask(cairo_t * cr, cairo_pattern_t * pattern);
    void cairo_mask_surface(cairo_t * cr, cairo_surface_t * surface, double surface_x, double surface_y);
    void cairo_stroke(cairo_t * cr);
    void cairo_stroke_preserve(cairo_t * cr);
    void cairo_fill(cairo_t * cr);
    void cairo_fill_preserve(cairo_t * cr);
    void cairo_copy_page(cairo_t * cr);
    void cairo_show_page(cairo_t * cr);
    cairo_bool_t cairo_in_stroke(cairo_t * cr, double x, double y);
    cairo_bool_t cairo_in_fill(cairo_t * cr, double x, double y);
    void cairo_stroke_extents(cairo_t * cr, double * x1, double * y1, double * x2, double * y2);
    void cairo_fill_extents(cairo_t * cr, double * x1, double * y1, double * x2, double * y2);
    void cairo_reset_clip(cairo_t * cr);
    void cairo_clip(cairo_t * cr);
    void cairo_clip_preserve(cairo_t * cr);
    void cairo_clip_extents(cairo_t * cr, double * x1, double * y1, double * x2, double * y2);
    typedef struct _cairo_rectangle
    {
            double x, y, width, height;
    } cairo_rectangle_t;
    typedef struct _cairo_rectangle_list
    {
            cairo_status_t status;
            cairo_rectangle_t * rectangles;
            int num_rectangles;
    } cairo_rectangle_list_t;
    cairo_rectangle_list_t * cairo_copy_clip_rectangle_list(cairo_t * cr);
    void cairo_rectangle_list_destroy(cairo_rectangle_list_t * rectangle_list);
    typedef struct _cairo_scaled_font cairo_scaled_font_t;
    typedef struct _cairo_font_face cairo_font_face_t;
    typedef struct 
    {
            unsigned long index;
            double x;
            double y;
    } cairo_glyph_t;
    typedef struct 
    {
            double x_bearing;
            double y_bearing;
            double width;
            double height;
            double x_advance;
            double y_advance;
    } cairo_text_extents_t;
    typedef struct 
    {
            double ascent;
            double descent;
            double height;
            double max_x_advance;
            double max_y_advance;
    } cairo_font_extents_t;
    typedef enum _cairo_font_slant
    {
        CAIRO_FONT_SLANT_NORMAL, 
        CAIRO_FONT_SLANT_ITALIC, 
        CAIRO_FONT_SLANT_OBLIQUE
    } cairo_font_slant_t;
    typedef enum _cairo_font_weight
    {
        CAIRO_FONT_WEIGHT_NORMAL, 
        CAIRO_FONT_WEIGHT_BOLD
    } cairo_font_weight_t;
    typedef enum _cairo_subpixel_order
    {
        CAIRO_SUBPIXEL_ORDER_DEFAULT, 
        CAIRO_SUBPIXEL_ORDER_RGB, 
        CAIRO_SUBPIXEL_ORDER_BGR, 
        CAIRO_SUBPIXEL_ORDER_VRGB, 
        CAIRO_SUBPIXEL_ORDER_VBGR
    } cairo_subpixel_order_t;
    typedef enum _cairo_hint_style
    {
        CAIRO_HINT_STYLE_DEFAULT, 
        CAIRO_HINT_STYLE_NONE, 
        CAIRO_HINT_STYLE_SLIGHT, 
        CAIRO_HINT_STYLE_MEDIUM, 
        CAIRO_HINT_STYLE_FULL
    } cairo_hint_style_t;
    typedef enum _cairo_hint_metrics
    {
        CAIRO_HINT_METRICS_DEFAULT, 
        CAIRO_HINT_METRICS_OFF, 
        CAIRO_HINT_METRICS_ON
    } cairo_hint_metrics_t;
    typedef struct _cairo_font_options cairo_font_options_t;
    cairo_font_options_t * cairo_font_options_create(void);
    cairo_font_options_t * cairo_font_options_copy(const cairo_font_options_t * original);
    void cairo_font_options_destroy(cairo_font_options_t * options);
    cairo_status_t cairo_font_options_status(cairo_font_options_t * options);
    void cairo_font_options_merge(cairo_font_options_t * options, const cairo_font_options_t * other);
    cairo_bool_t cairo_font_options_equal(const cairo_font_options_t * options, const cairo_font_options_t * other);
    unsigned long cairo_font_options_hash(const cairo_font_options_t * options);
    void cairo_font_options_set_antialias(cairo_font_options_t * options, cairo_antialias_t antialias);
    cairo_antialias_t cairo_font_options_get_antialias(const cairo_font_options_t * options);
    void cairo_font_options_set_subpixel_order(cairo_font_options_t * options, cairo_subpixel_order_t subpixel_order);
    cairo_subpixel_order_t cairo_font_options_get_subpixel_order(const cairo_font_options_t * options);
    void cairo_font_options_set_hint_style(cairo_font_options_t * options, cairo_hint_style_t hint_style);
    cairo_hint_style_t cairo_font_options_get_hint_style(const cairo_font_options_t * options);
    void cairo_font_options_set_hint_metrics(cairo_font_options_t * options, cairo_hint_metrics_t hint_metrics);
    cairo_hint_metrics_t cairo_font_options_get_hint_metrics(const cairo_font_options_t * options);
    void cairo_select_font_face(cairo_t * cr, const char * family, cairo_font_slant_t slant, cairo_font_weight_t weight);
    void cairo_set_font_size(cairo_t * cr, double size);
    void cairo_set_font_matrix(cairo_t * cr, const cairo_matrix_t * matrix);
    void cairo_get_font_matrix(cairo_t * cr, cairo_matrix_t * matrix);
    void cairo_set_font_options(cairo_t * cr, const cairo_font_options_t * options);
    void cairo_get_font_options(cairo_t * cr, cairo_font_options_t * options);
    void cairo_set_font_face(cairo_t * cr, cairo_font_face_t * font_face);
    cairo_font_face_t * cairo_get_font_face(cairo_t * cr);
    void cairo_set_scaled_font(cairo_t * cr, const cairo_scaled_font_t * scaled_font);
    cairo_scaled_font_t * cairo_get_scaled_font(cairo_t * cr);
    void cairo_show_text(cairo_t * cr, const char * utf8);
    void cairo_show_glyphs(cairo_t * cr, const cairo_glyph_t * glyphs, int num_glyphs);
    void cairo_text_path(cairo_t * cr, const char * utf8);
    void cairo_glyph_path(cairo_t * cr, const cairo_glyph_t * glyphs, int num_glyphs);
    void cairo_text_extents(cairo_t * cr, const char * utf8, cairo_text_extents_t * extents);
    void cairo_glyph_extents(cairo_t * cr, const cairo_glyph_t * glyphs, int num_glyphs, cairo_text_extents_t * extents);
    void cairo_font_extents(cairo_t * cr, cairo_font_extents_t * extents);
    cairo_font_face_t * cairo_font_face_reference(cairo_font_face_t * font_face);
    void cairo_font_face_destroy(cairo_font_face_t * font_face);
    unsigned int cairo_font_face_get_reference_count(cairo_font_face_t * font_face);
    cairo_status_t cairo_font_face_status(cairo_font_face_t * font_face);
    typedef enum _cairo_font_type
    {
        CAIRO_FONT_TYPE_TOY, 
        CAIRO_FONT_TYPE_FT, 
        CAIRO_FONT_TYPE_WIN32, 
        CAIRO_FONT_TYPE_QUARTZ
    } cairo_font_type_t;
    cairo_font_type_t cairo_font_face_get_type(cairo_font_face_t * font_face);
    void * cairo_font_face_get_user_data(cairo_font_face_t * font_face, const cairo_user_data_key_t * key);
    cairo_status_t cairo_font_face_set_user_data(cairo_font_face_t * font_face, const cairo_user_data_key_t * key, void * user_data, cairo_destroy_func_t destroy);
    cairo_scaled_font_t * cairo_scaled_font_create(cairo_font_face_t * font_face, const cairo_matrix_t * font_matrix, const cairo_matrix_t * ctm, const cairo_font_options_t * options);
    cairo_scaled_font_t * cairo_scaled_font_reference(cairo_scaled_font_t * scaled_font);
    void cairo_scaled_font_destroy(cairo_scaled_font_t * scaled_font);
    unsigned int cairo_scaled_font_get_reference_count(cairo_scaled_font_t * scaled_font);
    cairo_status_t cairo_scaled_font_status(cairo_scaled_font_t * scaled_font);
    cairo_font_type_t cairo_scaled_font_get_type(cairo_scaled_font_t * scaled_font);
    void * cairo_scaled_font_get_user_data(cairo_scaled_font_t * scaled_font, const cairo_user_data_key_t * key);
    cairo_status_t cairo_scaled_font_set_user_data(cairo_scaled_font_t * scaled_font, const cairo_user_data_key_t * key, void * user_data, cairo_destroy_func_t destroy);
    void cairo_scaled_font_extents(cairo_scaled_font_t * scaled_font, cairo_font_extents_t * extents);
    void cairo_scaled_font_text_extents(cairo_scaled_font_t * scaled_font, const char * utf8, cairo_text_extents_t * extents);
    void cairo_scaled_font_glyph_extents(cairo_scaled_font_t * scaled_font, const cairo_glyph_t * glyphs, int num_glyphs, cairo_text_extents_t * extents);
    cairo_font_face_t * cairo_scaled_font_get_font_face(cairo_scaled_font_t * scaled_font);
    void cairo_scaled_font_get_font_matrix(cairo_scaled_font_t * scaled_font, cairo_matrix_t * font_matrix);
    void cairo_scaled_font_get_ctm(cairo_scaled_font_t * scaled_font, cairo_matrix_t * ctm);
    void cairo_scaled_font_get_font_options(cairo_scaled_font_t * scaled_font, cairo_font_options_t * options);
    cairo_operator_t cairo_get_operator(cairo_t * cr);
    cairo_pattern_t * cairo_get_source(cairo_t * cr);
    double cairo_get_tolerance(cairo_t * cr);
    cairo_antialias_t cairo_get_antialias(cairo_t * cr);
    cairo_bool_t cairo_has_current_point(cairo_t * cr);
    void cairo_get_current_point(cairo_t * cr, double * x, double * y);
    cairo_fill_rule_t cairo_get_fill_rule(cairo_t * cr);
    double cairo_get_line_width(cairo_t * cr);
    cairo_line_cap_t cairo_get_line_cap(cairo_t * cr);
    cairo_line_join_t cairo_get_line_join(cairo_t * cr);
    double cairo_get_miter_limit(cairo_t * cr);
    int cairo_get_dash_count(cairo_t * cr);
    void cairo_get_dash(cairo_t * cr, double * dashes, double * offset);
    void cairo_get_matrix(cairo_t * cr, cairo_matrix_t * matrix);
    cairo_surface_t * cairo_get_target(cairo_t * cr);
    cairo_surface_t * cairo_get_group_target(cairo_t * cr);
    typedef enum _cairo_path_data_type
    {
        CAIRO_PATH_MOVE_TO, 
        CAIRO_PATH_LINE_TO, 
        CAIRO_PATH_CURVE_TO, 
        CAIRO_PATH_CLOSE_PATH
    } cairo_path_data_type_t;
    typedef union _cairo_path_data_t cairo_path_data_t;
    union _cairo_path_data_t
    {
            struct 
            {
                    cairo_path_data_type_t type;
                    int length;
            } header;
            struct 
            {
                    double x, y;
            } point;
    };
    typedef struct cairo_path
    {
            cairo_status_t status;
            cairo_path_data_t * data;
            int num_data;
    } cairo_path_t;
    cairo_path_t * cairo_copy_path(cairo_t * cr);
    cairo_path_t * cairo_copy_path_flat(cairo_t * cr);
    void cairo_append_path(cairo_t * cr, const cairo_path_t * path);
    void cairo_path_destroy(cairo_path_t * path);
    cairo_status_t cairo_status(cairo_t * cr);
    const char * cairo_status_to_string(cairo_status_t status);
    cairo_surface_t * cairo_surface_create_similar(cairo_surface_t * other, cairo_content_t content, int width, int height);
    cairo_surface_t * cairo_surface_reference(cairo_surface_t * surface);
    void cairo_surface_finish(cairo_surface_t * surface);
    void cairo_surface_destroy(cairo_surface_t * surface);
    unsigned int cairo_surface_get_reference_count(cairo_surface_t * surface);
    cairo_status_t cairo_surface_status(cairo_surface_t * surface);
    typedef enum _cairo_surface_type
    {
        CAIRO_SURFACE_TYPE_IMAGE, 
        CAIRO_SURFACE_TYPE_PDF, 
        CAIRO_SURFACE_TYPE_PS, 
        CAIRO_SURFACE_TYPE_XLIB, 
        CAIRO_SURFACE_TYPE_XCB, 
        CAIRO_SURFACE_TYPE_GLITZ, 
        CAIRO_SURFACE_TYPE_QUARTZ, 
        CAIRO_SURFACE_TYPE_WIN32, 
        CAIRO_SURFACE_TYPE_BEOS, 
        CAIRO_SURFACE_TYPE_DIRECTFB, 
        CAIRO_SURFACE_TYPE_SVG, 
        CAIRO_SURFACE_TYPE_OS2, 
        CAIRO_SURFACE_TYPE_WIN32_PRINTING, 
        CAIRO_SURFACE_TYPE_QUARTZ_IMAGE
    } cairo_surface_type_t;
    cairo_surface_type_t cairo_surface_get_type(cairo_surface_t * surface);
    cairo_content_t cairo_surface_get_content(cairo_surface_t * surface);
    cairo_status_t cairo_surface_write_to_png(cairo_surface_t * surface, const char * filename);
    cairo_status_t cairo_surface_write_to_png_stream(cairo_surface_t * surface, cairo_write_func_t write_func, void * closure);
    void * cairo_surface_get_user_data(cairo_surface_t * surface, const cairo_user_data_key_t * key);
    cairo_status_t cairo_surface_set_user_data(cairo_surface_t * surface, const cairo_user_data_key_t * key, void * user_data, cairo_destroy_func_t destroy);
    void cairo_surface_get_font_options(cairo_surface_t * surface, cairo_font_options_t * options);
    void cairo_surface_flush(cairo_surface_t * surface);
    void cairo_surface_mark_dirty(cairo_surface_t * surface);
    void cairo_surface_mark_dirty_rectangle(cairo_surface_t * surface, int x, int y, int width, int height);
    void cairo_surface_set_device_offset(cairo_surface_t * surface, double x_offset, double y_offset);
    void cairo_surface_get_device_offset(cairo_surface_t * surface, double * x_offset, double * y_offset);
    void cairo_surface_set_fallback_resolution(cairo_surface_t * surface, double x_pixels_per_inch, double y_pixels_per_inch);
    void cairo_surface_copy_page(cairo_surface_t * surface);
    void cairo_surface_show_page(cairo_surface_t * surface);
    typedef enum _cairo_format
    {
        CAIRO_FORMAT_ARGB32, 
        CAIRO_FORMAT_RGB24, 
        CAIRO_FORMAT_A8, 
        CAIRO_FORMAT_A1
    } cairo_format_t;
    cairo_surface_t * cairo_image_surface_create(cairo_format_t format, int width, int height);
    int cairo_format_stride_for_width(cairo_format_t format, int width);
    cairo_surface_t * cairo_image_surface_create_for_data(unsigned char * data, cairo_format_t format, int width, int height, int stride);
    unsigned char * cairo_image_surface_get_data(cairo_surface_t * surface);
    cairo_format_t cairo_image_surface_get_format(cairo_surface_t * surface);
    int cairo_image_surface_get_width(cairo_surface_t * surface);
    int cairo_image_surface_get_height(cairo_surface_t * surface);
    int cairo_image_surface_get_stride(cairo_surface_t * surface);
    cairo_surface_t * cairo_image_surface_create_from_png(const char * filename);
    cairo_surface_t * cairo_image_surface_create_from_png_stream(cairo_read_func_t read_func, void * closure);
    cairo_pattern_t * cairo_pattern_create_rgb(double red, double green, double blue);
    cairo_pattern_t * cairo_pattern_create_rgba(double red, double green, double blue, double alpha);
    cairo_pattern_t * cairo_pattern_create_for_surface(cairo_surface_t * surface);
    cairo_pattern_t * cairo_pattern_create_linear(double x0, double y0, double x1, double y1);
    cairo_pattern_t * cairo_pattern_create_radial(double cx0, double cy0, double radius0, double cx1, double cy1, double radius1);
    cairo_pattern_t * cairo_pattern_reference(cairo_pattern_t * pattern);
    void cairo_pattern_destroy(cairo_pattern_t * pattern);
    unsigned int cairo_pattern_get_reference_count(cairo_pattern_t * pattern);
    cairo_status_t cairo_pattern_status(cairo_pattern_t * pattern);
    void * cairo_pattern_get_user_data(cairo_pattern_t * pattern, const cairo_user_data_key_t * key);
    cairo_status_t cairo_pattern_set_user_data(cairo_pattern_t * pattern, const cairo_user_data_key_t * key, void * user_data, cairo_destroy_func_t destroy);
    typedef enum _cairo_pattern_type
    {
        CAIRO_PATTERN_TYPE_SOLID, 
        CAIRO_PATTERN_TYPE_SURFACE, 
        CAIRO_PATTERN_TYPE_LINEAR, 
        CAIRO_PATTERN_TYPE_RADIAL
    } cairo_pattern_type_t;
    cairo_pattern_type_t cairo_pattern_get_type(cairo_pattern_t * pattern);
    void cairo_pattern_add_color_stop_rgb(cairo_pattern_t * pattern, double offset, double red, double green, double blue);
    void cairo_pattern_add_color_stop_rgba(cairo_pattern_t * pattern, double offset, double red, double green, double blue, double alpha);
    void cairo_pattern_set_matrix(cairo_pattern_t * pattern, const cairo_matrix_t * matrix);
    void cairo_pattern_get_matrix(cairo_pattern_t * pattern, cairo_matrix_t * matrix);
    typedef enum _cairo_extend
    {
        CAIRO_EXTEND_NONE, 
        CAIRO_EXTEND_REPEAT, 
        CAIRO_EXTEND_REFLECT, 
        CAIRO_EXTEND_PAD
    } cairo_extend_t;
    void cairo_pattern_set_extend(cairo_pattern_t * pattern, cairo_extend_t extend);
    cairo_extend_t cairo_pattern_get_extend(cairo_pattern_t * pattern);
    typedef enum _cairo_filter
    {
        CAIRO_FILTER_FAST, 
        CAIRO_FILTER_GOOD, 
        CAIRO_FILTER_BEST, 
        CAIRO_FILTER_NEAREST, 
        CAIRO_FILTER_BILINEAR, 
        CAIRO_FILTER_GAUSSIAN
    } cairo_filter_t;
    void cairo_pattern_set_filter(cairo_pattern_t * pattern, cairo_filter_t filter);
    cairo_filter_t cairo_pattern_get_filter(cairo_pattern_t * pattern);
    cairo_status_t cairo_pattern_get_rgba(cairo_pattern_t * pattern, double * red, double * green, double * blue, double * alpha);
    cairo_status_t cairo_pattern_get_surface(cairo_pattern_t * pattern, cairo_surface_t * * surface);
    cairo_status_t cairo_pattern_get_color_stop_rgba(cairo_pattern_t * pattern, int index, double * offset, double * red, double * green, double * blue, double * alpha);
    cairo_status_t cairo_pattern_get_color_stop_count(cairo_pattern_t * pattern, int * count);
    cairo_status_t cairo_pattern_get_linear_points(cairo_pattern_t * pattern, double * x0, double * y0, double * x1, double * y1);
    cairo_status_t cairo_pattern_get_radial_circles(cairo_pattern_t * pattern, double * x0, double * y0, double * r0, double * x1, double * y1, double * r1);
    void cairo_matrix_init(cairo_matrix_t * matrix, double xx, double yx, double xy, double yy, double x0, double y0);
    void cairo_matrix_init_identity(cairo_matrix_t * matrix);
    void cairo_matrix_init_translate(cairo_matrix_t * matrix, double tx, double ty);
    void cairo_matrix_init_scale(cairo_matrix_t * matrix, double sx, double sy);
    void cairo_matrix_init_rotate(cairo_matrix_t * matrix, double radians);
    void cairo_matrix_translate(cairo_matrix_t * matrix, double tx, double ty);
    void cairo_matrix_scale(cairo_matrix_t * matrix, double sx, double sy);
    void cairo_matrix_rotate(cairo_matrix_t * matrix, double radians);
    cairo_status_t cairo_matrix_invert(cairo_matrix_t * matrix);
    void cairo_matrix_multiply(cairo_matrix_t * result, const cairo_matrix_t * a, const cairo_matrix_t * b);
    void cairo_matrix_transform_distance(const cairo_matrix_t * matrix, double * dx, double * dy);
    void cairo_matrix_transform_point(const cairo_matrix_t * matrix, double * x, double * y);
    void cairo_debug_reset_static_data(void);
}
extern "C"
{
    typedef struct _PangoCoverage PangoCoverage;
    typedef enum 
    {
        PANGO_COVERAGE_NONE, 
        PANGO_COVERAGE_FALLBACK, 
        PANGO_COVERAGE_APPROXIMATE, 
        PANGO_COVERAGE_EXACT
    } PangoCoverageLevel;
    PangoCoverage * pango_coverage_new(void);
    PangoCoverage * pango_coverage_ref(PangoCoverage * coverage);
    void pango_coverage_unref(PangoCoverage * coverage);
    PangoCoverage * pango_coverage_copy(PangoCoverage * coverage);
    PangoCoverageLevel pango_coverage_get(PangoCoverage * coverage, int index_);
    void pango_coverage_set(PangoCoverage * coverage, int index_, PangoCoverageLevel level);
    void pango_coverage_max(PangoCoverage * coverage, PangoCoverage * other);
    void pango_coverage_to_bytes(PangoCoverage * coverage, guchar * * bytes, int * n_bytes);
    PangoCoverage * pango_coverage_from_bytes(guchar * bytes, int n_bytes);
}
extern "C"
{
    typedef struct _PangoLogAttr PangoLogAttr;
    typedef struct _PangoEngineLang PangoEngineLang;
    typedef struct _PangoEngineShape PangoEngineShape;
    typedef struct _PangoFont PangoFont;
    typedef struct _PangoFontMap PangoFontMap;
    typedef struct _PangoRectangle PangoRectangle;
    typedef guint32 PangoGlyph;
    int pango_units_from_double(double d) __attribute__((__const__));
    double pango_units_to_double(int i) __attribute__((__const__));
    struct _PangoRectangle
    {
            int x;
            int y;
            int width;
            int height;
    };
    void pango_extents_to_pixels(PangoRectangle * inclusive, PangoRectangle * nearest);
    typedef enum 
    {
        PANGO_DIRECTION_LTR, 
        PANGO_DIRECTION_RTL, 
        PANGO_DIRECTION_TTB_LTR, 
        PANGO_DIRECTION_TTB_RTL, 
        PANGO_DIRECTION_WEAK_LTR, 
        PANGO_DIRECTION_WEAK_RTL, 
        PANGO_DIRECTION_NEUTRAL
    } PangoDirection;
    PangoDirection pango_unichar_direction(gunichar ch) __attribute__((__const__));
    PangoDirection pango_find_base_dir(const gchar * text, gint length);
    gboolean pango_get_mirror_char(gunichar ch, gunichar * mirrored_ch);
    extern "C"
    {
        typedef enum 
        {
            PANGO_GRAVITY_SOUTH, 
            PANGO_GRAVITY_EAST, 
            PANGO_GRAVITY_NORTH, 
            PANGO_GRAVITY_WEST, 
            PANGO_GRAVITY_AUTO
        } PangoGravity;
        typedef enum 
        {
            PANGO_GRAVITY_HINT_NATURAL, 
            PANGO_GRAVITY_HINT_STRONG, 
            PANGO_GRAVITY_HINT_LINE
        } PangoGravityHint;
        extern "C"
        {
            typedef struct _PangoMatrix PangoMatrix;
            struct _PangoMatrix
            {
                    double xx;
                    double xy;
                    double yx;
                    double yy;
                    double x0;
                    double y0;
            };
            GType pango_matrix_get_type(void) __attribute__((__const__));
            PangoMatrix * pango_matrix_copy(const PangoMatrix * matrix);
            void pango_matrix_free(PangoMatrix * matrix);
            void pango_matrix_translate(PangoMatrix * matrix, double tx, double ty);
            void pango_matrix_scale(PangoMatrix * matrix, double scale_x, double scale_y);
            void pango_matrix_rotate(PangoMatrix * matrix, double degrees);
            void pango_matrix_concat(PangoMatrix * matrix, const PangoMatrix * new_matrix);
            void pango_matrix_transform_point(const PangoMatrix * matrix, double * x, double * y);
            void pango_matrix_transform_distance(const PangoMatrix * matrix, double * dx, double * dy);
            void pango_matrix_transform_rectangle(const PangoMatrix * matrix, PangoRectangle * rect);
            void pango_matrix_transform_pixel_rectangle(const PangoMatrix * matrix, PangoRectangle * rect);
            double pango_matrix_get_font_scale_factor(const PangoMatrix * matrix) __attribute__((__pure__));
        }
        extern "C"
        {
            typedef struct _PangoLanguage PangoLanguage;
            GType pango_language_get_type(void) __attribute__((__const__));
            PangoLanguage * pango_language_from_string(const char * language);
            const char * pango_language_get_sample_string(PangoLanguage * language) __attribute__((__const__));
            PangoLanguage * pango_language_get_default(void) __attribute__((__const__));
            gboolean pango_language_matches(PangoLanguage * language, const char * range_list) __attribute__((__pure__));
        }
        extern "C"
        {
            typedef struct _PangoScriptIter PangoScriptIter;
            typedef enum 
            {
                PANGO_SCRIPT_INVALID_CODE = -1, 
                PANGO_SCRIPT_COMMON = 0, 
                PANGO_SCRIPT_INHERITED, 
                PANGO_SCRIPT_ARABIC, 
                PANGO_SCRIPT_ARMENIAN, 
                PANGO_SCRIPT_BENGALI, 
                PANGO_SCRIPT_BOPOMOFO, 
                PANGO_SCRIPT_CHEROKEE, 
                PANGO_SCRIPT_COPTIC, 
                PANGO_SCRIPT_CYRILLIC, 
                PANGO_SCRIPT_DESERET, 
                PANGO_SCRIPT_DEVANAGARI, 
                PANGO_SCRIPT_ETHIOPIC, 
                PANGO_SCRIPT_GEORGIAN, 
                PANGO_SCRIPT_GOTHIC, 
                PANGO_SCRIPT_GREEK, 
                PANGO_SCRIPT_GUJARATI, 
                PANGO_SCRIPT_GURMUKHI, 
                PANGO_SCRIPT_HAN, 
                PANGO_SCRIPT_HANGUL, 
                PANGO_SCRIPT_HEBREW, 
                PANGO_SCRIPT_HIRAGANA, 
                PANGO_SCRIPT_KANNADA, 
                PANGO_SCRIPT_KATAKANA, 
                PANGO_SCRIPT_KHMER, 
                PANGO_SCRIPT_LAO, 
                PANGO_SCRIPT_LATIN, 
                PANGO_SCRIPT_MALAYALAM, 
                PANGO_SCRIPT_MONGOLIAN, 
                PANGO_SCRIPT_MYANMAR, 
                PANGO_SCRIPT_OGHAM, 
                PANGO_SCRIPT_OLD_ITALIC, 
                PANGO_SCRIPT_ORIYA, 
                PANGO_SCRIPT_RUNIC, 
                PANGO_SCRIPT_SINHALA, 
                PANGO_SCRIPT_SYRIAC, 
                PANGO_SCRIPT_TAMIL, 
                PANGO_SCRIPT_TELUGU, 
                PANGO_SCRIPT_THAANA, 
                PANGO_SCRIPT_THAI, 
                PANGO_SCRIPT_TIBETAN, 
                PANGO_SCRIPT_CANADIAN_ABORIGINAL, 
                PANGO_SCRIPT_YI, 
                PANGO_SCRIPT_TAGALOG, 
                PANGO_SCRIPT_HANUNOO, 
                PANGO_SCRIPT_BUHID, 
                PANGO_SCRIPT_TAGBANWA, 
                PANGO_SCRIPT_BRAILLE, 
                PANGO_SCRIPT_CYPRIOT, 
                PANGO_SCRIPT_LIMBU, 
                PANGO_SCRIPT_OSMANYA, 
                PANGO_SCRIPT_SHAVIAN, 
                PANGO_SCRIPT_LINEAR_B, 
                PANGO_SCRIPT_TAI_LE, 
                PANGO_SCRIPT_UGARITIC, 
                PANGO_SCRIPT_NEW_TAI_LUE, 
                PANGO_SCRIPT_BUGINESE, 
                PANGO_SCRIPT_GLAGOLITIC, 
                PANGO_SCRIPT_TIFINAGH, 
                PANGO_SCRIPT_SYLOTI_NAGRI, 
                PANGO_SCRIPT_OLD_PERSIAN, 
                PANGO_SCRIPT_KHAROSHTHI, 
                PANGO_SCRIPT_UNKNOWN, 
                PANGO_SCRIPT_BALINESE, 
                PANGO_SCRIPT_CUNEIFORM, 
                PANGO_SCRIPT_PHOENICIAN, 
                PANGO_SCRIPT_PHAGS_PA, 
                PANGO_SCRIPT_NKO, 
                PANGO_SCRIPT_KAYAH_LI, 
                PANGO_SCRIPT_LEPCHA, 
                PANGO_SCRIPT_REJANG, 
                PANGO_SCRIPT_SUNDANESE, 
                PANGO_SCRIPT_SAURASHTRA, 
                PANGO_SCRIPT_CHAM, 
                PANGO_SCRIPT_OL_CHIKI, 
                PANGO_SCRIPT_VAI, 
                PANGO_SCRIPT_CARIAN, 
                PANGO_SCRIPT_LYCIAN, 
                PANGO_SCRIPT_LYDIAN
            } PangoScript;
            PangoScript pango_script_for_unichar(gunichar ch) __attribute__((__const__));
            PangoScriptIter * pango_script_iter_new(const char * text, int length);
            void pango_script_iter_get_range(PangoScriptIter * iter, const char * * start, const char * * end, PangoScript * script);
            gboolean pango_script_iter_next(PangoScriptIter * iter);
            void pango_script_iter_free(PangoScriptIter * iter);
            PangoLanguage * pango_script_get_sample_language(PangoScript script) __attribute__((__pure__));
            gboolean pango_language_includes_script(PangoLanguage * language, PangoScript script) __attribute__((__pure__));
        }
        double pango_gravity_to_rotation(PangoGravity gravity) __attribute__((__const__));
        PangoGravity pango_gravity_get_for_matrix(const PangoMatrix * matrix) __attribute__((__pure__));
        PangoGravity pango_gravity_get_for_script(PangoScript script, PangoGravity base_gravity, PangoGravityHint hint) __attribute__((__const__));
    }
}
extern "C"
{
    typedef struct _PangoFontDescription PangoFontDescription;
    typedef struct _PangoFontMetrics PangoFontMetrics;
    typedef enum 
    {
        PANGO_STYLE_NORMAL, 
        PANGO_STYLE_OBLIQUE, 
        PANGO_STYLE_ITALIC
    } PangoStyle;
    typedef enum 
    {
        PANGO_VARIANT_NORMAL, 
        PANGO_VARIANT_SMALL_CAPS
    } PangoVariant;
    typedef enum 
    {
        PANGO_WEIGHT_ULTRALIGHT = 200, 
        PANGO_WEIGHT_LIGHT = 300, 
        PANGO_WEIGHT_NORMAL = 400, 
        PANGO_WEIGHT_SEMIBOLD = 600, 
        PANGO_WEIGHT_BOLD = 700, 
        PANGO_WEIGHT_ULTRABOLD = 800, 
        PANGO_WEIGHT_HEAVY = 900
    } PangoWeight;
    typedef enum 
    {
        PANGO_STRETCH_ULTRA_CONDENSED, 
        PANGO_STRETCH_EXTRA_CONDENSED, 
        PANGO_STRETCH_CONDENSED, 
        PANGO_STRETCH_SEMI_CONDENSED, 
        PANGO_STRETCH_NORMAL, 
        PANGO_STRETCH_SEMI_EXPANDED, 
        PANGO_STRETCH_EXPANDED, 
        PANGO_STRETCH_EXTRA_EXPANDED, 
        PANGO_STRETCH_ULTRA_EXPANDED
    } PangoStretch;
    typedef enum 
    {
        PANGO_FONT_MASK_FAMILY = 1 << 0, 
        PANGO_FONT_MASK_STYLE = 1 << 1, 
        PANGO_FONT_MASK_VARIANT = 1 << 2, 
        PANGO_FONT_MASK_WEIGHT = 1 << 3, 
        PANGO_FONT_MASK_STRETCH = 1 << 4, 
        PANGO_FONT_MASK_SIZE = 1 << 5, 
        PANGO_FONT_MASK_GRAVITY = 1 << 6
    } PangoFontMask;
    GType pango_font_description_get_type(void) __attribute__((__const__));
    PangoFontDescription * pango_font_description_new(void);
    PangoFontDescription * pango_font_description_copy(const PangoFontDescription * desc);
    PangoFontDescription * pango_font_description_copy_static(const PangoFontDescription * desc);
    guint pango_font_description_hash(const PangoFontDescription * desc) __attribute__((__pure__));
    gboolean pango_font_description_equal(const PangoFontDescription * desc1, const PangoFontDescription * desc2) __attribute__((__pure__));
    void pango_font_description_free(PangoFontDescription * desc);
    void pango_font_descriptions_free(PangoFontDescription * * descs, int n_descs);
    void pango_font_description_set_family(PangoFontDescription * desc, const char * family);
    void pango_font_description_set_family_static(PangoFontDescription * desc, const char * family);
    const char * pango_font_description_get_family(const PangoFontDescription * desc) __attribute__((__pure__));
    void pango_font_description_set_style(PangoFontDescription * desc, PangoStyle style);
    PangoStyle pango_font_description_get_style(const PangoFontDescription * desc) __attribute__((__pure__));
    void pango_font_description_set_variant(PangoFontDescription * desc, PangoVariant variant);
    PangoVariant pango_font_description_get_variant(const PangoFontDescription * desc) __attribute__((__pure__));
    void pango_font_description_set_weight(PangoFontDescription * desc, PangoWeight weight);
    PangoWeight pango_font_description_get_weight(const PangoFontDescription * desc) __attribute__((__pure__));
    void pango_font_description_set_stretch(PangoFontDescription * desc, PangoStretch stretch);
    PangoStretch pango_font_description_get_stretch(const PangoFontDescription * desc) __attribute__((__pure__));
    void pango_font_description_set_size(PangoFontDescription * desc, gint size);
    gint pango_font_description_get_size(const PangoFontDescription * desc) __attribute__((__pure__));
    void pango_font_description_set_absolute_size(PangoFontDescription * desc, double size);
    gboolean pango_font_description_get_size_is_absolute(const PangoFontDescription * desc) __attribute__((__pure__));
    void pango_font_description_set_gravity(PangoFontDescription * desc, PangoGravity gravity);
    PangoGravity pango_font_description_get_gravity(const PangoFontDescription * desc) __attribute__((__pure__));
    PangoFontMask pango_font_description_get_set_fields(const PangoFontDescription * desc) __attribute__((__pure__));
    void pango_font_description_unset_fields(PangoFontDescription * desc, PangoFontMask to_unset);
    void pango_font_description_merge(PangoFontDescription * desc, const PangoFontDescription * desc_to_merge, gboolean replace_existing);
    void pango_font_description_merge_static(PangoFontDescription * desc, const PangoFontDescription * desc_to_merge, gboolean replace_existing);
    gboolean pango_font_description_better_match(const PangoFontDescription * desc, const PangoFontDescription * old_match, const PangoFontDescription * new_match) __attribute__((__pure__));
    PangoFontDescription * pango_font_description_from_string(const char * str);
    char * pango_font_description_to_string(const PangoFontDescription * desc);
    char * pango_font_description_to_filename(const PangoFontDescription * desc);
    GType pango_font_metrics_get_type(void) __attribute__((__const__));
    PangoFontMetrics * pango_font_metrics_ref(PangoFontMetrics * metrics);
    void pango_font_metrics_unref(PangoFontMetrics * metrics);
    int pango_font_metrics_get_ascent(PangoFontMetrics * metrics) __attribute__((__pure__));
    int pango_font_metrics_get_descent(PangoFontMetrics * metrics) __attribute__((__pure__));
    int pango_font_metrics_get_approximate_char_width(PangoFontMetrics * metrics) __attribute__((__pure__));
    int pango_font_metrics_get_approximate_digit_width(PangoFontMetrics * metrics) __attribute__((__pure__));
    int pango_font_metrics_get_underline_position(PangoFontMetrics * metrics) __attribute__((__pure__));
    int pango_font_metrics_get_underline_thickness(PangoFontMetrics * metrics) __attribute__((__pure__));
    int pango_font_metrics_get_strikethrough_position(PangoFontMetrics * metrics) __attribute__((__pure__));
    int pango_font_metrics_get_strikethrough_thickness(PangoFontMetrics * metrics) __attribute__((__pure__));
    typedef struct _PangoFontFamily PangoFontFamily;
    typedef struct _PangoFontFace PangoFontFace;
    GType pango_font_family_get_type(void) __attribute__((__const__));
    void pango_font_family_list_faces(PangoFontFamily * family, PangoFontFace * * * faces, int * n_faces);
    const char * pango_font_family_get_name(PangoFontFamily * family) __attribute__((__pure__));
    gboolean pango_font_family_is_monospace(PangoFontFamily * family) __attribute__((__pure__));
    GType pango_font_face_get_type(void) __attribute__((__const__));
    PangoFontDescription * pango_font_face_describe(PangoFontFace * face);
    const char * pango_font_face_get_face_name(PangoFontFace * face) __attribute__((__pure__));
    void pango_font_face_list_sizes(PangoFontFace * face, int * * sizes, int * n_sizes);
    gboolean pango_font_face_is_synthesized(PangoFontFace * face) __attribute__((__pure__));
    GType pango_font_get_type(void) __attribute__((__const__));
    PangoFontDescription * pango_font_describe(PangoFont * font);
    PangoFontDescription * pango_font_describe_with_absolute_size(PangoFont * font);
    PangoCoverage * pango_font_get_coverage(PangoFont * font, PangoLanguage * language);
    PangoEngineShape * pango_font_find_shaper(PangoFont * font, PangoLanguage * language, guint32 ch);
    PangoFontMetrics * pango_font_get_metrics(PangoFont * font, PangoLanguage * language);
    void pango_font_get_glyph_extents(PangoFont * font, PangoGlyph glyph, PangoRectangle * ink_rect, PangoRectangle * logical_rect);
    PangoFontMap * pango_font_get_font_map(PangoFont * font);
}
extern "C"
{
    typedef struct _PangoColor PangoColor;
    struct _PangoColor
    {
            guint16 red;
            guint16 green;
            guint16 blue;
    };
    GType pango_color_get_type(void) __attribute__((__const__));
    PangoColor * pango_color_copy(const PangoColor * src);
    void pango_color_free(PangoColor * color);
    gboolean pango_color_parse(PangoColor * color, const char * spec);
    gchar * pango_color_to_string(const PangoColor * color);
    typedef struct _PangoAttribute PangoAttribute;
    typedef struct _PangoAttrClass PangoAttrClass;
    typedef struct _PangoAttrString PangoAttrString;
    typedef struct _PangoAttrLanguage PangoAttrLanguage;
    typedef struct _PangoAttrInt PangoAttrInt;
    typedef struct _PangoAttrSize PangoAttrSize;
    typedef struct _PangoAttrFloat PangoAttrFloat;
    typedef struct _PangoAttrColor PangoAttrColor;
    typedef struct _PangoAttrFontDesc PangoAttrFontDesc;
    typedef struct _PangoAttrShape PangoAttrShape;
    typedef struct _PangoAttrList PangoAttrList;
    typedef struct _PangoAttrIterator PangoAttrIterator;
    typedef enum 
    {
        PANGO_ATTR_INVALID, 
        PANGO_ATTR_LANGUAGE, 
        PANGO_ATTR_FAMILY, 
        PANGO_ATTR_STYLE, 
        PANGO_ATTR_WEIGHT, 
        PANGO_ATTR_VARIANT, 
        PANGO_ATTR_STRETCH, 
        PANGO_ATTR_SIZE, 
        PANGO_ATTR_FONT_DESC, 
        PANGO_ATTR_FOREGROUND, 
        PANGO_ATTR_BACKGROUND, 
        PANGO_ATTR_UNDERLINE, 
        PANGO_ATTR_STRIKETHROUGH, 
        PANGO_ATTR_RISE, 
        PANGO_ATTR_SHAPE, 
        PANGO_ATTR_SCALE, 
        PANGO_ATTR_FALLBACK, 
        PANGO_ATTR_LETTER_SPACING, 
        PANGO_ATTR_UNDERLINE_COLOR, 
        PANGO_ATTR_STRIKETHROUGH_COLOR, 
        PANGO_ATTR_ABSOLUTE_SIZE, 
        PANGO_ATTR_GRAVITY, 
        PANGO_ATTR_GRAVITY_HINT
    } PangoAttrType;
    typedef enum 
    {
        PANGO_UNDERLINE_NONE, 
        PANGO_UNDERLINE_SINGLE, 
        PANGO_UNDERLINE_DOUBLE, 
        PANGO_UNDERLINE_LOW, 
        PANGO_UNDERLINE_ERROR
    } PangoUnderline;
    struct _PangoAttribute
    {
            const PangoAttrClass * klass;
            guint start_index;
            guint end_index;
    };
    typedef gboolean (* PangoAttrFilterFunc)(PangoAttribute * attribute, gpointer data);
    typedef gpointer (* PangoAttrDataCopyFunc)(gconstpointer data);
    struct _PangoAttrClass
    {
            PangoAttrType type;
            PangoAttribute * (* copy)(const PangoAttribute * attr);
            void (* destroy)(PangoAttribute * attr);
            gboolean (* equal)(const PangoAttribute * attr1, const PangoAttribute * attr2);
    };
    struct _PangoAttrString
    {
            PangoAttribute attr;
            char * value;
    };
    struct _PangoAttrLanguage
    {
            PangoAttribute attr;
            PangoLanguage * value;
    };
    struct _PangoAttrInt
    {
            PangoAttribute attr;
            int value;
    };
    struct _PangoAttrFloat
    {
            PangoAttribute attr;
            double value;
    };
    struct _PangoAttrColor
    {
            PangoAttribute attr;
            PangoColor color;
    };
    struct _PangoAttrSize
    {
            PangoAttribute attr;
            int size;
            guint absolute : 1;
    };
    struct _PangoAttrShape
    {
            PangoAttribute attr;
            PangoRectangle ink_rect;
            PangoRectangle logical_rect;
            gpointer data;
            PangoAttrDataCopyFunc copy_func;
            GDestroyNotify destroy_func;
    };
    struct _PangoAttrFontDesc
    {
            PangoAttribute attr;
            PangoFontDescription * desc;
    };
    PangoAttrType pango_attr_type_register(const gchar * name);
    void pango_attribute_init(PangoAttribute * attr, const PangoAttrClass * klass);
    PangoAttribute * pango_attribute_copy(const PangoAttribute * attr);
    void pango_attribute_destroy(PangoAttribute * attr);
    gboolean pango_attribute_equal(const PangoAttribute * attr1, const PangoAttribute * attr2) __attribute__((__pure__));
    PangoAttribute * pango_attr_language_new(PangoLanguage * language);
    PangoAttribute * pango_attr_family_new(const char * family);
    PangoAttribute * pango_attr_foreground_new(guint16 red, guint16 green, guint16 blue);
    PangoAttribute * pango_attr_background_new(guint16 red, guint16 green, guint16 blue);
    PangoAttribute * pango_attr_size_new(int size);
    PangoAttribute * pango_attr_size_new_absolute(int size);
    PangoAttribute * pango_attr_style_new(PangoStyle style);
    PangoAttribute * pango_attr_weight_new(PangoWeight weight);
    PangoAttribute * pango_attr_variant_new(PangoVariant variant);
    PangoAttribute * pango_attr_stretch_new(PangoStretch stretch);
    PangoAttribute * pango_attr_font_desc_new(const PangoFontDescription * desc);
    PangoAttribute * pango_attr_underline_new(PangoUnderline underline);
    PangoAttribute * pango_attr_underline_color_new(guint16 red, guint16 green, guint16 blue);
    PangoAttribute * pango_attr_strikethrough_new(gboolean strikethrough);
    PangoAttribute * pango_attr_strikethrough_color_new(guint16 red, guint16 green, guint16 blue);
    PangoAttribute * pango_attr_rise_new(int rise);
    PangoAttribute * pango_attr_scale_new(double scale_factor);
    PangoAttribute * pango_attr_fallback_new(gboolean enable_fallback);
    PangoAttribute * pango_attr_letter_spacing_new(int letter_spacing);
    PangoAttribute * pango_attr_shape_new(const PangoRectangle * ink_rect, const PangoRectangle * logical_rect);
    PangoAttribute * pango_attr_shape_new_with_data(const PangoRectangle * ink_rect, const PangoRectangle * logical_rect, gpointer data, PangoAttrDataCopyFunc copy_func, GDestroyNotify destroy_func);
    PangoAttribute * pango_attr_gravity_new(PangoGravity gravity);
    PangoAttribute * pango_attr_gravity_hint_new(PangoGravityHint hint);
    GType pango_attr_list_get_type(void) __attribute__((__const__));
    PangoAttrList * pango_attr_list_new(void);
    PangoAttrList * pango_attr_list_ref(PangoAttrList * list);
    void pango_attr_list_unref(PangoAttrList * list);
    PangoAttrList * pango_attr_list_copy(PangoAttrList * list);
    void pango_attr_list_insert(PangoAttrList * list, PangoAttribute * attr);
    void pango_attr_list_insert_before(PangoAttrList * list, PangoAttribute * attr);
    void pango_attr_list_change(PangoAttrList * list, PangoAttribute * attr);
    void pango_attr_list_splice(PangoAttrList * list, PangoAttrList * other, gint pos, gint len);
    PangoAttrList * pango_attr_list_filter(PangoAttrList * list, PangoAttrFilterFunc func, gpointer data);
    PangoAttrIterator * pango_attr_list_get_iterator(PangoAttrList * list);
    void pango_attr_iterator_range(PangoAttrIterator * iterator, gint * start, gint * end);
    gboolean pango_attr_iterator_next(PangoAttrIterator * iterator);
    PangoAttrIterator * pango_attr_iterator_copy(PangoAttrIterator * iterator);
    void pango_attr_iterator_destroy(PangoAttrIterator * iterator);
    PangoAttribute * pango_attr_iterator_get(PangoAttrIterator * iterator, PangoAttrType type);
    void pango_attr_iterator_get_font(PangoAttrIterator * iterator, PangoFontDescription * desc, PangoLanguage * * language, GSList * * extra_attrs);
    GSList * pango_attr_iterator_get_attrs(PangoAttrIterator * iterator);
    gboolean pango_parse_markup(const char * markup_text, int length, gunichar accel_marker, PangoAttrList * * attr_list, char * * text, gunichar * accel_char, GError * * error);
}
extern "C"
{
    extern "C"
    {
        typedef struct _PangoAnalysis PangoAnalysis;
        typedef struct _PangoItem PangoItem;
        struct _PangoAnalysis
        {
                PangoEngineShape * shape_engine;
                PangoEngineLang * lang_engine;
                PangoFont * font;
                guint8 level;
                guint8 gravity;
                guint8 flags;
                guint8 script;
                PangoLanguage * language;
                GSList * extra_attrs;
        };
        struct _PangoItem
        {
                gint offset;
                gint length;
                gint num_chars;
                PangoAnalysis analysis;
        };
        GType pango_item_get_type(void) __attribute__((__const__));
        PangoItem * pango_item_new(void);
        PangoItem * pango_item_copy(PangoItem * item);
        void pango_item_free(PangoItem * item);
        PangoItem * pango_item_split(PangoItem * orig, int split_index, int split_offset);
    }
    struct _PangoLogAttr
    {
            guint is_line_break : 1;
            guint is_mandatory_break : 1;
            guint is_char_break : 1;
            guint is_white : 1;
            guint is_cursor_position : 1;
            guint is_word_start : 1;
            guint is_word_end : 1;
            guint is_sentence_boundary : 1;
            guint is_sentence_start : 1;
            guint is_sentence_end : 1;
            guint backspace_deletes_character : 1;
            guint is_expandable_space : 1;
    };
    void pango_break(const gchar * text, int length, PangoAnalysis * analysis, PangoLogAttr * attrs, int attrs_len);
    void pango_find_paragraph_boundary(const gchar * text, gint length, gint * paragraph_delimiter_index, gint * next_paragraph_start);
    void pango_get_log_attrs(const char * text, int length, int level, PangoLanguage * language, PangoLogAttr * log_attrs, int attrs_len);
}
extern "C"
{
    GType pango_fontset_get_type(void) __attribute__((__const__));
    typedef struct _PangoFontset PangoFontset;
    typedef gboolean (* PangoFontsetForeachFunc)(PangoFontset * fontset, PangoFont * font, gpointer data);
    PangoFont * pango_fontset_get_font(PangoFontset * fontset, guint wc);
    PangoFontMetrics * pango_fontset_get_metrics(PangoFontset * fontset);
    void pango_fontset_foreach(PangoFontset * fontset, PangoFontsetForeachFunc func, gpointer data);
}
extern "C"
{
    typedef struct _PangoContext PangoContext;
    GType pango_font_map_get_type(void) __attribute__((__const__));
    PangoFont * pango_font_map_load_font(PangoFontMap * fontmap, PangoContext * context, const PangoFontDescription * desc);
    PangoFontset * pango_font_map_load_fontset(PangoFontMap * fontmap, PangoContext * context, const PangoFontDescription * desc, PangoLanguage * language);
    void pango_font_map_list_families(PangoFontMap * fontmap, PangoFontFamily * * * families, int * n_families);
}
extern "C"
{
    typedef struct _PangoContextClass PangoContextClass;
    GType pango_context_get_type(void) __attribute__((__const__));
    PangoFontMap * pango_context_get_font_map(PangoContext * context);
    void pango_context_list_families(PangoContext * context, PangoFontFamily * * * families, int * n_families);
    PangoFont * pango_context_load_font(PangoContext * context, const PangoFontDescription * desc);
    PangoFontset * pango_context_load_fontset(PangoContext * context, const PangoFontDescription * desc, PangoLanguage * language);
    PangoFontMetrics * pango_context_get_metrics(PangoContext * context, const PangoFontDescription * desc, PangoLanguage * language);
    void pango_context_set_font_description(PangoContext * context, const PangoFontDescription * desc);
    PangoFontDescription * pango_context_get_font_description(PangoContext * context);
    PangoLanguage * pango_context_get_language(PangoContext * context);
    void pango_context_set_language(PangoContext * context, PangoLanguage * language);
    void pango_context_set_base_dir(PangoContext * context, PangoDirection direction);
    PangoDirection pango_context_get_base_dir(PangoContext * context);
    void pango_context_set_base_gravity(PangoContext * context, PangoGravity gravity);
    PangoGravity pango_context_get_base_gravity(PangoContext * context);
    PangoGravity pango_context_get_gravity(PangoContext * context);
    void pango_context_set_gravity_hint(PangoContext * context, PangoGravityHint hint);
    PangoGravityHint pango_context_get_gravity_hint(PangoContext * context);
    void pango_context_set_matrix(PangoContext * context, const PangoMatrix * matrix);
    const PangoMatrix * pango_context_get_matrix(PangoContext * context);
    GList * pango_itemize(PangoContext * context, const char * text, int start_index, int length, PangoAttrList * attrs, PangoAttrIterator * cached_iter);
    GList * pango_itemize_with_base_dir(PangoContext * context, PangoDirection base_dir, const char * text, int start_index, int length, PangoAttrList * attrs, PangoAttrIterator * cached_iter);
}
extern "C"
{
    typedef struct _PangoGlyphGeometry PangoGlyphGeometry;
    typedef struct _PangoGlyphVisAttr PangoGlyphVisAttr;
    typedef struct _PangoGlyphInfo PangoGlyphInfo;
    typedef struct _PangoGlyphString PangoGlyphString;
    typedef gint32 PangoGlyphUnit;
    struct _PangoGlyphGeometry
    {
            PangoGlyphUnit width;
            PangoGlyphUnit x_offset;
            PangoGlyphUnit y_offset;
    };
    struct _PangoGlyphVisAttr
    {
            guint is_cluster_start : 1;
    };
    struct _PangoGlyphInfo
    {
            PangoGlyph glyph;
            PangoGlyphGeometry geometry;
            PangoGlyphVisAttr attr;
    };
    struct _PangoGlyphString
    {
            gint num_glyphs;
            PangoGlyphInfo * glyphs;
            gint * log_clusters;
            gint space;
    };
    PangoGlyphString * pango_glyph_string_new(void);
    void pango_glyph_string_set_size(PangoGlyphString * string, gint new_len);
    GType pango_glyph_string_get_type(void) __attribute__((__const__));
    PangoGlyphString * pango_glyph_string_copy(PangoGlyphString * string);
    void pango_glyph_string_free(PangoGlyphString * string);
    void pango_glyph_string_extents(PangoGlyphString * glyphs, PangoFont * font, PangoRectangle * ink_rect, PangoRectangle * logical_rect);
    int pango_glyph_string_get_width(PangoGlyphString * glyphs) __attribute__((__pure__));
    void pango_glyph_string_extents_range(PangoGlyphString * glyphs, int start, int end, PangoFont * font, PangoRectangle * ink_rect, PangoRectangle * logical_rect);
    void pango_glyph_string_get_logical_widths(PangoGlyphString * glyphs, const char * text, int length, int embedding_level, int * logical_widths);
    void pango_glyph_string_index_to_x(PangoGlyphString * glyphs, char * text, int length, PangoAnalysis * analysis, int index_, gboolean trailing, int * x_pos);
    void pango_glyph_string_x_to_index(PangoGlyphString * glyphs, char * text, int length, PangoAnalysis * analysis, int x_pos, int * index_, int * trailing);
    void pango_shape(const gchar * text, gint length, const PangoAnalysis * analysis, PangoGlyphString * glyphs);
    GList * pango_reorder_items(GList * logical_items);
}
extern "C"
{
}
extern "C"
{
    GType pango_attr_type_get_type(void);
    GType pango_underline_get_type(void);
    GType pango_coverage_level_get_type(void);
    GType pango_style_get_type(void);
    GType pango_variant_get_type(void);
    GType pango_weight_get_type(void);
    GType pango_stretch_get_type(void);
    GType pango_font_mask_get_type(void);
    GType pango_gravity_get_type(void);
    GType pango_gravity_hint_get_type(void);
    GType pango_alignment_get_type(void);
    GType pango_wrap_mode_get_type(void);
    GType pango_ellipsize_mode_get_type(void);
    GType pango_render_part_get_type(void);
    GType pango_script_get_type(void);
    GType pango_tab_align_get_type(void);
    GType pango_direction_get_type(void);
}
extern "C"
{
    typedef struct _PangoGlyphItem PangoGlyphItem;
    struct _PangoGlyphItem
    {
            PangoItem * item;
            PangoGlyphString * glyphs;
    };
    GType pango_glyph_item_get_type(void) __attribute__((__const__));
    PangoGlyphItem * pango_glyph_item_split(PangoGlyphItem * orig, const char * text, int split_index);
    PangoGlyphItem * pango_glyph_item_copy(PangoGlyphItem * orig);
    void pango_glyph_item_free(PangoGlyphItem * glyph_item);
    GSList * pango_glyph_item_apply_attrs(PangoGlyphItem * glyph_item, const char * text, PangoAttrList * list);
    void pango_glyph_item_letter_space(PangoGlyphItem * glyph_item, const char * text, PangoLogAttr * log_attrs, int letter_spacing);
}
extern "C"
{
    typedef struct _PangoTabArray PangoTabArray;
    typedef enum 
    {
        PANGO_TAB_LEFT
    } PangoTabAlign;
    PangoTabArray * pango_tab_array_new(gint initial_size, gboolean positions_in_pixels);
    PangoTabArray * pango_tab_array_new_with_positions(gint size, gboolean positions_in_pixels, PangoTabAlign first_alignment, gint first_position, ...);
    GType pango_tab_array_get_type(void) __attribute__((__const__));
    PangoTabArray * pango_tab_array_copy(PangoTabArray * src);
    void pango_tab_array_free(PangoTabArray * tab_array);
    gint pango_tab_array_get_size(PangoTabArray * tab_array);
    void pango_tab_array_resize(PangoTabArray * tab_array, gint new_size);
    void pango_tab_array_set_tab(PangoTabArray * tab_array, gint tab_index, PangoTabAlign alignment, gint location);
    void pango_tab_array_get_tab(PangoTabArray * tab_array, gint tab_index, PangoTabAlign * alignment, gint * location);
    void pango_tab_array_get_tabs(PangoTabArray * tab_array, PangoTabAlign * * alignments, gint * * locations);
    gboolean pango_tab_array_get_positions_in_pixels(PangoTabArray * tab_array);
}
extern "C"
{
    typedef struct _PangoLayout PangoLayout;
    typedef struct _PangoLayoutClass PangoLayoutClass;
    typedef struct _PangoLayoutLine PangoLayoutLine;
    typedef PangoGlyphItem PangoLayoutRun;
    typedef enum 
    {
        PANGO_ALIGN_LEFT, 
        PANGO_ALIGN_CENTER, 
        PANGO_ALIGN_RIGHT
    } PangoAlignment;
    typedef enum 
    {
        PANGO_WRAP_WORD, 
        PANGO_WRAP_CHAR, 
        PANGO_WRAP_WORD_CHAR
    } PangoWrapMode;
    typedef enum 
    {
        PANGO_ELLIPSIZE_NONE, 
        PANGO_ELLIPSIZE_START, 
        PANGO_ELLIPSIZE_MIDDLE, 
        PANGO_ELLIPSIZE_END
    } PangoEllipsizeMode;
    struct _PangoLayoutLine
    {
            PangoLayout * layout;
            gint start_index;
            gint length;
            GSList * runs;
            guint is_paragraph_start : 1;
            guint resolved_dir : 3;
    };
    GType pango_layout_get_type(void) __attribute__((__const__));
    PangoLayout * pango_layout_new(PangoContext * context);
    PangoLayout * pango_layout_copy(PangoLayout * src);
    PangoContext * pango_layout_get_context(PangoLayout * layout);
    void pango_layout_set_attributes(PangoLayout * layout, PangoAttrList * attrs);
    PangoAttrList * pango_layout_get_attributes(PangoLayout * layout);
    void pango_layout_set_text(PangoLayout * layout, const char * text, int length);
    const char * pango_layout_get_text(PangoLayout * layout);
    void pango_layout_set_markup(PangoLayout * layout, const char * markup, int length);
    void pango_layout_set_markup_with_accel(PangoLayout * layout, const char * markup, int length, gunichar accel_marker, gunichar * accel_char);
    void pango_layout_set_font_description(PangoLayout * layout, const PangoFontDescription * desc);
    const PangoFontDescription * pango_layout_get_font_description(PangoLayout * layout);
    void pango_layout_set_width(PangoLayout * layout, int width);
    int pango_layout_get_width(PangoLayout * layout);
    void pango_layout_set_height(PangoLayout * layout, int height);
    int pango_layout_get_height(PangoLayout * layout);
    void pango_layout_set_wrap(PangoLayout * layout, PangoWrapMode wrap);
    PangoWrapMode pango_layout_get_wrap(PangoLayout * layout);
    gboolean pango_layout_is_wrapped(PangoLayout * layout);
    void pango_layout_set_indent(PangoLayout * layout, int indent);
    int pango_layout_get_indent(PangoLayout * layout);
    void pango_layout_set_spacing(PangoLayout * layout, int spacing);
    int pango_layout_get_spacing(PangoLayout * layout);
    void pango_layout_set_justify(PangoLayout * layout, gboolean justify);
    gboolean pango_layout_get_justify(PangoLayout * layout);
    void pango_layout_set_auto_dir(PangoLayout * layout, gboolean auto_dir);
    gboolean pango_layout_get_auto_dir(PangoLayout * layout);
    void pango_layout_set_alignment(PangoLayout * layout, PangoAlignment alignment);
    PangoAlignment pango_layout_get_alignment(PangoLayout * layout);
    void pango_layout_set_tabs(PangoLayout * layout, PangoTabArray * tabs);
    PangoTabArray * pango_layout_get_tabs(PangoLayout * layout);
    void pango_layout_set_single_paragraph_mode(PangoLayout * layout, gboolean setting);
    gboolean pango_layout_get_single_paragraph_mode(PangoLayout * layout);
    void pango_layout_set_ellipsize(PangoLayout * layout, PangoEllipsizeMode ellipsize);
    PangoEllipsizeMode pango_layout_get_ellipsize(PangoLayout * layout);
    gboolean pango_layout_is_ellipsized(PangoLayout * layout);
    int pango_layout_get_unknown_glyphs_count(PangoLayout * layout);
    void pango_layout_context_changed(PangoLayout * layout);
    void pango_layout_get_log_attrs(PangoLayout * layout, PangoLogAttr * * attrs, gint * n_attrs);
    void pango_layout_index_to_pos(PangoLayout * layout, int index_, PangoRectangle * pos);
    void pango_layout_index_to_line_x(PangoLayout * layout, int index_, gboolean trailing, int * line, int * x_pos);
    void pango_layout_get_cursor_pos(PangoLayout * layout, int index_, PangoRectangle * strong_pos, PangoRectangle * weak_pos);
    void pango_layout_move_cursor_visually(PangoLayout * layout, gboolean strong, int old_index, int old_trailing, int direction, int * new_index, int * new_trailing);
    gboolean pango_layout_xy_to_index(PangoLayout * layout, int x, int y, int * index_, int * trailing);
    void pango_layout_get_extents(PangoLayout * layout, PangoRectangle * ink_rect, PangoRectangle * logical_rect);
    void pango_layout_get_pixel_extents(PangoLayout * layout, PangoRectangle * ink_rect, PangoRectangle * logical_rect);
    void pango_layout_get_size(PangoLayout * layout, int * width, int * height);
    void pango_layout_get_pixel_size(PangoLayout * layout, int * width, int * height);
    int pango_layout_get_line_count(PangoLayout * layout);
    PangoLayoutLine * pango_layout_get_line(PangoLayout * layout, int line);
    PangoLayoutLine * pango_layout_get_line_readonly(PangoLayout * layout, int line);
    GSList * pango_layout_get_lines(PangoLayout * layout);
    GSList * pango_layout_get_lines_readonly(PangoLayout * layout);
    GType pango_layout_line_get_type(void) __attribute__((__const__));
    PangoLayoutLine * pango_layout_line_ref(PangoLayoutLine * line);
    void pango_layout_line_unref(PangoLayoutLine * line);
    gboolean pango_layout_line_x_to_index(PangoLayoutLine * line, int x_pos, int * index_, int * trailing);
    void pango_layout_line_index_to_x(PangoLayoutLine * line, int index_, gboolean trailing, int * x_pos);
    void pango_layout_line_get_x_ranges(PangoLayoutLine * line, int start_index, int end_index, int * * ranges, int * n_ranges);
    void pango_layout_line_get_extents(PangoLayoutLine * line, PangoRectangle * ink_rect, PangoRectangle * logical_rect);
    void pango_layout_line_get_pixel_extents(PangoLayoutLine * layout_line, PangoRectangle * ink_rect, PangoRectangle * logical_rect);
    typedef struct _PangoLayoutIter PangoLayoutIter;
    GType pango_layout_iter_get_type(void) __attribute__((__const__));
    PangoLayoutIter * pango_layout_get_iter(PangoLayout * layout);
    PangoLayoutIter * pango_layout_iter_copy(PangoLayoutIter * iter);
    void pango_layout_iter_free(PangoLayoutIter * iter);
    int pango_layout_iter_get_index(PangoLayoutIter * iter);
    PangoLayoutRun * pango_layout_iter_get_run(PangoLayoutIter * iter);
    PangoLayoutRun * pango_layout_iter_get_run_readonly(PangoLayoutIter * iter);
    PangoLayoutLine * pango_layout_iter_get_line(PangoLayoutIter * iter);
    PangoLayoutLine * pango_layout_iter_get_line_readonly(PangoLayoutIter * iter);
    gboolean pango_layout_iter_at_last_line(PangoLayoutIter * iter);
    PangoLayout * pango_layout_iter_get_layout(PangoLayoutIter * iter);
    gboolean pango_layout_iter_next_char(PangoLayoutIter * iter);
    gboolean pango_layout_iter_next_cluster(PangoLayoutIter * iter);
    gboolean pango_layout_iter_next_run(PangoLayoutIter * iter);
    gboolean pango_layout_iter_next_line(PangoLayoutIter * iter);
    void pango_layout_iter_get_char_extents(PangoLayoutIter * iter, PangoRectangle * logical_rect);
    void pango_layout_iter_get_cluster_extents(PangoLayoutIter * iter, PangoRectangle * ink_rect, PangoRectangle * logical_rect);
    void pango_layout_iter_get_run_extents(PangoLayoutIter * iter, PangoRectangle * ink_rect, PangoRectangle * logical_rect);
    void pango_layout_iter_get_line_extents(PangoLayoutIter * iter, PangoRectangle * ink_rect, PangoRectangle * logical_rect);
    void pango_layout_iter_get_line_yrange(PangoLayoutIter * iter, int * y0_, int * y1_);
    void pango_layout_iter_get_layout_extents(PangoLayoutIter * iter, PangoRectangle * ink_rect, PangoRectangle * logical_rect);
    int pango_layout_iter_get_baseline(PangoLayoutIter * iter);
}
extern "C"
{
    typedef struct _PangoRenderer PangoRenderer;
    typedef struct _PangoRendererClass PangoRendererClass;
    typedef struct _PangoRendererPrivate PangoRendererPrivate;
    typedef enum 
    {
        PANGO_RENDER_PART_FOREGROUND, 
        PANGO_RENDER_PART_BACKGROUND, 
        PANGO_RENDER_PART_UNDERLINE, 
        PANGO_RENDER_PART_STRIKETHROUGH
    } PangoRenderPart;
    struct _PangoRenderer
    {
            GObject parent_instance;
            PangoUnderline underline;
            gboolean strikethrough;
            int active_count;
            PangoMatrix * matrix;
            PangoRendererPrivate * priv;
    };
    struct _PangoRendererClass
    {
            GObjectClass parent_class;
            void (* draw_glyphs)(PangoRenderer * renderer, PangoFont * font, PangoGlyphString * glyphs, int x, int y);
            void (* draw_rectangle)(PangoRenderer * renderer, PangoRenderPart part, int x, int y, int width, int height);
            void (* draw_error_underline)(PangoRenderer * renderer, int x, int y, int width, int height);
            void (* draw_shape)(PangoRenderer * renderer, PangoAttrShape * attr, int x, int y);
            void (* draw_trapezoid)(PangoRenderer * renderer, PangoRenderPart part, double y1_, double x11, double x21, double y2, double x12, double x22);
            void (* draw_glyph)(PangoRenderer * renderer, PangoFont * font, PangoGlyph glyph, double x, double y);
            void (* part_changed)(PangoRenderer * renderer, PangoRenderPart part);
            void (* begin)(PangoRenderer * renderer);
            void (* end)(PangoRenderer * renderer);
            void (* prepare_run)(PangoRenderer * renderer, PangoLayoutRun * run);
            void (* _pango_reserved1)(void);
            void (* _pango_reserved2)(void);
            void (* _pango_reserved3)(void);
            void (* _pango_reserved4)(void);
    };
    GType pango_renderer_get_type(void) __attribute__((__const__));
    void pango_renderer_draw_layout(PangoRenderer * renderer, PangoLayout * layout, int x, int y);
    void pango_renderer_draw_layout_line(PangoRenderer * renderer, PangoLayoutLine * line, int x, int y);
    void pango_renderer_draw_glyphs(PangoRenderer * renderer, PangoFont * font, PangoGlyphString * glyphs, int x, int y);
    void pango_renderer_draw_rectangle(PangoRenderer * renderer, PangoRenderPart part, int x, int y, int width, int height);
    void pango_renderer_draw_error_underline(PangoRenderer * renderer, int x, int y, int width, int height);
    void pango_renderer_draw_trapezoid(PangoRenderer * renderer, PangoRenderPart part, double y1_, double x11, double x21, double y2, double x12, double x22);
    void pango_renderer_draw_glyph(PangoRenderer * renderer, PangoFont * font, PangoGlyph glyph, double x, double y);
    void pango_renderer_activate(PangoRenderer * renderer);
    void pango_renderer_deactivate(PangoRenderer * renderer);
    void pango_renderer_part_changed(PangoRenderer * renderer, PangoRenderPart part);
    void pango_renderer_set_color(PangoRenderer * renderer, PangoRenderPart part, const PangoColor * color);
    PangoColor * pango_renderer_get_color(PangoRenderer * renderer, PangoRenderPart part);
    void pango_renderer_set_matrix(PangoRenderer * renderer, const PangoMatrix * matrix);
    const PangoMatrix * pango_renderer_get_matrix(PangoRenderer * renderer);
    PangoLayout * pango_renderer_get_layout(PangoRenderer * renderer);
    PangoLayoutLine * pango_renderer_get_layout_line(PangoRenderer * renderer);
}
extern "C"
{
    char * * pango_split_file_list(const char * str);
    char * pango_trim_string(const char * str);
    gint pango_read_line(FILE * stream, GString * str);
    gboolean pango_skip_space(const char * * pos);
    gboolean pango_scan_word(const char * * pos, GString * out);
    gboolean pango_scan_string(const char * * pos, GString * out);
    gboolean pango_scan_int(const char * * pos, int * out);
    gboolean pango_parse_enum(GType type, const char * str, int * value, gboolean warn, char * * possible_values);
    gboolean pango_parse_style(const char * str, PangoStyle * style, gboolean warn);
    gboolean pango_parse_variant(const char * str, PangoVariant * variant, gboolean warn);
    gboolean pango_parse_weight(const char * str, PangoWeight * weight, gboolean warn);
    gboolean pango_parse_stretch(const char * str, PangoStretch * stretch, gboolean warn);
    void pango_quantize_line_geometry(int * thickness, int * position);
    guint8 * pango_log2vis_get_embedding_levels(const gchar * text, int length, PangoDirection * pbase_dir);
    gboolean pango_is_zero_width(gunichar ch) __attribute__((__const__));
    int pango_version(void) __attribute__((__const__));
    const char * pango_version_string(void) __attribute__((__const__));
    const char * pango_version_check(int required_major, int required_minor, int required_micro) __attribute__((__const__));
}
extern "C"
{
}
extern "C"
{
    typedef struct _GdkPoint GdkPoint;
    typedef struct _GdkRectangle GdkRectangle;
    typedef struct _GdkSegment GdkSegment;
    typedef struct _GdkSpan GdkSpan;
    typedef guint32 GdkWChar;
    typedef struct _GdkAtom * GdkAtom;
    typedef guint32 GdkNativeWindow;
    typedef struct _GdkColor GdkColor;
    typedef struct _GdkColormap GdkColormap;
    typedef struct _GdkCursor GdkCursor;
    typedef struct _GdkFont GdkFont;
    typedef struct _GdkGC GdkGC;
    typedef struct _GdkImage GdkImage;
    typedef struct _GdkRegion GdkRegion;
    typedef struct _GdkVisual GdkVisual;
    typedef struct _GdkDrawable GdkDrawable;
    typedef struct _GdkDrawable GdkBitmap;
    typedef struct _GdkDrawable GdkPixmap;
    typedef struct _GdkDrawable GdkWindow;
    typedef struct _GdkDisplay GdkDisplay;
    typedef struct _GdkScreen GdkScreen;
    typedef enum 
    {
        GDK_LSB_FIRST, 
        GDK_MSB_FIRST
    } GdkByteOrder;
    typedef enum 
    {
        GDK_SHIFT_MASK = 1 << 0, 
        GDK_LOCK_MASK = 1 << 1, 
        GDK_CONTROL_MASK = 1 << 2, 
        GDK_MOD1_MASK = 1 << 3, 
        GDK_MOD2_MASK = 1 << 4, 
        GDK_MOD3_MASK = 1 << 5, 
        GDK_MOD4_MASK = 1 << 6, 
        GDK_MOD5_MASK = 1 << 7, 
        GDK_BUTTON1_MASK = 1 << 8, 
        GDK_BUTTON2_MASK = 1 << 9, 
        GDK_BUTTON3_MASK = 1 << 10, 
        GDK_BUTTON4_MASK = 1 << 11, 
        GDK_BUTTON5_MASK = 1 << 12, 
        GDK_SUPER_MASK = 1 << 26, 
        GDK_HYPER_MASK = 1 << 27, 
        GDK_META_MASK = 1 << 28, 
        GDK_RELEASE_MASK = 1 << 30, 
        GDK_MODIFIER_MASK = 0x5c001fff
    } GdkModifierType;
    typedef enum 
    {
        GDK_INPUT_READ = 1 << 0, 
        GDK_INPUT_WRITE = 1 << 1, 
        GDK_INPUT_EXCEPTION = 1 << 2
    } GdkInputCondition;
    typedef enum 
    {
        GDK_OK = 0, 
        GDK_ERROR = -1, 
        GDK_ERROR_PARAM = -2, 
        GDK_ERROR_FILE = -3, 
        GDK_ERROR_MEM = -4
    } GdkStatus;
    typedef enum 
    {
        GDK_GRAB_SUCCESS = 0, 
        GDK_GRAB_ALREADY_GRABBED = 1, 
        GDK_GRAB_INVALID_TIME = 2, 
        GDK_GRAB_NOT_VIEWABLE = 3, 
        GDK_GRAB_FROZEN = 4
    } GdkGrabStatus;
    typedef void (* GdkInputFunction)(gpointer data, gint source, GdkInputCondition condition);
    typedef void (* GdkDestroyNotify)(gpointer data);
    struct _GdkPoint
    {
            gint x;
            gint y;
    };
    struct _GdkRectangle
    {
            gint x;
            gint y;
            gint width;
            gint height;
    };
    struct _GdkSegment
    {
            gint x1;
            gint y1;
            gint x2;
            gint y2;
    };
    struct _GdkSpan
    {
            gint x;
            gint y;
            gint width;
    };
}
extern "C"
{
    struct _GdkColor
    {
            guint32 pixel;
            guint16 red;
            guint16 green;
            guint16 blue;
    };
    typedef struct _GdkColormapClass GdkColormapClass;
    struct _GdkColormap
    {
            GObject parent_instance;
            gint size;
            GdkColor * colors;
            GdkVisual * visual;
            gpointer windowing_data;
    };
    struct _GdkColormapClass
    {
            GObjectClass parent_class;
    };
    GType gdk_colormap_get_type(void) __attribute__((__const__));
    GdkColormap * gdk_colormap_new(GdkVisual * visual, gboolean allocate);
    GdkColormap * gdk_colormap_ref(GdkColormap * cmap);
    void gdk_colormap_unref(GdkColormap * cmap);
    GdkColormap * gdk_colormap_get_system(void);
    GdkScreen * gdk_colormap_get_screen(GdkColormap * cmap);
    gint gdk_colormap_get_system_size(void);
    void gdk_colormap_change(GdkColormap * colormap, gint ncolors);
    gint gdk_colormap_alloc_colors(GdkColormap * colormap, GdkColor * colors, gint ncolors, gboolean writeable, gboolean best_match, gboolean * success);
    gboolean gdk_colormap_alloc_color(GdkColormap * colormap, GdkColor * color, gboolean writeable, gboolean best_match);
    void gdk_colormap_free_colors(GdkColormap * colormap, GdkColor * colors, gint ncolors);
    void gdk_colormap_query_color(GdkColormap * colormap, gulong pixel, GdkColor * result);
    GdkVisual * gdk_colormap_get_visual(GdkColormap * colormap);
    GdkColor * gdk_color_copy(const GdkColor * color);
    void gdk_color_free(GdkColor * color);
    gboolean gdk_color_parse(const gchar * spec, GdkColor * color);
    guint gdk_color_hash(const GdkColor * colora);
    gboolean gdk_color_equal(const GdkColor * colora, const GdkColor * colorb);
    gchar * gdk_color_to_string(const GdkColor * color);
    GType gdk_color_get_type(void) __attribute__((__const__));
    void gdk_colors_store(GdkColormap * colormap, GdkColor * colors, gint ncolors);
    gint gdk_color_white(GdkColormap * colormap, GdkColor * color);
    gint gdk_color_black(GdkColormap * colormap, GdkColor * color);
    gint gdk_color_alloc(GdkColormap * colormap, GdkColor * color);
    gint gdk_color_change(GdkColormap * colormap, GdkColor * color);
    gint gdk_colors_alloc(GdkColormap * colormap, gboolean contiguous, gulong * planes, gint nplanes, gulong * pixels, gint npixels);
    void gdk_colors_free(GdkColormap * colormap, gulong * pixels, gint npixels, gulong planes);
}
extern "C"
{
    typedef struct _GdkRgbCmap GdkRgbCmap;
    struct _GdkRgbCmap
    {
            guint32 colors[256];
            gint n_colors;
            GSList * info_list;
    };
    void gdk_rgb_init(void);
    gulong gdk_rgb_xpixel_from_rgb(guint32 rgb) __attribute__((__const__));
    void gdk_rgb_gc_set_foreground(GdkGC * gc, guint32 rgb);
    void gdk_rgb_gc_set_background(GdkGC * gc, guint32 rgb);
    void gdk_rgb_find_color(GdkColormap * colormap, GdkColor * color);
    typedef enum 
    {
        GDK_RGB_DITHER_NONE, 
        GDK_RGB_DITHER_NORMAL, 
        GDK_RGB_DITHER_MAX
    } GdkRgbDither;
    void gdk_draw_rgb_image(GdkDrawable * drawable, GdkGC * gc, gint x, gint y, gint width, gint height, GdkRgbDither dith, guchar * rgb_buf, gint rowstride);
    void gdk_draw_rgb_image_dithalign(GdkDrawable * drawable, GdkGC * gc, gint x, gint y, gint width, gint height, GdkRgbDither dith, guchar * rgb_buf, gint rowstride, gint xdith, gint ydith);
    void gdk_draw_rgb_32_image(GdkDrawable * drawable, GdkGC * gc, gint x, gint y, gint width, gint height, GdkRgbDither dith, guchar * buf, gint rowstride);
    void gdk_draw_rgb_32_image_dithalign(GdkDrawable * drawable, GdkGC * gc, gint x, gint y, gint width, gint height, GdkRgbDither dith, guchar * buf, gint rowstride, gint xdith, gint ydith);
    void gdk_draw_gray_image(GdkDrawable * drawable, GdkGC * gc, gint x, gint y, gint width, gint height, GdkRgbDither dith, guchar * buf, gint rowstride);
    void gdk_draw_indexed_image(GdkDrawable * drawable, GdkGC * gc, gint x, gint y, gint width, gint height, GdkRgbDither dith, guchar * buf, gint rowstride, GdkRgbCmap * cmap);
    GdkRgbCmap * gdk_rgb_cmap_new(guint32 * colors, gint n_colors);
    void gdk_rgb_cmap_free(GdkRgbCmap * cmap);
    void gdk_rgb_set_verbose(gboolean verbose);
    void gdk_rgb_set_install(gboolean install);
    void gdk_rgb_set_min_colors(gint min_colors);
    GdkColormap * gdk_rgb_get_colormap(void);
    GdkVisual * gdk_rgb_get_visual(void);
    gboolean gdk_rgb_ditherable(void);
    gboolean gdk_rgb_colormap_ditherable(GdkColormap * cmap);
}
extern const guint gdk_pixbuf_major_version;
extern const guint gdk_pixbuf_minor_version;
extern const guint gdk_pixbuf_micro_version;
extern const char * gdk_pixbuf_version;
extern "C"
{
    typedef enum 
    {
        GDK_PIXBUF_ALPHA_BILEVEL, 
        GDK_PIXBUF_ALPHA_FULL
    } GdkPixbufAlphaMode;
    typedef enum 
    {
        GDK_COLORSPACE_RGB
    } GdkColorspace;
    typedef struct _GdkPixbuf GdkPixbuf;
    typedef void (* GdkPixbufDestroyNotify)(guchar * pixels, gpointer data);
    typedef enum 
    {
        GDK_PIXBUF_ERROR_CORRUPT_IMAGE, 
        GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY, 
        GDK_PIXBUF_ERROR_BAD_OPTION, 
        GDK_PIXBUF_ERROR_UNKNOWN_TYPE, 
        GDK_PIXBUF_ERROR_UNSUPPORTED_OPERATION, 
        GDK_PIXBUF_ERROR_FAILED
    } GdkPixbufError;
    GQuark gdk_pixbuf_error_quark(void);
    GType gdk_pixbuf_get_type(void) __attribute__((__const__));
    GdkPixbuf * gdk_pixbuf_ref(GdkPixbuf * pixbuf);
    void gdk_pixbuf_unref(GdkPixbuf * pixbuf);
    GdkColorspace gdk_pixbuf_get_colorspace(const GdkPixbuf * pixbuf);
    int gdk_pixbuf_get_n_channels(const GdkPixbuf * pixbuf);
    gboolean gdk_pixbuf_get_has_alpha(const GdkPixbuf * pixbuf);
    int gdk_pixbuf_get_bits_per_sample(const GdkPixbuf * pixbuf);
    guchar * gdk_pixbuf_get_pixels(const GdkPixbuf * pixbuf);
    int gdk_pixbuf_get_width(const GdkPixbuf * pixbuf);
    int gdk_pixbuf_get_height(const GdkPixbuf * pixbuf);
    int gdk_pixbuf_get_rowstride(const GdkPixbuf * pixbuf);
    GdkPixbuf * gdk_pixbuf_new(GdkColorspace colorspace, gboolean has_alpha, int bits_per_sample, int width, int height);
    GdkPixbuf * gdk_pixbuf_copy(const GdkPixbuf * pixbuf);
    GdkPixbuf * gdk_pixbuf_new_subpixbuf(GdkPixbuf * src_pixbuf, int src_x, int src_y, int width, int height);
    GdkPixbuf * gdk_pixbuf_new_from_file(const char * filename, GError * * error);
    GdkPixbuf * gdk_pixbuf_new_from_file_at_size(const char * filename, int width, int height, GError * * error);
    GdkPixbuf * gdk_pixbuf_new_from_file_at_scale(const char * filename, int width, int height, gboolean preserve_aspect_ratio, GError * * error);
    GdkPixbuf * gdk_pixbuf_new_from_data(const guchar * data, GdkColorspace colorspace, gboolean has_alpha, int bits_per_sample, int width, int height, int rowstride, GdkPixbufDestroyNotify destroy_fn, gpointer destroy_fn_data);
    GdkPixbuf * gdk_pixbuf_new_from_xpm_data(const char * * data);
    GdkPixbuf * gdk_pixbuf_new_from_inline(gint data_length, const guint8 * data, gboolean copy_pixels, GError * * error);
    void gdk_pixbuf_fill(GdkPixbuf * pixbuf, guint32 pixel);
    gboolean gdk_pixbuf_save(GdkPixbuf * pixbuf, const char * filename, const char * type, GError * * error, ...) __attribute__((__sentinel__));
    gboolean gdk_pixbuf_savev(GdkPixbuf * pixbuf, const char * filename, const char * type, char * * option_keys, char * * option_values, GError * * error);
    typedef gboolean (* GdkPixbufSaveFunc)(const gchar * buf, gsize count, GError * * error, gpointer data);
    gboolean gdk_pixbuf_save_to_callback(GdkPixbuf * pixbuf, GdkPixbufSaveFunc save_func, gpointer user_data, const char * type, GError * * error, ...) __attribute__((__sentinel__));
    gboolean gdk_pixbuf_save_to_callbackv(GdkPixbuf * pixbuf, GdkPixbufSaveFunc save_func, gpointer user_data, const char * type, char * * option_keys, char * * option_values, GError * * error);
    gboolean gdk_pixbuf_save_to_buffer(GdkPixbuf * pixbuf, gchar * * buffer, gsize * buffer_size, const char * type, GError * * error, ...) __attribute__((__sentinel__));
    gboolean gdk_pixbuf_save_to_bufferv(GdkPixbuf * pixbuf, gchar * * buffer, gsize * buffer_size, const char * type, char * * option_keys, char * * option_values, GError * * error);
    GdkPixbuf * gdk_pixbuf_add_alpha(const GdkPixbuf * pixbuf, gboolean substitute_color, guchar r, guchar g, guchar b);
    void gdk_pixbuf_copy_area(const GdkPixbuf * src_pixbuf, int src_x, int src_y, int width, int height, GdkPixbuf * dest_pixbuf, int dest_x, int dest_y);
    void gdk_pixbuf_saturate_and_pixelate(const GdkPixbuf * src, GdkPixbuf * dest, gfloat saturation, gboolean pixelate);
    GdkPixbuf * gdk_pixbuf_apply_embedded_orientation(GdkPixbuf * src);
    const gchar * gdk_pixbuf_get_option(GdkPixbuf * pixbuf, const gchar * key);
}
extern "C"
{
    typedef enum 
    {
        GDK_INTERP_NEAREST, 
        GDK_INTERP_TILES, 
        GDK_INTERP_BILINEAR, 
        GDK_INTERP_HYPER
    } GdkInterpType;
    typedef enum 
    {
        GDK_PIXBUF_ROTATE_NONE = 0, 
        GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE = 90, 
        GDK_PIXBUF_ROTATE_UPSIDEDOWN = 180, 
        GDK_PIXBUF_ROTATE_CLOCKWISE = 270
    } GdkPixbufRotation;
    void gdk_pixbuf_scale(const GdkPixbuf * src, GdkPixbuf * dest, int dest_x, int dest_y, int dest_width, int dest_height, double offset_x, double offset_y, double scale_x, double scale_y, GdkInterpType interp_type);
    void gdk_pixbuf_composite(const GdkPixbuf * src, GdkPixbuf * dest, int dest_x, int dest_y, int dest_width, int dest_height, double offset_x, double offset_y, double scale_x, double scale_y, GdkInterpType interp_type, int overall_alpha);
    void gdk_pixbuf_composite_color(const GdkPixbuf * src, GdkPixbuf * dest, int dest_x, int dest_y, int dest_width, int dest_height, double offset_x, double offset_y, double scale_x, double scale_y, GdkInterpType interp_type, int overall_alpha, int check_x, int check_y, int check_size, guint32 color1, guint32 color2);
    GdkPixbuf * gdk_pixbuf_scale_simple(const GdkPixbuf * src, int dest_width, int dest_height, GdkInterpType interp_type);
    GdkPixbuf * gdk_pixbuf_composite_color_simple(const GdkPixbuf * src, int dest_width, int dest_height, GdkInterpType interp_type, int overall_alpha, int check_size, guint32 color1, guint32 color2);
    GdkPixbuf * gdk_pixbuf_rotate_simple(const GdkPixbuf * src, GdkPixbufRotation angle);
    GdkPixbuf * gdk_pixbuf_flip(const GdkPixbuf * src, gboolean horizontal);
}
extern "C"
{
    typedef struct _GdkPixbufAnimation GdkPixbufAnimation;
    typedef struct _GdkPixbufAnimationIter GdkPixbufAnimationIter;
    GType gdk_pixbuf_animation_get_type(void) __attribute__((__const__));
    GdkPixbufAnimation * gdk_pixbuf_animation_new_from_file(const char * filename, GError * * error);
    GdkPixbufAnimation * gdk_pixbuf_animation_ref(GdkPixbufAnimation * animation);
    void gdk_pixbuf_animation_unref(GdkPixbufAnimation * animation);
    int gdk_pixbuf_animation_get_width(GdkPixbufAnimation * animation);
    int gdk_pixbuf_animation_get_height(GdkPixbufAnimation * animation);
    gboolean gdk_pixbuf_animation_is_static_image(GdkPixbufAnimation * animation);
    GdkPixbuf * gdk_pixbuf_animation_get_static_image(GdkPixbufAnimation * animation);
    GdkPixbufAnimationIter * gdk_pixbuf_animation_get_iter(GdkPixbufAnimation * animation, const GTimeVal * start_time);
    GType gdk_pixbuf_animation_iter_get_type(void) __attribute__((__const__));
    int gdk_pixbuf_animation_iter_get_delay_time(GdkPixbufAnimationIter * iter);
    GdkPixbuf * gdk_pixbuf_animation_iter_get_pixbuf(GdkPixbufAnimationIter * iter);
    gboolean gdk_pixbuf_animation_iter_on_currently_loading_frame(GdkPixbufAnimationIter * iter);
    gboolean gdk_pixbuf_animation_iter_advance(GdkPixbufAnimationIter * iter, const GTimeVal * current_time);
}
extern "C"
{
    typedef struct _GdkPixbufSimpleAnim GdkPixbufSimpleAnim;
    typedef struct _GdkPixbufSimpleAnimClass GdkPixbufSimpleAnimClass;
    GType gdk_pixbuf_simple_anim_get_type(void) __attribute__((__const__));
    GType gdk_pixbuf_simple_anim_iter_get_type(void) __attribute__((__const__));
    GdkPixbufSimpleAnim * gdk_pixbuf_simple_anim_new(gint width, gint height, gfloat rate);
    void gdk_pixbuf_simple_anim_add_frame(GdkPixbufSimpleAnim * animation, GdkPixbuf * pixbuf);
}
extern "C"
{
    typedef enum 
    {
        G_MODULE_BIND_LAZY = 1 << 0, 
        G_MODULE_BIND_LOCAL = 1 << 1, 
        G_MODULE_BIND_MASK = 0x03
    } GModuleFlags;
    typedef struct _GModule GModule;
    typedef const gchar * (* GModuleCheckInit)(GModule * module);
    typedef void (* GModuleUnload)(GModule * module);
    gboolean g_module_supported(void) __attribute__((__const__));
    GModule * g_module_open(const gchar * file_name, GModuleFlags flags);
    gboolean g_module_close(GModule * module);
    void g_module_make_resident(GModule * module);
    const gchar * g_module_error(void);
    gboolean g_module_symbol(GModule * module, const gchar * symbol_name, gpointer * symbol);
    const gchar * g_module_name(GModule * module);
    gchar * g_module_build_path(const gchar * directory, const gchar * module_name);
}
extern "C"
{
    typedef struct _GdkPixbufFormat GdkPixbufFormat;
    GSList * gdk_pixbuf_get_formats(void);
    gchar * gdk_pixbuf_format_get_name(GdkPixbufFormat * format);
    gchar * gdk_pixbuf_format_get_description(GdkPixbufFormat * format);
    gchar * * gdk_pixbuf_format_get_mime_types(GdkPixbufFormat * format);
    gchar * * gdk_pixbuf_format_get_extensions(GdkPixbufFormat * format);
    gboolean gdk_pixbuf_format_is_writable(GdkPixbufFormat * format);
    gboolean gdk_pixbuf_format_is_scalable(GdkPixbufFormat * format);
    gboolean gdk_pixbuf_format_is_disabled(GdkPixbufFormat * format);
    void gdk_pixbuf_format_set_disabled(GdkPixbufFormat * format, gboolean disabled);
    gchar * gdk_pixbuf_format_get_license(GdkPixbufFormat * format);
    GdkPixbufFormat * gdk_pixbuf_get_file_info(const gchar * filename, gint * width, gint * height);
}
extern "C"
{
    typedef struct _GdkPixbufLoader GdkPixbufLoader;
    struct _GdkPixbufLoader
    {
            GObject parent_instance;
            gpointer priv;
    };
    typedef struct _GdkPixbufLoaderClass GdkPixbufLoaderClass;
    struct _GdkPixbufLoaderClass
    {
            GObjectClass parent_class;
            void (* size_prepared)(GdkPixbufLoader * loader, int width, int height);
            void (* area_prepared)(GdkPixbufLoader * loader);
            void (* area_updated)(GdkPixbufLoader * loader, int x, int y, int width, int height);
            void (* closed)(GdkPixbufLoader * loader);
    };
    GType gdk_pixbuf_loader_get_type(void) __attribute__((__const__));
    GdkPixbufLoader * gdk_pixbuf_loader_new(void);
    GdkPixbufLoader * gdk_pixbuf_loader_new_with_type(const char * image_type, GError * * error);
    GdkPixbufLoader * gdk_pixbuf_loader_new_with_mime_type(const char * mime_type, GError * * error);
    void gdk_pixbuf_loader_set_size(GdkPixbufLoader * loader, int width, int height);
    gboolean gdk_pixbuf_loader_write(GdkPixbufLoader * loader, const guchar * buf, gsize count, GError * * error);
    GdkPixbuf * gdk_pixbuf_loader_get_pixbuf(GdkPixbufLoader * loader);
    GdkPixbufAnimation * gdk_pixbuf_loader_get_animation(GdkPixbufLoader * loader);
    gboolean gdk_pixbuf_loader_close(GdkPixbufLoader * loader, GError * * error);
    GdkPixbufFormat * gdk_pixbuf_loader_get_format(GdkPixbufLoader * loader);
}
extern "C"
{
    GType gdk_pixbuf_alpha_mode_get_type(void) __attribute__((__const__));
    GType gdk_colorspace_get_type(void) __attribute__((__const__));
    GType gdk_pixbuf_error_get_type(void) __attribute__((__const__));
    GType gdk_interp_type_get_type(void) __attribute__((__const__));
    GType gdk_pixbuf_rotation_get_type(void) __attribute__((__const__));
}
extern "C"
{
    void gdk_pixbuf_render_threshold_alpha(GdkPixbuf * pixbuf, GdkBitmap * bitmap, int src_x, int src_y, int dest_x, int dest_y, int width, int height, int alpha_threshold);
    void gdk_pixbuf_render_to_drawable(GdkPixbuf * pixbuf, GdkDrawable * drawable, GdkGC * gc, int src_x, int src_y, int dest_x, int dest_y, int width, int height, GdkRgbDither dither, int x_dither, int y_dither);
    void gdk_pixbuf_render_to_drawable_alpha(GdkPixbuf * pixbuf, GdkDrawable * drawable, int src_x, int src_y, int dest_x, int dest_y, int width, int height, GdkPixbufAlphaMode alpha_mode, int alpha_threshold, GdkRgbDither dither, int x_dither, int y_dither);
    void gdk_pixbuf_render_pixmap_and_mask_for_colormap(GdkPixbuf * pixbuf, GdkColormap * colormap, GdkPixmap * * pixmap_return, GdkBitmap * * mask_return, int alpha_threshold);
    void gdk_pixbuf_render_pixmap_and_mask(GdkPixbuf * pixbuf, GdkPixmap * * pixmap_return, GdkBitmap * * mask_return, int alpha_threshold);
    GdkPixbuf * gdk_pixbuf_get_from_drawable(GdkPixbuf * dest, GdkDrawable * src, GdkColormap * cmap, int src_x, int src_y, int dest_x, int dest_y, int width, int height);
    GdkPixbuf * gdk_pixbuf_get_from_image(GdkPixbuf * dest, GdkImage * src, GdkColormap * cmap, int src_x, int src_y, int dest_x, int dest_y, int width, int height);
}
extern "C"
{
    typedef struct _PangoCairoFont PangoCairoFont;
    typedef struct _PangoCairoFontMap PangoCairoFontMap;
    typedef void (* PangoCairoShapeRendererFunc)(cairo_t * cr, PangoAttrShape * attr, gboolean do_path, gpointer data);
    GType pango_cairo_font_map_get_type(void) __attribute__((__const__));
    PangoFontMap * pango_cairo_font_map_new(void);
    PangoFontMap * pango_cairo_font_map_new_for_font_type(cairo_font_type_t fonttype);
    PangoFontMap * pango_cairo_font_map_get_default(void);
    cairo_font_type_t pango_cairo_font_map_get_font_type(PangoCairoFontMap * fontmap);
    void pango_cairo_font_map_set_resolution(PangoCairoFontMap * fontmap, double dpi);
    double pango_cairo_font_map_get_resolution(PangoCairoFontMap * fontmap);
    PangoContext * pango_cairo_font_map_create_context(PangoCairoFontMap * fontmap);
    GType pango_cairo_font_get_type(void) __attribute__((__const__));
    cairo_scaled_font_t * pango_cairo_font_get_scaled_font(PangoCairoFont * font);
    void pango_cairo_update_context(cairo_t * cr, PangoContext * context);
    void pango_cairo_context_set_font_options(PangoContext * context, const cairo_font_options_t * options);
    const cairo_font_options_t * pango_cairo_context_get_font_options(PangoContext * context);
    void pango_cairo_context_set_resolution(PangoContext * context, double dpi);
    double pango_cairo_context_get_resolution(PangoContext * context);
    void pango_cairo_context_set_shape_renderer(PangoContext * context, PangoCairoShapeRendererFunc func, gpointer data, GDestroyNotify dnotify);
    PangoCairoShapeRendererFunc pango_cairo_context_get_shape_renderer(PangoContext * context, gpointer * data);
    PangoLayout * pango_cairo_create_layout(cairo_t * cr);
    void pango_cairo_update_layout(cairo_t * cr, PangoLayout * layout);
    void pango_cairo_show_glyph_string(cairo_t * cr, PangoFont * font, PangoGlyphString * glyphs);
    void pango_cairo_show_layout_line(cairo_t * cr, PangoLayoutLine * line);
    void pango_cairo_show_layout(cairo_t * cr, PangoLayout * layout);
    void pango_cairo_show_error_underline(cairo_t * cr, double x, double y, double width, double height);
    void pango_cairo_glyph_string_path(cairo_t * cr, PangoFont * font, PangoGlyphString * glyphs);
    void pango_cairo_layout_line_path(cairo_t * cr, PangoLayoutLine * line);
    void pango_cairo_layout_path(cairo_t * cr, PangoLayout * layout);
    void pango_cairo_error_underline_path(cairo_t * cr, double x, double y, double width, double height);
}
extern "C"
{
    cairo_t * gdk_cairo_create(GdkDrawable * drawable);
    void gdk_cairo_set_source_color(cairo_t * cr, GdkColor * color);
    void gdk_cairo_set_source_pixbuf(cairo_t * cr, GdkPixbuf * pixbuf, double pixbuf_x, double pixbuf_y);
    void gdk_cairo_set_source_pixmap(cairo_t * cr, GdkPixmap * pixmap, double pixmap_x, double pixmap_y);
    void gdk_cairo_rectangle(cairo_t * cr, GdkRectangle * rectangle);
    void gdk_cairo_region(cairo_t * cr, GdkRegion * region);
}
extern "C"
{
    typedef enum 
    {
        GDK_X_CURSOR = 0, 
        GDK_ARROW = 2, 
        GDK_BASED_ARROW_DOWN = 4, 
        GDK_BASED_ARROW_UP = 6, 
        GDK_BOAT = 8, 
        GDK_BOGOSITY = 10, 
        GDK_BOTTOM_LEFT_CORNER = 12, 
        GDK_BOTTOM_RIGHT_CORNER = 14, 
        GDK_BOTTOM_SIDE = 16, 
        GDK_BOTTOM_TEE = 18, 
        GDK_BOX_SPIRAL = 20, 
        GDK_CENTER_PTR = 22, 
        GDK_CIRCLE = 24, 
        GDK_CLOCK = 26, 
        GDK_COFFEE_MUG = 28, 
        GDK_CROSS = 30, 
        GDK_CROSS_REVERSE = 32, 
        GDK_CROSSHAIR = 34, 
        GDK_DIAMOND_CROSS = 36, 
        GDK_DOT = 38, 
        GDK_DOTBOX = 40, 
        GDK_DOUBLE_ARROW = 42, 
        GDK_DRAFT_LARGE = 44, 
        GDK_DRAFT_SMALL = 46, 
        GDK_DRAPED_BOX = 48, 
        GDK_EXCHANGE = 50, 
        GDK_FLEUR = 52, 
        GDK_GOBBLER = 54, 
        GDK_GUMBY = 56, 
        GDK_HAND1 = 58, 
        GDK_HAND2 = 60, 
        GDK_HEART = 62, 
        GDK_ICON = 64, 
        GDK_IRON_CROSS = 66, 
        GDK_LEFT_PTR = 68, 
        GDK_LEFT_SIDE = 70, 
        GDK_LEFT_TEE = 72, 
        GDK_LEFTBUTTON = 74, 
        GDK_LL_ANGLE = 76, 
        GDK_LR_ANGLE = 78, 
        GDK_MAN = 80, 
        GDK_MIDDLEBUTTON = 82, 
        GDK_MOUSE = 84, 
        GDK_PENCIL = 86, 
        GDK_PIRATE = 88, 
        GDK_PLUS = 90, 
        GDK_QUESTION_ARROW = 92, 
        GDK_RIGHT_PTR = 94, 
        GDK_RIGHT_SIDE = 96, 
        GDK_RIGHT_TEE = 98, 
        GDK_RIGHTBUTTON = 100, 
        GDK_RTL_LOGO = 102, 
        GDK_SAILBOAT = 104, 
        GDK_SB_DOWN_ARROW = 106, 
        GDK_SB_H_DOUBLE_ARROW = 108, 
        GDK_SB_LEFT_ARROW = 110, 
        GDK_SB_RIGHT_ARROW = 112, 
        GDK_SB_UP_ARROW = 114, 
        GDK_SB_V_DOUBLE_ARROW = 116, 
        GDK_SHUTTLE = 118, 
        GDK_SIZING = 120, 
        GDK_SPIDER = 122, 
        GDK_SPRAYCAN = 124, 
        GDK_STAR = 126, 
        GDK_TARGET = 128, 
        GDK_TCROSS = 130, 
        GDK_TOP_LEFT_ARROW = 132, 
        GDK_TOP_LEFT_CORNER = 134, 
        GDK_TOP_RIGHT_CORNER = 136, 
        GDK_TOP_SIDE = 138, 
        GDK_TOP_TEE = 140, 
        GDK_TREK = 142, 
        GDK_UL_ANGLE = 144, 
        GDK_UMBRELLA = 146, 
        GDK_UR_ANGLE = 148, 
        GDK_WATCH = 150, 
        GDK_XTERM = 152, 
        GDK_LAST_CURSOR, 
        GDK_CURSOR_IS_PIXMAP = -1
    } GdkCursorType;
    struct _GdkCursor
    {
            GdkCursorType type;
            guint ref_count;
    };
    GType gdk_cursor_get_type(void) __attribute__((__const__));
    GdkCursor * gdk_cursor_new_for_display(GdkDisplay * display, GdkCursorType cursor_type);
    GdkCursor * gdk_cursor_new(GdkCursorType cursor_type);
    GdkCursor * gdk_cursor_new_from_pixmap(GdkPixmap * source, GdkPixmap * mask, const GdkColor * fg, const GdkColor * bg, gint x, gint y);
    GdkCursor * gdk_cursor_new_from_pixbuf(GdkDisplay * display, GdkPixbuf * pixbuf, gint x, gint y);
    GdkDisplay * gdk_cursor_get_display(GdkCursor * cursor);
    GdkCursor * gdk_cursor_ref(GdkCursor * cursor);
    void gdk_cursor_unref(GdkCursor * cursor);
    GdkCursor * gdk_cursor_new_from_name(GdkDisplay * display, const gchar * name);
    GdkPixbuf * gdk_cursor_get_image(GdkCursor * cursor);
}
extern "C"
{
    typedef struct _GdkDragContext GdkDragContext;
    typedef enum 
    {
        GDK_ACTION_DEFAULT = 1 << 0, 
        GDK_ACTION_COPY = 1 << 1, 
        GDK_ACTION_MOVE = 1 << 2, 
        GDK_ACTION_LINK = 1 << 3, 
        GDK_ACTION_PRIVATE = 1 << 4, 
        GDK_ACTION_ASK = 1 << 5
    } GdkDragAction;
    typedef enum 
    {
        GDK_DRAG_PROTO_MOTIF, 
        GDK_DRAG_PROTO_XDND, 
        GDK_DRAG_PROTO_ROOTWIN, 
        GDK_DRAG_PROTO_NONE, 
        GDK_DRAG_PROTO_WIN32_DROPFILES, 
        GDK_DRAG_PROTO_OLE2, 
        GDK_DRAG_PROTO_LOCAL
    } GdkDragProtocol;
    typedef struct _GdkDragContextClass GdkDragContextClass;
    struct _GdkDragContext
    {
            GObject parent_instance;
            GdkDragProtocol protocol;
            gboolean is_source;
            GdkWindow * source_window;
            GdkWindow * dest_window;
            GList * targets;
            GdkDragAction actions;
            GdkDragAction suggested_action;
            GdkDragAction action;
            guint32 start_time;
            gpointer windowing_data;
    };
    struct _GdkDragContextClass
    {
            GObjectClass parent_class;
    };
    GType gdk_drag_context_get_type(void) __attribute__((__const__));
    GdkDragContext * gdk_drag_context_new(void);
    void gdk_drag_context_ref(GdkDragContext * context);
    void gdk_drag_context_unref(GdkDragContext * context);
    void gdk_drag_status(GdkDragContext * context, GdkDragAction action, guint32 time_);
    void gdk_drop_reply(GdkDragContext * context, gboolean ok, guint32 time_);
    void gdk_drop_finish(GdkDragContext * context, gboolean success, guint32 time_);
    GdkAtom gdk_drag_get_selection(GdkDragContext * context);
    GdkDragContext * gdk_drag_begin(GdkWindow * window, GList * targets);
    guint32 gdk_drag_get_protocol_for_display(GdkDisplay * display, guint32 xid, GdkDragProtocol * protocol);
    void gdk_drag_find_window_for_screen(GdkDragContext * context, GdkWindow * drag_window, GdkScreen * screen, gint x_root, gint y_root, GdkWindow * * dest_window, GdkDragProtocol * protocol);
    guint32 gdk_drag_get_protocol(guint32 xid, GdkDragProtocol * protocol);
    void gdk_drag_find_window(GdkDragContext * context, GdkWindow * drag_window, gint x_root, gint y_root, GdkWindow * * dest_window, GdkDragProtocol * protocol);
    gboolean gdk_drag_motion(GdkDragContext * context, GdkWindow * dest_window, GdkDragProtocol protocol, gint x_root, gint y_root, GdkDragAction suggested_action, GdkDragAction possible_actions, guint32 time_);
    void gdk_drag_drop(GdkDragContext * context, guint32 time_);
    void gdk_drag_abort(GdkDragContext * context, guint32 time_);
    gboolean gdk_drag_drop_succeeded(GdkDragContext * context);
}
extern "C"
{
    typedef struct _GdkDeviceKey GdkDeviceKey;
    typedef struct _GdkDeviceAxis GdkDeviceAxis;
    typedef struct _GdkDevice GdkDevice;
    typedef struct _GdkDeviceClass GdkDeviceClass;
    typedef struct _GdkTimeCoord GdkTimeCoord;
    typedef enum 
    {
        GDK_EXTENSION_EVENTS_NONE, 
        GDK_EXTENSION_EVENTS_ALL, 
        GDK_EXTENSION_EVENTS_CURSOR
    } GdkExtensionMode;
    typedef enum 
    {
        GDK_SOURCE_MOUSE, 
        GDK_SOURCE_PEN, 
        GDK_SOURCE_ERASER, 
        GDK_SOURCE_CURSOR
    } GdkInputSource;
    typedef enum 
    {
        GDK_MODE_DISABLED, 
        GDK_MODE_SCREEN, 
        GDK_MODE_WINDOW
    } GdkInputMode;
    typedef enum 
    {
        GDK_AXIS_IGNORE, 
        GDK_AXIS_X, 
        GDK_AXIS_Y, 
        GDK_AXIS_PRESSURE, 
        GDK_AXIS_XTILT, 
        GDK_AXIS_YTILT, 
        GDK_AXIS_WHEEL, 
        GDK_AXIS_LAST
    } GdkAxisUse;
    struct _GdkDeviceKey
    {
            guint keyval;
            GdkModifierType modifiers;
    };
    struct _GdkDeviceAxis
    {
            GdkAxisUse use;
            gdouble min;
            gdouble max;
    };
    struct _GdkDevice
    {
            GObject parent_instance;
            gchar * name;
            GdkInputSource source;
            GdkInputMode mode;
            gboolean has_cursor;
            gint num_axes;
            GdkDeviceAxis * axes;
            gint num_keys;
            GdkDeviceKey * keys;
    };
    struct _GdkTimeCoord
    {
            guint32 time;
            gdouble axes[128];
    };
    GType gdk_device_get_type(void) __attribute__((__const__));
    GList * gdk_devices_list(void);
    void gdk_device_set_source(GdkDevice * device, GdkInputSource source);
    gboolean gdk_device_set_mode(GdkDevice * device, GdkInputMode mode);
    void gdk_device_set_key(GdkDevice * device, guint index_, guint keyval, GdkModifierType modifiers);
    void gdk_device_set_axis_use(GdkDevice * device, guint index_, GdkAxisUse use);
    void gdk_device_get_state(GdkDevice * device, GdkWindow * window, gdouble * axes, GdkModifierType * mask);
    gboolean gdk_device_get_history(GdkDevice * device, GdkWindow * window, guint32 start, guint32 stop, GdkTimeCoord * * * events, gint * n_events);
    void gdk_device_free_history(GdkTimeCoord * * events, gint n_events);
    gboolean gdk_device_get_axis(GdkDevice * device, gdouble * axes, GdkAxisUse use, gdouble * value);
    void gdk_input_set_extension_events(GdkWindow * window, gint mask, GdkExtensionMode mode);
    GdkDevice * gdk_device_get_core_pointer(void);
}
extern "C"
{
    typedef struct _GdkEventAny GdkEventAny;
    typedef struct _GdkEventExpose GdkEventExpose;
    typedef struct _GdkEventNoExpose GdkEventNoExpose;
    typedef struct _GdkEventVisibility GdkEventVisibility;
    typedef struct _GdkEventMotion GdkEventMotion;
    typedef struct _GdkEventButton GdkEventButton;
    typedef struct _GdkEventScroll GdkEventScroll;
    typedef struct _GdkEventKey GdkEventKey;
    typedef struct _GdkEventFocus GdkEventFocus;
    typedef struct _GdkEventCrossing GdkEventCrossing;
    typedef struct _GdkEventConfigure GdkEventConfigure;
    typedef struct _GdkEventProperty GdkEventProperty;
    typedef struct _GdkEventSelection GdkEventSelection;
    typedef struct _GdkEventOwnerChange GdkEventOwnerChange;
    typedef struct _GdkEventProximity GdkEventProximity;
    typedef struct _GdkEventClient GdkEventClient;
    typedef struct _GdkEventDND GdkEventDND;
    typedef struct _GdkEventWindowState GdkEventWindowState;
    typedef struct _GdkEventSetting GdkEventSetting;
    typedef struct _GdkEventGrabBroken GdkEventGrabBroken;
    typedef union _GdkEvent GdkEvent;
    typedef void (* GdkEventFunc)(GdkEvent * event, gpointer data);
    typedef void GdkXEvent;
    typedef enum 
    {
        GDK_FILTER_CONTINUE, 
        GDK_FILTER_TRANSLATE, 
        GDK_FILTER_REMOVE
    } GdkFilterReturn;
    typedef GdkFilterReturn (* GdkFilterFunc)(GdkXEvent * xevent, GdkEvent * event, gpointer data);
    typedef enum 
    {
        GDK_NOTHING = -1, 
        GDK_DELETE = 0, 
        GDK_DESTROY = 1, 
        GDK_EXPOSE = 2, 
        GDK_MOTION_NOTIFY = 3, 
        GDK_BUTTON_PRESS = 4, 
        GDK_2BUTTON_PRESS = 5, 
        GDK_3BUTTON_PRESS = 6, 
        GDK_BUTTON_RELEASE = 7, 
        GDK_KEY_PRESS = 8, 
        GDK_KEY_RELEASE = 9, 
        GDK_ENTER_NOTIFY = 10, 
        GDK_LEAVE_NOTIFY = 11, 
        GDK_FOCUS_CHANGE = 12, 
        GDK_CONFIGURE = 13, 
        GDK_MAP = 14, 
        GDK_UNMAP = 15, 
        GDK_PROPERTY_NOTIFY = 16, 
        GDK_SELECTION_CLEAR = 17, 
        GDK_SELECTION_REQUEST = 18, 
        GDK_SELECTION_NOTIFY = 19, 
        GDK_PROXIMITY_IN = 20, 
        GDK_PROXIMITY_OUT = 21, 
        GDK_DRAG_ENTER = 22, 
        GDK_DRAG_LEAVE = 23, 
        GDK_DRAG_MOTION = 24, 
        GDK_DRAG_STATUS = 25, 
        GDK_DROP_START = 26, 
        GDK_DROP_FINISHED = 27, 
        GDK_CLIENT_EVENT = 28, 
        GDK_VISIBILITY_NOTIFY = 29, 
        GDK_NO_EXPOSE = 30, 
        GDK_SCROLL = 31, 
        GDK_WINDOW_STATE = 32, 
        GDK_SETTING = 33, 
        GDK_OWNER_CHANGE = 34, 
        GDK_GRAB_BROKEN = 35
    } GdkEventType;
    typedef enum 
    {
        GDK_EXPOSURE_MASK = 1 << 1, 
        GDK_POINTER_MOTION_MASK = 1 << 2, 
        GDK_POINTER_MOTION_HINT_MASK = 1 << 3, 
        GDK_BUTTON_MOTION_MASK = 1 << 4, 
        GDK_BUTTON1_MOTION_MASK = 1 << 5, 
        GDK_BUTTON2_MOTION_MASK = 1 << 6, 
        GDK_BUTTON3_MOTION_MASK = 1 << 7, 
        GDK_BUTTON_PRESS_MASK = 1 << 8, 
        GDK_BUTTON_RELEASE_MASK = 1 << 9, 
        GDK_KEY_PRESS_MASK = 1 << 10, 
        GDK_KEY_RELEASE_MASK = 1 << 11, 
        GDK_ENTER_NOTIFY_MASK = 1 << 12, 
        GDK_LEAVE_NOTIFY_MASK = 1 << 13, 
        GDK_FOCUS_CHANGE_MASK = 1 << 14, 
        GDK_STRUCTURE_MASK = 1 << 15, 
        GDK_PROPERTY_CHANGE_MASK = 1 << 16, 
        GDK_VISIBILITY_NOTIFY_MASK = 1 << 17, 
        GDK_PROXIMITY_IN_MASK = 1 << 18, 
        GDK_PROXIMITY_OUT_MASK = 1 << 19, 
        GDK_SUBSTRUCTURE_MASK = 1 << 20, 
        GDK_SCROLL_MASK = 1 << 21, 
        GDK_ALL_EVENTS_MASK = 0x3FFFFE
    } GdkEventMask;
    typedef enum 
    {
        GDK_VISIBILITY_UNOBSCURED, 
        GDK_VISIBILITY_PARTIAL, 
        GDK_VISIBILITY_FULLY_OBSCURED
    } GdkVisibilityState;
    typedef enum 
    {
        GDK_SCROLL_UP, 
        GDK_SCROLL_DOWN, 
        GDK_SCROLL_LEFT, 
        GDK_SCROLL_RIGHT
    } GdkScrollDirection;
    typedef enum 
    {
        GDK_NOTIFY_ANCESTOR = 0, 
        GDK_NOTIFY_VIRTUAL = 1, 
        GDK_NOTIFY_INFERIOR = 2, 
        GDK_NOTIFY_NONLINEAR = 3, 
        GDK_NOTIFY_NONLINEAR_VIRTUAL = 4, 
        GDK_NOTIFY_UNKNOWN = 5
    } GdkNotifyType;
    typedef enum 
    {
        GDK_CROSSING_NORMAL, 
        GDK_CROSSING_GRAB, 
        GDK_CROSSING_UNGRAB
    } GdkCrossingMode;
    typedef enum 
    {
        GDK_PROPERTY_NEW_VALUE, 
        GDK_PROPERTY_DELETE
    } GdkPropertyState;
    typedef enum 
    {
        GDK_WINDOW_STATE_WITHDRAWN = 1 << 0, 
        GDK_WINDOW_STATE_ICONIFIED = 1 << 1, 
        GDK_WINDOW_STATE_MAXIMIZED = 1 << 2, 
        GDK_WINDOW_STATE_STICKY = 1 << 3, 
        GDK_WINDOW_STATE_FULLSCREEN = 1 << 4, 
        GDK_WINDOW_STATE_ABOVE = 1 << 5, 
        GDK_WINDOW_STATE_BELOW = 1 << 6
    } GdkWindowState;
    typedef enum 
    {
        GDK_SETTING_ACTION_NEW, 
        GDK_SETTING_ACTION_CHANGED, 
        GDK_SETTING_ACTION_DELETED
    } GdkSettingAction;
    typedef enum 
    {
        GDK_OWNER_CHANGE_NEW_OWNER, 
        GDK_OWNER_CHANGE_DESTROY, 
        GDK_OWNER_CHANGE_CLOSE
    } GdkOwnerChange;
    struct _GdkEventAny
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
    };
    struct _GdkEventExpose
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            GdkRectangle area;
            GdkRegion * region;
            gint count;
    };
    struct _GdkEventNoExpose
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
    };
    struct _GdkEventVisibility
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            GdkVisibilityState state;
    };
    struct _GdkEventMotion
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            guint32 time;
            gdouble x;
            gdouble y;
            gdouble * axes;
            guint state;
            gint16 is_hint;
            GdkDevice * device;
            gdouble x_root, y_root;
    };
    struct _GdkEventButton
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            guint32 time;
            gdouble x;
            gdouble y;
            gdouble * axes;
            guint state;
            guint button;
            GdkDevice * device;
            gdouble x_root, y_root;
    };
    struct _GdkEventScroll
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            guint32 time;
            gdouble x;
            gdouble y;
            guint state;
            GdkScrollDirection direction;
            GdkDevice * device;
            gdouble x_root, y_root;
    };
    struct _GdkEventKey
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            guint32 time;
            guint state;
            guint keyval;
            gint length;
            gchar * string;
            guint16 hardware_keycode;
            guint8 group;
            guint is_modifier : 1;
    };
    struct _GdkEventCrossing
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            GdkWindow * subwindow;
            guint32 time;
            gdouble x;
            gdouble y;
            gdouble x_root;
            gdouble y_root;
            GdkCrossingMode mode;
            GdkNotifyType detail;
            gboolean focus;
            guint state;
    };
    struct _GdkEventFocus
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            gint16 in;
    };
    struct _GdkEventConfigure
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            gint x, y;
            gint width;
            gint height;
    };
    struct _GdkEventProperty
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            GdkAtom atom;
            guint32 time;
            guint state;
    };
    struct _GdkEventSelection
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            GdkAtom selection;
            GdkAtom target;
            GdkAtom property;
            guint32 time;
            GdkNativeWindow requestor;
    };
    struct _GdkEventOwnerChange
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            GdkNativeWindow owner;
            GdkOwnerChange reason;
            GdkAtom selection;
            guint32 time;
            guint32 selection_time;
    };
    struct _GdkEventProximity
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            guint32 time;
            GdkDevice * device;
    };
    struct _GdkEventClient
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            GdkAtom message_type;
            gushort data_format;
            union 
            {
                    char b[20];
                    short s[10];
                    long l[5];
            } data;
    };
    struct _GdkEventSetting
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            GdkSettingAction action;
            char * name;
    };
    struct _GdkEventWindowState
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            GdkWindowState changed_mask;
            GdkWindowState new_window_state;
    };
    struct _GdkEventGrabBroken
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            gboolean keyboard;
            gboolean implicit;
            GdkWindow * grab_window;
    };
    struct _GdkEventDND
    {
            GdkEventType type;
            GdkWindow * window;
            gint8 send_event;
            GdkDragContext * context;
            guint32 time;
            gshort x_root, y_root;
    };
    union _GdkEvent
    {
            GdkEventType type;
            GdkEventAny any;
            GdkEventExpose expose;
            GdkEventNoExpose no_expose;
            GdkEventVisibility visibility;
            GdkEventMotion motion;
            GdkEventButton button;
            GdkEventScroll scroll;
            GdkEventKey key;
            GdkEventCrossing crossing;
            GdkEventFocus focus_change;
            GdkEventConfigure configure;
            GdkEventProperty property;
            GdkEventSelection selection;
            GdkEventOwnerChange owner_change;
            GdkEventProximity proximity;
            GdkEventClient client;
            GdkEventDND dnd;
            GdkEventWindowState window_state;
            GdkEventSetting setting;
            GdkEventGrabBroken grab_broken;
    };
    GType gdk_event_get_type(void) __attribute__((__const__));
    gboolean gdk_events_pending(void);
    GdkEvent * gdk_event_get(void);
    GdkEvent * gdk_event_peek(void);
    GdkEvent * gdk_event_get_graphics_expose(GdkWindow * window);
    void gdk_event_put(GdkEvent * event);
    GdkEvent * gdk_event_new(GdkEventType type);
    GdkEvent * gdk_event_copy(GdkEvent * event);
    void gdk_event_free(GdkEvent * event);
    guint32 gdk_event_get_time(GdkEvent * event);
    gboolean gdk_event_get_state(GdkEvent * event, GdkModifierType * state);
    gboolean gdk_event_get_coords(GdkEvent * event, gdouble * x_win, gdouble * y_win);
    gboolean gdk_event_get_root_coords(GdkEvent * event, gdouble * x_root, gdouble * y_root);
    gboolean gdk_event_get_axis(GdkEvent * event, GdkAxisUse axis_use, gdouble * value);
    void gdk_event_request_motions(GdkEventMotion * event);
    void gdk_event_handler_set(GdkEventFunc func, gpointer data, GDestroyNotify notify);
    void gdk_event_set_screen(GdkEvent * event, GdkScreen * screen);
    GdkScreen * gdk_event_get_screen(GdkEvent * event);
    void gdk_set_show_events(gboolean show_events);
    gboolean gdk_get_show_events(void);
    void gdk_add_client_message_filter(GdkAtom message_type, GdkFilterFunc func, gpointer data);
    gboolean gdk_setting_get(const gchar * name, GValue * value);
}
extern "C"
{
    typedef struct _GdkDisplayClass GdkDisplayClass;
    typedef struct _GdkDisplayPointerHooks GdkDisplayPointerHooks;
    struct _GdkDisplay
    {
            GObject parent_instance;
            GList * queued_events;
            GList * queued_tail;
            guint32 button_click_time[2];
            GdkWindow * button_window[2];
            gint button_number[2];
            guint double_click_time;
            GdkDevice * core_pointer;
            const GdkDisplayPointerHooks * pointer_hooks;
            guint closed : 1;
            guint double_click_distance;
            gint button_x[2];
            gint button_y[2];
    };
    struct _GdkDisplayClass
    {
            GObjectClass parent_class;
            const gchar * (* get_display_name)(GdkDisplay * display);
            gint (* get_n_screens)(GdkDisplay * display);
            GdkScreen * (* get_screen)(GdkDisplay * display, gint screen_num);
            GdkScreen * (* get_default_screen)(GdkDisplay * display);
            void (* closed)(GdkDisplay * display, gboolean is_error);
    };
    struct _GdkDisplayPointerHooks
    {
            void (* get_pointer)(GdkDisplay * display, GdkScreen * * screen, gint * x, gint * y, GdkModifierType * mask);
            GdkWindow * (* window_get_pointer)(GdkDisplay * display, GdkWindow * window, gint * x, gint * y, GdkModifierType * mask);
            GdkWindow * (* window_at_pointer)(GdkDisplay * display, gint * win_x, gint * win_y);
    };
    GType gdk_display_get_type(void) __attribute__((__const__));
    GdkDisplay * gdk_display_open(const gchar * display_name);
    const gchar * gdk_display_get_name(GdkDisplay * display);
    gint gdk_display_get_n_screens(GdkDisplay * display);
    GdkScreen * gdk_display_get_screen(GdkDisplay * display, gint screen_num);
    GdkScreen * gdk_display_get_default_screen(GdkDisplay * display);
    void gdk_display_pointer_ungrab(GdkDisplay * display, guint32 time_);
    void gdk_display_keyboard_ungrab(GdkDisplay * display, guint32 time_);
    gboolean gdk_display_pointer_is_grabbed(GdkDisplay * display);
    void gdk_display_beep(GdkDisplay * display);
    void gdk_display_sync(GdkDisplay * display);
    void gdk_display_flush(GdkDisplay * display);
    void gdk_display_close(GdkDisplay * display);
    GList * gdk_display_list_devices(GdkDisplay * display);
    GdkEvent * gdk_display_get_event(GdkDisplay * display);
    GdkEvent * gdk_display_peek_event(GdkDisplay * display);
    void gdk_display_put_event(GdkDisplay * display, GdkEvent * event);
    void gdk_display_add_client_message_filter(GdkDisplay * display, GdkAtom message_type, GdkFilterFunc func, gpointer data);
    void gdk_display_set_double_click_time(GdkDisplay * display, guint msec);
    void gdk_display_set_double_click_distance(GdkDisplay * display, guint distance);
    GdkDisplay * gdk_display_get_default(void);
    GdkDevice * gdk_display_get_core_pointer(GdkDisplay * display);
    void gdk_display_get_pointer(GdkDisplay * display, GdkScreen * * screen, gint * x, gint * y, GdkModifierType * mask);
    GdkWindow * gdk_display_get_window_at_pointer(GdkDisplay * display, gint * win_x, gint * win_y);
    void gdk_display_warp_pointer(GdkDisplay * display, GdkScreen * screen, gint x, gint y);
    GdkDisplayPointerHooks * gdk_display_set_pointer_hooks(GdkDisplay * display, const GdkDisplayPointerHooks * new_hooks);
    GdkDisplay * gdk_display_open_default_libgtk_only(void);
    gboolean gdk_display_supports_cursor_alpha(GdkDisplay * display);
    gboolean gdk_display_supports_cursor_color(GdkDisplay * display);
    guint gdk_display_get_default_cursor_size(GdkDisplay * display);
    void gdk_display_get_maximal_cursor_size(GdkDisplay * display, guint * width, guint * height);
    GdkWindow * gdk_display_get_default_group(GdkDisplay * display);
    gboolean gdk_display_supports_selection_notification(GdkDisplay * display);
    gboolean gdk_display_request_selection_notification(GdkDisplay * display, GdkAtom selection);
    gboolean gdk_display_supports_clipboard_persistence(GdkDisplay * display);
    void gdk_display_store_clipboard(GdkDisplay * display, GdkWindow * clipboard_window, guint32 time_, GdkAtom * targets, gint n_targets);
    gboolean gdk_display_supports_shapes(GdkDisplay * display);
    gboolean gdk_display_supports_input_shapes(GdkDisplay * display);
    gboolean gdk_display_supports_composite(GdkDisplay * display);
}
extern "C"
{
    typedef struct _GdkGCValues GdkGCValues;
    typedef struct _GdkGCClass GdkGCClass;
    typedef enum 
    {
        GDK_CAP_NOT_LAST, 
        GDK_CAP_BUTT, 
        GDK_CAP_ROUND, 
        GDK_CAP_PROJECTING
    } GdkCapStyle;
    typedef enum 
    {
        GDK_SOLID, 
        GDK_TILED, 
        GDK_STIPPLED, 
        GDK_OPAQUE_STIPPLED
    } GdkFill;
    typedef enum 
    {
        GDK_COPY, 
        GDK_INVERT, 
        GDK_XOR, 
        GDK_CLEAR, 
        GDK_AND, 
        GDK_AND_REVERSE, 
        GDK_AND_INVERT, 
        GDK_NOOP, 
        GDK_OR, 
        GDK_EQUIV, 
        GDK_OR_REVERSE, 
        GDK_COPY_INVERT, 
        GDK_OR_INVERT, 
        GDK_NAND, 
        GDK_NOR, 
        GDK_SET
    } GdkFunction;
    typedef enum 
    {
        GDK_JOIN_MITER, 
        GDK_JOIN_ROUND, 
        GDK_JOIN_BEVEL
    } GdkJoinStyle;
    typedef enum 
    {
        GDK_LINE_SOLID, 
        GDK_LINE_ON_OFF_DASH, 
        GDK_LINE_DOUBLE_DASH
    } GdkLineStyle;
    typedef enum 
    {
        GDK_CLIP_BY_CHILDREN = 0, 
        GDK_INCLUDE_INFERIORS = 1
    } GdkSubwindowMode;
    typedef enum 
    {
        GDK_GC_FOREGROUND = 1 << 0, 
        GDK_GC_BACKGROUND = 1 << 1, 
        GDK_GC_FONT = 1 << 2, 
        GDK_GC_FUNCTION = 1 << 3, 
        GDK_GC_FILL = 1 << 4, 
        GDK_GC_TILE = 1 << 5, 
        GDK_GC_STIPPLE = 1 << 6, 
        GDK_GC_CLIP_MASK = 1 << 7, 
        GDK_GC_SUBWINDOW = 1 << 8, 
        GDK_GC_TS_X_ORIGIN = 1 << 9, 
        GDK_GC_TS_Y_ORIGIN = 1 << 10, 
        GDK_GC_CLIP_X_ORIGIN = 1 << 11, 
        GDK_GC_CLIP_Y_ORIGIN = 1 << 12, 
        GDK_GC_EXPOSURES = 1 << 13, 
        GDK_GC_LINE_WIDTH = 1 << 14, 
        GDK_GC_LINE_STYLE = 1 << 15, 
        GDK_GC_CAP_STYLE = 1 << 16, 
        GDK_GC_JOIN_STYLE = 1 << 17
    } GdkGCValuesMask;
    struct _GdkGCValues
    {
            GdkColor foreground;
            GdkColor background;
            GdkFont * font;
            GdkFunction function;
            GdkFill fill;
            GdkPixmap * tile;
            GdkPixmap * stipple;
            GdkPixmap * clip_mask;
            GdkSubwindowMode subwindow_mode;
            gint ts_x_origin;
            gint ts_y_origin;
            gint clip_x_origin;
            gint clip_y_origin;
            gint graphics_exposures;
            gint line_width;
            GdkLineStyle line_style;
            GdkCapStyle cap_style;
            GdkJoinStyle join_style;
    };
    struct _GdkGC
    {
            GObject parent_instance;
            gint clip_x_origin;
            gint clip_y_origin;
            gint ts_x_origin;
            gint ts_y_origin;
            GdkColormap * colormap;
    };
    struct _GdkGCClass
    {
            GObjectClass parent_class;
            void (* get_values)(GdkGC * gc, GdkGCValues * values);
            void (* set_values)(GdkGC * gc, GdkGCValues * values, GdkGCValuesMask mask);
            void (* set_dashes)(GdkGC * gc, gint dash_offset, gint8 dash_list[], gint n);
            void (* _gdk_reserved1)(void);
            void (* _gdk_reserved2)(void);
            void (* _gdk_reserved3)(void);
            void (* _gdk_reserved4)(void);
    };
    GType gdk_gc_get_type(void) __attribute__((__const__));
    GdkGC * gdk_gc_new(GdkDrawable * drawable);
    GdkGC * gdk_gc_new_with_values(GdkDrawable * drawable, GdkGCValues * values, GdkGCValuesMask values_mask);
    GdkGC * gdk_gc_ref(GdkGC * gc);
    void gdk_gc_unref(GdkGC * gc);
    void gdk_gc_get_values(GdkGC * gc, GdkGCValues * values);
    void gdk_gc_set_values(GdkGC * gc, GdkGCValues * values, GdkGCValuesMask values_mask);
    void gdk_gc_set_foreground(GdkGC * gc, const GdkColor * color);
    void gdk_gc_set_background(GdkGC * gc, const GdkColor * color);
    void gdk_gc_set_font(GdkGC * gc, GdkFont * font);
    void gdk_gc_set_function(GdkGC * gc, GdkFunction function);
    void gdk_gc_set_fill(GdkGC * gc, GdkFill fill);
    void gdk_gc_set_tile(GdkGC * gc, GdkPixmap * tile);
    void gdk_gc_set_stipple(GdkGC * gc, GdkPixmap * stipple);
    void gdk_gc_set_ts_origin(GdkGC * gc, gint x, gint y);
    void gdk_gc_set_clip_origin(GdkGC * gc, gint x, gint y);
    void gdk_gc_set_clip_mask(GdkGC * gc, GdkBitmap * mask);
    void gdk_gc_set_clip_rectangle(GdkGC * gc, GdkRectangle * rectangle);
    void gdk_gc_set_clip_region(GdkGC * gc, GdkRegion * region);
    void gdk_gc_set_subwindow(GdkGC * gc, GdkSubwindowMode mode);
    void gdk_gc_set_exposures(GdkGC * gc, gboolean exposures);
    void gdk_gc_set_line_attributes(GdkGC * gc, gint line_width, GdkLineStyle line_style, GdkCapStyle cap_style, GdkJoinStyle join_style);
    void gdk_gc_set_dashes(GdkGC * gc, gint dash_offset, gint8 dash_list[], gint n);
    void gdk_gc_offset(GdkGC * gc, gint x_offset, gint y_offset);
    void gdk_gc_copy(GdkGC * dst_gc, GdkGC * src_gc);
    void gdk_gc_set_colormap(GdkGC * gc, GdkColormap * colormap);
    GdkColormap * gdk_gc_get_colormap(GdkGC * gc);
    void gdk_gc_set_rgb_fg_color(GdkGC * gc, const GdkColor * color);
    void gdk_gc_set_rgb_bg_color(GdkGC * gc, const GdkColor * color);
    GdkScreen * gdk_gc_get_screen(GdkGC * gc);
}
extern "C"
{
    typedef struct _GdkDrawableClass GdkDrawableClass;
    typedef struct _GdkTrapezoid GdkTrapezoid;
    struct _GdkDrawable
    {
            GObject parent_instance;
    };
    struct _GdkDrawableClass
    {
            GObjectClass parent_class;
            GdkGC * (* create_gc)(GdkDrawable * drawable, GdkGCValues * values, GdkGCValuesMask mask);
            void (* draw_rectangle)(GdkDrawable * drawable, GdkGC * gc, gboolean filled, gint x, gint y, gint width, gint height);
            void (* draw_arc)(GdkDrawable * drawable, GdkGC * gc, gboolean filled, gint x, gint y, gint width, gint height, gint angle1, gint angle2);
            void (* draw_polygon)(GdkDrawable * drawable, GdkGC * gc, gboolean filled, GdkPoint * points, gint npoints);
            void (* draw_text)(GdkDrawable * drawable, GdkFont * font, GdkGC * gc, gint x, gint y, const gchar * text, gint text_length);
            void (* draw_text_wc)(GdkDrawable * drawable, GdkFont * font, GdkGC * gc, gint x, gint y, const GdkWChar * text, gint text_length);
            void (* draw_drawable)(GdkDrawable * drawable, GdkGC * gc, GdkDrawable * src, gint xsrc, gint ysrc, gint xdest, gint ydest, gint width, gint height);
            void (* draw_points)(GdkDrawable * drawable, GdkGC * gc, GdkPoint * points, gint npoints);
            void (* draw_segments)(GdkDrawable * drawable, GdkGC * gc, GdkSegment * segs, gint nsegs);
            void (* draw_lines)(GdkDrawable * drawable, GdkGC * gc, GdkPoint * points, gint npoints);
            void (* draw_glyphs)(GdkDrawable * drawable, GdkGC * gc, PangoFont * font, gint x, gint y, PangoGlyphString * glyphs);
            void (* draw_image)(GdkDrawable * drawable, GdkGC * gc, GdkImage * image, gint xsrc, gint ysrc, gint xdest, gint ydest, gint width, gint height);
            gint (* get_depth)(GdkDrawable * drawable);
            void (* get_size)(GdkDrawable * drawable, gint * width, gint * height);
            void (* set_colormap)(GdkDrawable * drawable, GdkColormap * cmap);
            GdkColormap * (* get_colormap)(GdkDrawable * drawable);
            GdkVisual * (* get_visual)(GdkDrawable * drawable);
            GdkScreen * (* get_screen)(GdkDrawable * drawable);
            GdkImage * (* get_image)(GdkDrawable * drawable, gint x, gint y, gint width, gint height);
            GdkRegion * (* get_clip_region)(GdkDrawable * drawable);
            GdkRegion * (* get_visible_region)(GdkDrawable * drawable);
            GdkDrawable * (* get_composite_drawable)(GdkDrawable * drawable, gint x, gint y, gint width, gint height, gint * composite_x_offset, gint * composite_y_offset);
            void (* draw_pixbuf)(GdkDrawable * drawable, GdkGC * gc, GdkPixbuf * pixbuf, gint src_x, gint src_y, gint dest_x, gint dest_y, gint width, gint height, GdkRgbDither dither, gint x_dither, gint y_dither);
            GdkImage * (* _copy_to_image)(GdkDrawable * drawable, GdkImage * image, gint src_x, gint src_y, gint dest_x, gint dest_y, gint width, gint height);
            void (* draw_glyphs_transformed)(GdkDrawable * drawable, GdkGC * gc, PangoMatrix * matrix, PangoFont * font, gint x, gint y, PangoGlyphString * glyphs);
            void (* draw_trapezoids)(GdkDrawable * drawable, GdkGC * gc, GdkTrapezoid * trapezoids, gint n_trapezoids);
            cairo_surface_t * (* ref_cairo_surface)(GdkDrawable * drawable);
            void (* _gdk_reserved4)(void);
            void (* _gdk_reserved5)(void);
            void (* _gdk_reserved6)(void);
            void (* _gdk_reserved7)(void);
            void (* _gdk_reserved9)(void);
            void (* _gdk_reserved10)(void);
            void (* _gdk_reserved11)(void);
            void (* _gdk_reserved12)(void);
            void (* _gdk_reserved13)(void);
            void (* _gdk_reserved14)(void);
            void (* _gdk_reserved15)(void);
            void (* _gdk_reserved16)(void);
    };
    struct _GdkTrapezoid
    {
            double y1, x11, x21, y2, x12, x22;
    };
    GType gdk_drawable_get_type(void) __attribute__((__const__));
    void gdk_drawable_set_data(GdkDrawable * drawable, const gchar * key, gpointer data, GDestroyNotify destroy_func);
    gpointer gdk_drawable_get_data(GdkDrawable * drawable, const gchar * key);
    void gdk_drawable_get_size(GdkDrawable * drawable, gint * width, gint * height);
    void gdk_drawable_set_colormap(GdkDrawable * drawable, GdkColormap * colormap);
    GdkColormap * gdk_drawable_get_colormap(GdkDrawable * drawable);
    GdkVisual * gdk_drawable_get_visual(GdkDrawable * drawable);
    gint gdk_drawable_get_depth(GdkDrawable * drawable);
    GdkScreen * gdk_drawable_get_screen(GdkDrawable * drawable);
    GdkDisplay * gdk_drawable_get_display(GdkDrawable * drawable);
    GdkDrawable * gdk_drawable_ref(GdkDrawable * drawable);
    void gdk_drawable_unref(GdkDrawable * drawable);
    void gdk_draw_point(GdkDrawable * drawable, GdkGC * gc, gint x, gint y);
    void gdk_draw_line(GdkDrawable * drawable, GdkGC * gc, gint x1_, gint y1_, gint x2_, gint y2_);
    void gdk_draw_rectangle(GdkDrawable * drawable, GdkGC * gc, gboolean filled, gint x, gint y, gint width, gint height);
    void gdk_draw_arc(GdkDrawable * drawable, GdkGC * gc, gboolean filled, gint x, gint y, gint width, gint height, gint angle1, gint angle2);
    void gdk_draw_polygon(GdkDrawable * drawable, GdkGC * gc, gboolean filled, GdkPoint * points, gint npoints);
    void gdk_draw_string(GdkDrawable * drawable, GdkFont * font, GdkGC * gc, gint x, gint y, const gchar * string);
    void gdk_draw_text(GdkDrawable * drawable, GdkFont * font, GdkGC * gc, gint x, gint y, const gchar * text, gint text_length);
    void gdk_draw_text_wc(GdkDrawable * drawable, GdkFont * font, GdkGC * gc, gint x, gint y, const GdkWChar * text, gint text_length);
    void gdk_draw_drawable(GdkDrawable * drawable, GdkGC * gc, GdkDrawable * src, gint xsrc, gint ysrc, gint xdest, gint ydest, gint width, gint height);
    void gdk_draw_image(GdkDrawable * drawable, GdkGC * gc, GdkImage * image, gint xsrc, gint ysrc, gint xdest, gint ydest, gint width, gint height);
    void gdk_draw_points(GdkDrawable * drawable, GdkGC * gc, GdkPoint * points, gint npoints);
    void gdk_draw_segments(GdkDrawable * drawable, GdkGC * gc, GdkSegment * segs, gint nsegs);
    void gdk_draw_lines(GdkDrawable * drawable, GdkGC * gc, GdkPoint * points, gint npoints);
    void gdk_draw_pixbuf(GdkDrawable * drawable, GdkGC * gc, GdkPixbuf * pixbuf, gint src_x, gint src_y, gint dest_x, gint dest_y, gint width, gint height, GdkRgbDither dither, gint x_dither, gint y_dither);
    void gdk_draw_glyphs(GdkDrawable * drawable, GdkGC * gc, PangoFont * font, gint x, gint y, PangoGlyphString * glyphs);
    void gdk_draw_layout_line(GdkDrawable * drawable, GdkGC * gc, gint x, gint y, PangoLayoutLine * line);
    void gdk_draw_layout(GdkDrawable * drawable, GdkGC * gc, gint x, gint y, PangoLayout * layout);
    void gdk_draw_layout_line_with_colors(GdkDrawable * drawable, GdkGC * gc, gint x, gint y, PangoLayoutLine * line, const GdkColor * foreground, const GdkColor * background);
    void gdk_draw_layout_with_colors(GdkDrawable * drawable, GdkGC * gc, gint x, gint y, PangoLayout * layout, const GdkColor * foreground, const GdkColor * background);
    void gdk_draw_glyphs_transformed(GdkDrawable * drawable, GdkGC * gc, PangoMatrix * matrix, PangoFont * font, gint x, gint y, PangoGlyphString * glyphs);
    void gdk_draw_trapezoids(GdkDrawable * drawable, GdkGC * gc, GdkTrapezoid * trapezoids, gint n_trapezoids);
    GdkImage * gdk_drawable_get_image(GdkDrawable * drawable, gint x, gint y, gint width, gint height);
    GdkImage * gdk_drawable_copy_to_image(GdkDrawable * drawable, GdkImage * image, gint src_x, gint src_y, gint dest_x, gint dest_y, gint width, gint height);
    GdkRegion * gdk_drawable_get_clip_region(GdkDrawable * drawable);
    GdkRegion * gdk_drawable_get_visible_region(GdkDrawable * drawable);
}
extern "C"
{
    GType gdk_cursor_type_get_type(void) __attribute__((__const__));
    GType gdk_drag_action_get_type(void) __attribute__((__const__));
    GType gdk_drag_protocol_get_type(void) __attribute__((__const__));
    GType gdk_filter_return_get_type(void) __attribute__((__const__));
    GType gdk_event_type_get_type(void) __attribute__((__const__));
    GType gdk_event_mask_get_type(void) __attribute__((__const__));
    GType gdk_visibility_state_get_type(void) __attribute__((__const__));
    GType gdk_scroll_direction_get_type(void) __attribute__((__const__));
    GType gdk_notify_type_get_type(void) __attribute__((__const__));
    GType gdk_crossing_mode_get_type(void) __attribute__((__const__));
    GType gdk_property_state_get_type(void) __attribute__((__const__));
    GType gdk_window_state_get_type(void) __attribute__((__const__));
    GType gdk_setting_action_get_type(void) __attribute__((__const__));
    GType gdk_owner_change_get_type(void) __attribute__((__const__));
    GType gdk_font_type_get_type(void) __attribute__((__const__));
    GType gdk_cap_style_get_type(void) __attribute__((__const__));
    GType gdk_fill_get_type(void) __attribute__((__const__));
    GType gdk_function_get_type(void) __attribute__((__const__));
    GType gdk_join_style_get_type(void) __attribute__((__const__));
    GType gdk_line_style_get_type(void) __attribute__((__const__));
    GType gdk_subwindow_mode_get_type(void) __attribute__((__const__));
    GType gdk_gc_values_mask_get_type(void) __attribute__((__const__));
    GType gdk_image_type_get_type(void) __attribute__((__const__));
    GType gdk_extension_mode_get_type(void) __attribute__((__const__));
    GType gdk_input_source_get_type(void) __attribute__((__const__));
    GType gdk_input_mode_get_type(void) __attribute__((__const__));
    GType gdk_axis_use_get_type(void) __attribute__((__const__));
    GType gdk_prop_mode_get_type(void) __attribute__((__const__));
    GType gdk_fill_rule_get_type(void) __attribute__((__const__));
    GType gdk_overlap_type_get_type(void) __attribute__((__const__));
    GType gdk_rgb_dither_get_type(void) __attribute__((__const__));
    GType gdk_byte_order_get_type(void) __attribute__((__const__));
    GType gdk_modifier_type_get_type(void) __attribute__((__const__));
    GType gdk_input_condition_get_type(void) __attribute__((__const__));
    GType gdk_status_get_type(void) __attribute__((__const__));
    GType gdk_grab_status_get_type(void) __attribute__((__const__));
    GType gdk_visual_type_get_type(void) __attribute__((__const__));
    GType gdk_window_class_get_type(void) __attribute__((__const__));
    GType gdk_window_type_get_type(void) __attribute__((__const__));
    GType gdk_window_attributes_type_get_type(void) __attribute__((__const__));
    GType gdk_window_hints_get_type(void) __attribute__((__const__));
    GType gdk_window_type_hint_get_type(void) __attribute__((__const__));
    GType gdk_wm_decoration_get_type(void) __attribute__((__const__));
    GType gdk_wm_function_get_type(void) __attribute__((__const__));
    GType gdk_gravity_get_type(void) __attribute__((__const__));
    GType gdk_window_edge_get_type(void) __attribute__((__const__));
}
extern "C"
{
    typedef enum 
    {
        GDK_FONT_FONT, 
        GDK_FONT_FONTSET
    } GdkFontType;
    struct _GdkFont
    {
            GdkFontType type;
            gint ascent;
            gint descent;
    };
    GType gdk_font_get_type(void) __attribute__((__const__));
    GdkFont * gdk_font_ref(GdkFont * font);
    void gdk_font_unref(GdkFont * font);
    gint gdk_font_id(const GdkFont * font);
    gboolean gdk_font_equal(const GdkFont * fonta, const GdkFont * fontb);
    GdkFont * gdk_font_load_for_display(GdkDisplay * display, const gchar * font_name);
    GdkFont * gdk_fontset_load_for_display(GdkDisplay * display, const gchar * fontset_name);
    GdkFont * gdk_font_from_description_for_display(GdkDisplay * display, PangoFontDescription * font_desc);
    GdkFont * gdk_font_load(const gchar * font_name);
    GdkFont * gdk_fontset_load(const gchar * fontset_name);
    GdkFont * gdk_font_from_description(PangoFontDescription * font_desc);
    gint gdk_string_width(GdkFont * font, const gchar * string);
    gint gdk_text_width(GdkFont * font, const gchar * text, gint text_length);
    gint gdk_text_width_wc(GdkFont * font, const GdkWChar * text, gint text_length);
    gint gdk_char_width(GdkFont * font, gchar character);
    gint gdk_char_width_wc(GdkFont * font, GdkWChar character);
    gint gdk_string_measure(GdkFont * font, const gchar * string);
    gint gdk_text_measure(GdkFont * font, const gchar * text, gint text_length);
    gint gdk_char_measure(GdkFont * font, gchar character);
    gint gdk_string_height(GdkFont * font, const gchar * string);
    gint gdk_text_height(GdkFont * font, const gchar * text, gint text_length);
    gint gdk_char_height(GdkFont * font, gchar character);
    void gdk_text_extents(GdkFont * font, const gchar * text, gint text_length, gint * lbearing, gint * rbearing, gint * width, gint * ascent, gint * descent);
    void gdk_text_extents_wc(GdkFont * font, const GdkWChar * text, gint text_length, gint * lbearing, gint * rbearing, gint * width, gint * ascent, gint * descent);
    void gdk_string_extents(GdkFont * font, const gchar * string, gint * lbearing, gint * rbearing, gint * width, gint * ascent, gint * descent);
    GdkDisplay * gdk_font_get_display(GdkFont * font);
}
extern "C"
{
    typedef enum 
    {
        GDK_IMAGE_NORMAL, 
        GDK_IMAGE_SHARED, 
        GDK_IMAGE_FASTEST
    } GdkImageType;
    typedef struct _GdkImageClass GdkImageClass;
    struct _GdkImage
    {
            GObject parent_instance;
            GdkImageType type;
            GdkVisual * visual;
            GdkByteOrder byte_order;
            gint width;
            gint height;
            guint16 depth;
            guint16 bpp;
            guint16 bpl;
            guint16 bits_per_pixel;
            gpointer mem;
            GdkColormap * colormap;
            gpointer windowing_data;
    };
    struct _GdkImageClass
    {
            GObjectClass parent_class;
    };
    GType gdk_image_get_type(void) __attribute__((__const__));
    GdkImage * gdk_image_new(GdkImageType type, GdkVisual * visual, gint width, gint height);
    GdkImage * gdk_image_get(GdkDrawable * drawable, gint x, gint y, gint width, gint height);
    GdkImage * gdk_image_ref(GdkImage * image);
    void gdk_image_unref(GdkImage * image);
    void gdk_image_put_pixel(GdkImage * image, gint x, gint y, guint32 pixel);
    guint32 gdk_image_get_pixel(GdkImage * image, gint x, gint y);
    void gdk_image_set_colormap(GdkImage * image, GdkColormap * colormap);
    GdkColormap * gdk_image_get_colormap(GdkImage * image);
}
extern "C"
{
    typedef struct _GdkKeymapKey GdkKeymapKey;
    struct _GdkKeymapKey
    {
            guint keycode;
            gint group;
            gint level;
    };
    typedef struct _GdkKeymap GdkKeymap;
    typedef struct _GdkKeymapClass GdkKeymapClass;
    struct _GdkKeymap
    {
            GObject parent_instance;
            GdkDisplay * display;
    };
    struct _GdkKeymapClass
    {
            GObjectClass parent_class;
            void (* direction_changed)(GdkKeymap * keymap);
            void (* keys_changed)(GdkKeymap * keymap);
    };
    GType gdk_keymap_get_type(void) __attribute__((__const__));
    GdkKeymap * gdk_keymap_get_default(void);
    GdkKeymap * gdk_keymap_get_for_display(GdkDisplay * display);
    guint gdk_keymap_lookup_key(GdkKeymap * keymap, const GdkKeymapKey * key);
    gboolean gdk_keymap_translate_keyboard_state(GdkKeymap * keymap, guint hardware_keycode, GdkModifierType state, gint group, guint * keyval, gint * effective_group, gint * level, GdkModifierType * consumed_modifiers);
    gboolean gdk_keymap_get_entries_for_keyval(GdkKeymap * keymap, guint keyval, GdkKeymapKey * * keys, gint * n_keys);
    gboolean gdk_keymap_get_entries_for_keycode(GdkKeymap * keymap, guint hardware_keycode, GdkKeymapKey * * keys, guint * * keyvals, gint * n_entries);
    PangoDirection gdk_keymap_get_direction(GdkKeymap * keymap);
    gboolean gdk_keymap_have_bidi_layouts(GdkKeymap * keymap);
    gchar * gdk_keyval_name(guint keyval) __attribute__((__const__));
    guint gdk_keyval_from_name(const gchar * keyval_name);
    void gdk_keyval_convert_case(guint symbol, guint * lower, guint * upper);
    guint gdk_keyval_to_upper(guint keyval) __attribute__((__const__));
    guint gdk_keyval_to_lower(guint keyval) __attribute__((__const__));
    gboolean gdk_keyval_is_upper(guint keyval) __attribute__((__const__));
    gboolean gdk_keyval_is_lower(guint keyval) __attribute__((__const__));
    guint32 gdk_keyval_to_unicode(guint keyval) __attribute__((__const__));
    guint gdk_unicode_to_keyval(guint32 wc) __attribute__((__const__));
}
extern "C"
{
    typedef struct _GdkDisplayManager GdkDisplayManager;
    typedef struct _GdkDisplayManagerClass GdkDisplayManagerClass;
    struct _GdkDisplayManagerClass
    {
            GObjectClass parent_class;
            void (* display_opened)(GdkDisplayManager * display_manager, GdkDisplay * display);
    };
    GType gdk_display_manager_get_type(void) __attribute__((__const__));
    GdkDisplayManager * gdk_display_manager_get(void);
    GdkDisplay * gdk_display_manager_get_default_display(GdkDisplayManager * display_manager);
    void gdk_display_manager_set_default_display(GdkDisplayManager * display_manager, GdkDisplay * display);
    GSList * gdk_display_manager_list_displays(GdkDisplayManager * display_manager);
}
extern "C"
{
    typedef struct _GdkPangoRenderer GdkPangoRenderer;
    typedef struct _GdkPangoRendererClass GdkPangoRendererClass;
    typedef struct _GdkPangoRendererPrivate GdkPangoRendererPrivate;
    struct _GdkPangoRenderer
    {
            PangoRenderer parent_instance;
            GdkPangoRendererPrivate * priv;
    };
    struct _GdkPangoRendererClass
    {
            PangoRendererClass parent_class;
    };
    GType gdk_pango_renderer_get_type(void) __attribute__((__const__));
    PangoRenderer * gdk_pango_renderer_new(GdkScreen * screen);
    PangoRenderer * gdk_pango_renderer_get_default(GdkScreen * screen);
    void gdk_pango_renderer_set_drawable(GdkPangoRenderer * gdk_renderer, GdkDrawable * drawable);
    void gdk_pango_renderer_set_gc(GdkPangoRenderer * gdk_renderer, GdkGC * gc);
    void gdk_pango_renderer_set_stipple(GdkPangoRenderer * gdk_renderer, PangoRenderPart part, GdkBitmap * stipple);
    void gdk_pango_renderer_set_override_color(GdkPangoRenderer * gdk_renderer, PangoRenderPart part, const GdkColor * color);
    PangoContext * gdk_pango_context_get_for_screen(GdkScreen * screen);
    PangoContext * gdk_pango_context_get(void);
    void gdk_pango_context_set_colormap(PangoContext * context, GdkColormap * colormap);
    GdkRegion * gdk_pango_layout_line_get_clip_region(PangoLayoutLine * line, gint x_origin, gint y_origin, gint * index_ranges, gint n_ranges);
    GdkRegion * gdk_pango_layout_get_clip_region(PangoLayout * layout, gint x_origin, gint y_origin, gint * index_ranges, gint n_ranges);
    typedef struct _GdkPangoAttrStipple GdkPangoAttrStipple;
    typedef struct _GdkPangoAttrEmbossed GdkPangoAttrEmbossed;
    typedef struct _GdkPangoAttrEmbossColor GdkPangoAttrEmbossColor;
    struct _GdkPangoAttrStipple
    {
            PangoAttribute attr;
            GdkBitmap * stipple;
    };
    struct _GdkPangoAttrEmbossed
    {
            PangoAttribute attr;
            gboolean embossed;
    };
    struct _GdkPangoAttrEmbossColor
    {
            PangoAttribute attr;
            PangoColor color;
    };
    PangoAttribute * gdk_pango_attr_stipple_new(GdkBitmap * stipple);
    PangoAttribute * gdk_pango_attr_embossed_new(gboolean embossed);
    PangoAttribute * gdk_pango_attr_emboss_color_new(const GdkColor * color);
}
extern "C"
{
    typedef struct _GdkPixmapObject GdkPixmapObject;
    typedef struct _GdkPixmapObjectClass GdkPixmapObjectClass;
    struct _GdkPixmapObject
    {
            GdkDrawable parent_instance;
            GdkDrawable * impl;
            gint depth;
    };
    struct _GdkPixmapObjectClass
    {
            GdkDrawableClass parent_class;
    };
    GType gdk_pixmap_get_type(void) __attribute__((__const__));
    GdkPixmap * gdk_pixmap_new(GdkDrawable * drawable, gint width, gint height, gint depth);
    GdkBitmap * gdk_bitmap_create_from_data(GdkDrawable * drawable, const gchar * data, gint width, gint height);
    GdkPixmap * gdk_pixmap_create_from_data(GdkDrawable * drawable, const gchar * data, gint width, gint height, gint depth, const GdkColor * fg, const GdkColor * bg);
    GdkPixmap * gdk_pixmap_create_from_xpm(GdkDrawable * drawable, GdkBitmap * * mask, const GdkColor * transparent_color, const gchar * filename);
    GdkPixmap * gdk_pixmap_colormap_create_from_xpm(GdkDrawable * drawable, GdkColormap * colormap, GdkBitmap * * mask, const GdkColor * transparent_color, const gchar * filename);
    GdkPixmap * gdk_pixmap_create_from_xpm_d(GdkDrawable * drawable, GdkBitmap * * mask, const GdkColor * transparent_color, gchar * * data);
    GdkPixmap * gdk_pixmap_colormap_create_from_xpm_d(GdkDrawable * drawable, GdkColormap * colormap, GdkBitmap * * mask, const GdkColor * transparent_color, gchar * * data);
    GdkPixmap * gdk_pixmap_foreign_new(GdkNativeWindow anid);
    GdkPixmap * gdk_pixmap_lookup(GdkNativeWindow anid);
    GdkPixmap * gdk_pixmap_foreign_new_for_display(GdkDisplay * display, GdkNativeWindow anid);
    GdkPixmap * gdk_pixmap_lookup_for_display(GdkDisplay * display, GdkNativeWindow anid);
    GdkPixmap * gdk_pixmap_foreign_new_for_screen(GdkScreen * screen, GdkNativeWindow anid, gint width, gint height, gint depth);
}
extern "C"
{
    typedef enum 
    {
        GDK_PROP_MODE_REPLACE, 
        GDK_PROP_MODE_PREPEND, 
        GDK_PROP_MODE_APPEND
    } GdkPropMode;
    GdkAtom gdk_atom_intern(const gchar * atom_name, gboolean only_if_exists);
    GdkAtom gdk_atom_intern_static_string(const gchar * atom_name);
    gchar * gdk_atom_name(GdkAtom atom);
    gboolean gdk_property_get(GdkWindow * window, GdkAtom property, GdkAtom type, gulong offset, gulong length, gint pdelete, GdkAtom * actual_property_type, gint * actual_format, gint * actual_length, guchar * * data);
    void gdk_property_change(GdkWindow * window, GdkAtom property, GdkAtom type, gint format, GdkPropMode mode, const guchar * data, gint nelements);
    void gdk_property_delete(GdkWindow * window, GdkAtom property);
    gint gdk_text_property_to_text_list(GdkAtom encoding, gint format, const guchar * text, gint length, gchar * * * list);
    gint gdk_text_property_to_utf8_list(GdkAtom encoding, gint format, const guchar * text, gint length, gchar * * * list);
    gboolean gdk_utf8_to_compound_text(const gchar * str, GdkAtom * encoding, gint * format, guchar * * ctext, gint * length);
    gint gdk_string_to_compound_text(const gchar * str, GdkAtom * encoding, gint * format, guchar * * ctext, gint * length);
    gint gdk_text_property_to_text_list_for_display(GdkDisplay * display, GdkAtom encoding, gint format, const guchar * text, gint length, gchar * * * list);
    gint gdk_text_property_to_utf8_list_for_display(GdkDisplay * display, GdkAtom encoding, gint format, const guchar * text, gint length, gchar * * * list);
    gchar * gdk_utf8_to_string_target(const gchar * str);
    gint gdk_string_to_compound_text_for_display(GdkDisplay * display, const gchar * str, GdkAtom * encoding, gint * format, guchar * * ctext, gint * length);
    gboolean gdk_utf8_to_compound_text_for_display(GdkDisplay * display, const gchar * str, GdkAtom * encoding, gint * format, guchar * * ctext, gint * length);
    void gdk_free_text_list(gchar * * list);
    void gdk_free_compound_text(guchar * ctext);
}
extern "C"
{
    typedef enum 
    {
        GDK_EVEN_ODD_RULE, 
        GDK_WINDING_RULE
    } GdkFillRule;
    typedef enum 
    {
        GDK_OVERLAP_RECTANGLE_IN, 
        GDK_OVERLAP_RECTANGLE_OUT, 
        GDK_OVERLAP_RECTANGLE_PART
    } GdkOverlapType;
    typedef void (* GdkSpanFunc)(GdkSpan * span, gpointer data);
    GdkRegion * gdk_region_new(void);
    GdkRegion * gdk_region_polygon(GdkPoint * points, gint npoints, GdkFillRule fill_rule);
    GdkRegion * gdk_region_copy(GdkRegion * region);
    GdkRegion * gdk_region_rectangle(GdkRectangle * rectangle);
    void gdk_region_destroy(GdkRegion * region);
    void gdk_region_get_clipbox(GdkRegion * region, GdkRectangle * rectangle);
    void gdk_region_get_rectangles(GdkRegion * region, GdkRectangle * * rectangles, gint * n_rectangles);
    gboolean gdk_region_empty(GdkRegion * region);
    gboolean gdk_region_equal(GdkRegion * region1, GdkRegion * region2);
    gboolean gdk_region_point_in(GdkRegion * region, int x, int y);
    GdkOverlapType gdk_region_rect_in(GdkRegion * region, GdkRectangle * rectangle);
    void gdk_region_offset(GdkRegion * region, gint dx, gint dy);
    void gdk_region_shrink(GdkRegion * region, gint dx, gint dy);
    void gdk_region_union_with_rect(GdkRegion * region, GdkRectangle * rect);
    void gdk_region_intersect(GdkRegion * source1, GdkRegion * source2);
    void gdk_region_union(GdkRegion * source1, GdkRegion * source2);
    void gdk_region_subtract(GdkRegion * source1, GdkRegion * source2);
    void gdk_region_xor(GdkRegion * source1, GdkRegion * source2);
    void gdk_region_spans_intersect_foreach(GdkRegion * region, GdkSpan * spans, int n_spans, gboolean sorted, GdkSpanFunc function, gpointer data);
}
extern "C"
{
    typedef struct _GdkScreenClass GdkScreenClass;
    struct _GdkScreen
    {
            GObject parent_instance;
            guint closed : 1;
            GdkGC * normal_gcs[32];
            GdkGC * exposure_gcs[32];
            cairo_font_options_t * font_options;
            double resolution;
    };
    struct _GdkScreenClass
    {
            GObjectClass parent_class;
            void (* size_changed)(GdkScreen * screen);
            void (* composited_changed)(GdkScreen * screen);
    };
    GType gdk_screen_get_type(void) __attribute__((__const__));
    GdkColormap * gdk_screen_get_default_colormap(GdkScreen * screen);
    void gdk_screen_set_default_colormap(GdkScreen * screen, GdkColormap * colormap);
    GdkColormap * gdk_screen_get_system_colormap(GdkScreen * screen);
    GdkVisual * gdk_screen_get_system_visual(GdkScreen * screen);
    GdkColormap * gdk_screen_get_rgb_colormap(GdkScreen * screen);
    GdkVisual * gdk_screen_get_rgb_visual(GdkScreen * screen);
    GdkColormap * gdk_screen_get_rgba_colormap(GdkScreen * screen);
    GdkVisual * gdk_screen_get_rgba_visual(GdkScreen * screen);
    gboolean gdk_screen_is_composited(GdkScreen * screen);
    GdkWindow * gdk_screen_get_root_window(GdkScreen * screen);
    GdkDisplay * gdk_screen_get_display(GdkScreen * screen);
    gint gdk_screen_get_number(GdkScreen * screen);
    gint gdk_screen_get_width(GdkScreen * screen);
    gint gdk_screen_get_height(GdkScreen * screen);
    gint gdk_screen_get_width_mm(GdkScreen * screen);
    gint gdk_screen_get_height_mm(GdkScreen * screen);
    GList * gdk_screen_list_visuals(GdkScreen * screen);
    GList * gdk_screen_get_toplevel_windows(GdkScreen * screen);
    gchar * gdk_screen_make_display_name(GdkScreen * screen);
    gint gdk_screen_get_n_monitors(GdkScreen * screen);
    void gdk_screen_get_monitor_geometry(GdkScreen * screen, gint monitor_num, GdkRectangle * dest);
    gint gdk_screen_get_monitor_at_point(GdkScreen * screen, gint x, gint y);
    gint gdk_screen_get_monitor_at_window(GdkScreen * screen, GdkWindow * window);
    void gdk_screen_broadcast_client_message(GdkScreen * screen, GdkEvent * event);
    GdkScreen * gdk_screen_get_default(void);
    gboolean gdk_screen_get_setting(GdkScreen * screen, const gchar * name, GValue * value);
    void gdk_screen_set_font_options(GdkScreen * screen, const cairo_font_options_t * options);
    const cairo_font_options_t * gdk_screen_get_font_options(GdkScreen * screen);
    void gdk_screen_set_resolution(GdkScreen * screen, gdouble dpi);
    gdouble gdk_screen_get_resolution(GdkScreen * screen);
    GdkWindow * gdk_screen_get_active_window(GdkScreen * screen);
    GList * gdk_screen_get_window_stack(GdkScreen * screen);
}
extern "C"
{
    typedef GdkAtom GdkSelection;
    typedef GdkAtom GdkTarget;
    typedef GdkAtom GdkSelectionType;
    gboolean gdk_selection_owner_set(GdkWindow * owner, GdkAtom selection, guint32 time_, gboolean send_event);
    GdkWindow * gdk_selection_owner_get(GdkAtom selection);
    gboolean gdk_selection_owner_set_for_display(GdkDisplay * display, GdkWindow * owner, GdkAtom selection, guint32 time_, gboolean send_event);
    GdkWindow * gdk_selection_owner_get_for_display(GdkDisplay * display, GdkAtom selection);
    void gdk_selection_convert(GdkWindow * requestor, GdkAtom selection, GdkAtom target, guint32 time_);
    gboolean gdk_selection_property_get(GdkWindow * requestor, guchar * * data, GdkAtom * prop_type, gint * prop_format);
    void gdk_selection_send_notify(guint32 requestor, GdkAtom selection, GdkAtom target, GdkAtom property, guint32 time_);
    void gdk_selection_send_notify_for_display(GdkDisplay * display, guint32 requestor, GdkAtom selection, GdkAtom target, GdkAtom property, guint32 time_);
}
extern "C"
{
    gboolean gdk_spawn_on_screen(GdkScreen * screen, const gchar * working_directory, gchar * * argv, gchar * * envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gint * child_pid, GError * * error);
    gboolean gdk_spawn_on_screen_with_pipes(GdkScreen * screen, const gchar * working_directory, gchar * * argv, gchar * * envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gint * child_pid, gint * standard_input, gint * standard_output, gint * standard_error, GError * * error);
    gboolean gdk_spawn_command_line_on_screen(GdkScreen * screen, const gchar * command_line, GError * * error);
}
extern "C"
{
    typedef struct _GdkVisualClass GdkVisualClass;
    typedef enum 
    {
        GDK_VISUAL_STATIC_GRAY, 
        GDK_VISUAL_GRAYSCALE, 
        GDK_VISUAL_STATIC_COLOR, 
        GDK_VISUAL_PSEUDO_COLOR, 
        GDK_VISUAL_TRUE_COLOR, 
        GDK_VISUAL_DIRECT_COLOR
    } GdkVisualType;
    struct _GdkVisual
    {
            GObject parent_instance;
            GdkVisualType type;
            gint depth;
            GdkByteOrder byte_order;
            gint colormap_size;
            gint bits_per_rgb;
            guint32 red_mask;
            gint red_shift;
            gint red_prec;
            guint32 green_mask;
            gint green_shift;
            gint green_prec;
            guint32 blue_mask;
            gint blue_shift;
            gint blue_prec;
    };
    GType gdk_visual_get_type(void) __attribute__((__const__));
    gint gdk_visual_get_best_depth(void);
    GdkVisualType gdk_visual_get_best_type(void);
    GdkVisual * gdk_visual_get_system(void);
    GdkVisual * gdk_visual_get_best(void);
    GdkVisual * gdk_visual_get_best_with_depth(gint depth);
    GdkVisual * gdk_visual_get_best_with_type(GdkVisualType visual_type);
    GdkVisual * gdk_visual_get_best_with_both(gint depth, GdkVisualType visual_type);
    void gdk_query_depths(gint * * depths, gint * count);
    void gdk_query_visual_types(GdkVisualType * * visual_types, gint * count);
    GList * gdk_list_visuals(void);
    GdkScreen * gdk_visual_get_screen(GdkVisual * visual);
}
extern "C"
{
    typedef struct _GdkGeometry GdkGeometry;
    typedef struct _GdkWindowAttr GdkWindowAttr;
    typedef struct _GdkPointerHooks GdkPointerHooks;
    typedef enum 
    {
        GDK_INPUT_OUTPUT, 
        GDK_INPUT_ONLY
    } GdkWindowClass;
    typedef enum 
    {
        GDK_WINDOW_ROOT, 
        GDK_WINDOW_TOPLEVEL, 
        GDK_WINDOW_CHILD, 
        GDK_WINDOW_DIALOG, 
        GDK_WINDOW_TEMP, 
        GDK_WINDOW_FOREIGN
    } GdkWindowType;
    typedef enum 
    {
        GDK_WA_TITLE = 1 << 1, 
        GDK_WA_X = 1 << 2, 
        GDK_WA_Y = 1 << 3, 
        GDK_WA_CURSOR = 1 << 4, 
        GDK_WA_COLORMAP = 1 << 5, 
        GDK_WA_VISUAL = 1 << 6, 
        GDK_WA_WMCLASS = 1 << 7, 
        GDK_WA_NOREDIR = 1 << 8, 
        GDK_WA_TYPE_HINT = 1 << 9
    } GdkWindowAttributesType;
    typedef enum 
    {
        GDK_HINT_POS = 1 << 0, 
        GDK_HINT_MIN_SIZE = 1 << 1, 
        GDK_HINT_MAX_SIZE = 1 << 2, 
        GDK_HINT_BASE_SIZE = 1 << 3, 
        GDK_HINT_ASPECT = 1 << 4, 
        GDK_HINT_RESIZE_INC = 1 << 5, 
        GDK_HINT_WIN_GRAVITY = 1 << 6, 
        GDK_HINT_USER_POS = 1 << 7, 
        GDK_HINT_USER_SIZE = 1 << 8
    } GdkWindowHints;
    typedef enum 
    {
        GDK_WINDOW_TYPE_HINT_NORMAL, 
        GDK_WINDOW_TYPE_HINT_DIALOG, 
        GDK_WINDOW_TYPE_HINT_MENU, 
        GDK_WINDOW_TYPE_HINT_TOOLBAR, 
        GDK_WINDOW_TYPE_HINT_SPLASHSCREEN, 
        GDK_WINDOW_TYPE_HINT_UTILITY, 
        GDK_WINDOW_TYPE_HINT_DOCK, 
        GDK_WINDOW_TYPE_HINT_DESKTOP, 
        GDK_WINDOW_TYPE_HINT_DROPDOWN_MENU, 
        GDK_WINDOW_TYPE_HINT_POPUP_MENU, 
        GDK_WINDOW_TYPE_HINT_TOOLTIP, 
        GDK_WINDOW_TYPE_HINT_NOTIFICATION, 
        GDK_WINDOW_TYPE_HINT_COMBO, 
        GDK_WINDOW_TYPE_HINT_DND
    } GdkWindowTypeHint;
    typedef enum 
    {
        GDK_DECOR_ALL = 1 << 0, 
        GDK_DECOR_BORDER = 1 << 1, 
        GDK_DECOR_RESIZEH = 1 << 2, 
        GDK_DECOR_TITLE = 1 << 3, 
        GDK_DECOR_MENU = 1 << 4, 
        GDK_DECOR_MINIMIZE = 1 << 5, 
        GDK_DECOR_MAXIMIZE = 1 << 6
    } GdkWMDecoration;
    typedef enum 
    {
        GDK_FUNC_ALL = 1 << 0, 
        GDK_FUNC_RESIZE = 1 << 1, 
        GDK_FUNC_MOVE = 1 << 2, 
        GDK_FUNC_MINIMIZE = 1 << 3, 
        GDK_FUNC_MAXIMIZE = 1 << 4, 
        GDK_FUNC_CLOSE = 1 << 5
    } GdkWMFunction;
    typedef enum 
    {
        GDK_GRAVITY_NORTH_WEST = 1, 
        GDK_GRAVITY_NORTH, 
        GDK_GRAVITY_NORTH_EAST, 
        GDK_GRAVITY_WEST, 
        GDK_GRAVITY_CENTER, 
        GDK_GRAVITY_EAST, 
        GDK_GRAVITY_SOUTH_WEST, 
        GDK_GRAVITY_SOUTH, 
        GDK_GRAVITY_SOUTH_EAST, 
        GDK_GRAVITY_STATIC
    } GdkGravity;
    typedef enum 
    {
        GDK_WINDOW_EDGE_NORTH_WEST, 
        GDK_WINDOW_EDGE_NORTH, 
        GDK_WINDOW_EDGE_NORTH_EAST, 
        GDK_WINDOW_EDGE_WEST, 
        GDK_WINDOW_EDGE_EAST, 
        GDK_WINDOW_EDGE_SOUTH_WEST, 
        GDK_WINDOW_EDGE_SOUTH, 
        GDK_WINDOW_EDGE_SOUTH_EAST
    } GdkWindowEdge;
    struct _GdkWindowAttr
    {
            gchar * title;
            gint event_mask;
            gint x, y;
            gint width;
            gint height;
            GdkWindowClass wclass;
            GdkVisual * visual;
            GdkColormap * colormap;
            GdkWindowType window_type;
            GdkCursor * cursor;
            gchar * wmclass_name;
            gchar * wmclass_class;
            gboolean override_redirect;
            GdkWindowTypeHint type_hint;
    };
    struct _GdkGeometry
    {
            gint min_width;
            gint min_height;
            gint max_width;
            gint max_height;
            gint base_width;
            gint base_height;
            gint width_inc;
            gint height_inc;
            gdouble min_aspect;
            gdouble max_aspect;
            GdkGravity win_gravity;
    };
    struct _GdkPointerHooks
    {
            GdkWindow * (* get_pointer)(GdkWindow * window, gint * x, gint * y, GdkModifierType * mask);
            GdkWindow * (* window_at_pointer)(GdkScreen * screen, gint * win_x, gint * win_y);
    };
    typedef struct _GdkWindowObject GdkWindowObject;
    typedef struct _GdkWindowObjectClass GdkWindowObjectClass;
    struct _GdkWindowObject
    {
            GdkDrawable parent_instance;
            GdkDrawable * impl;
            GdkWindowObject * parent;
            gpointer user_data;
            gint x;
            gint y;
            gint extension_events;
            GList * filters;
            GList * children;
            GdkColor bg_color;
            GdkPixmap * bg_pixmap;
            GSList * paint_stack;
            GdkRegion * update_area;
            guint update_freeze_count;
            guint8 window_type;
            guint8 depth;
            guint8 resize_count;
            GdkWindowState state;
            guint guffaw_gravity : 1;
            guint input_only : 1;
            guint modal_hint : 1;
            guint composited : 1;
            guint destroyed : 2;
            guint accept_focus : 1;
            guint focus_on_map : 1;
            guint shaped : 1;
            GdkEventMask event_mask;
            guint update_and_descendants_freeze_count;
    };
    struct _GdkWindowObjectClass
    {
            GdkDrawableClass parent_class;
    };
    GType gdk_window_object_get_type(void) __attribute__((__const__));
    GdkWindow * gdk_window_new(GdkWindow * parent, GdkWindowAttr * attributes, gint attributes_mask);
    void gdk_window_destroy(GdkWindow * window);
    GdkWindowType gdk_window_get_window_type(GdkWindow * window);
    GdkWindow * gdk_window_at_pointer(gint * win_x, gint * win_y);
    void gdk_window_show(GdkWindow * window);
    void gdk_window_hide(GdkWindow * window);
    void gdk_window_withdraw(GdkWindow * window);
    void gdk_window_show_unraised(GdkWindow * window);
    void gdk_window_move(GdkWindow * window, gint x, gint y);
    void gdk_window_resize(GdkWindow * window, gint width, gint height);
    void gdk_window_move_resize(GdkWindow * window, gint x, gint y, gint width, gint height);
    void gdk_window_reparent(GdkWindow * window, GdkWindow * new_parent, gint x, gint y);
    void gdk_window_clear(GdkWindow * window);
    void gdk_window_clear_area(GdkWindow * window, gint x, gint y, gint width, gint height);
    void gdk_window_clear_area_e(GdkWindow * window, gint x, gint y, gint width, gint height);
    void gdk_window_raise(GdkWindow * window);
    void gdk_window_lower(GdkWindow * window);
    void gdk_window_focus(GdkWindow * window, guint32 timestamp);
    void gdk_window_set_user_data(GdkWindow * window, gpointer user_data);
    void gdk_window_set_override_redirect(GdkWindow * window, gboolean override_redirect);
    void gdk_window_set_accept_focus(GdkWindow * window, gboolean accept_focus);
    void gdk_window_set_focus_on_map(GdkWindow * window, gboolean focus_on_map);
    void gdk_window_add_filter(GdkWindow * window, GdkFilterFunc function, gpointer data);
    void gdk_window_remove_filter(GdkWindow * window, GdkFilterFunc function, gpointer data);
    void gdk_window_scroll(GdkWindow * window, gint dx, gint dy);
    void gdk_window_move_region(GdkWindow * window, GdkRegion * region, gint dx, gint dy);
    void gdk_window_shape_combine_mask(GdkWindow * window, GdkBitmap * mask, gint x, gint y);
    void gdk_window_shape_combine_region(GdkWindow * window, GdkRegion * shape_region, gint offset_x, gint offset_y);
    void gdk_window_set_child_shapes(GdkWindow * window);
    void gdk_window_set_composited(GdkWindow * window, gboolean composited);
    void gdk_window_merge_child_shapes(GdkWindow * window);
    void gdk_window_input_shape_combine_mask(GdkWindow * window, GdkBitmap * mask, gint x, gint y);
    void gdk_window_input_shape_combine_region(GdkWindow * window, GdkRegion * shape_region, gint offset_x, gint offset_y);
    void gdk_window_set_child_input_shapes(GdkWindow * window);
    void gdk_window_merge_child_input_shapes(GdkWindow * window);
    gboolean gdk_window_is_visible(GdkWindow * window);
    gboolean gdk_window_is_viewable(GdkWindow * window);
    GdkWindowState gdk_window_get_state(GdkWindow * window);
    gboolean gdk_window_set_static_gravities(GdkWindow * window, gboolean use_static);
    GdkWindow * gdk_window_foreign_new(GdkNativeWindow anid);
    GdkWindow * gdk_window_lookup(GdkNativeWindow anid);
    GdkWindow * gdk_window_foreign_new_for_display(GdkDisplay * display, GdkNativeWindow anid);
    GdkWindow * gdk_window_lookup_for_display(GdkDisplay * display, GdkNativeWindow anid);
    void gdk_window_set_hints(GdkWindow * window, gint x, gint y, gint min_width, gint min_height, gint max_width, gint max_height, gint flags);
    void gdk_window_set_type_hint(GdkWindow * window, GdkWindowTypeHint hint);
    GdkWindowTypeHint gdk_window_get_type_hint(GdkWindow * window);
    void gdk_window_set_modal_hint(GdkWindow * window, gboolean modal);
    void gdk_window_set_skip_taskbar_hint(GdkWindow * window, gboolean skips_taskbar);
    void gdk_window_set_skip_pager_hint(GdkWindow * window, gboolean skips_pager);
    void gdk_window_set_urgency_hint(GdkWindow * window, gboolean urgent);
    void gdk_window_set_geometry_hints(GdkWindow * window, GdkGeometry * geometry, GdkWindowHints geom_mask);
    void gdk_set_sm_client_id(const gchar * sm_client_id);
    void gdk_window_begin_paint_rect(GdkWindow * window, GdkRectangle * rectangle);
    void gdk_window_begin_paint_region(GdkWindow * window, GdkRegion * region);
    void gdk_window_end_paint(GdkWindow * window);
    void gdk_window_set_title(GdkWindow * window, const gchar * title);
    void gdk_window_set_role(GdkWindow * window, const gchar * role);
    void gdk_window_set_startup_id(GdkWindow * window, const gchar * startup_id);
    void gdk_window_set_transient_for(GdkWindow * window, GdkWindow * parent);
    void gdk_window_set_background(GdkWindow * window, const GdkColor * color);
    void gdk_window_set_back_pixmap(GdkWindow * window, GdkPixmap * pixmap, gboolean parent_relative);
    void gdk_window_set_cursor(GdkWindow * window, GdkCursor * cursor);
    void gdk_window_get_user_data(GdkWindow * window, gpointer * data);
    void gdk_window_get_geometry(GdkWindow * window, gint * x, gint * y, gint * width, gint * height, gint * depth);
    void gdk_window_get_position(GdkWindow * window, gint * x, gint * y);
    gint gdk_window_get_origin(GdkWindow * window, gint * x, gint * y);
    gboolean gdk_window_get_deskrelative_origin(GdkWindow * window, gint * x, gint * y);
    void gdk_window_get_root_origin(GdkWindow * window, gint * x, gint * y);
    void gdk_window_get_frame_extents(GdkWindow * window, GdkRectangle * rect);
    GdkWindow * gdk_window_get_pointer(GdkWindow * window, gint * x, gint * y, GdkModifierType * mask);
    GdkWindow * gdk_window_get_parent(GdkWindow * window);
    GdkWindow * gdk_window_get_toplevel(GdkWindow * window);
    GList * gdk_window_get_children(GdkWindow * window);
    GList * gdk_window_peek_children(GdkWindow * window);
    GdkEventMask gdk_window_get_events(GdkWindow * window);
    void gdk_window_set_events(GdkWindow * window, GdkEventMask event_mask);
    void gdk_window_set_icon_list(GdkWindow * window, GList * pixbufs);
    void gdk_window_set_icon(GdkWindow * window, GdkWindow * icon_window, GdkPixmap * pixmap, GdkBitmap * mask);
    void gdk_window_set_icon_name(GdkWindow * window, const gchar * name);
    void gdk_window_set_group(GdkWindow * window, GdkWindow * leader);
    GdkWindow * gdk_window_get_group(GdkWindow * window);
    void gdk_window_set_decorations(GdkWindow * window, GdkWMDecoration decorations);
    gboolean gdk_window_get_decorations(GdkWindow * window, GdkWMDecoration * decorations);
    void gdk_window_set_functions(GdkWindow * window, GdkWMFunction functions);
    GList * gdk_window_get_toplevels(void);
    void gdk_window_beep(GdkWindow * window);
    void gdk_window_iconify(GdkWindow * window);
    void gdk_window_deiconify(GdkWindow * window);
    void gdk_window_stick(GdkWindow * window);
    void gdk_window_unstick(GdkWindow * window);
    void gdk_window_maximize(GdkWindow * window);
    void gdk_window_unmaximize(GdkWindow * window);
    void gdk_window_fullscreen(GdkWindow * window);
    void gdk_window_unfullscreen(GdkWindow * window);
    void gdk_window_set_keep_above(GdkWindow * window, gboolean setting);
    void gdk_window_set_keep_below(GdkWindow * window, gboolean setting);
    void gdk_window_set_opacity(GdkWindow * window, gdouble opacity);
    void gdk_window_register_dnd(GdkWindow * window);
    void gdk_window_begin_resize_drag(GdkWindow * window, GdkWindowEdge edge, gint button, gint root_x, gint root_y, guint32 timestamp);
    void gdk_window_begin_move_drag(GdkWindow * window, gint button, gint root_x, gint root_y, guint32 timestamp);
    void gdk_window_invalidate_rect(GdkWindow * window, GdkRectangle * rect, gboolean invalidate_children);
    void gdk_window_invalidate_region(GdkWindow * window, GdkRegion * region, gboolean invalidate_children);
    void gdk_window_invalidate_maybe_recurse(GdkWindow * window, GdkRegion * region, gboolean (* child_func)(GdkWindow *, gpointer), gpointer user_data);
    GdkRegion * gdk_window_get_update_area(GdkWindow * window);
    void gdk_window_freeze_updates(GdkWindow * window);
    void gdk_window_thaw_updates(GdkWindow * window);
    void gdk_window_freeze_toplevel_updates_libgtk_only(GdkWindow * window);
    void gdk_window_thaw_toplevel_updates_libgtk_only(GdkWindow * window);
    void gdk_window_process_all_updates(void);
    void gdk_window_process_updates(GdkWindow * window, gboolean update_children);
    void gdk_window_set_debug_updates(gboolean setting);
    void gdk_window_constrain_size(GdkGeometry * geometry, guint flags, gint width, gint height, gint * new_width, gint * new_height);
    void gdk_window_get_internal_paint_info(GdkWindow * window, GdkDrawable * * real_drawable, gint * x_offset, gint * y_offset);
    void gdk_window_enable_synchronized_configure(GdkWindow * window);
    void gdk_window_configure_finished(GdkWindow * window);
    GdkPointerHooks * gdk_set_pointer_hooks(const GdkPointerHooks * new_hooks);
    GdkWindow * gdk_get_default_root_window(void);
}
extern "C"
{
    void gdk_parse_args(gint * argc, gchar * * * argv);
    void gdk_init(gint * argc, gchar * * * argv);
    gboolean gdk_init_check(gint * argc, gchar * * * argv);
    void gdk_add_option_entries_libgtk_only(GOptionGroup * group);
    void gdk_pre_parse_libgtk_only(void);
    void gdk_exit(gint error_code);
    gchar * gdk_set_locale(void);
    const char * gdk_get_program_class(void);
    void gdk_set_program_class(const char * program_class);
    void gdk_error_trap_push(void);
    gint gdk_error_trap_pop(void);
    void gdk_set_use_xshm(gboolean use_xshm);
    gboolean gdk_get_use_xshm(void);
    gchar * gdk_get_display(void);
    const gchar * gdk_get_display_arg_name(void);
    gint gdk_input_add_full(gint source, GdkInputCondition condition, GdkInputFunction function, gpointer data, GdkDestroyNotify destroy);
    gint gdk_input_add(gint source, GdkInputCondition condition, GdkInputFunction function, gpointer data);
    void gdk_input_remove(gint tag);
    GdkGrabStatus gdk_pointer_grab(GdkWindow * window, gboolean owner_events, GdkEventMask event_mask, GdkWindow * confine_to, GdkCursor * cursor, guint32 time_);
    GdkGrabStatus gdk_keyboard_grab(GdkWindow * window, gboolean owner_events, guint32 time_);
    gboolean gdk_pointer_grab_info_libgtk_only(GdkDisplay * display, GdkWindow * * grab_window, gboolean * owner_events);
    gboolean gdk_keyboard_grab_info_libgtk_only(GdkDisplay * display, GdkWindow * * grab_window, gboolean * owner_events);
    void gdk_pointer_ungrab(guint32 time_);
    void gdk_keyboard_ungrab(guint32 time_);
    gboolean gdk_pointer_is_grabbed(void);
    gint gdk_screen_width(void) __attribute__((__const__));
    gint gdk_screen_height(void) __attribute__((__const__));
    gint gdk_screen_width_mm(void) __attribute__((__const__));
    gint gdk_screen_height_mm(void) __attribute__((__const__));
    void gdk_beep(void);
    void gdk_flush(void);
    void gdk_set_double_click_time(guint msec);
    gboolean gdk_rectangle_intersect(GdkRectangle * src1, GdkRectangle * src2, GdkRectangle * dest);
    void gdk_rectangle_union(GdkRectangle * src1, GdkRectangle * src2, GdkRectangle * dest);
    GType gdk_rectangle_get_type(void) __attribute__((__const__));
    gchar * gdk_wcstombs(const GdkWChar * src);
    gint gdk_mbstowcs(GdkWChar * dest, const gchar * src, gint dest_max);
    gboolean gdk_event_send_client_message(GdkEvent * event, GdkNativeWindow winid);
    void gdk_event_send_clientmessage_toall(GdkEvent * event);
    gboolean gdk_event_send_client_message_for_display(GdkDisplay * display, GdkEvent * event, GdkNativeWindow winid);
    void gdk_notify_startup_complete(void);
    void gdk_notify_startup_complete_with_id(const gchar * startup_id);
    extern GMutex * gdk_threads_mutex;
    extern GCallback gdk_threads_lock;
    extern GCallback gdk_threads_unlock;
    void gdk_threads_enter(void);
    void gdk_threads_leave(void);
    void gdk_threads_init(void);
    void gdk_threads_set_lock_functions(GCallback enter_fn, GCallback leave_fn);
    guint gdk_threads_add_idle_full(gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify);
    guint gdk_threads_add_idle(GSourceFunc function, gpointer data);
    guint gdk_threads_add_timeout_full(gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify);
    guint gdk_threads_add_timeout(guint interval, GSourceFunc function, gpointer data);
}
namespace Gdk {
    class Bitmap;
    class Colormap;
    class Pixmap;
    class Window;
    class Font;
    class GC;
    class Color;
    class Image;
    enum ByteOrder
    {
        LSB_FIRST, 
        MSB_FIRST
    };
}
namespace Glib {
    template<>
    class Value< Gdk::ByteOrder > : public Glib::Value_Enum< Gdk::ByteOrder >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum ModifierType
    {
        SHIFT_MASK = 1 << 0, 
        LOCK_MASK = 1 << 1, 
        CONTROL_MASK = 1 << 2, 
        MOD1_MASK = 1 << 3, 
        MOD2_MASK = 1 << 4, 
        MOD3_MASK = 1 << 5, 
        MOD4_MASK = 1 << 6, 
        MOD5_MASK = 1 << 7, 
        BUTTON1_MASK = 1 << 8, 
        BUTTON2_MASK = 1 << 9, 
        BUTTON3_MASK = 1 << 10, 
        BUTTON4_MASK = 1 << 11, 
        BUTTON5_MASK = 1 << 12, 
        SUPER_MASK = 1 << 26, 
        HYPER_MASK = 1 << 27, 
        META_MASK = 1 << 28, 
        RELEASE_MASK = 1 << 30, 
        MODIFIER_MASK = 0x5c001fff
    };
    inline ModifierType operator |(ModifierType lhs, ModifierType rhs)
    {
        return static_cast<ModifierType >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline ModifierType operator &(ModifierType lhs, ModifierType rhs)
    {
        return static_cast<ModifierType >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline ModifierType operator ^(ModifierType lhs, ModifierType rhs)
    {
        return static_cast<ModifierType >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline ModifierType operator ~(ModifierType flags)
    {
        return static_cast<ModifierType >(~static_cast<unsigned >(flags));
    }
    inline ModifierType & operator |=(ModifierType & lhs, ModifierType rhs)
    {
        return (lhs = static_cast<ModifierType >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline ModifierType & operator &=(ModifierType & lhs, ModifierType rhs)
    {
        return (lhs = static_cast<ModifierType >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline ModifierType & operator ^=(ModifierType & lhs, ModifierType rhs)
    {
        return (lhs = static_cast<ModifierType >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gdk::ModifierType > : public Glib::Value_Flags< Gdk::ModifierType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum Status
    {
        OK = 0, 
        ERROR = -1, 
        ERROR_PARAM = -2, 
        ERROR_FILE = -3, 
        ERROR_MEM = -4
    };
}
namespace Glib {
    template<>
    class Value< Gdk::Status > : public Glib::Value_Enum< Gdk::Status >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum InputCondition
    {
        INPUT_READ = 1 << 0, 
        INPUT_WRITE = 1 << 1, 
        INPUT_EXCEPTION = 1 << 2
    };
    inline InputCondition operator |(InputCondition lhs, InputCondition rhs)
    {
        return static_cast<InputCondition >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline InputCondition operator &(InputCondition lhs, InputCondition rhs)
    {
        return static_cast<InputCondition >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline InputCondition operator ^(InputCondition lhs, InputCondition rhs)
    {
        return static_cast<InputCondition >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline InputCondition operator ~(InputCondition flags)
    {
        return static_cast<InputCondition >(~static_cast<unsigned >(flags));
    }
    inline InputCondition & operator |=(InputCondition & lhs, InputCondition rhs)
    {
        return (lhs = static_cast<InputCondition >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline InputCondition & operator &=(InputCondition & lhs, InputCondition rhs)
    {
        return (lhs = static_cast<InputCondition >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline InputCondition & operator ^=(InputCondition & lhs, InputCondition rhs)
    {
        return (lhs = static_cast<InputCondition >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gdk::InputCondition > : public Glib::Value_Flags< Gdk::InputCondition >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    typedef GdkGeometry Geometry;
    typedef GdkNativeWindow NativeWindow;
    class Point
    {
        public :
            typedef Point CppObjectType;
            typedef GdkPoint BaseObjectType;
        private :
        public :
            Point();
            Point(int x, int y);
            void set_x(int x)
            {
                gobject_.x = x;
            }
            void set_y(int y)
            {
                gobject_.y = y;
            }
            int get_x() const
            {
                return gobject_.x;
            }
            int get_y() const
            {
                return gobject_.y;
            }
            bool equal(const Gdk::Point & rhs) const;
            GdkPoint * gobj()
            {
                return &gobject_;
            }
            const GdkPoint * gobj() const
            {
                return &gobject_;
            }
        protected :
            GdkPoint gobject_;
    };
    inline bool operator ==(const Point & lhs, const Point & rhs)
    {
        return lhs.equal(rhs);
    }
    inline bool operator !=(const Point & lhs, const Point & rhs)
    {
        return !lhs.equal(rhs);
    }
    struct AtomStringTraits
    {
            typedef std::string CppType;
            typedef GdkAtom CType;
            typedef GdkAtom CTypeNonConst;
            static GdkAtom to_c_type(GdkAtom atom)
            {
                return atom;
            }
            static void release_c_type(GdkAtom)
            {
            }
            static GdkAtom to_c_type(const std::string & atom_name);
            static std::string to_cpp_type(GdkAtom atom);
    };
    typedef AtomStringTraits AtomString;
    typedef Glib::ArrayHandle< std::string, AtomStringTraits > ArrayHandle_AtomString;
    typedef Glib::ListHandle< std::string, AtomStringTraits > ListHandle_AtomString;
}
namespace Glib {
    Gdk::Point & wrap(GdkPoint * object);
    const Gdk::Point & wrap(const GdkPoint * object);
}
namespace Gdk {
    class Rectangle
    {
        public :
            typedef Rectangle CppObjectType;
            typedef GdkRectangle BaseObjectType;
            static GType get_type() __attribute__((__const__));
            Rectangle();
            explicit Rectangle(const GdkRectangle * gobject);
            GdkRectangle * gobj()
            {
                return &gobject_;
            }
            const GdkRectangle * gobj() const
            {
                return &gobject_;
            }
        protected :
            GdkRectangle gobject_;
        private :
        public :
            Rectangle(int x, int y, int width, int height);
            Rectangle & join(const Rectangle & src2);
            Rectangle & intersect(const Rectangle & src2);
            Rectangle & intersect(const Rectangle & src2, bool & rectangles_intersect);
            bool has_zero_area() const;
            int get_x() const;
            void set_x(const int & value);
            int get_y() const;
            void set_y(const int & value);
            int get_width() const;
            void set_width(const int & value);
            int get_height() const;
            void set_height(const int & value);
    };
}
namespace Glib {
    Gdk::Rectangle & wrap(GdkRectangle * object);
    const Gdk::Rectangle & wrap(const GdkRectangle * object);
    template<>
    class Value< Gdk::Rectangle > : public Glib::Value_Boxed< Gdk::Rectangle >
    {
    };
}
namespace Cairo {
    typedef cairo_status_t ErrorStatus;
    typedef enum 
    {
        OPERATOR_CLEAR = CAIRO_OPERATOR_CLEAR, 
        OPERATOR_SOURCE = CAIRO_OPERATOR_SOURCE, 
        OPERATOR_OVER = CAIRO_OPERATOR_OVER, 
        OPERATOR_IN = CAIRO_OPERATOR_IN, 
        OPERATOR_OUT = CAIRO_OPERATOR_OUT, 
        OPERATOR_ATOP = CAIRO_OPERATOR_ATOP, 
        OPERATOR_DEST = CAIRO_OPERATOR_DEST, 
        OPERATOR_DEST_OVER = CAIRO_OPERATOR_DEST_OVER, 
        OPERATOR_DEST_IN = CAIRO_OPERATOR_DEST_IN, 
        OPERATOR_DEST_OUT = CAIRO_OPERATOR_DEST_OUT, 
        OPERATOR_DEST_ATOP = CAIRO_OPERATOR_DEST_ATOP, 
        OPERATOR_XOR = CAIRO_OPERATOR_XOR, 
        OPERATOR_ADD = CAIRO_OPERATOR_ADD, 
        OPERATOR_SATURATE = CAIRO_OPERATOR_SATURATE
    } Operator;
    typedef enum 
    {
        ANTIALIAS_DEFAULT = CAIRO_ANTIALIAS_DEFAULT, 
        ANTIALIAS_NONE = CAIRO_ANTIALIAS_NONE, 
        ANTIALIAS_GRAY = CAIRO_ANTIALIAS_GRAY, 
        ANTIALIAS_SUBPIXEL = CAIRO_ANTIALIAS_SUBPIXEL
    } Antialias;
    typedef enum 
    {
        FILL_RULE_WINDING = CAIRO_FILL_RULE_WINDING, 
        FILL_RULE_EVEN_ODD = CAIRO_FILL_RULE_EVEN_ODD
    } FillRule;
    typedef enum 
    {
        LINE_CAP_BUTT = CAIRO_LINE_CAP_BUTT, 
        LINE_CAP_ROUND = CAIRO_LINE_CAP_ROUND, 
        LINE_CAP_SQUARE = CAIRO_LINE_CAP_SQUARE
    } LineCap;
    typedef enum 
    {
        LINE_JOIN_MITER = CAIRO_LINE_JOIN_MITER, 
        LINE_JOIN_ROUND = CAIRO_LINE_JOIN_ROUND, 
        LINE_JOIN_BEVEL = CAIRO_LINE_JOIN_BEVEL
    } LineJoin;
    typedef enum 
    {
        FONT_SLANT_NORMAL = CAIRO_FONT_SLANT_NORMAL, 
        FONT_SLANT_ITALIC = CAIRO_FONT_SLANT_ITALIC, 
        FONT_SLANT_OBLIQUE = CAIRO_FONT_SLANT_OBLIQUE
    } FontSlant;
    typedef enum 
    {
        FONT_WEIGHT_NORMAL = CAIRO_FONT_WEIGHT_NORMAL, 
        FONT_WEIGHT_BOLD = CAIRO_FONT_WEIGHT_BOLD
    } FontWeight;
    typedef enum 
    {
        CONTENT_COLOR = CAIRO_CONTENT_COLOR, 
        CONTENT_ALPHA = CAIRO_CONTENT_ALPHA, 
        CONTENT_COLOR_ALPHA = CAIRO_CONTENT_COLOR_ALPHA
    } Content;
    typedef enum 
    {
        FORMAT_ARGB32 = CAIRO_FORMAT_ARGB32, 
        FORMAT_RGB24 = CAIRO_FORMAT_RGB24, 
        FORMAT_A8 = CAIRO_FORMAT_A8, 
        FORMAT_A1 = CAIRO_FORMAT_A1, 
        FORMAT_RGB16_565 = 4
    } Format;
    typedef enum 
    {
        EXTEND_NONE = CAIRO_EXTEND_NONE, 
        EXTEND_REPEAT = CAIRO_EXTEND_REPEAT, 
        EXTEND_REFLECT = CAIRO_EXTEND_REFLECT, 
        EXTEND_PAD = CAIRO_EXTEND_PAD
    } Extend;
    typedef enum 
    {
        FILTER_FAST = CAIRO_FILTER_FAST, 
        FILTER_GOOD = CAIRO_FILTER_GOOD, 
        FILTER_BEST = CAIRO_FILTER_BEST, 
        FILTER_NEAREST = CAIRO_FILTER_NEAREST, 
        FILTER_BILINEAR = CAIRO_FILTER_BILINEAR, 
        FILTER_GAUSSIAN = CAIRO_FILTER_GAUSSIAN
    } Filter;
    typedef enum 
    {
        SUBPIXEL_ORDER_DEFAULT = CAIRO_SUBPIXEL_ORDER_DEFAULT, 
        SUBPIXEL_ORDER_RGB = CAIRO_SUBPIXEL_ORDER_RGB, 
        SUBPIXEL_ORDER_BGR = CAIRO_SUBPIXEL_ORDER_BGR, 
        SUBPIXEL_ORDER_VRGB = CAIRO_SUBPIXEL_ORDER_VRGB, 
        SUBPIXEL_ORDER_VBGR = CAIRO_SUBPIXEL_ORDER_VBGR
    } SubpixelOrder;
    typedef enum 
    {
        HINT_STYLE_DEFAULT = CAIRO_HINT_STYLE_DEFAULT, 
        HINT_STYLE_NONE = CAIRO_HINT_STYLE_NONE, 
        HINT_STYLE_SLIGHT = CAIRO_HINT_STYLE_SLIGHT, 
        HINT_STYLE_MEDIUM = CAIRO_HINT_STYLE_MEDIUM, 
        HINT_STYLE_FULL = CAIRO_HINT_STYLE_FULL
    } HintStyle;
    typedef enum 
    {
        HINT_METRICS_DEFAULT = CAIRO_HINT_METRICS_DEFAULT, 
        HINT_METRICS_OFF = CAIRO_HINT_METRICS_OFF, 
        HINT_METRICS_ON = CAIRO_HINT_METRICS_ON
    } HintMetrics;
    typedef enum 
    {
        SURFACE_TYPE_IMAGE = CAIRO_SURFACE_TYPE_IMAGE, 
        SURFACE_TYPE_PDF = CAIRO_SURFACE_TYPE_PDF, 
        SURFACE_TYPE_PS = CAIRO_SURFACE_TYPE_PS, 
        SURFACE_TYPE_XLIB = CAIRO_SURFACE_TYPE_XLIB, 
        SURFACE_TYPE_XCB = CAIRO_SURFACE_TYPE_XCB, 
        SURFACE_TYPE_GLITZ = CAIRO_SURFACE_TYPE_GLITZ, 
        SURFACE_TYPE_QUARTZ = CAIRO_SURFACE_TYPE_QUARTZ, 
        SURFACE_TYPE_WIN32 = CAIRO_SURFACE_TYPE_WIN32, 
        SURFACE_TYPE_BEOS = CAIRO_SURFACE_TYPE_BEOS, 
        SURFACE_TYPE_DIRECTFB = CAIRO_SURFACE_TYPE_DIRECTFB, 
        SURFACE_TYPE_SVG = CAIRO_SURFACE_TYPE_SVG, 
        SURFACE_TYPE_OS2 = CAIRO_SURFACE_TYPE_OS2, 
        SURFACE_TYPE_WIN32_PRINTING = CAIRO_SURFACE_TYPE_WIN32_PRINTING, 
        SURFACE_TYPE_QUARTZ_IMAGE = CAIRO_SURFACE_TYPE_QUARTZ_IMAGE
    } SurfaceType;
    typedef enum 
    {
        PATTERN_TYPE_SOLID = CAIRO_PATTERN_TYPE_SOLID, 
        PATTERN_TYPE_SURFACE = CAIRO_PATTERN_TYPE_SURFACE, 
        PATTERN_TYPE_LINEAR = CAIRO_PATTERN_TYPE_LINEAR, 
        PATTERN_TYPE_RADIAL = CAIRO_PATTERN_TYPE_RADIAL
    } PatternType;
    typedef enum 
    {
        FONT_TYPE_TOY = CAIRO_FONT_TYPE_TOY, 
        FONT_TYPE_FT = CAIRO_FONT_TYPE_FT, 
        FONT_TYPE_WIN32 = CAIRO_FONT_TYPE_WIN32, 
        FONT_TYPE_ATSUI = CAIRO_FONT_TYPE_QUARTZ, 
        FONT_TYPE_QUARTZ = CAIRO_FONT_TYPE_QUARTZ
    } FontType;
}
namespace Cairo {
    class FontOptions
    {
        public :
            FontOptions();
            explicit FontOptions(cairo_font_options_t * cobject, bool take_ownership = false);
            FontOptions(const FontOptions & src);
            virtual ~FontOptions();
            FontOptions & operator =(const FontOptions & src);
            bool operator ==(const FontOptions & src) const;
            void merge(const FontOptions & other);
            unsigned long hash() const;
            void set_antialias(Antialias antialias);
            Antialias get_antialias() const;
            void set_subpixel_order(SubpixelOrder subpixel_order);
            SubpixelOrder get_subpixel_order() const;
            void set_hint_style(HintStyle hint_style);
            HintStyle get_hint_style() const;
            void set_hint_metrics(HintMetrics hint_metrics);
            HintMetrics get_hint_metrics() const;
            typedef cairo_font_options_t cobject;
            inline cobject * cobj()
            {
                return m_cobject;
            }
            inline const cobject * cobj() const
            {
                return m_cobject;
            }
            inline ErrorStatus get_status() const
            {
                return cairo_font_options_status(const_cast<cairo_font_options_t * >(cobj()));
            }
        protected :
            cobject * m_cobject;
    };
}
typedef struct _GdkScreen GdkScreen;
typedef struct _GdkScreenClass GdkScreenClass;
namespace Gdk {
    class Screen_Class;
}
namespace Gdk {
    class Display;
    class Colormap;
    class Visual;
    class Window;
    class Screen : public Glib::Object
    {
        public :
            typedef Screen CppObjectType;
            typedef Screen_Class CppClassType;
            typedef GdkScreen BaseObjectType;
            typedef GdkScreenClass BaseClassType;
        private :
            friend class Screen_Class;
            static CppClassType screen_class_;
        private :
            Screen(const Screen &);
            Screen & operator =(const Screen &);
        protected :
            explicit Screen(const Glib::ConstructParams & construct_params);
            explicit Screen(GdkScreen * castitem);
        public :
            virtual ~Screen();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GdkScreen * gobj()
            {
                return reinterpret_cast<GdkScreen * >(gobject_);
            }
            const GdkScreen * gobj() const
            {
                return reinterpret_cast<GdkScreen * >(gobject_);
            }
            GdkScreen * gobj_copy();
        private :
        protected :
        public :
            Glib::RefPtr< Colormap > get_default_colormap();
            Glib::RefPtr< const Colormap > get_default_colormap() const;
            void set_default_colormap(const Glib::RefPtr< const Colormap > & colormap);
            Glib::RefPtr< Colormap > get_system_colormap();
            Glib::RefPtr< const Colormap > get_system_colormap() const;
            Glib::RefPtr< Visual > get_system_visual();
            Glib::RefPtr< const Visual > get_system_visual() const;
            Glib::RefPtr< Colormap > get_rgb_colormap();
            Glib::RefPtr< const Colormap > get_rgb_colormap() const;
            Glib::RefPtr< Visual > get_rgb_visual();
            Glib::RefPtr< const Visual > get_rgb_visual() const;
            Glib::RefPtr< Colormap > get_rgba_colormap();
            Glib::RefPtr< const Colormap > get_rgba_colormap() const;
            Glib::RefPtr< Visual > get_rgba_visual();
            Glib::RefPtr< const Visual > get_rgba_visual() const;
            bool is_composited() const;
            Glib::RefPtr< Window > get_root_window();
            Glib::RefPtr< const Window > get_root_window() const;
            Glib::RefPtr< Display > get_display();
            Glib::RefPtr< const Display > get_display() const;
            int get_number() const;
            int get_width() const;
            int get_height() const;
            int get_width_mm() const;
            int get_height_mm() const;
            Glib::ListHandle< Glib::RefPtr< Visual > > list_visuals();
            Glib::ListHandle< Glib::RefPtr< Window > > get_toplevel_windows();
            Glib::ustring make_display_name();
            int get_n_monitors() const;
            void get_monitor_geometry(int monitor_num, Rectangle & dest) const;
            int get_monitor_at_point(int x, int y) const;
            int get_monitor_at_window(const Glib::RefPtr< Window > & window) const;
            void broadcast_client_message(GdkEvent * event);
            static Glib::RefPtr< Screen > get_default();
            template<class ValueType >
            bool get_setting(const Glib::ustring & name, ValueType & value) const;
            void set_font_options(const Cairo::FontOptions & options);
            Cairo::FontOptions get_font_options() const;
            void set_resolution(double dpi);
            double get_resolution() const;
            Glib::RefPtr< Gdk::Window > get_active_window();
            Glib::RefPtr< const Gdk::Window > get_active_window() const;
            Glib::ListHandle< Glib::RefPtr< Window > > get_window_stack();
            Glib::SignalProxy0< void > signal_size_changed();
        public :
        public :
        protected :
            virtual void on_size_changed();
    };
    template<class ValueType >
    bool Screen::get_setting(const Glib::ustring & name, ValueType & value) const
    {
        Glib::Value< ValueType > glibmmvalue;
        glibmmvalue.init(Glib::Value< ValueType >::value_type());
        gboolean result = gdk_screen_get_setting(const_cast<GdkScreen * >(gobj()), name.c_str(), glibmmvalue.gobj());
        value = glibmmvalue.get();
        return result;
    }
}
namespace Glib {
    Glib::RefPtr< Gdk::Screen > wrap(GdkScreen * object, bool take_copy = false);
}
typedef struct _GdkVisual GdkVisual;
typedef struct _GdkVisualClass GdkVisualClass;
namespace Gdk {
    class Visual_Class;
}
namespace Gdk {
    class Screen;
    enum VisualType
    {
        VISUAL_STATIC_GRAY, 
        VISUAL_GRAYSCALE, 
        VISUAL_STATIC_COLOR, 
        VISUAL_PSEUDO_COLOR, 
        VISUAL_TRUE_COLOR, 
        VISUAL_DIRECT_COLOR
    };
}
namespace Glib {
    template<>
    class Value< Gdk::VisualType > : public Glib::Value_Enum< Gdk::VisualType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    class Visual : public Glib::Object
    {
        public :
            typedef Visual CppObjectType;
            typedef Visual_Class CppClassType;
            typedef GdkVisual BaseObjectType;
            typedef GdkVisualClass BaseClassType;
        private :
            friend class Visual_Class;
            static CppClassType visual_class_;
        private :
            Visual(const Visual &);
            Visual & operator =(const Visual &);
        protected :
            explicit Visual(const Glib::ConstructParams & construct_params);
            explicit Visual(GdkVisual * castitem);
        public :
            virtual ~Visual();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GdkVisual * gobj()
            {
                return reinterpret_cast<GdkVisual * >(gobject_);
            }
            const GdkVisual * gobj() const
            {
                return reinterpret_cast<GdkVisual * >(gobject_);
            }
            GdkVisual * gobj_copy();
        private :
        protected :
            Visual();
        public :
            static Glib::RefPtr< Visual > get_system();
            static Glib::RefPtr< Visual > get_best();
            static Glib::RefPtr< Visual > get_best(int depth);
            static Glib::RefPtr< Visual > get_best(VisualType visual_type);
            static Glib::RefPtr< Visual > get_best(int depth, VisualType visual_type);
            static int get_best_depth();
            static VisualType get_best_type();
            Glib::RefPtr< Screen > get_screen();
            Glib::RefPtr< const Screen > get_screen() const;
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gdk::Visual > wrap(GdkVisual * object, bool take_copy = false);
}
namespace Pango {
    class Rectangle
    {
        public :
            typedef Rectangle CppObjectType;
            typedef PangoRectangle BaseObjectType;
        private :
        public :
            Rectangle();
            Rectangle(int x, int y, int width, int height);
            explicit Rectangle(const PangoRectangle * src);
            void set_x(int x)
            {
                gobject_.x = x;
            }
            void set_y(int y)
            {
                gobject_.y = y;
            }
            void set_width(int w)
            {
                gobject_.width = w;
            }
            void set_height(int h)
            {
                gobject_.height = h;
            }
            int get_x() const
            {
                return gobject_.x;
            }
            int get_y() const
            {
                return gobject_.y;
            }
            int get_width() const
            {
                return gobject_.width;
            }
            int get_height() const
            {
                return gobject_.height;
            }
            int get_ascent() const
            {
                return (-(*gobj()).y);
            }
            int get_descent() const
            {
                return ((*gobj()).y + (*gobj()).height);
            }
            int get_lbearing() const
            {
                return ((*gobj()).x);
            }
            int get_rbearing() const
            {
                return ((*gobj()).x + (*gobj()).width);
            }
            bool equal(const Rectangle & rhs) const;
            PangoRectangle * gobj()
            {
                return &gobject_;
            }
            const PangoRectangle * gobj() const
            {
                return &gobject_;
            }
        protected :
            PangoRectangle gobject_;
    };
    inline bool operator ==(const Rectangle & lhs, const Rectangle & rhs)
    {
        return lhs.equal(rhs);
    }
    inline bool operator !=(const Rectangle & lhs, const Rectangle & rhs)
    {
        return !lhs.equal(rhs);
    }
}
namespace Glib {
    Pango::Rectangle & wrap(PangoRectangle * object);
    const Pango::Rectangle & wrap(const PangoRectangle * object);
}
extern "C"
{
    typedef struct _PangoLanguage PangoLanguage;
}
namespace Pango {
    enum Script
    {
        SCRIPT_INVALID_CODE = -1, 
        SCRIPT_COMMON, 
        SCRIPT_INHERITED, 
        SCRIPT_ARABIC, 
        SCRIPT_ARMENIAN, 
        SCRIPT_BENGALI, 
        SCRIPT_BOPOMOFO, 
        SCRIPT_CHEROKEE, 
        SCRIPT_COPTIC, 
        SCRIPT_CYRILLIC, 
        SCRIPT_DESERET, 
        SCRIPT_DEVANAGARI, 
        SCRIPT_ETHIOPIC, 
        SCRIPT_GEORGIAN, 
        SCRIPT_GOTHIC, 
        SCRIPT_GREEK, 
        SCRIPT_GUJARATI, 
        SCRIPT_GURMUKHI, 
        SCRIPT_HAN, 
        SCRIPT_HANGUL, 
        SCRIPT_HEBREW, 
        SCRIPT_HIRAGANA, 
        SCRIPT_KANNADA, 
        SCRIPT_KATAKANA, 
        SCRIPT_KHMER, 
        SCRIPT_LAO, 
        SCRIPT_LATIN, 
        SCRIPT_MALAYALAM, 
        SCRIPT_MONGOLIAN, 
        SCRIPT_MYANMAR, 
        SCRIPT_OGHAM, 
        SCRIPT_OLD_ITALIC, 
        SCRIPT_ORIYA, 
        SCRIPT_RUNIC, 
        SCRIPT_SINHALA, 
        SCRIPT_SYRIAC, 
        SCRIPT_TAMIL, 
        SCRIPT_TELUGU, 
        SCRIPT_THAANA, 
        SCRIPT_THAI, 
        SCRIPT_TIBETAN, 
        SCRIPT_CANADIAN_ABORIGINAL, 
        SCRIPT_YI, 
        SCRIPT_TAGALOG, 
        SCRIPT_HANUNOO, 
        SCRIPT_BUHID, 
        SCRIPT_TAGBANWA, 
        SCRIPT_BRAILLE, 
        SCRIPT_CYPRIOT, 
        SCRIPT_LIMBU, 
        SCRIPT_OSMANYA, 
        SCRIPT_SHAVIAN, 
        SCRIPT_LINEAR_B, 
        SCRIPT_TAI_LE, 
        SCRIPT_UGARITIC, 
        SCRIPT_NEW_TAI_LUE, 
        SCRIPT_BUGINESE, 
        SCRIPT_GLAGOLITIC, 
        SCRIPT_TIFINAGH, 
        SCRIPT_SYLOTI_NAGRI, 
        SCRIPT_OLD_PERSIAN, 
        SCRIPT_KHAROSHTHI, 
        SCRIPT_UNKNOWN, 
        SCRIPT_BALINESE, 
        SCRIPT_CUNEIFORM, 
        SCRIPT_PHOENICIAN, 
        SCRIPT_PHAGS_PA, 
        SCRIPT_NKO
    };
}
namespace Glib {
    template<>
    class Value< Pango::Script > : public Glib::Value_Enum< Pango::Script >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Pango {
    class Language
    {
        public :
            typedef Language CppObjectType;
            typedef PangoLanguage BaseObjectType;
            static GType get_type() __attribute__((__const__));
            explicit Language(PangoLanguage * gobject, bool make_a_copy = true);
            Language(const Language & other);
            Language & operator =(const Language & other);
            ~Language();
            void swap(Language & other);
            PangoLanguage * gobj()
            {
                return gobject_;
            }
            const PangoLanguage * gobj() const
            {
                return gobject_;
            }
            PangoLanguage * gobj_copy() const;
        protected :
            PangoLanguage * gobject_;
        private :
        public :
            Language();
            Language(const Glib::ustring & language);
            Glib::ustring get_string() const;
            bool matches(const Glib::ustring & range_list) const;
            bool includes_script(Script script) const;
    };
}
namespace Pango {
    inline void swap(Language & lhs, Language & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    Pango::Language wrap(PangoLanguage * object, bool take_copy = false);
    template<>
    class Value< Pango::Language > : public Glib::Value_Boxed< Pango::Language >
    {
    };
}
namespace Pango {
    class GlyphInfo;
    class GlyphGeometry;
    typedef PangoGlyph Glyph;
    typedef PangoGlyphUnit GlyphUnit;
    typedef PangoGlyphVisAttr GlyphVisAttr;
    class GlyphInfo
    {
        public :
            typedef GlyphInfo CppObjectType;
            typedef PangoGlyphInfo BaseObjectType;
        private :
        public :
            GlyphInfo();
            Glyph get_glyph() const;
            GlyphGeometry get_geometry() const;
            GlyphVisAttr get_attr() const;
            PangoGlyphInfo * gobj()
            {
                return &gobject_;
            }
            const PangoGlyphInfo * gobj() const
            {
                return &gobject_;
            }
        protected :
            PangoGlyphInfo gobject_;
    };
    class GlyphGeometry
    {
        public :
            typedef GlyphGeometry CppObjectType;
            typedef PangoGlyphGeometry BaseObjectType;
        private :
        public :
            GlyphGeometry();
            explicit GlyphGeometry(const PangoGlyphGeometry * src);
            GlyphUnit get_width() const;
            GlyphUnit get_x_offset() const;
            GlyphUnit get_y_offset() const;
            PangoGlyphGeometry * gobj()
            {
                return &gobject_;
            }
            const PangoGlyphGeometry * gobj() const
            {
                return &gobject_;
            }
        protected :
            PangoGlyphGeometry gobject_;
    };
}
namespace Glib {
    Pango::GlyphInfo & wrap(PangoGlyphInfo * object);
    const Pango::GlyphInfo & wrap(const PangoGlyphInfo * object);
    Pango::GlyphGeometry & wrap(PangoGlyphGeometry * object);
    const Pango::GlyphGeometry & wrap(const PangoGlyphGeometry * object);
}
extern "C"
{
    typedef struct _PangoFontDescription PangoFontDescription;
}
namespace Pango {
    enum Style
    {
        STYLE_NORMAL, 
        STYLE_OBLIQUE, 
        STYLE_ITALIC
    };
}
namespace Glib {
    template<>
    class Value< Pango::Style > : public Glib::Value_Enum< Pango::Style >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Pango {
    enum Variant
    {
        VARIANT_NORMAL, 
        VARIANT_SMALL_CAPS
    };
}
namespace Glib {
    template<>
    class Value< Pango::Variant > : public Glib::Value_Enum< Pango::Variant >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Pango {
    enum Stretch
    {
        STRETCH_ULTRA_CONDENSED, 
        STRETCH_EXTRA_CONDENSED, 
        STRETCH_CONDENSED, 
        STRETCH_SEMI_CONDENSED, 
        STRETCH_NORMAL, 
        STRETCH_SEMI_EXPANDED, 
        STRETCH_EXPANDED, 
        STRETCH_EXTRA_EXPANDED, 
        STRETCH_ULTRA_EXPANDED
    };
}
namespace Glib {
    template<>
    class Value< Pango::Stretch > : public Glib::Value_Enum< Pango::Stretch >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Pango {
    enum Weight
    {
        WEIGHT_ULTRALIGHT = 200, 
        WEIGHT_LIGHT = 300, 
        WEIGHT_NORMAL = 400, 
        WEIGHT_SEMIBOLD = 600, 
        WEIGHT_BOLD = 700, 
        WEIGHT_ULTRABOLD = 800, 
        WEIGHT_HEAVY = 900
    };
}
namespace Glib {
    template<>
    class Value< Pango::Weight > : public Glib::Value_Enum< Pango::Weight >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Pango {
    enum FontMask
    {
        FONT_MASK_FAMILY = 1 << 0, 
        FONT_MASK_STYLE = 1 << 1, 
        FONT_MASK_VARIANT = 1 << 2, 
        FONT_MASK_WEIGHT = 1 << 3, 
        FONT_MASK_STRETCH = 1 << 4, 
        FONT_MASK_SIZE = 1 << 5, 
        FONT_MASK_GRAVITY = 1 << 6
    };
    inline FontMask operator |(FontMask lhs, FontMask rhs)
    {
        return static_cast<FontMask >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline FontMask operator &(FontMask lhs, FontMask rhs)
    {
        return static_cast<FontMask >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline FontMask operator ^(FontMask lhs, FontMask rhs)
    {
        return static_cast<FontMask >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline FontMask operator ~(FontMask flags)
    {
        return static_cast<FontMask >(~static_cast<unsigned >(flags));
    }
    inline FontMask & operator |=(FontMask & lhs, FontMask rhs)
    {
        return (lhs = static_cast<FontMask >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline FontMask & operator &=(FontMask & lhs, FontMask rhs)
    {
        return (lhs = static_cast<FontMask >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline FontMask & operator ^=(FontMask & lhs, FontMask rhs)
    {
        return (lhs = static_cast<FontMask >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Pango::FontMask > : public Glib::Value_Flags< Pango::FontMask >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Pango {
    enum Gravity
    {
        GRAVITY_SOUTH, 
        GRAVITY_EAST, 
        GRAVITY_NORTH, 
        GRAVITY_WEST, 
        GRAVITY_AUTO
    };
}
namespace Glib {
    template<>
    class Value< Pango::Gravity > : public Glib::Value_Enum< Pango::Gravity >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Pango {
    class FontDescription
    {
        public :
            typedef FontDescription CppObjectType;
            typedef PangoFontDescription BaseObjectType;
            static GType get_type() __attribute__((__const__));
            FontDescription();
            explicit FontDescription(PangoFontDescription * gobject, bool make_a_copy = true);
            FontDescription(const FontDescription & other);
            FontDescription & operator =(const FontDescription & other);
            ~FontDescription();
            void swap(FontDescription & other);
            PangoFontDescription * gobj()
            {
                return gobject_;
            }
            const PangoFontDescription * gobj() const
            {
                return gobject_;
            }
            PangoFontDescription * gobj_copy() const;
        protected :
            PangoFontDescription * gobject_;
        private :
        public :
            explicit FontDescription(const Glib::ustring & font_name);
            guint hash() const;
            void set_family(const Glib::ustring & family);
            Glib::ustring get_family() const;
            void set_style(Style style);
            Style get_style() const;
            void set_variant(Variant variant);
            Variant get_variant() const;
            void set_weight(Weight weight);
            Weight get_weight() const;
            void set_stretch(Stretch stretch);
            Stretch get_stretch() const;
            void set_size(int size);
            int get_size() const;
            void set_absolute_size(double size);
            bool get_size_is_absolute() const;
            void set_gravity(Gravity gravity);
            Gravity get_gravity() const;
            FontMask get_set_fields() const;
            void unset_fields(FontMask to_unset);
            void merge(const FontDescription & desc_to_merge, bool replace_existing);
            bool better_match(const FontDescription & old_match, const FontDescription & new_match) const;
            Glib::ustring to_string() const;
            Glib::ustring to_filename() const;
    };
}
namespace Pango {
    bool operator ==(const FontDescription & lhs, const FontDescription & rhs);
    bool operator !=(const FontDescription & lhs, const FontDescription & rhs);
}
namespace Pango {
    inline void swap(FontDescription & lhs, FontDescription & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    Pango::FontDescription wrap(PangoFontDescription * object, bool take_copy = false);
    template<>
    class Value< Pango::FontDescription > : public Glib::Value_Boxed< Pango::FontDescription >
    {
    };
}
extern "C"
{
    typedef struct _PangoFontMetrics PangoFontMetrics;
}
namespace Pango {
    class FontMetrics
    {
        public :
            typedef FontMetrics CppObjectType;
            typedef PangoFontMetrics BaseObjectType;
            static GType get_type() __attribute__((__const__));
            FontMetrics();
            explicit FontMetrics(PangoFontMetrics * gobject, bool make_a_copy = true);
            FontMetrics(const FontMetrics & other);
            FontMetrics & operator =(const FontMetrics & other);
            ~FontMetrics();
            void swap(FontMetrics & other);
            PangoFontMetrics * gobj()
            {
                return gobject_;
            }
            const PangoFontMetrics * gobj() const
            {
                return gobject_;
            }
            PangoFontMetrics * gobj_copy() const;
        protected :
            PangoFontMetrics * gobject_;
        private :
        public :
            int get_ascent() const;
            int get_descent() const;
            int get_approximate_char_width() const;
            int get_approximate_digit_width() const;
            int get_underline_position() const;
            int get_underline_thickness() const;
            int get_strikethrough_position() const;
            int get_strikethrough_thickness() const;
    };
}
namespace Pango {
    inline void swap(FontMetrics & lhs, FontMetrics & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    Pango::FontMetrics wrap(PangoFontMetrics * object, bool take_copy = false);
    template<>
    class Value< Pango::FontMetrics > : public Glib::Value_Boxed< Pango::FontMetrics >
    {
    };
}
namespace Pango {
    enum CoverageLevel
    {
        COVERAGE_NONE, 
        COVERAGE_FALLBACK, 
        COVERAGE_APPROXIMATE, 
        COVERAGE_EXACT
    };
}
namespace Glib {
    template<>
    class Value< Pango::CoverageLevel > : public Glib::Value_Enum< Pango::CoverageLevel >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Pango {
    class Coverage
    {
        public :
            typedef Coverage CppObjectType;
            typedef PangoCoverage BaseObjectType;
            static Glib::RefPtr< Coverage > create();
            void reference() const;
            void unreference() const;
            PangoCoverage * gobj();
            const PangoCoverage * gobj() const;
            PangoCoverage * gobj_copy() const;
        protected :
            Coverage();
            void operator delete(void *, size_t);
        private :
            Coverage(const Coverage &);
            Coverage & operator =(const Coverage &);
        public :
            static Glib::RefPtr< Coverage > create(const guchar * bytes, int n_bytes);
            CoverageLevel get(int index) const;
            void set(int index, CoverageLevel level);
            void max(const Glib::RefPtr< Coverage > & other) const;
            Glib::ArrayHandle< unsigned char > to_bytes() const;
    };
}
namespace Glib {
    Glib::RefPtr< Pango::Coverage > wrap(PangoCoverage * object, bool take_copy = false);
}
typedef struct _PangoFont PangoFont;
typedef struct _PangoFontClass PangoFontClass;
namespace Pango {
    class Font_Class;
}
namespace Pango {
    const int SCALE = 1024;
    const double SCALE_XX_SMALL = 0.5787037037037;
    const double SCALE_X_SMALL = 0.6444444444444;
    const double SCALE_SMALL = 0.8333333333333;
    const double SCALE_MEDIUM = 1.0;
    const double SCALE_LARGE = 1.2;
    const double SCALE_X_LARGE = 1.4399999999999;
    const double SCALE_XX_LARGE = 1.728;
    class FontMap;
    class Font : public Glib::Object
    {
        public :
            typedef Font CppObjectType;
            typedef Font_Class CppClassType;
            typedef PangoFont BaseObjectType;
            typedef PangoFontClass BaseClassType;
        private :
            friend class Font_Class;
            static CppClassType font_class_;
        private :
            Font(const Font &);
            Font & operator =(const Font &);
        protected :
            explicit Font(const Glib::ConstructParams & construct_params);
            explicit Font(PangoFont * castitem);
        public :
            virtual ~Font();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            PangoFont * gobj()
            {
                return reinterpret_cast<PangoFont * >(gobject_);
            }
            const PangoFont * gobj() const
            {
                return reinterpret_cast<PangoFont * >(gobject_);
            }
            PangoFont * gobj_copy();
        private :
        public :
            FontDescription describe() const;
            FontDescription describe_with_absolute_size() const;
            Glib::RefPtr< Coverage > get_coverage(const Language & language) const;
            FontMetrics get_metrics() const;
            FontMetrics get_metrics(const Language & language) const;
            void get_glyph_extents(Glyph glyph, Rectangle & ink_rect, Rectangle & logical_rect) const;
            Glib::RefPtr< FontMap > get_font_map();
            Glib::RefPtr< const FontMap > get_font_map() const;
            Rectangle get_glyph_ink_extents(Glyph glyph) const;
            Rectangle get_glyph_logical_extents(Glyph glyph) const;
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Pango::Font > wrap(PangoFont * object, bool take_copy = false);
}
typedef struct _PangoFontset PangoFontset;
typedef struct _PangoFontsetClass PangoFontsetClass;
namespace Pango {
    class Fontset_Class;
}
namespace Pango {
    class Fontset : public Glib::Object
    {
        public :
            typedef Fontset CppObjectType;
            typedef Fontset_Class CppClassType;
            typedef PangoFontset BaseObjectType;
            typedef PangoFontsetClass BaseClassType;
        private :
            friend class Fontset_Class;
            static CppClassType fontset_class_;
        private :
            Fontset(const Fontset &);
            Fontset & operator =(const Fontset &);
        protected :
            explicit Fontset(const Glib::ConstructParams & construct_params);
            explicit Fontset(PangoFontset * castitem);
        public :
            virtual ~Fontset();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            PangoFontset * gobj()
            {
                return reinterpret_cast<PangoFontset * >(gobject_);
            }
            const PangoFontset * gobj() const
            {
                return reinterpret_cast<PangoFontset * >(gobject_);
            }
            PangoFontset * gobj_copy();
        private :
        public :
            Glib::RefPtr< Font > get_font(guint wc) const;
            FontMetrics get_metrics() const;
            typedef sigc::slot< bool, const Glib::RefPtr< Font > & > ForeachSlot;
            void foreach(const ForeachSlot & slot);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Pango::Fontset > wrap(PangoFontset * object, bool take_copy = false);
}
typedef struct _PangoFontFace PangoFontFace;
typedef struct _PangoFontFaceClass PangoFontFaceClass;
namespace Pango {
    class FontFace_Class;
}
namespace Pango {
    class FontFace : public Glib::Object
    {
        public :
            typedef FontFace CppObjectType;
            typedef FontFace_Class CppClassType;
            typedef PangoFontFace BaseObjectType;
            typedef PangoFontFaceClass BaseClassType;
        private :
            friend class FontFace_Class;
            static CppClassType fontface_class_;
        private :
            FontFace(const FontFace &);
            FontFace & operator =(const FontFace &);
        protected :
            explicit FontFace(const Glib::ConstructParams & construct_params);
            explicit FontFace(PangoFontFace * castitem);
        public :
            virtual ~FontFace();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            PangoFontFace * gobj()
            {
                return reinterpret_cast<PangoFontFace * >(gobject_);
            }
            const PangoFontFace * gobj() const
            {
                return reinterpret_cast<PangoFontFace * >(gobject_);
            }
            PangoFontFace * gobj_copy();
        private :
        public :
            FontDescription describe() const;
            Glib::ustring get_name() const;
            Glib::ArrayHandle< int > list_sizes() const;
            bool is_synthesized() const;
        protected :
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Pango::FontFace > wrap(PangoFontFace * object, bool take_copy = false);
}
typedef struct _PangoFontFamily PangoFontFamily;
typedef struct _PangoFontFamilyClass PangoFontFamilyClass;
namespace Pango {
    class FontFamily_Class;
}
namespace Pango {
    class FontFamily : public Glib::Object
    {
        public :
            typedef FontFamily CppObjectType;
            typedef FontFamily_Class CppClassType;
            typedef PangoFontFamily BaseObjectType;
            typedef PangoFontFamilyClass BaseClassType;
        private :
            friend class FontFamily_Class;
            static CppClassType fontfamily_class_;
        private :
            FontFamily(const FontFamily &);
            FontFamily & operator =(const FontFamily &);
        protected :
            explicit FontFamily(const Glib::ConstructParams & construct_params);
            explicit FontFamily(PangoFontFamily * castitem);
        public :
            virtual ~FontFamily();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            PangoFontFamily * gobj()
            {
                return reinterpret_cast<PangoFontFamily * >(gobject_);
            }
            const PangoFontFamily * gobj() const
            {
                return reinterpret_cast<PangoFontFamily * >(gobject_);
            }
            PangoFontFamily * gobj_copy();
        private :
        public :
            Glib::ArrayHandle< Glib::RefPtr< FontFace > > list_faces() const;
            Glib::ustring get_name() const;
            bool is_monospace() const;
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Pango::FontFamily > wrap(PangoFontFamily * object, bool take_copy = false);
}
typedef struct _PangoFontMap PangoFontMap;
typedef struct _PangoFontMapClass PangoFontMapClass;
namespace Pango {
    class FontMap_Class;
}
namespace Pango {
    class Context;
    class FontMap : public Glib::Object
    {
        public :
            typedef FontMap CppObjectType;
            typedef FontMap_Class CppClassType;
            typedef PangoFontMap BaseObjectType;
            typedef PangoFontMapClass BaseClassType;
        private :
            friend class FontMap_Class;
            static CppClassType fontmap_class_;
        private :
            FontMap(const FontMap &);
            FontMap & operator =(const FontMap &);
        protected :
            explicit FontMap(const Glib::ConstructParams & construct_params);
            explicit FontMap(PangoFontMap * castitem);
        public :
            virtual ~FontMap();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            PangoFontMap * gobj()
            {
                return reinterpret_cast<PangoFontMap * >(gobject_);
            }
            const PangoFontMap * gobj() const
            {
                return reinterpret_cast<PangoFontMap * >(gobject_);
            }
            PangoFontMap * gobj_copy();
        private :
        public :
            Glib::RefPtr< Font > load_font(const Glib::RefPtr< Context > & context, const FontDescription & desc) const;
            Glib::RefPtr< Fontset > load_fontset(const Glib::RefPtr< Context > & context, const FontDescription & desc, const Language & language) const;
            Glib::ArrayHandle< Glib::RefPtr< FontFamily > > list_families() const;
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Pango::FontMap > wrap(PangoFontMap * object, bool take_copy = false);
}
namespace Pango {
    class Color
    {
        public :
            typedef Color CppObjectType;
            typedef PangoColor BaseObjectType;
            static GType get_type() __attribute__((__const__));
            Color();
            explicit Color(const PangoColor * gobject);
            PangoColor * gobj()
            {
                return &gobject_;
            }
            const PangoColor * gobj() const
            {
                return &gobject_;
            }
        protected :
            PangoColor gobject_;
        private :
        public :
            operator bool();
            guint16 get_red() const;
            guint16 get_green() const;
            guint16 get_blue() const;
            void set_red(const guint16 & value);
            void set_green(const guint16 & value);
            void set_blue(const guint16 & value);
            bool parse(const Glib::ustring & spec);
            Glib::ustring to_string() const;
    };
}
namespace Glib {
    Pango::Color & wrap(PangoColor * object);
    const Pango::Color & wrap(const PangoColor * object);
    template<>
    class Value< Pango::Color > : public Glib::Value_Boxed< Pango::Color >
    {
    };
}
namespace Pango {
    enum AttrType
    {
        ATTR_INVALID, 
        ATTR_LANGUAGE, 
        ATTR_FAMILY, 
        ATTR_STYLE, 
        ATTR_WEIGHT, 
        ATTR_VARIANT, 
        ATTR_STRETCH, 
        ATTR_SIZE, 
        ATTR_FONT_DESC, 
        ATTR_FOREGROUND, 
        ATTR_BACKGROUND, 
        ATTR_UNDERLINE, 
        ATTR_STRIKETHROUGH, 
        ATTR_RISE, 
        ATTR_SHAPE, 
        ATTR_SCALE, 
        ATTR_FALLBACK, 
        ATTR_LETTER_SPACING, 
        ATTR_UNDERLINE_COLOR, 
        ATTR_STRIKETHROUGH_COLOR, 
        ATTR_ABSOLUTE_SIZE, 
        ATTR_GRAVITY, 
        ATTR_GRAVITY_HINT
    };
}
namespace Glib {
    template<>
    class Value< Pango::AttrType > : public Glib::Value_Enum< Pango::AttrType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Pango {
    enum Underline
    {
        UNDERLINE_NONE, 
        UNDERLINE_SINGLE, 
        UNDERLINE_DOUBLE, 
        UNDERLINE_LOW, 
        UNDERLINE_ERROR
    };
}
namespace Glib {
    template<>
    class Value< Pango::Underline > : public Glib::Value_Enum< Pango::Underline >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Pango {
    typedef PangoLogAttr LogAttr;
    class AttrString;
    class AttrLanguage;
    class AttrColor;
    class AttrInt;
    class AttrFloat;
    class AttrFontDesc;
    class AttrShape;
    class Attribute
    {
        public :
            typedef Attribute CppObjectType;
            typedef PangoAttribute BaseObjectType;
        private :
        public :
            Attribute();
            Attribute(const Attribute & src);
            explicit Attribute(PangoAttribute * castitem, bool take_copy = true);
            ~Attribute();
            Attribute & operator =(const Attribute & src);
            AttrType get_type() const;
            static AttrType register_type(const Glib::ustring & name);
            unsigned int get_start_index() const;
            unsigned int get_end_index() const;
            void set_start_index(const unsigned int & value);
            void set_end_index(const unsigned int & value);
            bool equal(const Attribute & attr2) const;
            PangoAttribute * gobj()
            {
                return gobject_;
            }
            const PangoAttribute * gobj() const
            {
                return gobject_;
            }
            static AttrString create_attr_family(const Glib::ustring & family);
            static AttrLanguage create_attr_language(const Language & language);
            static AttrColor create_attr_foreground(guint16 red, guint16 green, guint16 blue);
            static AttrColor create_attr_background(guint16 red, guint16 green, guint16 blue);
            static AttrInt create_attr_size(int size);
            static AttrInt create_attr_style(Style style);
            static AttrInt create_attr_weight(Weight weight);
            static AttrInt create_attr_variant(Variant variant);
            static AttrInt create_attr_stretch(Stretch stretch);
            static AttrFontDesc create_attr_font_desc(const FontDescription & desc);
            static AttrInt create_attr_underline(Underline underline);
            static AttrInt create_attr_strikethrough(bool strikethrough);
            static AttrInt create_attr_rise(int rise);
            static AttrFloat create_attr_scale(double scale_factor);
            static AttrShape create_attr_shape(const Rectangle & ink_rect, const Rectangle & logical_rect);
        protected :
            PangoAttribute * gobject_;
    };
    inline bool operator ==(const Attribute & lhs, const Attribute & rhs)
    {
        return lhs.equal(rhs);
    }
    inline bool operator !=(const Attribute & lhs, const Attribute & rhs)
    {
        return lhs.equal(rhs);
    }
    class AttrString : public Attribute
    {
        public :
            typedef AttrString CppObjectType;
            typedef PangoAttrString BaseObjectType;
        private :
        protected :
            AttrString();
        public :
            AttrString(const AttrString & src);
            explicit AttrString(PangoAttrString * castitem, bool take_copy = true);
            AttrString & operator =(const AttrString & src);
            Glib::ustring get_string() const;
            void set_string(const Glib::ustring & string);
            PangoAttrString * gobj()
            {
                return reinterpret_cast<PangoAttrString * >(gobject_);
            }
            const PangoAttrString * gobj() const
            {
                return reinterpret_cast<const PangoAttrString * >(gobject_);
            }
    };
    class AttrLanguage : public Attribute
    {
        public :
            typedef AttrLanguage CppObjectType;
            typedef PangoAttrLanguage BaseObjectType;
        private :
        protected :
            AttrLanguage();
        public :
            AttrLanguage(const AttrLanguage & src);
            explicit AttrLanguage(PangoAttrLanguage * castitem, bool take_copy = true);
            AttrLanguage & operator =(const AttrLanguage & src);
            Language get_language() const;
            void set_language(const Language & value);
            PangoAttrLanguage * gobj()
            {
                return reinterpret_cast<PangoAttrLanguage * >(gobject_);
            }
            const PangoAttrLanguage * gobj() const
            {
                return reinterpret_cast<const PangoAttrLanguage * >(gobject_);
            }
    };
    class AttrColor : public Attribute
    {
        public :
            typedef AttrColor CppObjectType;
            typedef PangoAttrColor BaseObjectType;
        private :
        protected :
            AttrColor();
        public :
            AttrColor(const AttrColor & src);
            explicit AttrColor(PangoAttrColor * castitem, bool take_copy = true);
            AttrColor & operator =(const AttrColor & src);
            Color get_color() const;
            void set_color(const Color & value);
            PangoAttrColor * gobj()
            {
                return reinterpret_cast<PangoAttrColor * >(gobject_);
            }
            const PangoAttrColor * gobj() const
            {
                return reinterpret_cast<const PangoAttrColor * >(gobject_);
            }
    };
    class AttrInt : public Attribute
    {
        public :
            typedef AttrInt CppObjectType;
            typedef PangoAttrInt BaseObjectType;
        private :
        protected :
            AttrInt();
        public :
            AttrInt(const AttrInt & src);
            explicit AttrInt(PangoAttrInt * castitem, bool take_copy = true);
            AttrInt & operator =(const AttrInt & src);
            int get_value() const;
            void set_value(const int & value);
            PangoAttrInt * gobj()
            {
                return reinterpret_cast<PangoAttrInt * >(gobject_);
            }
            const PangoAttrInt * gobj() const
            {
                return reinterpret_cast<const PangoAttrInt * >(gobject_);
            }
    };
    class AttrFloat : public Attribute
    {
        public :
            typedef AttrFloat CppObjectType;
            typedef PangoAttrFloat BaseObjectType;
        private :
        protected :
            AttrFloat();
        public :
            AttrFloat(const AttrFloat & src);
            explicit AttrFloat(PangoAttrFloat * castitem, bool take_copy = true);
            AttrFloat & operator =(const AttrFloat & src);
            double get_value() const;
            void set_value(const double & value);
            PangoAttrFloat * gobj()
            {
                return reinterpret_cast<PangoAttrFloat * >(gobject_);
            }
            const PangoAttrFloat * gobj() const
            {
                return reinterpret_cast<const PangoAttrFloat * >(gobject_);
            }
    };
    class AttrFontDesc : public Attribute
    {
        public :
            typedef AttrFontDesc CppObjectType;
            typedef PangoAttrFontDesc BaseObjectType;
        private :
        protected :
            AttrFontDesc();
        public :
            AttrFontDesc(const AttrFontDesc & src);
            explicit AttrFontDesc(PangoAttrFontDesc * castitem, bool take_copy = true);
            AttrFontDesc & operator =(const AttrFontDesc & src);
            FontDescription get_desc() const;
            void set_desc(const FontDescription & desc);
            PangoAttrFontDesc * gobj()
            {
                return reinterpret_cast<PangoAttrFontDesc * >(gobject_);
            }
            const PangoAttrFontDesc * gobj() const
            {
                return reinterpret_cast<const PangoAttrFontDesc * >(gobject_);
            }
    };
    class AttrShape : public Attribute
    {
        public :
            typedef AttrShape CppObjectType;
            typedef PangoAttrShape BaseObjectType;
        private :
        protected :
            AttrShape();
        public :
            AttrShape(const AttrShape & src);
            explicit AttrShape(PangoAttrShape * castitem, bool take_copy = true);
            AttrShape & operator =(const AttrShape & src);
            Rectangle get_ink_rect() const;
            Rectangle get_logical_rect() const;
            void set_ink_rect(const Rectangle & value);
            void set_logical_rect(const Rectangle & value);
            PangoAttrShape * gobj()
            {
                return reinterpret_cast<PangoAttrShape * >(gobject_);
            }
            const PangoAttrShape * gobj() const
            {
                return reinterpret_cast<const PangoAttrShape * >(gobject_);
            }
    };
    struct AttributeTraits
    {
            typedef Pango::Attribute CppType;
            typedef const PangoAttribute * CType;
            typedef PangoAttribute * CTypeNonConst;
            static CType to_c_type(const CppType & obj)
            {
                return obj.gobj();
            }
            static CType to_c_type(CType ptr)
            {
                return ptr;
            }
            static CppType to_cpp_type(CType ptr)
            {
                return CppType(const_cast<CTypeNonConst >(ptr), true);
            }
            static void release_c_type(CType ptr)
            {
                pango_attribute_destroy(const_cast<CTypeNonConst >(ptr));
            }
    };
    typedef Glib::SListHandle< Attribute, AttributeTraits > SListHandle_Attribute;
}
namespace Glib {
    Pango::Attribute wrap(PangoAttribute * object, bool take_copy = false);
    Pango::AttrString wrap(PangoAttrString * object, bool take_copy = false);
    Pango::AttrLanguage wrap(PangoAttrLanguage * object, bool take_copy = false);
    Pango::AttrColor wrap(PangoAttrColor * object, bool take_copy = false);
    Pango::AttrInt wrap(PangoAttrInt * object, bool take_copy = false);
    Pango::AttrFloat wrap(PangoAttrFloat * object, bool take_copy = false);
    Pango::AttrFontDesc wrap(PangoAttrFontDesc * object, bool take_copy = false);
    Pango::AttrShape wrap(PangoAttrShape * object, bool take_copy = false);
}
namespace Pango {
    class Font;
    class GlyphString;
    class Analysis
    {
        public :
            typedef Analysis CppObjectType;
            typedef PangoAnalysis BaseObjectType;
        private :
        protected :
            Analysis();
        public :
            explicit Analysis(const PangoAnalysis * src);
        public :
            Glib::RefPtr< Font > get_font();
            Glib::RefPtr< const Font > get_font() const;
            guint8 get_level() const;
            Language get_language() const;
            SListHandle_Attribute get_extra_attrs() const;
            PangoAnalysis * gobj()
            {
                return &gobject_;
            }
            const PangoAnalysis * gobj() const
            {
                return &gobject_;
            }
        protected :
            PangoAnalysis gobject_;
    };
    class Item
    {
        public :
            typedef Item CppObjectType;
            typedef PangoItem BaseObjectType;
        private :
        public :
            explicit Item(PangoItem * castitem, bool make_a_copy = true);
            Item(const Item & src);
            Item & operator =(const Item & src);
            ~Item();
            PangoItem * gobj_copy() const;
        public :
            Item split(int split_index, int split_offset);
            int get_offset() const;
            int get_length() const;
            int get_num_chars() const;
            Analysis get_analysis() const;
            Glib::ustring get_segment(const Glib::ustring & text) const;
            GlyphString shape(const Glib::ustring & text) const;
            PangoItem * gobj()
            {
                return gobject_;
            }
            const PangoItem * gobj() const
            {
                return gobject_;
            }
        protected :
            PangoItem * gobject_;
    };
    struct ItemTraits
    {
            typedef Pango::Item CppType;
            typedef const PangoItem * CType;
            typedef PangoItem * CTypeNonConst;
            static CType to_c_type(const CppType & obj)
            {
                return obj.gobj();
            }
            static CType to_c_type(CType ptr)
            {
                return ptr;
            }
            static CppType to_cpp_type(CType ptr)
            {
                return CppType(const_cast<CTypeNonConst >(ptr), true);
            }
            static void release_c_type(CType ptr)
            {
                pango_item_free(const_cast<CTypeNonConst >(ptr));
            }
    };
    typedef Glib::ListHandle< Item, ItemTraits > ListHandle_Item;
}
namespace Glib {
    Pango::Analysis & wrap(PangoAnalysis * object);
    const Pango::Analysis & wrap(const PangoAnalysis * object);
    Pango::Item wrap(PangoItem * object, bool take_copy = true);
}
namespace Pango {
    class AttrIter
    {
        public :
            typedef AttrIter CppObjectType;
            typedef PangoAttrIterator BaseObjectType;
        private :
        public :
            typedef std::forward_iterator_tag iterator_category;
            typedef int difference_type;
        protected :
            AttrIter();
        public :
            explicit AttrIter(PangoAttrIterator * castitem, bool take_copy = true);
            AttrIter(const AttrIter & src);
            ~AttrIter();
            AttrIter & operator =(const AttrIter & src);
            AttrIter & operator ++();
            const AttrIter operator ++(int);
            operator bool() const;
            bool next();
            void get_range(int & start, int & end) const;
            Attribute get_attribute(AttrType type) const;
            FontDescription get_font_desc() const;
            Language get_language() const;
            SListHandle_Attribute get_extra_attrs() const;
            SListHandle_Attribute get_attrs() const;
            PangoAttrIterator * gobj()
            {
                return gobject_;
            }
            const PangoAttrIterator * gobj() const
            {
                return gobject_;
            }
        protected :
            PangoAttrIterator * gobject_;
    };
}
namespace Glib {
    Pango::AttrIter wrap(PangoAttrIterator * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _PangoAttrList PangoAttrList;
}
namespace Pango {
    class AttrList
    {
        public :
            typedef AttrList CppObjectType;
            typedef PangoAttrList BaseObjectType;
            static GType get_type() __attribute__((__const__));
            AttrList();
            explicit AttrList(PangoAttrList * gobject, bool make_a_copy = true);
            AttrList(const AttrList & other);
            AttrList & operator =(const AttrList & other);
            ~AttrList();
            void swap(AttrList & other);
            PangoAttrList * gobj()
            {
                return gobject_;
            }
            const PangoAttrList * gobj() const
            {
                return gobject_;
            }
            PangoAttrList * gobj_copy() const;
        protected :
            PangoAttrList * gobject_;
        private :
        public :
            explicit AttrList(const Glib::ustring & markup_text, gunichar accel_marker = 0);
            AttrList(const Glib::ustring & markup_text, gunichar accel_marker, Glib::ustring & text, gunichar & accel_char);
            operator bool();
            void insert(Attribute & attr);
            void insert_before(Attribute & attr);
            void change(Attribute & attr);
            void splice(AttrList & other, int pos, int len);
            AttrIter get_iter();
    };
}
namespace Pango {
    inline void swap(AttrList & lhs, AttrList & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    Pango::AttrList wrap(PangoAttrList * object, bool take_copy = false);
    template<>
    class Value< Pango::AttrList > : public Glib::Value_Boxed< Pango::AttrList >
    {
    };
}
namespace Pango {
    typedef PangoMatrix Matrix;
}
namespace std __attribute__((__visibility__("default"))) {
    namespace rel_ops {
        template<class _Tp >
        inline bool operator !=(const _Tp & __x, const _Tp & __y)
        {
            return !(__x == __y);
        }
        template<class _Tp >
        inline bool operator >(const _Tp & __x, const _Tp & __y)
        {
            return __y < __x;
        }
        template<class _Tp >
        inline bool operator <=(const _Tp & __x, const _Tp & __y)
        {
            return !(__y < __x);
        }
        template<class _Tp >
        inline bool operator >=(const _Tp & __x, const _Tp & __y)
        {
            return !(__x < __y);
        }
    }
}
namespace std __attribute__((__visibility__("default"))) {
    class logic_error : public exception
    {
            string _M_msg;
        public :
            explicit logic_error(const string & __arg);
            virtual ~logic_error() throw ();
            virtual const char * what() const throw ();
    };
    class domain_error : public logic_error
    {
        public :
            explicit domain_error(const string & __arg);
    };
    class invalid_argument : public logic_error
    {
        public :
            explicit invalid_argument(const string & __arg);
    };
    class length_error : public logic_error
    {
        public :
            explicit length_error(const string & __arg);
    };
    class out_of_range : public logic_error
    {
        public :
            explicit out_of_range(const string & __arg);
    };
    class runtime_error : public exception
    {
            string _M_msg;
        public :
            explicit runtime_error(const string & __arg);
            virtual ~runtime_error() throw ();
            virtual const char * what() const throw ();
    };
    class range_error : public runtime_error
    {
        public :
            explicit range_error(const string & __arg);
    };
    class overflow_error : public runtime_error
    {
        public :
            explicit overflow_error(const string & __arg);
    };
    class underflow_error : public runtime_error
    {
        public :
            explicit underflow_error(const string & __arg);
    };
}
namespace Cairo {
    class logic_error : public std::logic_error
    {
        public :
            explicit logic_error(ErrorStatus status);
            virtual ~logic_error() throw ();
            ErrorStatus get_status_code() const;
        private :
            ErrorStatus m_status;
    };
}
namespace Cairo {
    template<class T_CppObject >
    class RefPtr
    {
        public :
            inline RefPtr();
            inline ~RefPtr();
            explicit inline RefPtr(T_CppObject * pCppObject);
            explicit inline RefPtr(T_CppObject * pCppObject, int * refcount);
            inline RefPtr(const RefPtr< T_CppObject > & src);
            template<class T_CastFrom >
            inline RefPtr(const RefPtr< T_CastFrom > & src);
            inline void swap(RefPtr< T_CppObject > & other);
            inline RefPtr< T_CppObject > & operator =(const RefPtr< T_CppObject > & src);
            template<class T_CastFrom >
            inline RefPtr< T_CppObject > & operator =(const RefPtr< T_CastFrom > & src);
            inline bool operator ==(const RefPtr< T_CppObject > & src) const;
            inline bool operator !=(const RefPtr< T_CppObject > & src) const;
            inline T_CppObject * operator ->() const;
            inline operator bool() const;
            inline void clear();
            template<class T_CastFrom >
            static inline RefPtr< T_CppObject > cast_dynamic(const RefPtr< T_CastFrom > & src);
            template<class T_CastFrom >
            static inline RefPtr< T_CppObject > cast_static(const RefPtr< T_CastFrom > & src);
            template<class T_CastFrom >
            static inline RefPtr< T_CppObject > cast_const(const RefPtr< T_CastFrom > & src);
            inline int * refcount_() const
            {
                return pCppRefcount_;
            }
        private :
            void unref();
            T_CppObject * pCppObject_;
            mutable int * pCppRefcount_;
    };
    template<class T_CppObject >
    inline T_CppObject * RefPtr< T_CppObject >::operator ->() const
    {
        return pCppObject_;
    }
    template<class T_CppObject >
    inline RefPtr< T_CppObject >::RefPtr()
        : pCppObject_(0), pCppRefcount_(0) 
    {
    }
    template<class T_CppObject >
    inline RefPtr< T_CppObject >::~RefPtr()
    {
        unref();
    }
    template<class T_CppObject >
    inline void RefPtr< T_CppObject >::unref()
    {
        if (pCppRefcount_)
        {
            --(*pCppRefcount_);
            if (*pCppRefcount_ == 0)
            {
                if (pCppObject_)
                {
                    delete pCppObject_;
                    pCppObject_ = 0;
                }
                delete pCppRefcount_;
                pCppRefcount_ = 0;
            }
        }
    }
    template<class T_CppObject >
    inline RefPtr< T_CppObject >::RefPtr(T_CppObject * pCppObject)
        : pCppObject_(pCppObject), pCppRefcount_(0) 
    {
        if (pCppObject)
        {
            pCppRefcount_ = new int;
            *pCppRefcount_ = 1;
        }
    }
    template<class T_CppObject >
    inline RefPtr< T_CppObject >::RefPtr(T_CppObject * pCppObject, int * refcount)
        : pCppObject_(pCppObject), pCppRefcount_(refcount) 
    {
        if (pCppObject_ && pCppRefcount_)
            ++(*pCppRefcount_);
    }
    template<class T_CppObject >
    inline RefPtr< T_CppObject >::RefPtr(const RefPtr< T_CppObject > & src)
        : pCppObject_(src.pCppObject_), pCppRefcount_(src.pCppRefcount_) 
    {
        if (pCppObject_ && pCppRefcount_)
            ++(*pCppRefcount_);
    }
    template<class T_CppObject >
    template<class T_CastFrom >
    inline RefPtr< T_CppObject >::RefPtr(const RefPtr< T_CastFrom > & src)
        : pCppObject_(src.operator ->()), pCppRefcount_(src.refcount_()) 
    {
        if (pCppObject_ && pCppRefcount_)
            ++(*pCppRefcount_);
    }
    template<class T_CppObject >
    inline void RefPtr< T_CppObject >::swap(RefPtr< T_CppObject > & other)
    {
        T_CppObject *const temp = pCppObject_;
        int * temp_count = pCppRefcount_;
        pCppObject_ = other.pCppObject_;
        pCppRefcount_ = other.pCppRefcount_;
        other.pCppObject_ = temp;
        other.pCppRefcount_ = temp_count;
    }
    template<class T_CppObject >
    inline RefPtr< T_CppObject > & RefPtr< T_CppObject >::operator =(const RefPtr< T_CppObject > & src)
    {
        RefPtr< T_CppObject > temp(src);
        this->swap(temp);
        return *this;
    }
    template<class T_CppObject >
    template<class T_CastFrom >
    inline RefPtr< T_CppObject > & RefPtr< T_CppObject >::operator =(const RefPtr< T_CastFrom > & src)
    {
        RefPtr< T_CppObject > temp(src);
        this->swap(temp);
        return *this;
    }
    template<class T_CppObject >
    inline bool RefPtr< T_CppObject >::operator ==(const RefPtr< T_CppObject > & src) const
    {
        return (pCppObject_ == src.pCppObject_);
    }
    template<class T_CppObject >
    inline bool RefPtr< T_CppObject >::operator !=(const RefPtr< T_CppObject > & src) const
    {
        return (pCppObject_ != src.pCppObject_);
    }
    template<class T_CppObject >
    inline RefPtr< T_CppObject >::operator bool() const
    {
        return (pCppObject_ != 0);
    }
    template<class T_CppObject >
    inline void RefPtr< T_CppObject >::clear()
    {
        RefPtr< T_CppObject > temp;
        this->swap(temp);
    }
    template<class T_CppObject >
    template<class T_CastFrom >
    inline RefPtr< T_CppObject > RefPtr< T_CppObject >::cast_dynamic(const RefPtr< T_CastFrom > & src)
    {
        T_CppObject *const pCppObject = dynamic_cast<T_CppObject * >(src.operator ->());
        if (pCppObject)
            return RefPtr< T_CppObject >(pCppObject, src.refcount_());
        else
            return RefPtr< T_CppObject >();
    }
    template<class T_CppObject >
    template<class T_CastFrom >
    inline RefPtr< T_CppObject > RefPtr< T_CppObject >::cast_static(const RefPtr< T_CastFrom > & src)
    {
        T_CppObject *const pCppObject = static_cast<T_CppObject * >(src.operator ->());
        return RefPtr< T_CppObject >(pCppObject, src.refcount_());
    }
    template<class T_CppObject >
    template<class T_CastFrom >
    inline RefPtr< T_CppObject > RefPtr< T_CppObject >::cast_const(const RefPtr< T_CastFrom > & src)
    {
        T_CppObject *const pCppObject = const_cast<T_CppObject * >(src.operator ->());
        return RefPtr< T_CppObject >(pCppObject, src.refcount_());
    }
    template<class T_CppObject >
    inline void swap(RefPtr< T_CppObject > & lhs, RefPtr< T_CppObject > & rhs)
    {
        lhs.swap(rhs);
    }
}
extern "C"
{
    cairo_surface_t * cairo_pdf_surface_create(const char * filename, double width_in_points, double height_in_points);
    cairo_surface_t * cairo_pdf_surface_create_for_stream(cairo_write_func_t write_func, void * closure, double width_in_points, double height_in_points);
    void cairo_pdf_surface_set_size(cairo_surface_t * surface, double width_in_points, double height_in_points);
}
extern "C"
{
    typedef enum _cairo_ps_level
    {
        CAIRO_PS_LEVEL_2, 
        CAIRO_PS_LEVEL_3
    } cairo_ps_level_t;
    cairo_surface_t * cairo_ps_surface_create(const char * filename, double width_in_points, double height_in_points);
    cairo_surface_t * cairo_ps_surface_create_for_stream(cairo_write_func_t write_func, void * closure, double width_in_points, double height_in_points);
    void cairo_ps_surface_restrict_to_level(cairo_surface_t * surface, cairo_ps_level_t level);
    void cairo_ps_get_levels(cairo_ps_level_t const * * levels, int * num_levels);
    const char * cairo_ps_level_to_string(cairo_ps_level_t level);
    void cairo_ps_surface_set_eps(cairo_surface_t * surface, cairo_bool_t eps);
    cairo_bool_t cairo_ps_surface_get_eps(cairo_surface_t * surface);
    void cairo_ps_surface_set_size(cairo_surface_t * surface, double width_in_points, double height_in_points);
    void cairo_ps_surface_dsc_comment(cairo_surface_t * surface, const char * comment);
    void cairo_ps_surface_dsc_begin_setup(cairo_surface_t * surface);
    void cairo_ps_surface_dsc_begin_page_setup(cairo_surface_t * surface);
}
extern "C"
{
    typedef enum _cairo_svg_version
    {
        CAIRO_SVG_VERSION_1_1, 
        CAIRO_SVG_VERSION_1_2
    } cairo_svg_version_t;
    cairo_surface_t * cairo_svg_surface_create(const char * filename, double width_in_points, double height_in_points);
    cairo_surface_t * cairo_svg_surface_create_for_stream(cairo_write_func_t write_func, void * closure, double width_in_points, double height_in_points);
    void cairo_svg_surface_restrict_to_version(cairo_surface_t * surface, cairo_svg_version_t version);
    void cairo_svg_get_versions(cairo_svg_version_t const * * versions, int * num_versions);
    const char * cairo_svg_version_to_string(cairo_svg_version_t version);
}
namespace Cairo {
    class Surface
    {
        public :
            explicit Surface(cairo_surface_t * cobject, bool has_reference = false);
            virtual ~Surface();
            void get_font_options(FontOptions & options) const;
            void finish();
            void flush();
            void mark_dirty();
            void mark_dirty(int x, int y, int width, int height);
            void set_device_offset(double x_offset, double y_offset);
            void get_device_offset(double & x_offset, double & y_offset) const;
            void set_fallback_resolution(double x_pixels_per_inch, double y_pixels_per_inch);
            SurfaceType get_type() const;
            void copy_page();
            void show_page();
            void write_to_png(const std::string & filename);
            void write_to_png(cairo_write_func_t write_func, void * closure);
            typedef cairo_surface_t cobject;
            inline cobject * cobj()
            {
                return m_cobject;
            }
            inline const cobject * cobj() const
            {
                return m_cobject;
            }
            inline ErrorStatus get_status() const
            {
                return cairo_surface_status(const_cast<cairo_surface_t * >(cobj()));
            }
            void reference() const;
            void unreference() const;
            static RefPtr< Surface > create(const RefPtr< Surface > other, Content content, int width, int height);
        protected :
            cobject * m_cobject;
    };
    class ImageSurface : public Surface
    {
        protected :
        public :
            explicit ImageSurface(cairo_surface_t * cobject, bool has_reference = false);
            virtual ~ImageSurface();
            int get_width() const;
            int get_height() const;
            unsigned char * get_data();
            const unsigned char * get_data() const;
            Format get_format() const;
            int get_stride() const;
            static int format_stride_for_width(Cairo::Format format, int width);
            static RefPtr< ImageSurface > create(Format format, int width, int height);
            static RefPtr< ImageSurface > create(unsigned char * data, Format format, int width, int height, int stride);
            static RefPtr< ImageSurface > create_from_png(std::string filename);
            static RefPtr< ImageSurface > create_from_png(cairo_read_func_t read_func, void * closure);
    };
    class PdfSurface : public Surface
    {
        public :
            explicit PdfSurface(cairo_surface_t * cobject, bool has_reference = false);
            virtual ~PdfSurface();
            static RefPtr< PdfSurface > create(std::string filename, double width_in_points, double height_in_points);
            static RefPtr< PdfSurface > create(cairo_write_func_t write_func, void * closure, double width_in_points, double height_in_points);
            void set_size(double width_in_points, double height_in_points);
    };
    typedef enum 
    {
        PS_LEVEL_2 = CAIRO_PS_LEVEL_2, 
        PS_LEVEL_3 = CAIRO_PS_LEVEL_3
    } PsLevel;
    class PsSurface : public Surface
    {
        public :
            explicit PsSurface(cairo_surface_t * cobject, bool has_reference = false);
            virtual ~PsSurface();
            static RefPtr< PsSurface > create(std::string filename, double width_in_points, double height_in_points);
            static RefPtr< PsSurface > create(cairo_write_func_t write_func, void * closure, double width_in_points, double height_in_points);
            void set_size(double width_in_points, double height_in_points);
            void dsc_comment(std::string comment);
            void dsc_begin_setup();
            void dsc_begin_page_setup();
            void set_eps(bool eps);
            void restrict_to_level(PsLevel level);
            static const std::vector< PsLevel > get_levels();
            static std::string level_to_string(PsLevel level);
    };
    typedef enum 
    {
        SVG_VERSION_1_1 = CAIRO_SVG_VERSION_1_1, 
        SVG_VERSION_1_2 = CAIRO_SVG_VERSION_1_2
    } SvgVersion;
    class SvgSurface : public Surface
    {
        public :
            explicit SvgSurface(cairo_surface_t * cobject, bool has_reference = false);
            virtual ~SvgSurface();
            static RefPtr< SvgSurface > create(std::string filename, double width_in_points, double height_in_points);
            static RefPtr< SvgSurface > create(cairo_write_func_t write_func, void * closure, double width_in_points, double height_in_points);
            void restrict_to_version(SvgVersion version);
            static const std::vector< SvgVersion > get_versions();
            static std::string version_to_string(SvgVersion version);
    };
}
namespace Cairo {
    class FontFace
    {
        protected :
        public :
            explicit FontFace(cairo_font_face_t * cobject, bool has_reference = false);
            virtual ~FontFace();
            FontType get_type() const;
            typedef cairo_font_face_t cobject;
            inline cobject * cobj()
            {
                return m_cobject;
            }
            inline const cobject * cobj() const
            {
                return m_cobject;
            }
            inline ErrorStatus get_status() const
            {
                return cairo_font_face_status(const_cast<cairo_font_face_t * >(cobj()));
            }
            void reference() const;
            void unreference() const;
        protected :
            cobject * m_cobject;
    };
}
namespace Cairo {
    struct ColorStop
    {
            double offset;
            double red, green, blue, alpha;
    };
    class Pattern
    {
        protected :
        public :
            explicit Pattern(cairo_pattern_t * cobject, bool has_reference = false);
            virtual ~Pattern();
            void set_matrix(const cairo_matrix_t & matrix);
            void get_matrix(cairo_matrix_t & matrix) const;
            PatternType get_type() const;
            typedef cairo_pattern_t cobject;
            inline cobject * cobj()
            {
                return m_cobject;
            }
            inline const cobject * cobj() const
            {
                return m_cobject;
            }
            inline ErrorStatus get_status() const
            {
                return cairo_pattern_status(const_cast<cairo_pattern_t * >(cobj()));
            }
            void reference() const;
            void unreference() const;
        protected :
            Pattern();
            cobject * m_cobject;
    };
    class SolidPattern : public Pattern
    {
        protected :
        public :
            explicit SolidPattern(cairo_pattern_t * cobject, bool has_reference = false);
            void get_rgba(double & red, double & green, double & blue, double & alpha) const;
            static RefPtr< SolidPattern > create_rgb(double red, double green, double blue);
            static RefPtr< SolidPattern > create_rgba(double red, double green, double blue, double alpha);
            virtual ~SolidPattern();
    };
    class SurfacePattern : public Pattern
    {
        protected :
            explicit SurfacePattern(const RefPtr< Surface > & surface);
        public :
            explicit SurfacePattern(cairo_pattern_t * cobject, bool has_reference = false);
            RefPtr< const Surface > get_surface() const;
            RefPtr< Surface > get_surface();
            virtual ~SurfacePattern();
            static RefPtr< SurfacePattern > create(const RefPtr< Surface > & surface);
            void set_extend(Extend extend);
            Extend get_extend() const;
            void set_filter(Filter filter);
            Filter get_filter() const;
    };
    class Gradient : public Pattern
    {
        protected :
        public :
            explicit Gradient(cairo_pattern_t * cobject, bool has_reference = false);
            virtual ~Gradient();
            void add_color_stop_rgb(double offset, double red, double green, double blue);
            void add_color_stop_rgba(double offset, double red, double green, double blue, double alpha);
            std::vector< ColorStop > get_color_stops() const;
        protected :
            Gradient();
    };
    class LinearGradient : public Gradient
    {
        protected :
            LinearGradient(double x0, double y0, double x1, double y1);
        public :
            explicit LinearGradient(cairo_pattern_t * cobject, bool has_reference = false);
            void get_linear_points(double & x0, double & y0, double & x1, double & y1) const;
            virtual ~LinearGradient();
            static RefPtr< LinearGradient > create(double x0, double y0, double x1, double y1);
    };
    class RadialGradient : public Gradient
    {
        protected :
            RadialGradient(double cx0, double cy0, double radius0, double cx1, double cy1, double radius1);
        public :
            explicit RadialGradient(cairo_pattern_t * cobject, bool has_reference = false);
            void get_radial_circles(double & x0, double & y0, double & r0, double & x1, double & y1, double & r1) const;
            virtual ~RadialGradient();
            static RefPtr< RadialGradient > create(double cx0, double cy0, double radius0, double cx1, double cy1, double radius1);
    };
}
namespace Cairo {
    class Path
    {
        public :
            explicit Path(cairo_path_t * cobject, bool take_ownership = false);
            virtual ~Path();
            typedef cairo_path_t cobject;
            inline cobject * cobj()
            {
                return m_cobject;
            }
            inline const cobject * cobj() const
            {
                return m_cobject;
            }
        protected :
            cobject * m_cobject;
    };
}
extern "C"
{
    typedef float float_t;
    typedef double double_t;
    extern double acos(double __x) throw ();
    extern double __acos(double __x) throw ();
    extern double asin(double __x) throw ();
    extern double __asin(double __x) throw ();
    extern double atan(double __x) throw ();
    extern double __atan(double __x) throw ();
    extern double atan2(double __y, double __x) throw ();
    extern double __atan2(double __y, double __x) throw ();
    extern double cos(double __x) throw ();
    extern double __cos(double __x) throw ();
    extern double sin(double __x) throw ();
    extern double __sin(double __x) throw ();
    extern double tan(double __x) throw ();
    extern double __tan(double __x) throw ();
    extern double cosh(double __x) throw ();
    extern double __cosh(double __x) throw ();
    extern double sinh(double __x) throw ();
    extern double __sinh(double __x) throw ();
    extern double tanh(double __x) throw ();
    extern double __tanh(double __x) throw ();
    extern void sincos(double __x, double * __sinx, double * __cosx) throw ();
    extern void __sincos(double __x, double * __sinx, double * __cosx) throw ();
    extern double acosh(double __x) throw ();
    extern double __acosh(double __x) throw ();
    extern double asinh(double __x) throw ();
    extern double __asinh(double __x) throw ();
    extern double atanh(double __x) throw ();
    extern double __atanh(double __x) throw ();
    extern double exp(double __x) throw ();
    extern double __exp(double __x) throw ();
    extern double frexp(double __x, int * __exponent) throw ();
    extern double __frexp(double __x, int * __exponent) throw ();
    extern double ldexp(double __x, int __exponent) throw ();
    extern double __ldexp(double __x, int __exponent) throw ();
    extern double log(double __x) throw ();
    extern double __log(double __x) throw ();
    extern double log10(double __x) throw ();
    extern double __log10(double __x) throw ();
    extern double modf(double __x, double * __iptr) throw ();
    extern double __modf(double __x, double * __iptr) throw ();
    extern double exp10(double __x) throw ();
    extern double __exp10(double __x) throw ();
    extern double pow10(double __x) throw ();
    extern double __pow10(double __x) throw ();
    extern double expm1(double __x) throw ();
    extern double __expm1(double __x) throw ();
    extern double log1p(double __x) throw ();
    extern double __log1p(double __x) throw ();
    extern double logb(double __x) throw ();
    extern double __logb(double __x) throw ();
    extern double exp2(double __x) throw ();
    extern double __exp2(double __x) throw ();
    extern double log2(double __x) throw ();
    extern double __log2(double __x) throw ();
    extern double pow(double __x, double __y) throw ();
    extern double __pow(double __x, double __y) throw ();
    extern double sqrt(double __x) throw ();
    extern double __sqrt(double __x) throw ();
    extern double hypot(double __x, double __y) throw ();
    extern double __hypot(double __x, double __y) throw ();
    extern double cbrt(double __x) throw ();
    extern double __cbrt(double __x) throw ();
    extern double ceil(double __x) throw () __attribute__((__const__));
    extern double __ceil(double __x) throw () __attribute__((__const__));
    extern double fabs(double __x) throw () __attribute__((__const__));
    extern double __fabs(double __x) throw () __attribute__((__const__));
    extern double floor(double __x) throw () __attribute__((__const__));
    extern double __floor(double __x) throw () __attribute__((__const__));
    extern double fmod(double __x, double __y) throw ();
    extern double __fmod(double __x, double __y) throw ();
    extern int __isinf(double __value) throw () __attribute__((__const__));
    extern int __finite(double __value) throw () __attribute__((__const__));
    extern int isinf(double __value) throw () __attribute__((__const__));
    extern int finite(double __value) throw () __attribute__((__const__));
    extern double drem(double __x, double __y) throw ();
    extern double __drem(double __x, double __y) throw ();
    extern double significand(double __x) throw ();
    extern double __significand(double __x) throw ();
    extern double copysign(double __x, double __y) throw () __attribute__((__const__));
    extern double __copysign(double __x, double __y) throw () __attribute__((__const__));
    extern double nan(__const char * __tagb) throw () __attribute__((__const__));
    extern double __nan(__const char * __tagb) throw () __attribute__((__const__));
    extern int __isnan(double __value) throw () __attribute__((__const__));
    extern int isnan(double __value) throw () __attribute__((__const__));
    extern double j0(double) throw ();
    extern double __j0(double) throw ();
    extern double j1(double) throw ();
    extern double __j1(double) throw ();
    extern double jn(int, double) throw ();
    extern double __jn(int, double) throw ();
    extern double y0(double) throw ();
    extern double __y0(double) throw ();
    extern double y1(double) throw ();
    extern double __y1(double) throw ();
    extern double yn(int, double) throw ();
    extern double __yn(int, double) throw ();
    extern double erf(double) throw ();
    extern double __erf(double) throw ();
    extern double erfc(double) throw ();
    extern double __erfc(double) throw ();
    extern double lgamma(double) throw ();
    extern double __lgamma(double) throw ();
    extern double tgamma(double) throw ();
    extern double __tgamma(double) throw ();
    extern double gamma(double) throw ();
    extern double __gamma(double) throw ();
    extern double lgamma_r(double, int * __signgamp) throw ();
    extern double __lgamma_r(double, int * __signgamp) throw ();
    extern double rint(double __x) throw ();
    extern double __rint(double __x) throw ();
    extern double nextafter(double __x, double __y) throw () __attribute__((__const__));
    extern double __nextafter(double __x, double __y) throw () __attribute__((__const__));
    extern double nexttoward(double __x, long double __y) throw () __attribute__((__const__));
    extern double __nexttoward(double __x, long double __y) throw () __attribute__((__const__));
    extern double remainder(double __x, double __y) throw ();
    extern double __remainder(double __x, double __y) throw ();
    extern double scalbn(double __x, int __n) throw ();
    extern double __scalbn(double __x, int __n) throw ();
    extern int ilogb(double __x) throw ();
    extern int __ilogb(double __x) throw ();
    extern double scalbln(double __x, long int __n) throw ();
    extern double __scalbln(double __x, long int __n) throw ();
    extern double nearbyint(double __x) throw ();
    extern double __nearbyint(double __x) throw ();
    extern double round(double __x) throw () __attribute__((__const__));
    extern double __round(double __x) throw () __attribute__((__const__));
    extern double trunc(double __x) throw () __attribute__((__const__));
    extern double __trunc(double __x) throw () __attribute__((__const__));
    extern double remquo(double __x, double __y, int * __quo) throw ();
    extern double __remquo(double __x, double __y, int * __quo) throw ();
    extern long int lrint(double __x) throw ();
    extern long int __lrint(double __x) throw ();
    extern long long int llrint(double __x) throw ();
    extern long long int __llrint(double __x) throw ();
    extern long int lround(double __x) throw ();
    extern long int __lround(double __x) throw ();
    extern long long int llround(double __x) throw ();
    extern long long int __llround(double __x) throw ();
    extern double fdim(double __x, double __y) throw ();
    extern double __fdim(double __x, double __y) throw ();
    extern double fmax(double __x, double __y) throw ();
    extern double __fmax(double __x, double __y) throw ();
    extern double fmin(double __x, double __y) throw ();
    extern double __fmin(double __x, double __y) throw ();
    extern int __fpclassify(double __value) throw () __attribute__((__const__));
    extern int __signbit(double __value) throw () __attribute__((__const__));
    extern double fma(double __x, double __y, double __z) throw ();
    extern double __fma(double __x, double __y, double __z) throw ();
    extern double scalb(double __x, double __n) throw ();
    extern double __scalb(double __x, double __n) throw ();
    extern float acosf(float __x) throw ();
    extern float __acosf(float __x) throw ();
    extern float asinf(float __x) throw ();
    extern float __asinf(float __x) throw ();
    extern float atanf(float __x) throw ();
    extern float __atanf(float __x) throw ();
    extern float atan2f(float __y, float __x) throw ();
    extern float __atan2f(float __y, float __x) throw ();
    extern float cosf(float __x) throw ();
    extern float __cosf(float __x) throw ();
    extern float sinf(float __x) throw ();
    extern float __sinf(float __x) throw ();
    extern float tanf(float __x) throw ();
    extern float __tanf(float __x) throw ();
    extern float coshf(float __x) throw ();
    extern float __coshf(float __x) throw ();
    extern float sinhf(float __x) throw ();
    extern float __sinhf(float __x) throw ();
    extern float tanhf(float __x) throw ();
    extern float __tanhf(float __x) throw ();
    extern void sincosf(float __x, float * __sinx, float * __cosx) throw ();
    extern void __sincosf(float __x, float * __sinx, float * __cosx) throw ();
    extern float acoshf(float __x) throw ();
    extern float __acoshf(float __x) throw ();
    extern float asinhf(float __x) throw ();
    extern float __asinhf(float __x) throw ();
    extern float atanhf(float __x) throw ();
    extern float __atanhf(float __x) throw ();
    extern float expf(float __x) throw ();
    extern float __expf(float __x) throw ();
    extern float frexpf(float __x, int * __exponent) throw ();
    extern float __frexpf(float __x, int * __exponent) throw ();
    extern float ldexpf(float __x, int __exponent) throw ();
    extern float __ldexpf(float __x, int __exponent) throw ();
    extern float logf(float __x) throw ();
    extern float __logf(float __x) throw ();
    extern float log10f(float __x) throw ();
    extern float __log10f(float __x) throw ();
    extern float modff(float __x, float * __iptr) throw ();
    extern float __modff(float __x, float * __iptr) throw ();
    extern float exp10f(float __x) throw ();
    extern float __exp10f(float __x) throw ();
    extern float pow10f(float __x) throw ();
    extern float __pow10f(float __x) throw ();
    extern float expm1f(float __x) throw ();
    extern float __expm1f(float __x) throw ();
    extern float log1pf(float __x) throw ();
    extern float __log1pf(float __x) throw ();
    extern float logbf(float __x) throw ();
    extern float __logbf(float __x) throw ();
    extern float exp2f(float __x) throw ();
    extern float __exp2f(float __x) throw ();
    extern float log2f(float __x) throw ();
    extern float __log2f(float __x) throw ();
    extern float powf(float __x, float __y) throw ();
    extern float __powf(float __x, float __y) throw ();
    extern float sqrtf(float __x) throw ();
    extern float __sqrtf(float __x) throw ();
    extern float hypotf(float __x, float __y) throw ();
    extern float __hypotf(float __x, float __y) throw ();
    extern float cbrtf(float __x) throw ();
    extern float __cbrtf(float __x) throw ();
    extern float ceilf(float __x) throw () __attribute__((__const__));
    extern float __ceilf(float __x) throw () __attribute__((__const__));
    extern float fabsf(float __x) throw () __attribute__((__const__));
    extern float __fabsf(float __x) throw () __attribute__((__const__));
    extern float floorf(float __x) throw () __attribute__((__const__));
    extern float __floorf(float __x) throw () __attribute__((__const__));
    extern float fmodf(float __x, float __y) throw ();
    extern float __fmodf(float __x, float __y) throw ();
    extern int __isinff(float __value) throw () __attribute__((__const__));
    extern int __finitef(float __value) throw () __attribute__((__const__));
    extern int isinff(float __value) throw () __attribute__((__const__));
    extern int finitef(float __value) throw () __attribute__((__const__));
    extern float dremf(float __x, float __y) throw ();
    extern float __dremf(float __x, float __y) throw ();
    extern float significandf(float __x) throw ();
    extern float __significandf(float __x) throw ();
    extern float copysignf(float __x, float __y) throw () __attribute__((__const__));
    extern float __copysignf(float __x, float __y) throw () __attribute__((__const__));
    extern float nanf(__const char * __tagb) throw () __attribute__((__const__));
    extern float __nanf(__const char * __tagb) throw () __attribute__((__const__));
    extern int __isnanf(float __value) throw () __attribute__((__const__));
    extern int isnanf(float __value) throw () __attribute__((__const__));
    extern float j0f(float) throw ();
    extern float __j0f(float) throw ();
    extern float j1f(float) throw ();
    extern float __j1f(float) throw ();
    extern float jnf(int, float) throw ();
    extern float __jnf(int, float) throw ();
    extern float y0f(float) throw ();
    extern float __y0f(float) throw ();
    extern float y1f(float) throw ();
    extern float __y1f(float) throw ();
    extern float ynf(int, float) throw ();
    extern float __ynf(int, float) throw ();
    extern float erff(float) throw ();
    extern float __erff(float) throw ();
    extern float erfcf(float) throw ();
    extern float __erfcf(float) throw ();
    extern float lgammaf(float) throw ();
    extern float __lgammaf(float) throw ();
    extern float tgammaf(float) throw ();
    extern float __tgammaf(float) throw ();
    extern float gammaf(float) throw ();
    extern float __gammaf(float) throw ();
    extern float lgammaf_r(float, int * __signgamp) throw ();
    extern float __lgammaf_r(float, int * __signgamp) throw ();
    extern float rintf(float __x) throw ();
    extern float __rintf(float __x) throw ();
    extern float nextafterf(float __x, float __y) throw () __attribute__((__const__));
    extern float __nextafterf(float __x, float __y) throw () __attribute__((__const__));
    extern float nexttowardf(float __x, long double __y) throw () __attribute__((__const__));
    extern float __nexttowardf(float __x, long double __y) throw () __attribute__((__const__));
    extern float remainderf(float __x, float __y) throw ();
    extern float __remainderf(float __x, float __y) throw ();
    extern float scalbnf(float __x, int __n) throw ();
    extern float __scalbnf(float __x, int __n) throw ();
    extern int ilogbf(float __x) throw ();
    extern int __ilogbf(float __x) throw ();
    extern float scalblnf(float __x, long int __n) throw ();
    extern float __scalblnf(float __x, long int __n) throw ();
    extern float nearbyintf(float __x) throw ();
    extern float __nearbyintf(float __x) throw ();
    extern float roundf(float __x) throw () __attribute__((__const__));
    extern float __roundf(float __x) throw () __attribute__((__const__));
    extern float truncf(float __x) throw () __attribute__((__const__));
    extern float __truncf(float __x) throw () __attribute__((__const__));
    extern float remquof(float __x, float __y, int * __quo) throw ();
    extern float __remquof(float __x, float __y, int * __quo) throw ();
    extern long int lrintf(float __x) throw ();
    extern long int __lrintf(float __x) throw ();
    extern long long int llrintf(float __x) throw ();
    extern long long int __llrintf(float __x) throw ();
    extern long int lroundf(float __x) throw ();
    extern long int __lroundf(float __x) throw ();
    extern long long int llroundf(float __x) throw ();
    extern long long int __llroundf(float __x) throw ();
    extern float fdimf(float __x, float __y) throw ();
    extern float __fdimf(float __x, float __y) throw ();
    extern float fmaxf(float __x, float __y) throw ();
    extern float __fmaxf(float __x, float __y) throw ();
    extern float fminf(float __x, float __y) throw ();
    extern float __fminf(float __x, float __y) throw ();
    extern int __fpclassifyf(float __value) throw () __attribute__((__const__));
    extern int __signbitf(float __value) throw () __attribute__((__const__));
    extern float fmaf(float __x, float __y, float __z) throw ();
    extern float __fmaf(float __x, float __y, float __z) throw ();
    extern float scalbf(float __x, float __n) throw ();
    extern float __scalbf(float __x, float __n) throw ();
    extern long double acosl(long double __x) throw ();
    extern long double __acosl(long double __x) throw ();
    extern long double asinl(long double __x) throw ();
    extern long double __asinl(long double __x) throw ();
    extern long double atanl(long double __x) throw ();
    extern long double __atanl(long double __x) throw ();
    extern long double atan2l(long double __y, long double __x) throw ();
    extern long double __atan2l(long double __y, long double __x) throw ();
    extern long double cosl(long double __x) throw ();
    extern long double __cosl(long double __x) throw ();
    extern long double sinl(long double __x) throw ();
    extern long double __sinl(long double __x) throw ();
    extern long double tanl(long double __x) throw ();
    extern long double __tanl(long double __x) throw ();
    extern long double coshl(long double __x) throw ();
    extern long double __coshl(long double __x) throw ();
    extern long double sinhl(long double __x) throw ();
    extern long double __sinhl(long double __x) throw ();
    extern long double tanhl(long double __x) throw ();
    extern long double __tanhl(long double __x) throw ();
    extern void sincosl(long double __x, long double * __sinx, long double * __cosx) throw ();
    extern void __sincosl(long double __x, long double * __sinx, long double * __cosx) throw ();
    extern long double acoshl(long double __x) throw ();
    extern long double __acoshl(long double __x) throw ();
    extern long double asinhl(long double __x) throw ();
    extern long double __asinhl(long double __x) throw ();
    extern long double atanhl(long double __x) throw ();
    extern long double __atanhl(long double __x) throw ();
    extern long double expl(long double __x) throw ();
    extern long double __expl(long double __x) throw ();
    extern long double frexpl(long double __x, int * __exponent) throw ();
    extern long double __frexpl(long double __x, int * __exponent) throw ();
    extern long double ldexpl(long double __x, int __exponent) throw ();
    extern long double __ldexpl(long double __x, int __exponent) throw ();
    extern long double logl(long double __x) throw ();
    extern long double __logl(long double __x) throw ();
    extern long double log10l(long double __x) throw ();
    extern long double __log10l(long double __x) throw ();
    extern long double modfl(long double __x, long double * __iptr) throw ();
    extern long double __modfl(long double __x, long double * __iptr) throw ();
    extern long double exp10l(long double __x) throw ();
    extern long double __exp10l(long double __x) throw ();
    extern long double pow10l(long double __x) throw ();
    extern long double __pow10l(long double __x) throw ();
    extern long double expm1l(long double __x) throw ();
    extern long double __expm1l(long double __x) throw ();
    extern long double log1pl(long double __x) throw ();
    extern long double __log1pl(long double __x) throw ();
    extern long double logbl(long double __x) throw ();
    extern long double __logbl(long double __x) throw ();
    extern long double exp2l(long double __x) throw ();
    extern long double __exp2l(long double __x) throw ();
    extern long double log2l(long double __x) throw ();
    extern long double __log2l(long double __x) throw ();
    extern long double powl(long double __x, long double __y) throw ();
    extern long double __powl(long double __x, long double __y) throw ();
    extern long double sqrtl(long double __x) throw ();
    extern long double __sqrtl(long double __x) throw ();
    extern long double hypotl(long double __x, long double __y) throw ();
    extern long double __hypotl(long double __x, long double __y) throw ();
    extern long double cbrtl(long double __x) throw ();
    extern long double __cbrtl(long double __x) throw ();
    extern long double ceill(long double __x) throw () __attribute__((__const__));
    extern long double __ceill(long double __x) throw () __attribute__((__const__));
    extern long double fabsl(long double __x) throw () __attribute__((__const__));
    extern long double __fabsl(long double __x) throw () __attribute__((__const__));
    extern long double floorl(long double __x) throw () __attribute__((__const__));
    extern long double __floorl(long double __x) throw () __attribute__((__const__));
    extern long double fmodl(long double __x, long double __y) throw ();
    extern long double __fmodl(long double __x, long double __y) throw ();
    extern int __isinfl(long double __value) throw () __attribute__((__const__));
    extern int __finitel(long double __value) throw () __attribute__((__const__));
    extern int isinfl(long double __value) throw () __attribute__((__const__));
    extern int finitel(long double __value) throw () __attribute__((__const__));
    extern long double dreml(long double __x, long double __y) throw ();
    extern long double __dreml(long double __x, long double __y) throw ();
    extern long double significandl(long double __x) throw ();
    extern long double __significandl(long double __x) throw ();
    extern long double copysignl(long double __x, long double __y) throw () __attribute__((__const__));
    extern long double __copysignl(long double __x, long double __y) throw () __attribute__((__const__));
    extern long double nanl(__const char * __tagb) throw () __attribute__((__const__));
    extern long double __nanl(__const char * __tagb) throw () __attribute__((__const__));
    extern int __isnanl(long double __value) throw () __attribute__((__const__));
    extern int isnanl(long double __value) throw () __attribute__((__const__));
    extern long double j0l(long double) throw ();
    extern long double __j0l(long double) throw ();
    extern long double j1l(long double) throw ();
    extern long double __j1l(long double) throw ();
    extern long double jnl(int, long double) throw ();
    extern long double __jnl(int, long double) throw ();
    extern long double y0l(long double) throw ();
    extern long double __y0l(long double) throw ();
    extern long double y1l(long double) throw ();
    extern long double __y1l(long double) throw ();
    extern long double ynl(int, long double) throw ();
    extern long double __ynl(int, long double) throw ();
    extern long double erfl(long double) throw ();
    extern long double __erfl(long double) throw ();
    extern long double erfcl(long double) throw ();
    extern long double __erfcl(long double) throw ();
    extern long double lgammal(long double) throw ();
    extern long double __lgammal(long double) throw ();
    extern long double tgammal(long double) throw ();
    extern long double __tgammal(long double) throw ();
    extern long double gammal(long double) throw ();
    extern long double __gammal(long double) throw ();
    extern long double lgammal_r(long double, int * __signgamp) throw ();
    extern long double __lgammal_r(long double, int * __signgamp) throw ();
    extern long double rintl(long double __x) throw ();
    extern long double __rintl(long double __x) throw ();
    extern long double nextafterl(long double __x, long double __y) throw () __attribute__((__const__));
    extern long double __nextafterl(long double __x, long double __y) throw () __attribute__((__const__));
    extern long double nexttowardl(long double __x, long double __y) throw () __attribute__((__const__));
    extern long double __nexttowardl(long double __x, long double __y) throw () __attribute__((__const__));
    extern long double remainderl(long double __x, long double __y) throw ();
    extern long double __remainderl(long double __x, long double __y) throw ();
    extern long double scalbnl(long double __x, int __n) throw ();
    extern long double __scalbnl(long double __x, int __n) throw ();
    extern int ilogbl(long double __x) throw ();
    extern int __ilogbl(long double __x) throw ();
    extern long double scalblnl(long double __x, long int __n) throw ();
    extern long double __scalblnl(long double __x, long int __n) throw ();
    extern long double nearbyintl(long double __x) throw ();
    extern long double __nearbyintl(long double __x) throw ();
    extern long double roundl(long double __x) throw () __attribute__((__const__));
    extern long double __roundl(long double __x) throw () __attribute__((__const__));
    extern long double truncl(long double __x) throw () __attribute__((__const__));
    extern long double __truncl(long double __x) throw () __attribute__((__const__));
    extern long double remquol(long double __x, long double __y, int * __quo) throw ();
    extern long double __remquol(long double __x, long double __y, int * __quo) throw ();
    extern long int lrintl(long double __x) throw ();
    extern long int __lrintl(long double __x) throw ();
    extern long long int llrintl(long double __x) throw ();
    extern long long int __llrintl(long double __x) throw ();
    extern long int lroundl(long double __x) throw ();
    extern long int __lroundl(long double __x) throw ();
    extern long long int llroundl(long double __x) throw ();
    extern long long int __llroundl(long double __x) throw ();
    extern long double fdiml(long double __x, long double __y) throw ();
    extern long double __fdiml(long double __x, long double __y) throw ();
    extern long double fmaxl(long double __x, long double __y) throw ();
    extern long double __fmaxl(long double __x, long double __y) throw ();
    extern long double fminl(long double __x, long double __y) throw ();
    extern long double __fminl(long double __x, long double __y) throw ();
    extern int __fpclassifyl(long double __value) throw () __attribute__((__const__));
    extern int __signbitl(long double __value) throw () __attribute__((__const__));
    extern long double fmal(long double __x, long double __y, long double __z) throw ();
    extern long double __fmal(long double __x, long double __y, long double __z) throw ();
    extern long double scalbl(long double __x, long double __n) throw ();
    extern long double __scalbl(long double __x, long double __n) throw ();
    extern int signgam;
    enum 
    {
        FP_NAN, 
        FP_INFINITE, 
        FP_ZERO, 
        FP_SUBNORMAL, 
        FP_NORMAL
    };
    typedef enum 
    {
        _IEEE_ = -1, 
        _SVID_, 
        _XOPEN_, 
        _POSIX_, 
        _ISOC_
    } _LIB_VERSION_TYPE;
    extern _LIB_VERSION_TYPE _LIB_VERSION;
    struct __exception
    {
            int type;
            char * name;
            double arg1;
            double arg2;
            double retval;
    };
    extern int matherr(struct __exception * __exc) throw ();
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Tp >
    _Tp __cmath_power(_Tp, unsigned int);
    template<typename _Tp >
    inline _Tp __pow_helper(_Tp __x, int __n)
    {
        return __n < 0 ? _Tp(1) / __cmath_power(__x, -__n) : __cmath_power(__x, __n);
    }
    inline double abs(double __x)
    {
        return __builtin_fabs(__x);
    }
    inline float abs(float __x)
    {
        return __builtin_fabsf(__x);
    }
    inline long double abs(long double __x)
    {
        return __builtin_fabsl(__x);
    }
    using ::acos;
    inline float acos(float __x)
    {
        return __builtin_acosf(__x);
    }
    inline long double acos(long double __x)
    {
        return __builtin_acosl(__x);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type acos(_Tp __x)
    {
        return __builtin_acos(__x);
    }
    using ::asin;
    inline float asin(float __x)
    {
        return __builtin_asinf(__x);
    }
    inline long double asin(long double __x)
    {
        return __builtin_asinl(__x);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type asin(_Tp __x)
    {
        return __builtin_asin(__x);
    }
    using ::atan;
    inline float atan(float __x)
    {
        return __builtin_atanf(__x);
    }
    inline long double atan(long double __x)
    {
        return __builtin_atanl(__x);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type atan(_Tp __x)
    {
        return __builtin_atan(__x);
    }
    using ::atan2;
    inline float atan2(float __y, float __x)
    {
        return __builtin_atan2f(__y, __x);
    }
    inline long double atan2(long double __y, long double __x)
    {
        return __builtin_atan2l(__y, __x);
    }
    template<typename _Tp, typename _Up >
    inline typename __gnu_cxx::__promote_2< typename __gnu_cxx::__enable_if< __traitand< __is_arithmetic< _Tp >, __is_arithmetic< _Up > >::__value, _Tp >::__type, _Up >::__type atan2(_Tp __y, _Up __x)
    {
        typedef typename __gnu_cxx::__promote_2< _Tp, _Up >::__type __type;
        return atan2(__type(__y), __type(__x));
    }
    using ::ceil;
    inline float ceil(float __x)
    {
        return __builtin_ceilf(__x);
    }
    inline long double ceil(long double __x)
    {
        return __builtin_ceill(__x);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type ceil(_Tp __x)
    {
        return __builtin_ceil(__x);
    }
    using ::cos;
    inline float cos(float __x)
    {
        return __builtin_cosf(__x);
    }
    inline long double cos(long double __x)
    {
        return __builtin_cosl(__x);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type cos(_Tp __x)
    {
        return __builtin_cos(__x);
    }
    using ::cosh;
    inline float cosh(float __x)
    {
        return __builtin_coshf(__x);
    }
    inline long double cosh(long double __x)
    {
        return __builtin_coshl(__x);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type cosh(_Tp __x)
    {
        return __builtin_cosh(__x);
    }
    using ::exp;
    inline float exp(float __x)
    {
        return __builtin_expf(__x);
    }
    inline long double exp(long double __x)
    {
        return __builtin_expl(__x);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type exp(_Tp __x)
    {
        return __builtin_exp(__x);
    }
    using ::fabs;
    inline float fabs(float __x)
    {
        return __builtin_fabsf(__x);
    }
    inline long double fabs(long double __x)
    {
        return __builtin_fabsl(__x);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type fabs(_Tp __x)
    {
        return __builtin_fabs(__x);
    }
    using ::floor;
    inline float floor(float __x)
    {
        return __builtin_floorf(__x);
    }
    inline long double floor(long double __x)
    {
        return __builtin_floorl(__x);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type floor(_Tp __x)
    {
        return __builtin_floor(__x);
    }
    using ::fmod;
    inline float fmod(float __x, float __y)
    {
        return __builtin_fmodf(__x, __y);
    }
    inline long double fmod(long double __x, long double __y)
    {
        return __builtin_fmodl(__x, __y);
    }
    using ::frexp;
    inline float frexp(float __x, int * __exp)
    {
        return __builtin_frexpf(__x, __exp);
    }
    inline long double frexp(long double __x, int * __exp)
    {
        return __builtin_frexpl(__x, __exp);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type frexp(_Tp __x, int * __exp)
    {
        return __builtin_frexp(__x, __exp);
    }
    using ::ldexp;
    inline float ldexp(float __x, int __exp)
    {
        return __builtin_ldexpf(__x, __exp);
    }
    inline long double ldexp(long double __x, int __exp)
    {
        return __builtin_ldexpl(__x, __exp);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type ldexp(_Tp __x, int __exp)
    {
        return __builtin_ldexp(__x, __exp);
    }
    using ::log;
    inline float log(float __x)
    {
        return __builtin_logf(__x);
    }
    inline long double log(long double __x)
    {
        return __builtin_logl(__x);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type log(_Tp __x)
    {
        return __builtin_log(__x);
    }
    using ::log10;
    inline float log10(float __x)
    {
        return __builtin_log10f(__x);
    }
    inline long double log10(long double __x)
    {
        return __builtin_log10l(__x);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type log10(_Tp __x)
    {
        return __builtin_log10(__x);
    }
    using ::modf;
    inline float modf(float __x, float * __iptr)
    {
        return __builtin_modff(__x, __iptr);
    }
    inline long double modf(long double __x, long double * __iptr)
    {
        return __builtin_modfl(__x, __iptr);
    }
    using ::pow;
    inline float pow(float __x, float __y)
    {
        return __builtin_powf(__x, __y);
    }
    inline long double pow(long double __x, long double __y)
    {
        return __builtin_powl(__x, __y);
    }
    inline double pow(double __x, int __i)
    {
        return __builtin_powi(__x, __i);
    }
    inline float pow(float __x, int __n)
    {
        return __builtin_powif(__x, __n);
    }
    inline long double pow(long double __x, int __n)
    {
        return __builtin_powil(__x, __n);
    }
    template<typename _Tp, typename _Up >
    inline typename __gnu_cxx::__promote_2< typename __gnu_cxx::__enable_if< __traitand< __is_arithmetic< _Tp >, __is_arithmetic< _Up > >::__value, _Tp >::__type, _Up >::__type pow(_Tp __x, _Up __y)
    {
        typedef typename __gnu_cxx::__promote_2< _Tp, _Up >::__type __type;
        return pow(__type(__x), __type(__y));
    }
    using ::sin;
    inline float sin(float __x)
    {
        return __builtin_sinf(__x);
    }
    inline long double sin(long double __x)
    {
        return __builtin_sinl(__x);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type sin(_Tp __x)
    {
        return __builtin_sin(__x);
    }
    using ::sinh;
    inline float sinh(float __x)
    {
        return __builtin_sinhf(__x);
    }
    inline long double sinh(long double __x)
    {
        return __builtin_sinhl(__x);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type sinh(_Tp __x)
    {
        return __builtin_sinh(__x);
    }
    using ::sqrt;
    inline float sqrt(float __x)
    {
        return __builtin_sqrtf(__x);
    }
    inline long double sqrt(long double __x)
    {
        return __builtin_sqrtl(__x);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type sqrt(_Tp __x)
    {
        return __builtin_sqrt(__x);
    }
    using ::tan;
    inline float tan(float __x)
    {
        return __builtin_tanf(__x);
    }
    inline long double tan(long double __x)
    {
        return __builtin_tanl(__x);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type tan(_Tp __x)
    {
        return __builtin_tan(__x);
    }
    using ::tanh;
    inline float tanh(float __x)
    {
        return __builtin_tanhf(__x);
    }
    inline long double tanh(long double __x)
    {
        return __builtin_tanhl(__x);
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type tanh(_Tp __x)
    {
        return __builtin_tanh(__x);
    }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
    template<typename _Tp >
    inline int __capture_fpclassify(_Tp __f)
    {
        return (sizeof (__f) == sizeof(float) ? __fpclassifyf(__f) : sizeof (__f) == sizeof(double) ? __fpclassify(__f) : __fpclassifyl(__f));
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp >::__value, int >::__type fpclassify(_Tp __f)
    {
        typedef typename __gnu_cxx::__promote< _Tp >::__type __type;
        return ::__gnu_cxx::__capture_fpclassify(__type(__f));
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp >::__value, int >::__type isfinite(_Tp __f)
    {
        typedef typename __gnu_cxx::__promote< _Tp >::__type __type;
        return __builtin_isfinite(__type(__f));
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp >::__value, int >::__type isinf(_Tp __f)
    {
        typedef typename __gnu_cxx::__promote< _Tp >::__type __type;
        return __builtin_isinf(__type(__f));
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp >::__value, int >::__type isnan(_Tp __f)
    {
        typedef typename __gnu_cxx::__promote< _Tp >::__type __type;
        return __builtin_isnan(__type(__f));
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp >::__value, int >::__type isnormal(_Tp __f)
    {
        typedef typename __gnu_cxx::__promote< _Tp >::__type __type;
        return __builtin_isnormal(__type(__f));
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp >::__value, int >::__type signbit(_Tp __f)
    {
        typedef typename __gnu_cxx::__promote< _Tp >::__type __type;
        return __builtin_signbit(__type(__f));
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp >::__value, int >::__type isgreater(_Tp __f1, _Tp __f2)
    {
        typedef typename __gnu_cxx::__promote< _Tp >::__type __type;
        return __builtin_isgreater(__type(__f1), __type(__f2));
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp >::__value, int >::__type isgreaterequal(_Tp __f1, _Tp __f2)
    {
        typedef typename __gnu_cxx::__promote< _Tp >::__type __type;
        return __builtin_isgreaterequal(__type(__f1), __type(__f2));
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp >::__value, int >::__type isless(_Tp __f1, _Tp __f2)
    {
        typedef typename __gnu_cxx::__promote< _Tp >::__type __type;
        return __builtin_isless(__type(__f1), __type(__f2));
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp >::__value, int >::__type islessequal(_Tp __f1, _Tp __f2)
    {
        typedef typename __gnu_cxx::__promote< _Tp >::__type __type;
        return __builtin_islessequal(__type(__f1), __type(__f2));
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp >::__value, int >::__type islessgreater(_Tp __f1, _Tp __f2)
    {
        typedef typename __gnu_cxx::__promote< _Tp >::__type __type;
        return __builtin_islessgreater(__type(__f1), __type(__f2));
    }
    template<typename _Tp >
    inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp >::__value, int >::__type isunordered(_Tp __f1, _Tp __f2)
    {
        typedef typename __gnu_cxx::__promote< _Tp >::__type __type;
        return __builtin_isunordered(__type(__f1), __type(__f2));
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Tp >
    inline _Tp __cmath_power(_Tp __x, unsigned int __n)
    {
        _Tp __y = __n % 2 ? __x : _Tp(1);
        while (__n >>= 1)
        {
            __x = __x * __x;
            if (__n % 2)
                __y = __y * __x;
        }
        return __y;
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<class _Clos, typename _Tp >
    class _Expr;
    template<typename _Tp1, typename _Tp2 >
    class _ValArray;
    template<class _Oper, template<class , class  > class _Meta, class _Dom >
    struct _UnClos;
    template<class _Oper, template<class , class  > class _Meta1, template<class , class  > class _Meta2, class _Dom1, class _Dom2 >
    class _BinClos;
    template<template<class , class  > class _Meta, class _Dom >
    class _SClos;
    template<template<class , class  > class _Meta, class _Dom >
    class _GClos;
    template<template<class , class  > class _Meta, class _Dom >
    class _IClos;
    template<template<class , class  > class _Meta, class _Dom >
    class _ValFunClos;
    template<template<class , class  > class _Meta, class _Dom >
    class _RefFunClos;
    template<class _Tp >
    class valarray;
    class slice;
    template<class _Tp >
    class slice_array;
    class gslice;
    template<class _Tp >
    class gslice_array;
    template<class _Tp >
    class mask_array;
    template<class _Tp >
    class indirect_array;
}
namespace std __attribute__((__visibility__("default"))) {
    inline void * __valarray_get_memory(size_t __n)
    {
        return operator new(__n);
    }
    template<typename _Tp >
    inline _Tp *__restrict__ __valarray_get_storage(size_t __n)
    {
        return static_cast<_Tp *__restrict__ >(std::__valarray_get_memory(__n * sizeof(_Tp)));
    }
    inline void __valarray_release_memory(void * __p)
    {
        operator delete(__p);
    }
    template<typename _Tp, bool >
    struct _Array_default_ctor
    {
            inline static void _S_do_it(_Tp *__restrict__ __b, _Tp *__restrict__ __e)
            {
                while (__b != __e)
                    new (__b++) _Tp ();
            }
    };
    template<typename _Tp >
    struct _Array_default_ctor< _Tp, true >
    {
            inline static void _S_do_it(_Tp *__restrict__ __b, _Tp *__restrict__ __e)
            {
                __builtin_memset(__b, 0, (__e - __b) * sizeof(_Tp));
            }
    };
    template<typename _Tp >
    inline void __valarray_default_construct(_Tp *__restrict__ __b, _Tp *__restrict__ __e)
    {
        _Array_default_ctor< _Tp, __is_scalar< _Tp >::__value >::_S_do_it(__b, __e);
    }
    template<typename _Tp, bool >
    struct _Array_init_ctor
    {
            inline static void _S_do_it(_Tp *__restrict__ __b, _Tp *__restrict__ __e, const _Tp __t)
            {
                while (__b != __e)
                    new (__b++) _Tp (__t);
            }
    };
    template<typename _Tp >
    struct _Array_init_ctor< _Tp, true >
    {
            inline static void _S_do_it(_Tp *__restrict__ __b, _Tp *__restrict__ __e, const _Tp __t)
            {
                while (__b != __e)
                    *__b++ = __t;
            }
    };
    template<typename _Tp >
    inline void __valarray_fill_construct(_Tp *__restrict__ __b, _Tp *__restrict__ __e, const _Tp __t)
    {
        _Array_init_ctor< _Tp, __is_pod(_Tp) >::_S_do_it(__b, __e, __t);
    }
    template<typename _Tp, bool >
    struct _Array_copy_ctor
    {
            inline static void _S_do_it(const _Tp *__restrict__ __b, const _Tp *__restrict__ __e, _Tp *__restrict__ __o)
            {
                while (__b != __e)
                    new (__o++) _Tp (*__b++);
            }
    };
    template<typename _Tp >
    struct _Array_copy_ctor< _Tp, true >
    {
            inline static void _S_do_it(const _Tp *__restrict__ __b, const _Tp *__restrict__ __e, _Tp *__restrict__ __o)
            {
                __builtin_memcpy(__o, __b, (__e - __b) * sizeof(_Tp));
            }
    };
    template<typename _Tp >
    inline void __valarray_copy_construct(const _Tp *__restrict__ __b, const _Tp *__restrict__ __e, _Tp *__restrict__ __o)
    {
        _Array_copy_ctor< _Tp, __is_pod(_Tp) >::_S_do_it(__b, __e, __o);
    }
    template<typename _Tp >
    inline void __valarray_copy_construct(const _Tp *__restrict__ __a, size_t __n, size_t __s, _Tp *__restrict__ __o)
    {
        if (__is_pod(_Tp))
            while (__n--)
            {
                *__o++ = *__a;
                __a += __s;
            }
        else
            while (__n--)
            {
                new (__o++) _Tp (*__a);
                __a += __s;
            }
    }
    template<typename _Tp >
    inline void __valarray_copy_construct(const _Tp *__restrict__ __a, const size_t *__restrict__ __i, _Tp *__restrict__ __o, size_t __n)
    {
        if (__is_pod(_Tp))
            while (__n--)
                *__o++ = __a[*__i++];
        else
            while (__n--)
                new (__o++) _Tp (__a[*__i++]);
    }
    template<typename _Tp >
    inline void __valarray_destroy_elements(_Tp *__restrict__ __b, _Tp *__restrict__ __e)
    {
        if (!__is_pod(_Tp))
            while (__b != __e)
            {
                __b->~_Tp();
                ++__b;
            }
    }
    template<typename _Tp >
    inline void __valarray_fill(_Tp *__restrict__ __a, size_t __n, const _Tp & __t)
    {
        while (__n--)
            *__a++ = __t;
    }
    template<typename _Tp >
    inline void __valarray_fill(_Tp *__restrict__ __a, size_t __n, size_t __s, const _Tp & __t)
    {
        for (size_t __i = 0;
            __i < __n;
            ++__i , __a += __s)
        *__a = __t;
    }
    template<typename _Tp >
    inline void __valarray_fill(_Tp *__restrict__ __a, const size_t *__restrict__ __i, size_t __n, const _Tp & __t)
    {
        for (size_t __j = 0;
            __j < __n;
            ++__j , ++__i)
        __a[*__i] = __t;
    }
    template<typename _Tp, bool >
    struct _Array_copier
    {
            inline static void _S_do_it(const _Tp *__restrict__ __a, size_t __n, _Tp *__restrict__ __b)
            {
                while (__n--)
                    *__b++ = *__a++;
            }
    };
    template<typename _Tp >
    struct _Array_copier< _Tp, true >
    {
            inline static void _S_do_it(const _Tp *__restrict__ __a, size_t __n, _Tp *__restrict__ __b)
            {
                __builtin_memcpy(__b, __a, __n * sizeof(_Tp));
            }
    };
    template<typename _Tp >
    inline void __valarray_copy(const _Tp *__restrict__ __a, size_t __n, _Tp *__restrict__ __b)
    {
        _Array_copier< _Tp, __is_pod(_Tp) >::_S_do_it(__a, __n, __b);
    }
    template<typename _Tp >
    inline void __valarray_copy(const _Tp *__restrict__ __a, size_t __n, size_t __s, _Tp *__restrict__ __b)
    {
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__b , __a += __s)
        *__b = *__a;
    }
    template<typename _Tp >
    inline void __valarray_copy(const _Tp *__restrict__ __a, _Tp *__restrict__ __b, size_t __n, size_t __s)
    {
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__a , __b += __s)
        *__b = *__a;
    }
    template<typename _Tp >
    inline void __valarray_copy(const _Tp *__restrict__ __src, size_t __n, size_t __s1, _Tp *__restrict__ __dst, size_t __s2)
    {
        for (size_t __i = 0;
            __i < __n;
            ++__i)
        __dst[__i * __s2] = __src[__i * __s1];
    }
    template<typename _Tp >
    inline void __valarray_copy(const _Tp *__restrict__ __a, const size_t *__restrict__ __i, _Tp *__restrict__ __b, size_t __n)
    {
        for (size_t __j = 0;
            __j < __n;
            ++__j , ++__b , ++__i)
        *__b = __a[*__i];
    }
    template<typename _Tp >
    inline void __valarray_copy(const _Tp *__restrict__ __a, size_t __n, _Tp *__restrict__ __b, const size_t *__restrict__ __i)
    {
        for (size_t __j = 0;
            __j < __n;
            ++__j , ++__a , ++__i)
        __b[*__i] = *__a;
    }
    template<typename _Tp >
    inline void __valarray_copy(const _Tp *__restrict__ __src, size_t __n, const size_t *__restrict__ __i, _Tp *__restrict__ __dst, const size_t *__restrict__ __j)
    {
        for (size_t __k = 0;
            __k < __n;
            ++__k)
        __dst[*__j++] = __src[*__i++];
    }
    template<typename _Tp >
    inline _Tp __valarray_sum(const _Tp *__restrict__ __f, const _Tp *__restrict__ __l)
    {
        _Tp __r = _Tp();
        while (__f != __l)
            __r += *__f++;
        return __r;
    }
    template<typename _Tp >
    inline _Tp __valarray_product(const _Tp *__restrict__ __f, const _Tp *__restrict__ __l)
    {
        _Tp __r = _Tp(1);
        while (__f != __l)
            __r = __r * *__f++;
        return __r;
    }
    template<typename _Ta >
    inline typename _Ta::value_type __valarray_min(const _Ta & __a)
    {
        size_t __s = __a.size();
        typedef typename _Ta::value_type _Value_type;
        _Value_type __r = __s == 0 ? _Value_type() : __a[0];
        for (size_t __i = 1;
            __i < __s;
            ++__i)
        {
            _Value_type __t = __a[__i];
            if (__t < __r)
                __r = __t;
        }
        return __r;
    }
    template<typename _Ta >
    inline typename _Ta::value_type __valarray_max(const _Ta & __a)
    {
        size_t __s = __a.size();
        typedef typename _Ta::value_type _Value_type;
        _Value_type __r = __s == 0 ? _Value_type() : __a[0];
        for (size_t __i = 1;
            __i < __s;
            ++__i)
        {
            _Value_type __t = __a[__i];
            if (__t > __r)
                __r = __t;
        }
        return __r;
    }
    template<typename _Tp >
    struct _Array
    {
            explicit _Array(size_t);
            explicit _Array(_Tp *const __restrict__);
            explicit _Array(const valarray< _Tp > &);
            _Array(const _Tp *__restrict__, size_t);
            _Tp * begin() const;
            _Tp *const __restrict__ _M_data;
    };
    template<typename _Tp >
    inline void __valarray_copy_construct(_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)
    {
        std::__valarray_copy_construct(__a._M_data, __i._M_data, __b._M_data, __n);
    }
    template<typename _Tp >
    inline void __valarray_copy_construct(_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)
    {
        std::__valarray_copy_construct(__a._M_data, __n, __s, __b._M_data);
    }
    template<typename _Tp >
    inline void __valarray_fill(_Array< _Tp > __a, size_t __n, const _Tp & __t)
    {
        std::__valarray_fill(__a._M_data, __n, __t);
    }
    template<typename _Tp >
    inline void __valarray_fill(_Array< _Tp > __a, size_t __n, size_t __s, const _Tp & __t)
    {
        std::__valarray_fill(__a._M_data, __n, __s, __t);
    }
    template<typename _Tp >
    inline void __valarray_fill(_Array< _Tp > __a, _Array< size_t > __i, size_t __n, const _Tp & __t)
    {
        std::__valarray_fill(__a._M_data, __i._M_data, __n, __t);
    }
    template<typename _Tp >
    inline void __valarray_copy(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)
    {
        std::__valarray_copy(__a._M_data, __n, __b._M_data);
    }
    template<typename _Tp >
    inline void __valarray_copy(_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)
    {
        std::__valarray_copy(__a._M_data, __n, __s, __b._M_data);
    }
    template<typename _Tp >
    inline void __valarray_copy(_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)
    {
        __valarray_copy(__a._M_data, __b._M_data, __n, __s);
    }
    template<typename _Tp >
    inline void __valarray_copy(_Array< _Tp > __a, size_t __n, size_t __s1, _Array< _Tp > __b, size_t __s2)
    {
        std::__valarray_copy(__a._M_data, __n, __s1, __b._M_data, __s2);
    }
    template<typename _Tp >
    inline void __valarray_copy(_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)
    {
        std::__valarray_copy(__a._M_data, __i._M_data, __b._M_data, __n);
    }
    template<typename _Tp >
    inline void __valarray_copy(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)
    {
        std::__valarray_copy(__a._M_data, __n, __b._M_data, __i._M_data);
    }
    template<typename _Tp >
    inline void __valarray_copy(_Array< _Tp > __src, size_t __n, _Array< size_t > __i, _Array< _Tp > __dst, _Array< size_t > __j)
    {
        std::__valarray_copy(__src._M_data, __n, __i._M_data, __dst._M_data, __j._M_data);
    }
    template<typename _Tp >
    inline _Array< _Tp >::_Array(size_t __n)
        : _M_data(__valarray_get_storage< _Tp >(__n)) 
    {
        std::__valarray_default_construct(_M_data, _M_data + __n);
    }
    template<typename _Tp >
    inline _Array< _Tp >::_Array(_Tp *const __restrict__ __p)
        : _M_data(__p) 
    {
    }
    template<typename _Tp >
    inline _Array< _Tp >::_Array(const valarray< _Tp > & __v)
        : _M_data(__v._M_data) 
    {
    }
    template<typename _Tp >
    inline _Array< _Tp >::_Array(const _Tp *__restrict__ __b, size_t __s)
        : _M_data(__valarray_get_storage< _Tp >(__s)) 
    {
        std::__valarray_copy_construct(__b, __s, _M_data);
    }
    template<typename _Tp >
    inline _Tp * _Array< _Tp >::begin() const
    {
        return _M_data;
    }
    template<typename _Tp >
    inline void _Array_augmented___plus(_Array< _Tp > __a, size_t __n, const _Tp & __t)
    {
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p)
        *__p += __t;
    }
    template<typename _Tp >
    inline void _Array_augmented___plus(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)
    {
        _Tp * __p = __a._M_data;
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__p , ++__q)
        *__p += *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___plus(_Array< _Tp > __a, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__p)
        *__p += __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___plus(_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __s * __n;
            __p += __s , ++__q)
        *__p += *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___plus(_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , __q += __s)
        *__p += *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___plus(_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , __p += __s)
        *__p += __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___plus(_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)
    {
        _Tp * __q(__b._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__q)
        __a._M_data[*__j] += *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___plus(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)
    {
        _Tp * __p(__a._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__p)
        *__p += __b._M_data[*__j];
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___plus(_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        size_t * __j(__i._M_data);
        for (size_t __k = 0;
            __k < __n;
            ++__k , ++__j)
        __a._M_data[*__j] += __e[__k];
    }
    template<typename _Tp >
    void _Array_augmented___plus(_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__q , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p += *__q;
        }
    }
    template<typename _Tp >
    void _Array_augmented___plus(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)
    {
        bool * __ok(__m._M_data);
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , ++__ok , ++__q)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__q;
            }
            *__p += *__q;
        }
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___plus(_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p += __e[__i];
        }
    }
    template<typename _Tp >
    inline void _Array_augmented___minus(_Array< _Tp > __a, size_t __n, const _Tp & __t)
    {
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p)
        *__p -= __t;
    }
    template<typename _Tp >
    inline void _Array_augmented___minus(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)
    {
        _Tp * __p = __a._M_data;
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__p , ++__q)
        *__p -= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___minus(_Array< _Tp > __a, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__p)
        *__p -= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___minus(_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __s * __n;
            __p += __s , ++__q)
        *__p -= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___minus(_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , __q += __s)
        *__p -= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___minus(_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , __p += __s)
        *__p -= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___minus(_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)
    {
        _Tp * __q(__b._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__q)
        __a._M_data[*__j] -= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___minus(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)
    {
        _Tp * __p(__a._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__p)
        *__p -= __b._M_data[*__j];
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___minus(_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        size_t * __j(__i._M_data);
        for (size_t __k = 0;
            __k < __n;
            ++__k , ++__j)
        __a._M_data[*__j] -= __e[__k];
    }
    template<typename _Tp >
    void _Array_augmented___minus(_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__q , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p -= *__q;
        }
    }
    template<typename _Tp >
    void _Array_augmented___minus(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)
    {
        bool * __ok(__m._M_data);
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , ++__ok , ++__q)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__q;
            }
            *__p -= *__q;
        }
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___minus(_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p -= __e[__i];
        }
    }
    template<typename _Tp >
    inline void _Array_augmented___multiplies(_Array< _Tp > __a, size_t __n, const _Tp & __t)
    {
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p)
        *__p *= __t;
    }
    template<typename _Tp >
    inline void _Array_augmented___multiplies(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)
    {
        _Tp * __p = __a._M_data;
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__p , ++__q)
        *__p *= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___multiplies(_Array< _Tp > __a, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__p)
        *__p *= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___multiplies(_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __s * __n;
            __p += __s , ++__q)
        *__p *= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___multiplies(_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , __q += __s)
        *__p *= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___multiplies(_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , __p += __s)
        *__p *= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___multiplies(_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)
    {
        _Tp * __q(__b._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__q)
        __a._M_data[*__j] *= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___multiplies(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)
    {
        _Tp * __p(__a._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__p)
        *__p *= __b._M_data[*__j];
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___multiplies(_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        size_t * __j(__i._M_data);
        for (size_t __k = 0;
            __k < __n;
            ++__k , ++__j)
        __a._M_data[*__j] *= __e[__k];
    }
    template<typename _Tp >
    void _Array_augmented___multiplies(_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__q , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p *= *__q;
        }
    }
    template<typename _Tp >
    void _Array_augmented___multiplies(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)
    {
        bool * __ok(__m._M_data);
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , ++__ok , ++__q)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__q;
            }
            *__p *= *__q;
        }
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___multiplies(_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p *= __e[__i];
        }
    }
    template<typename _Tp >
    inline void _Array_augmented___divides(_Array< _Tp > __a, size_t __n, const _Tp & __t)
    {
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p)
        *__p /= __t;
    }
    template<typename _Tp >
    inline void _Array_augmented___divides(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)
    {
        _Tp * __p = __a._M_data;
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__p , ++__q)
        *__p /= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___divides(_Array< _Tp > __a, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__p)
        *__p /= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___divides(_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __s * __n;
            __p += __s , ++__q)
        *__p /= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___divides(_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , __q += __s)
        *__p /= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___divides(_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , __p += __s)
        *__p /= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___divides(_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)
    {
        _Tp * __q(__b._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__q)
        __a._M_data[*__j] /= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___divides(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)
    {
        _Tp * __p(__a._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__p)
        *__p /= __b._M_data[*__j];
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___divides(_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        size_t * __j(__i._M_data);
        for (size_t __k = 0;
            __k < __n;
            ++__k , ++__j)
        __a._M_data[*__j] /= __e[__k];
    }
    template<typename _Tp >
    void _Array_augmented___divides(_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__q , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p /= *__q;
        }
    }
    template<typename _Tp >
    void _Array_augmented___divides(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)
    {
        bool * __ok(__m._M_data);
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , ++__ok , ++__q)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__q;
            }
            *__p /= *__q;
        }
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___divides(_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p /= __e[__i];
        }
    }
    template<typename _Tp >
    inline void _Array_augmented___modulus(_Array< _Tp > __a, size_t __n, const _Tp & __t)
    {
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p)
        *__p %= __t;
    }
    template<typename _Tp >
    inline void _Array_augmented___modulus(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)
    {
        _Tp * __p = __a._M_data;
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__p , ++__q)
        *__p %= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___modulus(_Array< _Tp > __a, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__p)
        *__p %= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___modulus(_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __s * __n;
            __p += __s , ++__q)
        *__p %= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___modulus(_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , __q += __s)
        *__p %= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___modulus(_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , __p += __s)
        *__p %= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___modulus(_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)
    {
        _Tp * __q(__b._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__q)
        __a._M_data[*__j] %= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___modulus(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)
    {
        _Tp * __p(__a._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__p)
        *__p %= __b._M_data[*__j];
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___modulus(_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        size_t * __j(__i._M_data);
        for (size_t __k = 0;
            __k < __n;
            ++__k , ++__j)
        __a._M_data[*__j] %= __e[__k];
    }
    template<typename _Tp >
    void _Array_augmented___modulus(_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__q , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p %= *__q;
        }
    }
    template<typename _Tp >
    void _Array_augmented___modulus(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)
    {
        bool * __ok(__m._M_data);
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , ++__ok , ++__q)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__q;
            }
            *__p %= *__q;
        }
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___modulus(_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p %= __e[__i];
        }
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_xor(_Array< _Tp > __a, size_t __n, const _Tp & __t)
    {
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p)
        *__p ^= __t;
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_xor(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)
    {
        _Tp * __p = __a._M_data;
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__p , ++__q)
        *__p ^= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___bitwise_xor(_Array< _Tp > __a, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__p)
        *__p ^= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_xor(_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __s * __n;
            __p += __s , ++__q)
        *__p ^= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_xor(_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , __q += __s)
        *__p ^= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___bitwise_xor(_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , __p += __s)
        *__p ^= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_xor(_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)
    {
        _Tp * __q(__b._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__q)
        __a._M_data[*__j] ^= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_xor(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)
    {
        _Tp * __p(__a._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__p)
        *__p ^= __b._M_data[*__j];
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___bitwise_xor(_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        size_t * __j(__i._M_data);
        for (size_t __k = 0;
            __k < __n;
            ++__k , ++__j)
        __a._M_data[*__j] ^= __e[__k];
    }
    template<typename _Tp >
    void _Array_augmented___bitwise_xor(_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__q , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p ^= *__q;
        }
    }
    template<typename _Tp >
    void _Array_augmented___bitwise_xor(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)
    {
        bool * __ok(__m._M_data);
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , ++__ok , ++__q)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__q;
            }
            *__p ^= *__q;
        }
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___bitwise_xor(_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p ^= __e[__i];
        }
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_or(_Array< _Tp > __a, size_t __n, const _Tp & __t)
    {
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p)
        *__p |= __t;
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_or(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)
    {
        _Tp * __p = __a._M_data;
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__p , ++__q)
        *__p |= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___bitwise_or(_Array< _Tp > __a, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__p)
        *__p |= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_or(_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __s * __n;
            __p += __s , ++__q)
        *__p |= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_or(_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , __q += __s)
        *__p |= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___bitwise_or(_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , __p += __s)
        *__p |= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_or(_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)
    {
        _Tp * __q(__b._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__q)
        __a._M_data[*__j] |= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_or(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)
    {
        _Tp * __p(__a._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__p)
        *__p |= __b._M_data[*__j];
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___bitwise_or(_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        size_t * __j(__i._M_data);
        for (size_t __k = 0;
            __k < __n;
            ++__k , ++__j)
        __a._M_data[*__j] |= __e[__k];
    }
    template<typename _Tp >
    void _Array_augmented___bitwise_or(_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__q , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p |= *__q;
        }
    }
    template<typename _Tp >
    void _Array_augmented___bitwise_or(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)
    {
        bool * __ok(__m._M_data);
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , ++__ok , ++__q)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__q;
            }
            *__p |= *__q;
        }
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___bitwise_or(_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p |= __e[__i];
        }
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_and(_Array< _Tp > __a, size_t __n, const _Tp & __t)
    {
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p)
        *__p &= __t;
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_and(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)
    {
        _Tp * __p = __a._M_data;
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__p , ++__q)
        *__p &= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___bitwise_and(_Array< _Tp > __a, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__p)
        *__p &= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_and(_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __s * __n;
            __p += __s , ++__q)
        *__p &= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_and(_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , __q += __s)
        *__p &= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___bitwise_and(_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , __p += __s)
        *__p &= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_and(_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)
    {
        _Tp * __q(__b._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__q)
        __a._M_data[*__j] &= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___bitwise_and(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)
    {
        _Tp * __p(__a._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__p)
        *__p &= __b._M_data[*__j];
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___bitwise_and(_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        size_t * __j(__i._M_data);
        for (size_t __k = 0;
            __k < __n;
            ++__k , ++__j)
        __a._M_data[*__j] &= __e[__k];
    }
    template<typename _Tp >
    void _Array_augmented___bitwise_and(_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__q , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p &= *__q;
        }
    }
    template<typename _Tp >
    void _Array_augmented___bitwise_and(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)
    {
        bool * __ok(__m._M_data);
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , ++__ok , ++__q)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__q;
            }
            *__p &= *__q;
        }
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___bitwise_and(_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p &= __e[__i];
        }
    }
    template<typename _Tp >
    inline void _Array_augmented___shift_left(_Array< _Tp > __a, size_t __n, const _Tp & __t)
    {
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p)
        *__p <<= __t;
    }
    template<typename _Tp >
    inline void _Array_augmented___shift_left(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)
    {
        _Tp * __p = __a._M_data;
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__p , ++__q)
        *__p <<= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___shift_left(_Array< _Tp > __a, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__p)
        *__p <<= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___shift_left(_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __s * __n;
            __p += __s , ++__q)
        *__p <<= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___shift_left(_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , __q += __s)
        *__p <<= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___shift_left(_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , __p += __s)
        *__p <<= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___shift_left(_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)
    {
        _Tp * __q(__b._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__q)
        __a._M_data[*__j] <<= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___shift_left(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)
    {
        _Tp * __p(__a._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__p)
        *__p <<= __b._M_data[*__j];
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___shift_left(_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        size_t * __j(__i._M_data);
        for (size_t __k = 0;
            __k < __n;
            ++__k , ++__j)
        __a._M_data[*__j] <<= __e[__k];
    }
    template<typename _Tp >
    void _Array_augmented___shift_left(_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__q , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p <<= *__q;
        }
    }
    template<typename _Tp >
    void _Array_augmented___shift_left(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)
    {
        bool * __ok(__m._M_data);
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , ++__ok , ++__q)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__q;
            }
            *__p <<= *__q;
        }
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___shift_left(_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p <<= __e[__i];
        }
    }
    template<typename _Tp >
    inline void _Array_augmented___shift_right(_Array< _Tp > __a, size_t __n, const _Tp & __t)
    {
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p)
        *__p >>= __t;
    }
    template<typename _Tp >
    inline void _Array_augmented___shift_right(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)
    {
        _Tp * __p = __a._M_data;
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__p , ++__q)
        *__p >>= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___shift_right(_Array< _Tp > __a, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__p)
        *__p >>= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___shift_right(_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __s * __n;
            __p += __s , ++__q)
        *__p >>= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___shift_right(_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)
    {
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , __q += __s)
        *__p >>= *__q;
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___shift_right(_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , __p += __s)
        *__p >>= __e[__i];
    }
    template<typename _Tp >
    inline void _Array_augmented___shift_right(_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)
    {
        _Tp * __q(__b._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__q)
        __a._M_data[*__j] >>= *__q;
    }
    template<typename _Tp >
    inline void _Array_augmented___shift_right(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)
    {
        _Tp * __p(__a._M_data);
        for (size_t * __j = __i._M_data;
            __j < __i._M_data + __n;
            ++__j , ++__p)
        *__p >>= __b._M_data[*__j];
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___shift_right(_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        size_t * __j(__i._M_data);
        for (size_t __k = 0;
            __k < __n;
            ++__k , ++__j)
        __a._M_data[*__j] >>= __e[__k];
    }
    template<typename _Tp >
    void _Array_augmented___shift_right(_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__q , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p >>= *__q;
        }
    }
    template<typename _Tp >
    void _Array_augmented___shift_right(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)
    {
        bool * __ok(__m._M_data);
        _Tp * __q(__b._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , ++__ok , ++__q)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__q;
            }
            *__p >>= *__q;
        }
    }
    template<typename _Tp, class _Dom >
    void _Array_augmented___shift_right(_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > & __e, size_t __n)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p >>= __e[__i];
        }
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Tp >
    void __valarray_fill(_Array< _Tp > __a, size_t __n, _Array< bool > __m, const _Tp & __t)
    {
        _Tp * __p = __a._M_data;
        bool * __ok(__m._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p = __t;
        }
    }
    template<typename _Tp >
    void __valarray_copy(_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)
    {
        _Tp * __p(__a._M_data);
        bool * __ok(__m._M_data);
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__q , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__q = *__p;
        }
    }
    template<typename _Tp >
    void __valarray_copy(_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)
    {
        _Tp * __q(__b._M_data);
        bool * __ok(__m._M_data);
        for (_Tp * __p = __a._M_data;
            __p < __a._M_data + __n;
            ++__p , ++__ok , ++__q)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__q;
            }
            *__q = *__p;
        }
    }
    template<typename _Tp >
    void __valarray_copy(_Array< _Tp > __a, _Array< bool > __m, size_t __n, _Array< _Tp > __b, _Array< bool > __k)
    {
        _Tp * __p(__a._M_data);
        _Tp * __q(__b._M_data);
        bool * __srcok(__m._M_data);
        bool * __dstok(__k._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__srcok , ++__p , ++__dstok , ++__q , ++__i)
        {
            while (!*__srcok)
            {
                ++__srcok;
                ++__p;
            }
            while (!*__dstok)
            {
                ++__dstok;
                ++__q;
            }
            *__q = *__p;
        }
    }
    template<typename _Tp, class _Dom >
    void __valarray_copy(const _Expr< _Dom, _Tp > & __e, size_t __n, _Array< _Tp > __a)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__p)
        *__p = __e[__i];
    }
    template<typename _Tp, class _Dom >
    void __valarray_copy(const _Expr< _Dom, _Tp > & __e, size_t __n, _Array< _Tp > __a, size_t __s)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , __p += __s)
        *__p = __e[__i];
    }
    template<typename _Tp, class _Dom >
    void __valarray_copy(const _Expr< _Dom, _Tp > & __e, size_t __n, _Array< _Tp > __a, _Array< size_t > __i)
    {
        size_t * __j(__i._M_data);
        for (size_t __k = 0;
            __k < __n;
            ++__k , ++__j)
        __a._M_data[*__j] = __e[__k];
    }
    template<typename _Tp >
    void __valarray_copy(_Array< _Tp > __e, _Array< size_t > __f, size_t __n, _Array< _Tp > __a, _Array< size_t > __i)
    {
        size_t * __g(__f._M_data);
        size_t * __j(__i._M_data);
        for (size_t __k = 0;
            __k < __n;
            ++__k , ++__j , ++__g)
        __a._M_data[*__j] = __e._M_data[*__g];
    }
    template<typename _Tp, class _Dom >
    void __valarray_copy(const _Expr< _Dom, _Tp > & __e, size_t __n, _Array< _Tp > __a, _Array< bool > __m)
    {
        bool * __ok(__m._M_data);
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            *__p = __e[__i];
        }
    }
    template<typename _Tp, class _Dom >
    void __valarray_copy_construct(const _Expr< _Dom, _Tp > & __e, size_t __n, _Array< _Tp > __a)
    {
        _Tp * __p(__a._M_data);
        for (size_t __i = 0;
            __i < __n;
            ++__i , ++__p)
        new (__p) _Tp (__e[__i]);
    }
    template<typename _Tp >
    void __valarray_copy_construct(_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)
    {
        _Tp * __p(__a._M_data);
        bool * __ok(__m._M_data);
        for (_Tp * __q = __b._M_data;
            __q < __b._M_data + __n;
            ++__q , ++__ok , ++__p)
        {
            while (!*__ok)
            {
                ++__ok;
                ++__p;
            }
            new (__q) _Tp (*__p);
        }
    }
}
namespace std __attribute__((__visibility__("default"))) {
    class slice
    {
        public :
            slice();
            slice(size_t, size_t, size_t);
            size_t start() const;
            size_t size() const;
            size_t stride() const;
        private :
            size_t _M_off;
            size_t _M_sz;
            size_t _M_st;
    };
    inline slice::slice()
        : _M_off(0), _M_sz(0), _M_st(0) 
    {
    }
    inline slice::slice(size_t __o, size_t __d, size_t __s)
        : _M_off(__o), _M_sz(__d), _M_st(__s) 
    {
    }
    inline size_t slice::start() const
    {
        return _M_off;
    }
    inline size_t slice::size() const
    {
        return _M_sz;
    }
    inline size_t slice::stride() const
    {
        return _M_st;
    }
    template<typename _Tp >
    class slice_array
    {
        public :
            typedef _Tp value_type;
            slice_array(const slice_array &);
            slice_array & operator =(const slice_array &);
            void operator =(const valarray< _Tp > &) const;
            void operator *=(const valarray< _Tp > &) const;
            void operator /=(const valarray< _Tp > &) const;
            void operator %=(const valarray< _Tp > &) const;
            void operator +=(const valarray< _Tp > &) const;
            void operator -=(const valarray< _Tp > &) const;
            void operator ^=(const valarray< _Tp > &) const;
            void operator &=(const valarray< _Tp > &) const;
            void operator |=(const valarray< _Tp > &) const;
            void operator <<=(const valarray< _Tp > &) const;
            void operator >>=(const valarray< _Tp > &) const;
            void operator =(const _Tp &) const;
            template<class _Dom >
            void operator =(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator *=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator /=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator %=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator +=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator -=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator ^=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator &=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator |=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator <<=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator >>=(const _Expr< _Dom, _Tp > &) const;
        private :
            friend class valarray< _Tp >;
            slice_array(_Array< _Tp >, const slice &);
            const size_t _M_sz;
            const size_t _M_stride;
            const _Array< _Tp > _M_array;
            slice_array();
    };
    template<typename _Tp >
    inline slice_array< _Tp >::slice_array(_Array< _Tp > __a, const slice & __s)
        : _M_sz(__s.size()), _M_stride(__s.stride()), _M_array(__a.begin() + __s.start()) 
    {
    }
    template<typename _Tp >
    inline slice_array< _Tp >::slice_array(const slice_array< _Tp > & a)
        : _M_sz(a._M_sz), _M_stride(a._M_stride), _M_array(a._M_array) 
    {
    }
    template<typename _Tp >
    inline slice_array< _Tp > & slice_array< _Tp >::operator =(const slice_array< _Tp > & __a)
    {
        std::__valarray_copy(__a._M_array, __a._M_sz, __a._M_stride, _M_array, _M_stride);
        return *this;
    }
    template<typename _Tp >
    inline void slice_array< _Tp >::operator =(const _Tp & __t) const
    {
        std::__valarray_fill(_M_array, _M_sz, _M_stride, __t);
    }
    template<typename _Tp >
    inline void slice_array< _Tp >::operator =(const valarray< _Tp > & __v) const
    {
        std::__valarray_copy(_Array< _Tp >(__v), _M_array, _M_sz, _M_stride);
    }
    template<typename _Tp >
    template<class _Dom >
    inline void slice_array< _Tp >::operator =(const _Expr< _Dom, _Tp > & __e) const
    {
        std::__valarray_copy(__e, _M_sz, _M_array, _M_stride);
    }
    template<typename _Tp >
    inline void slice_array< _Tp >::operator *=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___multiplies(_M_array, _M_sz, _M_stride, _Array< _Tp >(__v));
    }
    template<typename _Tp >
    template<class _Dom >
    inline void slice_array< _Tp >::operator *=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___multiplies(_M_array, _M_stride, __e, _M_sz);
    }
    template<typename _Tp >
    inline void slice_array< _Tp >::operator /=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___divides(_M_array, _M_sz, _M_stride, _Array< _Tp >(__v));
    }
    template<typename _Tp >
    template<class _Dom >
    inline void slice_array< _Tp >::operator /=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___divides(_M_array, _M_stride, __e, _M_sz);
    }
    template<typename _Tp >
    inline void slice_array< _Tp >::operator %=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___modulus(_M_array, _M_sz, _M_stride, _Array< _Tp >(__v));
    }
    template<typename _Tp >
    template<class _Dom >
    inline void slice_array< _Tp >::operator %=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___modulus(_M_array, _M_stride, __e, _M_sz);
    }
    template<typename _Tp >
    inline void slice_array< _Tp >::operator +=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___plus(_M_array, _M_sz, _M_stride, _Array< _Tp >(__v));
    }
    template<typename _Tp >
    template<class _Dom >
    inline void slice_array< _Tp >::operator +=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___plus(_M_array, _M_stride, __e, _M_sz);
    }
    template<typename _Tp >
    inline void slice_array< _Tp >::operator -=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___minus(_M_array, _M_sz, _M_stride, _Array< _Tp >(__v));
    }
    template<typename _Tp >
    template<class _Dom >
    inline void slice_array< _Tp >::operator -=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___minus(_M_array, _M_stride, __e, _M_sz);
    }
    template<typename _Tp >
    inline void slice_array< _Tp >::operator ^=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___bitwise_xor(_M_array, _M_sz, _M_stride, _Array< _Tp >(__v));
    }
    template<typename _Tp >
    template<class _Dom >
    inline void slice_array< _Tp >::operator ^=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___bitwise_xor(_M_array, _M_stride, __e, _M_sz);
    }
    template<typename _Tp >
    inline void slice_array< _Tp >::operator &=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___bitwise_and(_M_array, _M_sz, _M_stride, _Array< _Tp >(__v));
    }
    template<typename _Tp >
    template<class _Dom >
    inline void slice_array< _Tp >::operator &=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___bitwise_and(_M_array, _M_stride, __e, _M_sz);
    }
    template<typename _Tp >
    inline void slice_array< _Tp >::operator |=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___bitwise_or(_M_array, _M_sz, _M_stride, _Array< _Tp >(__v));
    }
    template<typename _Tp >
    template<class _Dom >
    inline void slice_array< _Tp >::operator |=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___bitwise_or(_M_array, _M_stride, __e, _M_sz);
    }
    template<typename _Tp >
    inline void slice_array< _Tp >::operator <<=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___shift_left(_M_array, _M_sz, _M_stride, _Array< _Tp >(__v));
    }
    template<typename _Tp >
    template<class _Dom >
    inline void slice_array< _Tp >::operator <<=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___shift_left(_M_array, _M_stride, __e, _M_sz);
    }
    template<typename _Tp >
    inline void slice_array< _Tp >::operator >>=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___shift_right(_M_array, _M_sz, _M_stride, _Array< _Tp >(__v));
    }
    template<typename _Tp >
    template<class _Dom >
    inline void slice_array< _Tp >::operator >>=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___shift_right(_M_array, _M_stride, __e, _M_sz);
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Tp1, typename _Tp2 >
    class _Constant;
    struct __abs
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __t) const
            {
                return abs(__t);
            }
    };
    struct __cos
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __t) const
            {
                return cos(__t);
            }
    };
    struct __acos
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __t) const
            {
                return acos(__t);
            }
    };
    struct __cosh
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __t) const
            {
                return cosh(__t);
            }
    };
    struct __sin
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __t) const
            {
                return sin(__t);
            }
    };
    struct __asin
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __t) const
            {
                return asin(__t);
            }
    };
    struct __sinh
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __t) const
            {
                return sinh(__t);
            }
    };
    struct __tan
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __t) const
            {
                return tan(__t);
            }
    };
    struct __atan
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __t) const
            {
                return atan(__t);
            }
    };
    struct __tanh
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __t) const
            {
                return tanh(__t);
            }
    };
    struct __exp
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __t) const
            {
                return exp(__t);
            }
    };
    struct __log
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __t) const
            {
                return log(__t);
            }
    };
    struct __log10
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __t) const
            {
                return log10(__t);
            }
    };
    struct __sqrt
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __t) const
            {
                return sqrt(__t);
            }
    };
    struct __unary_plus
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __t) const
            {
                return +__t;
            }
    };
    struct __negate
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __t) const
            {
                return -__t;
            }
    };
    struct __bitwise_not
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __t) const
            {
                return ~__t;
            }
    };
    struct __plus
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x + __y;
            }
    };
    struct __minus
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x - __y;
            }
    };
    struct __multiplies
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x * __y;
            }
    };
    struct __divides
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x / __y;
            }
    };
    struct __modulus
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x % __y;
            }
    };
    struct __bitwise_xor
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x ^ __y;
            }
    };
    struct __bitwise_and
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x & __y;
            }
    };
    struct __bitwise_or
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x | __y;
            }
    };
    struct __shift_left
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x << __y;
            }
    };
    struct __shift_right
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x >> __y;
            }
    };
    struct __logical_and
    {
            template<typename _Tp >
            bool operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x && __y;
            }
    };
    struct __logical_or
    {
            template<typename _Tp >
            bool operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x || __y;
            }
    };
    struct __logical_not
    {
            template<typename _Tp >
            bool operator ()(const _Tp & __x) const
            {
                return !__x;
            }
    };
    struct __equal_to
    {
            template<typename _Tp >
            bool operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x == __y;
            }
    };
    struct __not_equal_to
    {
            template<typename _Tp >
            bool operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x != __y;
            }
    };
    struct __less
    {
            template<typename _Tp >
            bool operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x < __y;
            }
    };
    struct __greater
    {
            template<typename _Tp >
            bool operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x > __y;
            }
    };
    struct __less_equal
    {
            template<typename _Tp >
            bool operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x <= __y;
            }
    };
    struct __greater_equal
    {
            template<typename _Tp >
            bool operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return __x >= __y;
            }
    };
    struct __atan2
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return atan2(__x, __y);
            }
    };
    struct __pow
    {
            template<typename _Tp >
            _Tp operator ()(const _Tp & __x, const _Tp & __y) const
            {
                return pow(__x, __y);
            }
    };
    template<typename , typename _Tp >
    struct __fun
    {
            typedef _Tp result_type;
    };
    template<typename _Tp >
    struct __fun< __logical_not, _Tp >
    {
            typedef bool result_type;
    };
    template<typename _Tp >
    struct __fun< __logical_and, _Tp >
    {
            typedef bool result_type;
    };
    template<typename _Tp >
    struct __fun< __logical_or, _Tp >
    {
            typedef bool result_type;
    };
    template<typename _Tp >
    struct __fun< __less, _Tp >
    {
            typedef bool result_type;
    };
    template<typename _Tp >
    struct __fun< __greater, _Tp >
    {
            typedef bool result_type;
    };
    template<typename _Tp >
    struct __fun< __less_equal, _Tp >
    {
            typedef bool result_type;
    };
    template<typename _Tp >
    struct __fun< __greater_equal, _Tp >
    {
            typedef bool result_type;
    };
    template<typename _Tp >
    struct __fun< __equal_to, _Tp >
    {
            typedef bool result_type;
    };
    template<typename _Tp >
    struct __fun< __not_equal_to, _Tp >
    {
            typedef bool result_type;
    };
    template<typename _Dom, typename _Arg >
    class _FunBase
    {
        public :
            typedef typename _Dom::value_type value_type;
            _FunBase(const _Dom & __e, value_type __f(_Arg))
                : _M_expr(__e), _M_func(__f) 
            {
            }
            value_type operator [](size_t __i) const
            {
                return _M_func(_M_expr[__i]);
            }
            size_t size() const
            {
                return _M_expr.size();
            }
        private :
            const _Dom & _M_expr;
            value_type (* _M_func)(_Arg);
    };
    template<class _Dom >
    struct _ValFunClos< _Expr, _Dom > : _FunBase< _Dom, typename _Dom::value_type >
    {
            typedef _FunBase< _Dom, typename _Dom::value_type > _Base;
            typedef typename _Base::value_type value_type;
            typedef value_type _Tp;
            _ValFunClos(const _Dom & __e, _Tp __f(_Tp))
                : _Base(__e, __f) 
            {
            }
    };
    template<typename _Tp >
    struct _ValFunClos< _ValArray, _Tp > : _FunBase< valarray< _Tp >, _Tp >
    {
            typedef _FunBase< valarray< _Tp >, _Tp > _Base;
            typedef _Tp value_type;
            _ValFunClos(const valarray< _Tp > & __v, _Tp __f(_Tp))
                : _Base(__v, __f) 
            {
            }
    };
    template<class _Dom >
    struct _RefFunClos< _Expr, _Dom > : _FunBase< _Dom, const typename _Dom::value_type & >
    {
            typedef _FunBase< _Dom, const typename _Dom::value_type & > _Base;
            typedef typename _Base::value_type value_type;
            typedef value_type _Tp;
            _RefFunClos(const _Dom & __e, _Tp __f(const _Tp &))
                : _Base(__e, __f) 
            {
            }
    };
    template<typename _Tp >
    struct _RefFunClos< _ValArray, _Tp > : _FunBase< valarray< _Tp >, const _Tp & >
    {
            typedef _FunBase< valarray< _Tp >, const _Tp & > _Base;
            typedef _Tp value_type;
            _RefFunClos(const valarray< _Tp > & __v, _Tp __f(const _Tp &))
                : _Base(__v, __f) 
            {
            }
    };
    template<class _Oper, class _Arg >
    class _UnBase
    {
        public :
            typedef typename _Arg::value_type _Vt;
            typedef typename __fun< _Oper, _Vt >::result_type value_type;
            _UnBase(const _Arg & __e)
                : _M_expr(__e) 
            {
            }
            value_type operator [](size_t __i) const
            {
                return _Oper()(_M_expr[__i]);
            }
            size_t size() const
            {
                return _M_expr.size();
            }
        private :
            const _Arg & _M_expr;
    };
    template<class _Oper, class _Dom >
    struct _UnClos< _Oper, _Expr, _Dom > : _UnBase< _Oper, _Dom >
    {
            typedef _Dom _Arg;
            typedef _UnBase< _Oper, _Dom > _Base;
            typedef typename _Base::value_type value_type;
            _UnClos(const _Arg & __e)
                : _Base(__e) 
            {
            }
    };
    template<class _Oper, typename _Tp >
    struct _UnClos< _Oper, _ValArray, _Tp > : _UnBase< _Oper, valarray< _Tp > >
    {
            typedef valarray< _Tp > _Arg;
            typedef _UnBase< _Oper, valarray< _Tp > > _Base;
            typedef typename _Base::value_type value_type;
            _UnClos(const _Arg & __e)
                : _Base(__e) 
            {
            }
    };
    template<class _Oper, class _FirstArg, class _SecondArg >
    class _BinBase
    {
        public :
            typedef typename _FirstArg::value_type _Vt;
            typedef typename __fun< _Oper, _Vt >::result_type value_type;
            _BinBase(const _FirstArg & __e1, const _SecondArg & __e2)
                : _M_expr1(__e1), _M_expr2(__e2) 
            {
            }
            value_type operator [](size_t __i) const
            {
                return _Oper()(_M_expr1[__i], _M_expr2[__i]);
            }
            size_t size() const
            {
                return _M_expr1.size();
            }
        private :
            const _FirstArg & _M_expr1;
            const _SecondArg & _M_expr2;
    };
    template<class _Oper, class _Clos >
    class _BinBase2
    {
        public :
            typedef typename _Clos::value_type _Vt;
            typedef typename __fun< _Oper, _Vt >::result_type value_type;
            _BinBase2(const _Clos & __e, const _Vt & __t)
                : _M_expr1(__e), _M_expr2(__t) 
            {
            }
            value_type operator [](size_t __i) const
            {
                return _Oper()(_M_expr1[__i], _M_expr2);
            }
            size_t size() const
            {
                return _M_expr1.size();
            }
        private :
            const _Clos & _M_expr1;
            const _Vt & _M_expr2;
    };
    template<class _Oper, class _Clos >
    class _BinBase1
    {
        public :
            typedef typename _Clos::value_type _Vt;
            typedef typename __fun< _Oper, _Vt >::result_type value_type;
            _BinBase1(const _Vt & __t, const _Clos & __e)
                : _M_expr1(__t), _M_expr2(__e) 
            {
            }
            value_type operator [](size_t __i) const
            {
                return _Oper()(_M_expr1, _M_expr2[__i]);
            }
            size_t size() const
            {
                return _M_expr2.size();
            }
        private :
            const _Vt & _M_expr1;
            const _Clos & _M_expr2;
    };
    template<class _Oper, class _Dom1, class _Dom2 >
    struct _BinClos< _Oper, _Expr, _Expr, _Dom1, _Dom2 > : _BinBase< _Oper, _Dom1, _Dom2 >
    {
            typedef _BinBase< _Oper, _Dom1, _Dom2 > _Base;
            typedef typename _Base::value_type value_type;
            _BinClos(const _Dom1 & __e1, const _Dom2 & __e2)
                : _Base(__e1, __e2) 
            {
            }
    };
    template<class _Oper, typename _Tp >
    struct _BinClos< _Oper, _ValArray, _ValArray, _Tp, _Tp > : _BinBase< _Oper, valarray< _Tp >, valarray< _Tp > >
    {
            typedef _BinBase< _Oper, valarray< _Tp >, valarray< _Tp > > _Base;
            typedef typename _Base::value_type value_type;
            _BinClos(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
                : _Base(__v, __w) 
            {
            }
    };
    template<class _Oper, class _Dom >
    struct _BinClos< _Oper, _Expr, _ValArray, _Dom, typename _Dom::value_type > : _BinBase< _Oper, _Dom, valarray< typename _Dom::value_type > >
    {
            typedef typename _Dom::value_type _Tp;
            typedef _BinBase< _Oper, _Dom, valarray< _Tp > > _Base;
            typedef typename _Base::value_type value_type;
            _BinClos(const _Dom & __e1, const valarray< _Tp > & __e2)
                : _Base(__e1, __e2) 
            {
            }
    };
    template<class _Oper, class _Dom >
    struct _BinClos< _Oper, _ValArray, _Expr, typename _Dom::value_type, _Dom > : _BinBase< _Oper, valarray< typename _Dom::value_type >, _Dom >
    {
            typedef typename _Dom::value_type _Tp;
            typedef _BinBase< _Oper, valarray< _Tp >, _Dom > _Base;
            typedef typename _Base::value_type value_type;
            _BinClos(const valarray< _Tp > & __e1, const _Dom & __e2)
                : _Base(__e1, __e2) 
            {
            }
    };
    template<class _Oper, class _Dom >
    struct _BinClos< _Oper, _Expr, _Constant, _Dom, typename _Dom::value_type > : _BinBase2< _Oper, _Dom >
    {
            typedef typename _Dom::value_type _Tp;
            typedef _BinBase2< _Oper, _Dom > _Base;
            typedef typename _Base::value_type value_type;
            _BinClos(const _Dom & __e1, const _Tp & __e2)
                : _Base(__e1, __e2) 
            {
            }
    };
    template<class _Oper, class _Dom >
    struct _BinClos< _Oper, _Constant, _Expr, typename _Dom::value_type, _Dom > : _BinBase1< _Oper, _Dom >
    {
            typedef typename _Dom::value_type _Tp;
            typedef _BinBase1< _Oper, _Dom > _Base;
            typedef typename _Base::value_type value_type;
            _BinClos(const _Tp & __e1, const _Dom & __e2)
                : _Base(__e1, __e2) 
            {
            }
    };
    template<class _Oper, typename _Tp >
    struct _BinClos< _Oper, _ValArray, _Constant, _Tp, _Tp > : _BinBase2< _Oper, valarray< _Tp > >
    {
            typedef _BinBase2< _Oper, valarray< _Tp > > _Base;
            typedef typename _Base::value_type value_type;
            _BinClos(const valarray< _Tp > & __v, const _Tp & __t)
                : _Base(__v, __t) 
            {
            }
    };
    template<class _Oper, typename _Tp >
    struct _BinClos< _Oper, _Constant, _ValArray, _Tp, _Tp > : _BinBase1< _Oper, valarray< _Tp > >
    {
            typedef _BinBase1< _Oper, valarray< _Tp > > _Base;
            typedef typename _Base::value_type value_type;
            _BinClos(const _Tp & __t, const valarray< _Tp > & __v)
                : _Base(__t, __v) 
            {
            }
    };
    template<typename _Dom >
    class _SBase
    {
        public :
            typedef typename _Dom::value_type value_type;
            _SBase(const _Dom & __e, const slice & __s)
                : _M_expr(__e), _M_slice(__s) 
            {
            }
            value_type operator [](size_t __i) const
            {
                return _M_expr[_M_slice.start() + __i * _M_slice.stride()];
            }
            size_t size() const
            {
                return _M_slice.size();
            }
        private :
            const _Dom & _M_expr;
            const slice & _M_slice;
    };
    template<typename _Tp >
    class _SBase< _Array< _Tp > >
    {
        public :
            typedef _Tp value_type;
            _SBase(_Array< _Tp > __a, const slice & __s)
                : _M_array(__a._M_data + __s.start()), _M_size(__s.size()), _M_stride(__s.stride()) 
            {
            }
            value_type operator [](size_t __i) const
            {
                return _M_array._M_data[__i * _M_stride];
            }
            size_t size() const
            {
                return _M_size;
            }
        private :
            const _Array< _Tp > _M_array;
            const size_t _M_size;
            const size_t _M_stride;
    };
    template<class _Dom >
    struct _SClos< _Expr, _Dom > : _SBase< _Dom >
    {
            typedef _SBase< _Dom > _Base;
            typedef typename _Base::value_type value_type;
            _SClos(const _Dom & __e, const slice & __s)
                : _Base(__e, __s) 
            {
            }
    };
    template<typename _Tp >
    struct _SClos< _ValArray, _Tp > : _SBase< _Array< _Tp > >
    {
            typedef _SBase< _Array< _Tp > > _Base;
            typedef _Tp value_type;
            _SClos(_Array< _Tp > __a, const slice & __s)
                : _Base(__a, __s) 
            {
            }
    };
}
namespace std __attribute__((__visibility__("default"))) {
    template<class _Tp >
    class valarray
    {
            template<class _Op >
            struct _UnaryOp
            {
                    typedef typename __fun< _Op, _Tp >::result_type __rt;
                    typedef _Expr< _UnClos< _Op, _ValArray, _Tp >, __rt > _Rt;
            };
        public :
            typedef _Tp value_type;
            valarray();
            explicit valarray(size_t);
            valarray(const _Tp &, size_t);
            valarray(const _Tp *__restrict__, size_t);
            valarray(const valarray &);
            valarray(const slice_array< _Tp > &);
            valarray(const gslice_array< _Tp > &);
            valarray(const mask_array< _Tp > &);
            valarray(const indirect_array< _Tp > &);
            template<class _Dom >
            valarray(const _Expr< _Dom, _Tp > & __e);
            ~valarray();
            valarray< _Tp > & operator =(const valarray< _Tp > &);
            valarray< _Tp > & operator =(const _Tp &);
            valarray< _Tp > & operator =(const slice_array< _Tp > &);
            valarray< _Tp > & operator =(const gslice_array< _Tp > &);
            valarray< _Tp > & operator =(const mask_array< _Tp > &);
            valarray< _Tp > & operator =(const indirect_array< _Tp > &);
            template<class _Dom >
            valarray< _Tp > & operator =(const _Expr< _Dom, _Tp > &);
            _Tp & operator [](size_t);
            const _Tp & operator [](size_t) const;
            _Expr< _SClos< _ValArray, _Tp >, _Tp > operator [](slice) const;
            slice_array< _Tp > operator [](slice);
            _Expr< _GClos< _ValArray, _Tp >, _Tp > operator [](const gslice &) const;
            gslice_array< _Tp > operator [](const gslice &);
            valarray< _Tp > operator [](const valarray< bool > &) const;
            mask_array< _Tp > operator [](const valarray< bool > &);
            _Expr< _IClos< _ValArray, _Tp >, _Tp > operator [](const valarray< size_t > &) const;
            indirect_array< _Tp > operator [](const valarray< size_t > &);
            typename _UnaryOp< __unary_plus >::_Rt operator +() const;
            typename _UnaryOp< __negate >::_Rt operator -() const;
            typename _UnaryOp< __bitwise_not >::_Rt operator ~() const;
            typename _UnaryOp< __logical_not >::_Rt operator !() const;
            valarray< _Tp > & operator *=(const _Tp &);
            valarray< _Tp > & operator /=(const _Tp &);
            valarray< _Tp > & operator %=(const _Tp &);
            valarray< _Tp > & operator +=(const _Tp &);
            valarray< _Tp > & operator -=(const _Tp &);
            valarray< _Tp > & operator ^=(const _Tp &);
            valarray< _Tp > & operator &=(const _Tp &);
            valarray< _Tp > & operator |=(const _Tp &);
            valarray< _Tp > & operator <<=(const _Tp &);
            valarray< _Tp > & operator >>=(const _Tp &);
            valarray< _Tp > & operator *=(const valarray< _Tp > &);
            valarray< _Tp > & operator /=(const valarray< _Tp > &);
            valarray< _Tp > & operator %=(const valarray< _Tp > &);
            valarray< _Tp > & operator +=(const valarray< _Tp > &);
            valarray< _Tp > & operator -=(const valarray< _Tp > &);
            valarray< _Tp > & operator ^=(const valarray< _Tp > &);
            valarray< _Tp > & operator |=(const valarray< _Tp > &);
            valarray< _Tp > & operator &=(const valarray< _Tp > &);
            valarray< _Tp > & operator <<=(const valarray< _Tp > &);
            valarray< _Tp > & operator >>=(const valarray< _Tp > &);
            template<class _Dom >
            valarray< _Tp > & operator *=(const _Expr< _Dom, _Tp > &);
            template<class _Dom >
            valarray< _Tp > & operator /=(const _Expr< _Dom, _Tp > &);
            template<class _Dom >
            valarray< _Tp > & operator %=(const _Expr< _Dom, _Tp > &);
            template<class _Dom >
            valarray< _Tp > & operator +=(const _Expr< _Dom, _Tp > &);
            template<class _Dom >
            valarray< _Tp > & operator -=(const _Expr< _Dom, _Tp > &);
            template<class _Dom >
            valarray< _Tp > & operator ^=(const _Expr< _Dom, _Tp > &);
            template<class _Dom >
            valarray< _Tp > & operator |=(const _Expr< _Dom, _Tp > &);
            template<class _Dom >
            valarray< _Tp > & operator &=(const _Expr< _Dom, _Tp > &);
            template<class _Dom >
            valarray< _Tp > & operator <<=(const _Expr< _Dom, _Tp > &);
            template<class _Dom >
            valarray< _Tp > & operator >>=(const _Expr< _Dom, _Tp > &);
            size_t size() const;
            _Tp sum() const;
            _Tp min() const;
            _Tp max() const;
            valarray< _Tp > shift(int) const;
            valarray< _Tp > cshift(int) const;
            _Expr< _ValFunClos< _ValArray, _Tp >, _Tp > apply(_Tp func(_Tp)) const;
            _Expr< _RefFunClos< _ValArray, _Tp >, _Tp > apply(_Tp func(const _Tp &)) const;
            void resize(size_t __size, _Tp __c = _Tp());
        private :
            size_t _M_size;
            _Tp *__restrict__ _M_data;
            friend class _Array< _Tp >;
    };
    template<typename _Tp >
    inline const _Tp & valarray< _Tp >::operator [](size_t __i) const
    {
        ;
        return _M_data[__i];
    }
    template<typename _Tp >
    inline _Tp & valarray< _Tp >::operator [](size_t __i)
    {
        ;
        return _M_data[__i];
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<class _Dom >
    class _GBase
    {
        public :
            typedef typename _Dom::value_type value_type;
            _GBase(const _Dom & __e, const valarray< size_t > & __i)
                : _M_expr(__e), _M_index(__i) 
            {
            }
            value_type operator [](size_t __i) const
            {
                return _M_expr[_M_index[__i]];
            }
            size_t size() const
            {
                return _M_index.size();
            }
        private :
            const _Dom & _M_expr;
            const valarray< size_t > & _M_index;
    };
    template<typename _Tp >
    class _GBase< _Array< _Tp > >
    {
        public :
            typedef _Tp value_type;
            _GBase(_Array< _Tp > __a, const valarray< size_t > & __i)
                : _M_array(__a), _M_index(__i) 
            {
            }
            value_type operator [](size_t __i) const
            {
                return _M_array._M_data[_M_index[__i]];
            }
            size_t size() const
            {
                return _M_index.size();
            }
        private :
            const _Array< _Tp > _M_array;
            const valarray< size_t > & _M_index;
    };
    template<class _Dom >
    struct _GClos< _Expr, _Dom > : _GBase< _Dom >
    {
            typedef _GBase< _Dom > _Base;
            typedef typename _Base::value_type value_type;
            _GClos(const _Dom & __e, const valarray< size_t > & __i)
                : _Base(__e, __i) 
            {
            }
    };
    template<typename _Tp >
    struct _GClos< _ValArray, _Tp > : _GBase< _Array< _Tp > >
    {
            typedef _GBase< _Array< _Tp > > _Base;
            typedef typename _Base::value_type value_type;
            _GClos(_Array< _Tp > __a, const valarray< size_t > & __i)
                : _Base(__a, __i) 
            {
            }
    };
    template<class _Dom >
    class _IBase
    {
        public :
            typedef typename _Dom::value_type value_type;
            _IBase(const _Dom & __e, const valarray< size_t > & __i)
                : _M_expr(__e), _M_index(__i) 
            {
            }
            value_type operator [](size_t __i) const
            {
                return _M_expr[_M_index[__i]];
            }
            size_t size() const
            {
                return _M_index.size();
            }
        private :
            const _Dom & _M_expr;
            const valarray< size_t > & _M_index;
    };
    template<class _Dom >
    struct _IClos< _Expr, _Dom > : _IBase< _Dom >
    {
            typedef _IBase< _Dom > _Base;
            typedef typename _Base::value_type value_type;
            _IClos(const _Dom & __e, const valarray< size_t > & __i)
                : _Base(__e, __i) 
            {
            }
    };
    template<typename _Tp >
    struct _IClos< _ValArray, _Tp > : _IBase< valarray< _Tp > >
    {
            typedef _IBase< valarray< _Tp > > _Base;
            typedef _Tp value_type;
            _IClos(const valarray< _Tp > & __a, const valarray< size_t > & __i)
                : _Base(__a, __i) 
            {
            }
    };
    template<class _Clos, typename _Tp >
    class _Expr
    {
        public :
            typedef _Tp value_type;
            _Expr(const _Clos &);
            const _Clos & operator ()() const;
            value_type operator [](size_t) const;
            valarray< value_type > operator [](slice) const;
            valarray< value_type > operator [](const gslice &) const;
            valarray< value_type > operator [](const valarray< bool > &) const;
            valarray< value_type > operator [](const valarray< size_t > &) const;
            _Expr< _UnClos< __unary_plus, std::_Expr, _Clos >, value_type > operator +() const;
            _Expr< _UnClos< __negate, std::_Expr, _Clos >, value_type > operator -() const;
            _Expr< _UnClos< __bitwise_not, std::_Expr, _Clos >, value_type > operator ~() const;
            _Expr< _UnClos< __logical_not, std::_Expr, _Clos >, bool > operator !() const;
            size_t size() const;
            value_type sum() const;
            valarray< value_type > shift(int) const;
            valarray< value_type > cshift(int) const;
            value_type min() const;
            value_type max() const;
            valarray< value_type > apply(value_type (*)(const value_type &)) const;
            valarray< value_type > apply(value_type (*)(value_type)) const;
        private :
            const _Clos _M_closure;
    };
    template<class _Clos, typename _Tp >
    inline _Expr< _Clos, _Tp >::_Expr(const _Clos & __c)
        : _M_closure(__c) 
    {
    }
    template<class _Clos, typename _Tp >
    inline const _Clos & _Expr< _Clos, _Tp >::operator ()() const
    {
        return _M_closure;
    }
    template<class _Clos, typename _Tp >
    inline _Tp _Expr< _Clos, _Tp >::operator [](size_t __i) const
    {
        return _M_closure[__i];
    }
    template<class _Clos, typename _Tp >
    inline valarray< _Tp > _Expr< _Clos, _Tp >::operator [](slice __s) const
    {
        valarray< _Tp > __v = valarray< _Tp >(*this)[__s];
        return __v;
    }
    template<class _Clos, typename _Tp >
    inline valarray< _Tp > _Expr< _Clos, _Tp >::operator [](const gslice & __gs) const
    {
        valarray< _Tp > __v = valarray< _Tp >(*this)[__gs];
        return __v;
    }
    template<class _Clos, typename _Tp >
    inline valarray< _Tp > _Expr< _Clos, _Tp >::operator [](const valarray< bool > & __m) const
    {
        valarray< _Tp > __v = valarray< _Tp >(*this)[__m];
        return __v;
    }
    template<class _Clos, typename _Tp >
    inline valarray< _Tp > _Expr< _Clos, _Tp >::operator [](const valarray< size_t > & __i) const
    {
        valarray< _Tp > __v = valarray< _Tp >(*this)[__i];
        return __v;
    }
    template<class _Clos, typename _Tp >
    inline size_t _Expr< _Clos, _Tp >::size() const
    {
        return _M_closure.size();
    }
    template<class _Clos, typename _Tp >
    inline valarray< _Tp > _Expr< _Clos, _Tp >::shift(int __n) const
    {
        valarray< _Tp > __v = valarray< _Tp >(*this).shift(__n);
        return __v;
    }
    template<class _Clos, typename _Tp >
    inline valarray< _Tp > _Expr< _Clos, _Tp >::cshift(int __n) const
    {
        valarray< _Tp > __v = valarray< _Tp >(*this).cshift(__n);
        return __v;
    }
    template<class _Clos, typename _Tp >
    inline valarray< _Tp > _Expr< _Clos, _Tp >::apply(_Tp __f(const _Tp &)) const
    {
        valarray< _Tp > __v = valarray< _Tp >(*this).apply(__f);
        return __v;
    }
    template<class _Clos, typename _Tp >
    inline valarray< _Tp > _Expr< _Clos, _Tp >::apply(_Tp __f(_Tp)) const
    {
        valarray< _Tp > __v = valarray< _Tp >(*this).apply(__f);
        return __v;
    }
    template<class _Clos, typename _Tp >
    inline _Tp _Expr< _Clos, _Tp >::sum() const
    {
        size_t __n = _M_closure.size();
        if (__n == 0)
            return _Tp();
        else
        {
            _Tp __s = _M_closure[--__n];
            while (__n != 0)
                __s += _M_closure[--__n];
            return __s;
        }
    }
    template<class _Clos, typename _Tp >
    inline _Tp _Expr< _Clos, _Tp >::min() const
    {
        return __valarray_min(_M_closure);
    }
    template<class _Clos, typename _Tp >
    inline _Tp _Expr< _Clos, _Tp >::max() const
    {
        return __valarray_max(_M_closure);
    }
    template<class _Dom, typename _Tp >
    inline _Expr< _UnClos< __logical_not, _Expr, _Dom >, bool > _Expr< _Dom, _Tp >::operator !() const
    {
        typedef _UnClos< __logical_not, std::_Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(this->_M_closure));
    }
    template<class _Dom, typename _Tp >
    inline _Expr< _UnClos< __unary_plus, std::_Expr, _Dom >, _Tp > _Expr< _Dom, _Tp >::operator +() const
    {
        typedef _UnClos< __unary_plus, std::_Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(this->_M_closure));
    }
    template<class _Dom, typename _Tp >
    inline _Expr< _UnClos< __negate, std::_Expr, _Dom >, _Tp > _Expr< _Dom, _Tp >::operator -() const
    {
        typedef _UnClos< __negate, std::_Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(this->_M_closure));
    }
    template<class _Dom, typename _Tp >
    inline _Expr< _UnClos< __bitwise_not, std::_Expr, _Dom >, _Tp > _Expr< _Dom, _Tp >::operator ~() const
    {
        typedef _UnClos< __bitwise_not, std::_Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(this->_M_closure));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __plus, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __plus, typename _Dom1::value_type >::result_type > operator +(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __plus, _Arg >::result_type _Value;
        typedef _BinClos< __plus, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __plus, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __plus, typename _Dom::value_type >::result_type > operator +(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __plus, _Arg >::result_type _Value;
        typedef _BinClos< __plus, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __plus, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __plus, typename _Dom::value_type >::result_type > operator +(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __plus, _Arg >::result_type _Value;
        typedef _BinClos< __plus, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __plus, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __plus, typename _Dom::value_type >::result_type > operator +(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __plus, _Arg >::result_type _Value;
        typedef _BinClos< __plus, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __plus, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __plus, typename _Dom::value_type >::result_type > operator +(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __plus, _Tp >::result_type _Value;
        typedef _BinClos< __plus, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __minus, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __minus, typename _Dom1::value_type >::result_type > operator -(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __minus, _Arg >::result_type _Value;
        typedef _BinClos< __minus, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __minus, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __minus, typename _Dom::value_type >::result_type > operator -(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __minus, _Arg >::result_type _Value;
        typedef _BinClos< __minus, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __minus, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __minus, typename _Dom::value_type >::result_type > operator -(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __minus, _Arg >::result_type _Value;
        typedef _BinClos< __minus, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __minus, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __minus, typename _Dom::value_type >::result_type > operator -(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __minus, _Arg >::result_type _Value;
        typedef _BinClos< __minus, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __minus, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __minus, typename _Dom::value_type >::result_type > operator -(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __minus, _Tp >::result_type _Value;
        typedef _BinClos< __minus, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __multiplies, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __multiplies, typename _Dom1::value_type >::result_type > operator *(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __multiplies, _Arg >::result_type _Value;
        typedef _BinClos< __multiplies, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __multiplies, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __multiplies, typename _Dom::value_type >::result_type > operator *(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __multiplies, _Arg >::result_type _Value;
        typedef _BinClos< __multiplies, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __multiplies, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __multiplies, typename _Dom::value_type >::result_type > operator *(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __multiplies, _Arg >::result_type _Value;
        typedef _BinClos< __multiplies, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __multiplies, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __multiplies, typename _Dom::value_type >::result_type > operator *(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __multiplies, _Arg >::result_type _Value;
        typedef _BinClos< __multiplies, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __multiplies, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __multiplies, typename _Dom::value_type >::result_type > operator *(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __multiplies, _Tp >::result_type _Value;
        typedef _BinClos< __multiplies, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __divides, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __divides, typename _Dom1::value_type >::result_type > operator /(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __divides, _Arg >::result_type _Value;
        typedef _BinClos< __divides, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __divides, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __divides, typename _Dom::value_type >::result_type > operator /(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __divides, _Arg >::result_type _Value;
        typedef _BinClos< __divides, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __divides, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __divides, typename _Dom::value_type >::result_type > operator /(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __divides, _Arg >::result_type _Value;
        typedef _BinClos< __divides, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __divides, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __divides, typename _Dom::value_type >::result_type > operator /(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __divides, _Arg >::result_type _Value;
        typedef _BinClos< __divides, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __divides, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __divides, typename _Dom::value_type >::result_type > operator /(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __divides, _Tp >::result_type _Value;
        typedef _BinClos< __divides, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __modulus, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __modulus, typename _Dom1::value_type >::result_type > operator %(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __modulus, _Arg >::result_type _Value;
        typedef _BinClos< __modulus, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __modulus, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __modulus, typename _Dom::value_type >::result_type > operator %(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __modulus, _Arg >::result_type _Value;
        typedef _BinClos< __modulus, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __modulus, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __modulus, typename _Dom::value_type >::result_type > operator %(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __modulus, _Arg >::result_type _Value;
        typedef _BinClos< __modulus, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __modulus, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __modulus, typename _Dom::value_type >::result_type > operator %(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __modulus, _Arg >::result_type _Value;
        typedef _BinClos< __modulus, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __modulus, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __modulus, typename _Dom::value_type >::result_type > operator %(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __modulus, _Tp >::result_type _Value;
        typedef _BinClos< __modulus, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __bitwise_xor, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __bitwise_xor, typename _Dom1::value_type >::result_type > operator ^(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __bitwise_xor, _Arg >::result_type _Value;
        typedef _BinClos< __bitwise_xor, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __bitwise_xor, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __bitwise_xor, typename _Dom::value_type >::result_type > operator ^(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __bitwise_xor, _Arg >::result_type _Value;
        typedef _BinClos< __bitwise_xor, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __bitwise_xor, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __bitwise_xor, typename _Dom::value_type >::result_type > operator ^(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __bitwise_xor, _Arg >::result_type _Value;
        typedef _BinClos< __bitwise_xor, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __bitwise_xor, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __bitwise_xor, typename _Dom::value_type >::result_type > operator ^(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __bitwise_xor, _Arg >::result_type _Value;
        typedef _BinClos< __bitwise_xor, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __bitwise_xor, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __bitwise_xor, typename _Dom::value_type >::result_type > operator ^(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __bitwise_xor, _Tp >::result_type _Value;
        typedef _BinClos< __bitwise_xor, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __bitwise_and, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __bitwise_and, typename _Dom1::value_type >::result_type > operator &(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __bitwise_and, _Arg >::result_type _Value;
        typedef _BinClos< __bitwise_and, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __bitwise_and, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __bitwise_and, typename _Dom::value_type >::result_type > operator &(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __bitwise_and, _Arg >::result_type _Value;
        typedef _BinClos< __bitwise_and, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __bitwise_and, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __bitwise_and, typename _Dom::value_type >::result_type > operator &(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __bitwise_and, _Arg >::result_type _Value;
        typedef _BinClos< __bitwise_and, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __bitwise_and, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __bitwise_and, typename _Dom::value_type >::result_type > operator &(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __bitwise_and, _Arg >::result_type _Value;
        typedef _BinClos< __bitwise_and, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __bitwise_and, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __bitwise_and, typename _Dom::value_type >::result_type > operator &(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __bitwise_and, _Tp >::result_type _Value;
        typedef _BinClos< __bitwise_and, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __bitwise_or, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __bitwise_or, typename _Dom1::value_type >::result_type > operator |(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __bitwise_or, _Arg >::result_type _Value;
        typedef _BinClos< __bitwise_or, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __bitwise_or, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __bitwise_or, typename _Dom::value_type >::result_type > operator |(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __bitwise_or, _Arg >::result_type _Value;
        typedef _BinClos< __bitwise_or, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __bitwise_or, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __bitwise_or, typename _Dom::value_type >::result_type > operator |(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __bitwise_or, _Arg >::result_type _Value;
        typedef _BinClos< __bitwise_or, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __bitwise_or, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __bitwise_or, typename _Dom::value_type >::result_type > operator |(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __bitwise_or, _Arg >::result_type _Value;
        typedef _BinClos< __bitwise_or, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __bitwise_or, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __bitwise_or, typename _Dom::value_type >::result_type > operator |(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __bitwise_or, _Tp >::result_type _Value;
        typedef _BinClos< __bitwise_or, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __shift_left, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __shift_left, typename _Dom1::value_type >::result_type > operator <<(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __shift_left, _Arg >::result_type _Value;
        typedef _BinClos< __shift_left, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __shift_left, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __shift_left, typename _Dom::value_type >::result_type > operator <<(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __shift_left, _Arg >::result_type _Value;
        typedef _BinClos< __shift_left, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __shift_left, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __shift_left, typename _Dom::value_type >::result_type > operator <<(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __shift_left, _Arg >::result_type _Value;
        typedef _BinClos< __shift_left, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __shift_left, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __shift_left, typename _Dom::value_type >::result_type > operator <<(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __shift_left, _Arg >::result_type _Value;
        typedef _BinClos< __shift_left, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __shift_left, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __shift_left, typename _Dom::value_type >::result_type > operator <<(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __shift_left, _Tp >::result_type _Value;
        typedef _BinClos< __shift_left, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __shift_right, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __shift_right, typename _Dom1::value_type >::result_type > operator >>(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __shift_right, _Arg >::result_type _Value;
        typedef _BinClos< __shift_right, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __shift_right, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __shift_right, typename _Dom::value_type >::result_type > operator >>(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __shift_right, _Arg >::result_type _Value;
        typedef _BinClos< __shift_right, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __shift_right, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __shift_right, typename _Dom::value_type >::result_type > operator >>(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __shift_right, _Arg >::result_type _Value;
        typedef _BinClos< __shift_right, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __shift_right, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __shift_right, typename _Dom::value_type >::result_type > operator >>(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __shift_right, _Arg >::result_type _Value;
        typedef _BinClos< __shift_right, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __shift_right, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __shift_right, typename _Dom::value_type >::result_type > operator >>(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __shift_right, _Tp >::result_type _Value;
        typedef _BinClos< __shift_right, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __logical_and, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __logical_and, typename _Dom1::value_type >::result_type > operator &&(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __logical_and, _Arg >::result_type _Value;
        typedef _BinClos< __logical_and, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __logical_and, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __logical_and, typename _Dom::value_type >::result_type > operator &&(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __logical_and, _Arg >::result_type _Value;
        typedef _BinClos< __logical_and, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __logical_and, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __logical_and, typename _Dom::value_type >::result_type > operator &&(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __logical_and, _Arg >::result_type _Value;
        typedef _BinClos< __logical_and, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __logical_and, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __logical_and, typename _Dom::value_type >::result_type > operator &&(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __logical_and, _Arg >::result_type _Value;
        typedef _BinClos< __logical_and, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __logical_and, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __logical_and, typename _Dom::value_type >::result_type > operator &&(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __logical_and, _Tp >::result_type _Value;
        typedef _BinClos< __logical_and, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __logical_or, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __logical_or, typename _Dom1::value_type >::result_type > operator ||(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __logical_or, _Arg >::result_type _Value;
        typedef _BinClos< __logical_or, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __logical_or, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __logical_or, typename _Dom::value_type >::result_type > operator ||(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __logical_or, _Arg >::result_type _Value;
        typedef _BinClos< __logical_or, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __logical_or, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __logical_or, typename _Dom::value_type >::result_type > operator ||(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __logical_or, _Arg >::result_type _Value;
        typedef _BinClos< __logical_or, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __logical_or, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __logical_or, typename _Dom::value_type >::result_type > operator ||(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __logical_or, _Arg >::result_type _Value;
        typedef _BinClos< __logical_or, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __logical_or, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __logical_or, typename _Dom::value_type >::result_type > operator ||(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __logical_or, _Tp >::result_type _Value;
        typedef _BinClos< __logical_or, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __equal_to, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __equal_to, typename _Dom1::value_type >::result_type > operator ==(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __equal_to, _Arg >::result_type _Value;
        typedef _BinClos< __equal_to, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __equal_to, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __equal_to, typename _Dom::value_type >::result_type > operator ==(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __equal_to, _Arg >::result_type _Value;
        typedef _BinClos< __equal_to, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __equal_to, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __equal_to, typename _Dom::value_type >::result_type > operator ==(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __equal_to, _Arg >::result_type _Value;
        typedef _BinClos< __equal_to, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __equal_to, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __equal_to, typename _Dom::value_type >::result_type > operator ==(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __equal_to, _Arg >::result_type _Value;
        typedef _BinClos< __equal_to, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __equal_to, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __equal_to, typename _Dom::value_type >::result_type > operator ==(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __equal_to, _Tp >::result_type _Value;
        typedef _BinClos< __equal_to, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __not_equal_to, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __not_equal_to, typename _Dom1::value_type >::result_type > operator !=(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __not_equal_to, _Arg >::result_type _Value;
        typedef _BinClos< __not_equal_to, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __not_equal_to, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __not_equal_to, typename _Dom::value_type >::result_type > operator !=(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __not_equal_to, _Arg >::result_type _Value;
        typedef _BinClos< __not_equal_to, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __not_equal_to, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __not_equal_to, typename _Dom::value_type >::result_type > operator !=(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __not_equal_to, _Arg >::result_type _Value;
        typedef _BinClos< __not_equal_to, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __not_equal_to, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __not_equal_to, typename _Dom::value_type >::result_type > operator !=(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __not_equal_to, _Arg >::result_type _Value;
        typedef _BinClos< __not_equal_to, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __not_equal_to, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __not_equal_to, typename _Dom::value_type >::result_type > operator !=(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __not_equal_to, _Tp >::result_type _Value;
        typedef _BinClos< __not_equal_to, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __less, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __less, typename _Dom1::value_type >::result_type > operator <(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __less, _Arg >::result_type _Value;
        typedef _BinClos< __less, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __less, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __less, typename _Dom::value_type >::result_type > operator <(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __less, _Arg >::result_type _Value;
        typedef _BinClos< __less, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __less, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __less, typename _Dom::value_type >::result_type > operator <(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __less, _Arg >::result_type _Value;
        typedef _BinClos< __less, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __less, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __less, typename _Dom::value_type >::result_type > operator <(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __less, _Arg >::result_type _Value;
        typedef _BinClos< __less, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __less, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __less, typename _Dom::value_type >::result_type > operator <(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __less, _Tp >::result_type _Value;
        typedef _BinClos< __less, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __greater, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __greater, typename _Dom1::value_type >::result_type > operator >(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __greater, _Arg >::result_type _Value;
        typedef _BinClos< __greater, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __greater, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __greater, typename _Dom::value_type >::result_type > operator >(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __greater, _Arg >::result_type _Value;
        typedef _BinClos< __greater, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __greater, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __greater, typename _Dom::value_type >::result_type > operator >(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __greater, _Arg >::result_type _Value;
        typedef _BinClos< __greater, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __greater, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __greater, typename _Dom::value_type >::result_type > operator >(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __greater, _Arg >::result_type _Value;
        typedef _BinClos< __greater, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __greater, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __greater, typename _Dom::value_type >::result_type > operator >(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __greater, _Tp >::result_type _Value;
        typedef _BinClos< __greater, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __less_equal, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __less_equal, typename _Dom1::value_type >::result_type > operator <=(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __less_equal, _Arg >::result_type _Value;
        typedef _BinClos< __less_equal, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __less_equal, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __less_equal, typename _Dom::value_type >::result_type > operator <=(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __less_equal, _Arg >::result_type _Value;
        typedef _BinClos< __less_equal, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __less_equal, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __less_equal, typename _Dom::value_type >::result_type > operator <=(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __less_equal, _Arg >::result_type _Value;
        typedef _BinClos< __less_equal, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __less_equal, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __less_equal, typename _Dom::value_type >::result_type > operator <=(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __less_equal, _Arg >::result_type _Value;
        typedef _BinClos< __less_equal, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __less_equal, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __less_equal, typename _Dom::value_type >::result_type > operator <=(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __less_equal, _Tp >::result_type _Value;
        typedef _BinClos< __less_equal, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __greater_equal, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __greater_equal, typename _Dom1::value_type >::result_type > operator >=(const _Expr< _Dom1, typename _Dom1::value_type > & __v, const _Expr< _Dom2, typename _Dom2::value_type > & __w)
    {
        typedef typename _Dom1::value_type _Arg;
        typedef typename __fun< __greater_equal, _Arg >::result_type _Value;
        typedef _BinClos< __greater_equal, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __w()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __greater_equal, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __greater_equal, typename _Dom::value_type >::result_type > operator >=(const _Expr< _Dom, typename _Dom::value_type > & __v, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __greater_equal, _Arg >::result_type _Value;
        typedef _BinClos< __greater_equal, _Expr, _Constant, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __greater_equal, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __greater_equal, typename _Dom::value_type >::result_type > operator >=(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __greater_equal, _Arg >::result_type _Value;
        typedef _BinClos< __greater_equal, _Constant, _Expr, _Arg, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__t, __v()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __greater_equal, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __greater_equal, typename _Dom::value_type >::result_type > operator >=(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Arg;
        typedef typename __fun< __greater_equal, _Arg >::result_type _Value;
        typedef _BinClos< __greater_equal, _Expr, _ValArray, _Dom, _Arg > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __greater_equal, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __greater_equal, typename _Dom::value_type >::result_type > operator >=(const valarray< typename _Dom::value_type > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef typename __fun< __greater_equal, _Tp >::result_type _Value;
        typedef _BinClos< __greater_equal, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Value >(_Closure(__v, __e()));
    }
    template<class _Dom >
    inline _Expr< _UnClos< __abs, _Expr, _Dom >, typename _Dom::value_type > abs(const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _UnClos< __abs, _Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e()));
    }
    template<typename _Tp >
    inline _Expr< _UnClos< __abs, _ValArray, _Tp >, _Tp > abs(const valarray< _Tp > & __v)
    {
        typedef _UnClos< __abs, _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v));
    }
    template<class _Dom >
    inline _Expr< _UnClos< __cos, _Expr, _Dom >, typename _Dom::value_type > cos(const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _UnClos< __cos, _Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e()));
    }
    template<typename _Tp >
    inline _Expr< _UnClos< __cos, _ValArray, _Tp >, _Tp > cos(const valarray< _Tp > & __v)
    {
        typedef _UnClos< __cos, _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v));
    }
    template<class _Dom >
    inline _Expr< _UnClos< __acos, _Expr, _Dom >, typename _Dom::value_type > acos(const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _UnClos< __acos, _Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e()));
    }
    template<typename _Tp >
    inline _Expr< _UnClos< __acos, _ValArray, _Tp >, _Tp > acos(const valarray< _Tp > & __v)
    {
        typedef _UnClos< __acos, _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v));
    }
    template<class _Dom >
    inline _Expr< _UnClos< __cosh, _Expr, _Dom >, typename _Dom::value_type > cosh(const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _UnClos< __cosh, _Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e()));
    }
    template<typename _Tp >
    inline _Expr< _UnClos< __cosh, _ValArray, _Tp >, _Tp > cosh(const valarray< _Tp > & __v)
    {
        typedef _UnClos< __cosh, _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v));
    }
    template<class _Dom >
    inline _Expr< _UnClos< __sin, _Expr, _Dom >, typename _Dom::value_type > sin(const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _UnClos< __sin, _Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e()));
    }
    template<typename _Tp >
    inline _Expr< _UnClos< __sin, _ValArray, _Tp >, _Tp > sin(const valarray< _Tp > & __v)
    {
        typedef _UnClos< __sin, _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v));
    }
    template<class _Dom >
    inline _Expr< _UnClos< __asin, _Expr, _Dom >, typename _Dom::value_type > asin(const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _UnClos< __asin, _Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e()));
    }
    template<typename _Tp >
    inline _Expr< _UnClos< __asin, _ValArray, _Tp >, _Tp > asin(const valarray< _Tp > & __v)
    {
        typedef _UnClos< __asin, _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v));
    }
    template<class _Dom >
    inline _Expr< _UnClos< __sinh, _Expr, _Dom >, typename _Dom::value_type > sinh(const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _UnClos< __sinh, _Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e()));
    }
    template<typename _Tp >
    inline _Expr< _UnClos< __sinh, _ValArray, _Tp >, _Tp > sinh(const valarray< _Tp > & __v)
    {
        typedef _UnClos< __sinh, _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v));
    }
    template<class _Dom >
    inline _Expr< _UnClos< __tan, _Expr, _Dom >, typename _Dom::value_type > tan(const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _UnClos< __tan, _Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e()));
    }
    template<typename _Tp >
    inline _Expr< _UnClos< __tan, _ValArray, _Tp >, _Tp > tan(const valarray< _Tp > & __v)
    {
        typedef _UnClos< __tan, _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v));
    }
    template<class _Dom >
    inline _Expr< _UnClos< __tanh, _Expr, _Dom >, typename _Dom::value_type > tanh(const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _UnClos< __tanh, _Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e()));
    }
    template<typename _Tp >
    inline _Expr< _UnClos< __tanh, _ValArray, _Tp >, _Tp > tanh(const valarray< _Tp > & __v)
    {
        typedef _UnClos< __tanh, _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v));
    }
    template<class _Dom >
    inline _Expr< _UnClos< __atan, _Expr, _Dom >, typename _Dom::value_type > atan(const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _UnClos< __atan, _Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e()));
    }
    template<typename _Tp >
    inline _Expr< _UnClos< __atan, _ValArray, _Tp >, _Tp > atan(const valarray< _Tp > & __v)
    {
        typedef _UnClos< __atan, _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v));
    }
    template<class _Dom >
    inline _Expr< _UnClos< __exp, _Expr, _Dom >, typename _Dom::value_type > exp(const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _UnClos< __exp, _Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e()));
    }
    template<typename _Tp >
    inline _Expr< _UnClos< __exp, _ValArray, _Tp >, _Tp > exp(const valarray< _Tp > & __v)
    {
        typedef _UnClos< __exp, _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v));
    }
    template<class _Dom >
    inline _Expr< _UnClos< __log, _Expr, _Dom >, typename _Dom::value_type > log(const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _UnClos< __log, _Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e()));
    }
    template<typename _Tp >
    inline _Expr< _UnClos< __log, _ValArray, _Tp >, _Tp > log(const valarray< _Tp > & __v)
    {
        typedef _UnClos< __log, _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v));
    }
    template<class _Dom >
    inline _Expr< _UnClos< __log10, _Expr, _Dom >, typename _Dom::value_type > log10(const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _UnClos< __log10, _Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e()));
    }
    template<typename _Tp >
    inline _Expr< _UnClos< __log10, _ValArray, _Tp >, _Tp > log10(const valarray< _Tp > & __v)
    {
        typedef _UnClos< __log10, _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v));
    }
    template<class _Dom >
    inline _Expr< _UnClos< __sqrt, _Expr, _Dom >, typename _Dom::value_type > sqrt(const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _UnClos< __sqrt, _Expr, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e()));
    }
    template<typename _Tp >
    inline _Expr< _UnClos< __sqrt, _ValArray, _Tp >, _Tp > sqrt(const valarray< _Tp > & __v)
    {
        typedef _UnClos< __sqrt, _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __atan2, _Expr, _Expr, _Dom1, _Dom2 >, typename _Dom1::value_type > atan2(const _Expr< _Dom1, typename _Dom1::value_type > & __e1, const _Expr< _Dom2, typename _Dom2::value_type > & __e2)
    {
        typedef typename _Dom1::value_type _Tp;
        typedef _BinClos< __atan2, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e1(), __e2()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __atan2, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename _Dom::value_type > atan2(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _BinClos< __atan2, _Expr, _ValArray, _Dom, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __atan2, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename _Dom::value_type > atan2(const valarray< typename _Dom::valarray > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _BinClos< __atan2, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v, __e()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __atan2, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename _Dom::value_type > atan2(const _Expr< _Dom, typename _Dom::value_type > & __e, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _BinClos< __atan2, _Expr, _Constant, _Dom, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __atan2, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename _Dom::value_type > atan2(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _BinClos< __atan2, _Constant, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__t, __e()));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __atan2, _ValArray, _ValArray, _Tp, _Tp >, _Tp > atan2(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        typedef _BinClos< __atan2, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __atan2, _ValArray, _Constant, _Tp, _Tp >, _Tp > atan2(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __atan2, _ValArray, _Constant, _Tp, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __atan2, _Constant, _ValArray, _Tp, _Tp >, _Tp > atan2(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __atan2, _Constant, _ValArray, _Tp, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__t, __v));
    }
    template<class _Dom1, class _Dom2 >
    inline _Expr< _BinClos< __pow, _Expr, _Expr, _Dom1, _Dom2 >, typename _Dom1::value_type > pow(const _Expr< _Dom1, typename _Dom1::value_type > & __e1, const _Expr< _Dom2, typename _Dom2::value_type > & __e2)
    {
        typedef typename _Dom1::value_type _Tp;
        typedef _BinClos< __pow, _Expr, _Expr, _Dom1, _Dom2 > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e1(), __e2()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __pow, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename _Dom::value_type > pow(const _Expr< _Dom, typename _Dom::value_type > & __e, const valarray< typename _Dom::value_type > & __v)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _BinClos< __pow, _Expr, _ValArray, _Dom, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e(), __v));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __pow, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename _Dom::value_type > pow(const valarray< typename _Dom::valarray > & __v, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _BinClos< __pow, _ValArray, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v, __e()));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __pow, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename _Dom::value_type > pow(const _Expr< _Dom, typename _Dom::value_type > & __e, const typename _Dom::value_type & __t)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _BinClos< __pow, _Expr, _Constant, _Dom, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__e(), __t));
    }
    template<class _Dom >
    inline _Expr< _BinClos< __pow, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename _Dom::value_type > pow(const typename _Dom::value_type & __t, const _Expr< _Dom, typename _Dom::value_type > & __e)
    {
        typedef typename _Dom::value_type _Tp;
        typedef _BinClos< __pow, _Constant, _Expr, _Tp, _Dom > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__t, __e()));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __pow, _ValArray, _ValArray, _Tp, _Tp >, _Tp > pow(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        typedef _BinClos< __pow, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __pow, _ValArray, _Constant, _Tp, _Tp >, _Tp > pow(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __pow, _ValArray, _Constant, _Tp, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __pow, _Constant, _ValArray, _Tp, _Tp >, _Tp > pow(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __pow, _Constant, _ValArray, _Tp, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(__t, __v));
    }
}
namespace std __attribute__((__visibility__("default"))) {
    class gslice
    {
        public :
            gslice();
            gslice(size_t, const valarray< size_t > &, const valarray< size_t > &);
            gslice(const gslice &);
            ~gslice();
            gslice & operator =(const gslice &);
            size_t start() const;
            valarray< size_t > size() const;
            valarray< size_t > stride() const;
        private :
            struct _Indexer
            {
                    size_t _M_count;
                    size_t _M_start;
                    valarray< size_t > _M_size;
                    valarray< size_t > _M_stride;
                    valarray< size_t > _M_index;
                    _Indexer()
                        : _M_count(1), _M_start(0), _M_size(), _M_stride(), _M_index() 
                    {
                    }
                    _Indexer(size_t, const valarray< size_t > &, const valarray< size_t > &);
                    void _M_increment_use()
                    {
                        ++_M_count;
                    }
                    size_t _M_decrement_use()
                    {
                        return --_M_count;
                    }
            };
            _Indexer * _M_index;
            template<typename _Tp >
            friend class valarray;
    };
    inline size_t gslice::start() const
    {
        return _M_index ? _M_index->_M_start : 0;
    }
    inline valarray< size_t > gslice::size() const
    {
        return _M_index ? _M_index->_M_size : valarray< size_t >();
    }
    inline valarray< size_t > gslice::stride() const
    {
        return _M_index ? _M_index->_M_stride : valarray< size_t >();
    }
    inline gslice::gslice()
        : _M_index(new gslice::_Indexer ()) 
    {
    }
    inline gslice::gslice(size_t __o, const valarray< size_t > & __l, const valarray< size_t > & __s)
        : _M_index(new gslice::_Indexer (__o, __l, __s)) 
    {
    }
    inline gslice::gslice(const gslice & __g)
        : _M_index(__g._M_index) 
    {
        if (_M_index)
            _M_index->_M_increment_use();
    }
    inline gslice::~gslice()
    {
        if (_M_index && _M_index->_M_decrement_use() == 0)
            delete _M_index;
    }
    inline gslice & gslice::operator =(const gslice & __g)
    {
        if (__g._M_index)
            __g._M_index->_M_increment_use();
        if (_M_index && _M_index->_M_decrement_use() == 0)
            delete _M_index;
        _M_index = __g._M_index;
        return *this;
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Tp >
    class gslice_array
    {
        public :
            typedef _Tp value_type;
            gslice_array(const gslice_array &);
            gslice_array & operator =(const gslice_array &);
            void operator =(const valarray< _Tp > &) const;
            void operator *=(const valarray< _Tp > &) const;
            void operator /=(const valarray< _Tp > &) const;
            void operator %=(const valarray< _Tp > &) const;
            void operator +=(const valarray< _Tp > &) const;
            void operator -=(const valarray< _Tp > &) const;
            void operator ^=(const valarray< _Tp > &) const;
            void operator &=(const valarray< _Tp > &) const;
            void operator |=(const valarray< _Tp > &) const;
            void operator <<=(const valarray< _Tp > &) const;
            void operator >>=(const valarray< _Tp > &) const;
            void operator =(const _Tp &) const;
            template<class _Dom >
            void operator =(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator *=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator /=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator %=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator +=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator -=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator ^=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator &=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator |=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator <<=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator >>=(const _Expr< _Dom, _Tp > &) const;
        private :
            _Array< _Tp > _M_array;
            const valarray< size_t > & _M_index;
            friend class valarray< _Tp >;
            gslice_array(_Array< _Tp >, const valarray< size_t > &);
            gslice_array();
    };
    template<typename _Tp >
    inline gslice_array< _Tp >::gslice_array(_Array< _Tp > __a, const valarray< size_t > & __i)
        : _M_array(__a), _M_index(__i) 
    {
    }
    template<typename _Tp >
    inline gslice_array< _Tp >::gslice_array(const gslice_array< _Tp > & __a)
        : _M_array(__a._M_array), _M_index(__a._M_index) 
    {
    }
    template<typename _Tp >
    inline gslice_array< _Tp > & gslice_array< _Tp >::operator =(const gslice_array< _Tp > & __a)
    {
        std::__valarray_copy(_Array< _Tp >(__a._M_array), _Array< size_t >(__a._M_index), _M_index.size(), _M_array, _Array< size_t >(_M_index));
        return *this;
    }
    template<typename _Tp >
    inline void gslice_array< _Tp >::operator =(const _Tp & __t) const
    {
        std::__valarray_fill(_M_array, _Array< size_t >(_M_index), _M_index.size(), __t);
    }
    template<typename _Tp >
    inline void gslice_array< _Tp >::operator =(const valarray< _Tp > & __v) const
    {
        std::__valarray_copy(_Array< _Tp >(__v), __v.size(), _M_array, _Array< size_t >(_M_index));
    }
    template<typename _Tp >
    template<class _Dom >
    inline void gslice_array< _Tp >::operator =(const _Expr< _Dom, _Tp > & __e) const
    {
        std::__valarray_copy(__e, _M_index.size(), _M_array, _Array< size_t >(_M_index));
    }
    template<typename _Tp >
    inline void gslice_array< _Tp >::operator *=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___multiplies(_M_array, _Array< size_t >(_M_index), _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void gslice_array< _Tp >::operator *=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___multiplies(_M_array, _Array< size_t >(_M_index), __e, _M_index.size());
    }
    template<typename _Tp >
    inline void gslice_array< _Tp >::operator /=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___divides(_M_array, _Array< size_t >(_M_index), _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void gslice_array< _Tp >::operator /=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___divides(_M_array, _Array< size_t >(_M_index), __e, _M_index.size());
    }
    template<typename _Tp >
    inline void gslice_array< _Tp >::operator %=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___modulus(_M_array, _Array< size_t >(_M_index), _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void gslice_array< _Tp >::operator %=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___modulus(_M_array, _Array< size_t >(_M_index), __e, _M_index.size());
    }
    template<typename _Tp >
    inline void gslice_array< _Tp >::operator +=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___plus(_M_array, _Array< size_t >(_M_index), _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void gslice_array< _Tp >::operator +=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___plus(_M_array, _Array< size_t >(_M_index), __e, _M_index.size());
    }
    template<typename _Tp >
    inline void gslice_array< _Tp >::operator -=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___minus(_M_array, _Array< size_t >(_M_index), _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void gslice_array< _Tp >::operator -=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___minus(_M_array, _Array< size_t >(_M_index), __e, _M_index.size());
    }
    template<typename _Tp >
    inline void gslice_array< _Tp >::operator ^=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___bitwise_xor(_M_array, _Array< size_t >(_M_index), _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void gslice_array< _Tp >::operator ^=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___bitwise_xor(_M_array, _Array< size_t >(_M_index), __e, _M_index.size());
    }
    template<typename _Tp >
    inline void gslice_array< _Tp >::operator &=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___bitwise_and(_M_array, _Array< size_t >(_M_index), _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void gslice_array< _Tp >::operator &=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___bitwise_and(_M_array, _Array< size_t >(_M_index), __e, _M_index.size());
    }
    template<typename _Tp >
    inline void gslice_array< _Tp >::operator |=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___bitwise_or(_M_array, _Array< size_t >(_M_index), _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void gslice_array< _Tp >::operator |=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___bitwise_or(_M_array, _Array< size_t >(_M_index), __e, _M_index.size());
    }
    template<typename _Tp >
    inline void gslice_array< _Tp >::operator <<=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___shift_left(_M_array, _Array< size_t >(_M_index), _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void gslice_array< _Tp >::operator <<=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___shift_left(_M_array, _Array< size_t >(_M_index), __e, _M_index.size());
    }
    template<typename _Tp >
    inline void gslice_array< _Tp >::operator >>=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___shift_right(_M_array, _Array< size_t >(_M_index), _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void gslice_array< _Tp >::operator >>=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___shift_right(_M_array, _Array< size_t >(_M_index), __e, _M_index.size());
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<class _Tp >
    class mask_array
    {
        public :
            typedef _Tp value_type;
            mask_array(const mask_array &);
            mask_array & operator =(const mask_array &);
            void operator =(const valarray< _Tp > &) const;
            void operator *=(const valarray< _Tp > &) const;
            void operator /=(const valarray< _Tp > &) const;
            void operator %=(const valarray< _Tp > &) const;
            void operator +=(const valarray< _Tp > &) const;
            void operator -=(const valarray< _Tp > &) const;
            void operator ^=(const valarray< _Tp > &) const;
            void operator &=(const valarray< _Tp > &) const;
            void operator |=(const valarray< _Tp > &) const;
            void operator <<=(const valarray< _Tp > &) const;
            void operator >>=(const valarray< _Tp > &) const;
            void operator =(const _Tp &) const;
            template<class _Dom >
            void operator =(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator *=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator /=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator %=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator +=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator -=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator ^=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator &=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator |=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator <<=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator >>=(const _Expr< _Dom, _Tp > &) const;
        private :
            mask_array(_Array< _Tp >, size_t, _Array< bool >);
            friend class valarray< _Tp >;
            const size_t _M_sz;
            const _Array< bool > _M_mask;
            const _Array< _Tp > _M_array;
            mask_array();
    };
    template<typename _Tp >
    inline mask_array< _Tp >::mask_array(const mask_array< _Tp > & a)
        : _M_sz(a._M_sz), _M_mask(a._M_mask), _M_array(a._M_array) 
    {
    }
    template<typename _Tp >
    inline mask_array< _Tp >::mask_array(_Array< _Tp > __a, size_t __s, _Array< bool > __m)
        : _M_sz(__s), _M_mask(__m), _M_array(__a) 
    {
    }
    template<typename _Tp >
    inline mask_array< _Tp > & mask_array< _Tp >::operator =(const mask_array< _Tp > & __a)
    {
        std::__valarray_copy(__a._M_array, __a._M_mask, _M_sz, _M_array, _M_mask);
        return *this;
    }
    template<typename _Tp >
    inline void mask_array< _Tp >::operator =(const _Tp & __t) const
    {
        std::__valarray_fill(_M_array, _M_sz, _M_mask, __t);
    }
    template<typename _Tp >
    inline void mask_array< _Tp >::operator =(const valarray< _Tp > & __v) const
    {
        std::__valarray_copy(_Array< _Tp >(__v), __v.size(), _M_array, _M_mask);
    }
    template<typename _Tp >
    template<class _Ex >
    inline void mask_array< _Tp >::operator =(const _Expr< _Ex, _Tp > & __e) const
    {
        std::__valarray_copy(__e, __e.size(), _M_array, _M_mask);
    }
    template<typename _Tp >
    inline void mask_array< _Tp >::operator *=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___multiplies(_M_array, _M_mask, _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void mask_array< _Tp >::operator *=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___multiplies(_M_array, _M_mask, __e, __e.size());
    }
    template<typename _Tp >
    inline void mask_array< _Tp >::operator /=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___divides(_M_array, _M_mask, _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void mask_array< _Tp >::operator /=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___divides(_M_array, _M_mask, __e, __e.size());
    }
    template<typename _Tp >
    inline void mask_array< _Tp >::operator %=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___modulus(_M_array, _M_mask, _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void mask_array< _Tp >::operator %=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___modulus(_M_array, _M_mask, __e, __e.size());
    }
    template<typename _Tp >
    inline void mask_array< _Tp >::operator +=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___plus(_M_array, _M_mask, _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void mask_array< _Tp >::operator +=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___plus(_M_array, _M_mask, __e, __e.size());
    }
    template<typename _Tp >
    inline void mask_array< _Tp >::operator -=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___minus(_M_array, _M_mask, _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void mask_array< _Tp >::operator -=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___minus(_M_array, _M_mask, __e, __e.size());
    }
    template<typename _Tp >
    inline void mask_array< _Tp >::operator ^=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___bitwise_xor(_M_array, _M_mask, _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void mask_array< _Tp >::operator ^=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___bitwise_xor(_M_array, _M_mask, __e, __e.size());
    }
    template<typename _Tp >
    inline void mask_array< _Tp >::operator &=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___bitwise_and(_M_array, _M_mask, _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void mask_array< _Tp >::operator &=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___bitwise_and(_M_array, _M_mask, __e, __e.size());
    }
    template<typename _Tp >
    inline void mask_array< _Tp >::operator |=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___bitwise_or(_M_array, _M_mask, _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void mask_array< _Tp >::operator |=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___bitwise_or(_M_array, _M_mask, __e, __e.size());
    }
    template<typename _Tp >
    inline void mask_array< _Tp >::operator <<=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___shift_left(_M_array, _M_mask, _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void mask_array< _Tp >::operator <<=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___shift_left(_M_array, _M_mask, __e, __e.size());
    }
    template<typename _Tp >
    inline void mask_array< _Tp >::operator >>=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___shift_right(_M_array, _M_mask, _Array< _Tp >(__v), __v.size());
    }
    template<typename _Tp >
    template<class _Dom >
    inline void mask_array< _Tp >::operator >>=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___shift_right(_M_array, _M_mask, __e, __e.size());
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<class _Tp >
    class indirect_array
    {
        public :
            typedef _Tp value_type;
            indirect_array(const indirect_array &);
            indirect_array & operator =(const indirect_array &);
            void operator =(const valarray< _Tp > &) const;
            void operator *=(const valarray< _Tp > &) const;
            void operator /=(const valarray< _Tp > &) const;
            void operator %=(const valarray< _Tp > &) const;
            void operator +=(const valarray< _Tp > &) const;
            void operator -=(const valarray< _Tp > &) const;
            void operator ^=(const valarray< _Tp > &) const;
            void operator &=(const valarray< _Tp > &) const;
            void operator |=(const valarray< _Tp > &) const;
            void operator <<=(const valarray< _Tp > &) const;
            void operator >>=(const valarray< _Tp > &) const;
            void operator =(const _Tp &) const;
            template<class _Dom >
            void operator =(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator *=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator /=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator %=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator +=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator -=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator ^=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator &=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator |=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator <<=(const _Expr< _Dom, _Tp > &) const;
            template<class _Dom >
            void operator >>=(const _Expr< _Dom, _Tp > &) const;
        private :
            indirect_array(_Array< _Tp >, size_t, _Array< size_t >);
            friend class valarray< _Tp >;
            friend class gslice_array< _Tp >;
            const size_t _M_sz;
            const _Array< size_t > _M_index;
            const _Array< _Tp > _M_array;
            indirect_array();
    };
    template<typename _Tp >
    inline indirect_array< _Tp >::indirect_array(const indirect_array< _Tp > & __a)
        : _M_sz(__a._M_sz), _M_index(__a._M_index), _M_array(__a._M_array) 
    {
    }
    template<typename _Tp >
    inline indirect_array< _Tp >::indirect_array(_Array< _Tp > __a, size_t __s, _Array< size_t > __i)
        : _M_sz(__s), _M_index(__i), _M_array(__a) 
    {
    }
    template<typename _Tp >
    inline indirect_array< _Tp > & indirect_array< _Tp >::operator =(const indirect_array< _Tp > & __a)
    {
        std::__valarray_copy(__a._M_array, _M_sz, __a._M_index, _M_array, _M_index);
        return *this;
    }
    template<typename _Tp >
    inline void indirect_array< _Tp >::operator =(const _Tp & __t) const
    {
        std::__valarray_fill(_M_array, _M_index, _M_sz, __t);
    }
    template<typename _Tp >
    inline void indirect_array< _Tp >::operator =(const valarray< _Tp > & __v) const
    {
        std::__valarray_copy(_Array< _Tp >(__v), _M_sz, _M_array, _M_index);
    }
    template<typename _Tp >
    template<class _Dom >
    inline void indirect_array< _Tp >::operator =(const _Expr< _Dom, _Tp > & __e) const
    {
        std::__valarray_copy(__e, _M_sz, _M_array, _M_index);
    }
    template<typename _Tp >
    inline void indirect_array< _Tp >::operator *=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___multiplies(_M_array, _M_index, _Array< _Tp >(__v), _M_sz);
    }
    template<typename _Tp >
    template<class _Dom >
    inline void indirect_array< _Tp >::operator *=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___multiplies(_M_array, _M_index, __e, _M_sz);
    }
    template<typename _Tp >
    inline void indirect_array< _Tp >::operator /=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___divides(_M_array, _M_index, _Array< _Tp >(__v), _M_sz);
    }
    template<typename _Tp >
    template<class _Dom >
    inline void indirect_array< _Tp >::operator /=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___divides(_M_array, _M_index, __e, _M_sz);
    }
    template<typename _Tp >
    inline void indirect_array< _Tp >::operator %=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___modulus(_M_array, _M_index, _Array< _Tp >(__v), _M_sz);
    }
    template<typename _Tp >
    template<class _Dom >
    inline void indirect_array< _Tp >::operator %=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___modulus(_M_array, _M_index, __e, _M_sz);
    }
    template<typename _Tp >
    inline void indirect_array< _Tp >::operator +=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___plus(_M_array, _M_index, _Array< _Tp >(__v), _M_sz);
    }
    template<typename _Tp >
    template<class _Dom >
    inline void indirect_array< _Tp >::operator +=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___plus(_M_array, _M_index, __e, _M_sz);
    }
    template<typename _Tp >
    inline void indirect_array< _Tp >::operator -=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___minus(_M_array, _M_index, _Array< _Tp >(__v), _M_sz);
    }
    template<typename _Tp >
    template<class _Dom >
    inline void indirect_array< _Tp >::operator -=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___minus(_M_array, _M_index, __e, _M_sz);
    }
    template<typename _Tp >
    inline void indirect_array< _Tp >::operator ^=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___bitwise_xor(_M_array, _M_index, _Array< _Tp >(__v), _M_sz);
    }
    template<typename _Tp >
    template<class _Dom >
    inline void indirect_array< _Tp >::operator ^=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___bitwise_xor(_M_array, _M_index, __e, _M_sz);
    }
    template<typename _Tp >
    inline void indirect_array< _Tp >::operator &=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___bitwise_and(_M_array, _M_index, _Array< _Tp >(__v), _M_sz);
    }
    template<typename _Tp >
    template<class _Dom >
    inline void indirect_array< _Tp >::operator &=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___bitwise_and(_M_array, _M_index, __e, _M_sz);
    }
    template<typename _Tp >
    inline void indirect_array< _Tp >::operator |=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___bitwise_or(_M_array, _M_index, _Array< _Tp >(__v), _M_sz);
    }
    template<typename _Tp >
    template<class _Dom >
    inline void indirect_array< _Tp >::operator |=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___bitwise_or(_M_array, _M_index, __e, _M_sz);
    }
    template<typename _Tp >
    inline void indirect_array< _Tp >::operator <<=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___shift_left(_M_array, _M_index, _Array< _Tp >(__v), _M_sz);
    }
    template<typename _Tp >
    template<class _Dom >
    inline void indirect_array< _Tp >::operator <<=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___shift_left(_M_array, _M_index, __e, _M_sz);
    }
    template<typename _Tp >
    inline void indirect_array< _Tp >::operator >>=(const valarray< _Tp > & __v) const
    {
        _Array_augmented___shift_right(_M_array, _M_index, _Array< _Tp >(__v), _M_sz);
    }
    template<typename _Tp >
    template<class _Dom >
    inline void indirect_array< _Tp >::operator >>=(const _Expr< _Dom, _Tp > & __e) const
    {
        _Array_augmented___shift_right(_M_array, _M_index, __e, _M_sz);
    }
}
namespace std __attribute__((__visibility__("default"))) {
    template<typename _Tp >
    inline valarray< _Tp >::valarray()
        : _M_size(0), _M_data(0) 
    {
    }
    template<typename _Tp >
    inline valarray< _Tp >::valarray(size_t __n)
        : _M_size(__n), _M_data(__valarray_get_storage< _Tp >(__n)) 
    {
        std::__valarray_default_construct(_M_data, _M_data + __n);
    }
    template<typename _Tp >
    inline valarray< _Tp >::valarray(const _Tp & __t, size_t __n)
        : _M_size(__n), _M_data(__valarray_get_storage< _Tp >(__n)) 
    {
        std::__valarray_fill_construct(_M_data, _M_data + __n, __t);
    }
    template<typename _Tp >
    inline valarray< _Tp >::valarray(const _Tp *__restrict__ __p, size_t __n)
        : _M_size(__n), _M_data(__valarray_get_storage< _Tp >(__n)) 
    {
        ;
        std::__valarray_copy_construct(__p, __p + __n, _M_data);
    }
    template<typename _Tp >
    inline valarray< _Tp >::valarray(const valarray< _Tp > & __v)
        : _M_size(__v._M_size), _M_data(__valarray_get_storage< _Tp >(__v._M_size)) 
    {
        std::__valarray_copy_construct(__v._M_data, __v._M_data + _M_size, _M_data);
    }
    template<typename _Tp >
    inline valarray< _Tp >::valarray(const slice_array< _Tp > & __sa)
        : _M_size(__sa._M_sz), _M_data(__valarray_get_storage< _Tp >(__sa._M_sz)) 
    {
        std::__valarray_copy_construct(__sa._M_array, __sa._M_sz, __sa._M_stride, _Array< _Tp >(_M_data));
    }
    template<typename _Tp >
    inline valarray< _Tp >::valarray(const gslice_array< _Tp > & __ga)
        : _M_size(__ga._M_index.size()), _M_data(__valarray_get_storage< _Tp >(_M_size)) 
    {
        std::__valarray_copy_construct(__ga._M_array, _Array< size_t >(__ga._M_index), _Array< _Tp >(_M_data), _M_size);
    }
    template<typename _Tp >
    inline valarray< _Tp >::valarray(const mask_array< _Tp > & __ma)
        : _M_size(__ma._M_sz), _M_data(__valarray_get_storage< _Tp >(__ma._M_sz)) 
    {
        std::__valarray_copy_construct(__ma._M_array, __ma._M_mask, _Array< _Tp >(_M_data), _M_size);
    }
    template<typename _Tp >
    inline valarray< _Tp >::valarray(const indirect_array< _Tp > & __ia)
        : _M_size(__ia._M_sz), _M_data(__valarray_get_storage< _Tp >(__ia._M_sz)) 
    {
        std::__valarray_copy_construct(__ia._M_array, __ia._M_index, _Array< _Tp >(_M_data), _M_size);
    }
    template<typename _Tp >
    template<class _Dom >
    inline valarray< _Tp >::valarray(const _Expr< _Dom, _Tp > & __e)
        : _M_size(__e.size()), _M_data(__valarray_get_storage< _Tp >(_M_size)) 
    {
        std::__valarray_copy_construct(__e, _M_size, _Array< _Tp >(_M_data));
    }
    template<typename _Tp >
    inline valarray< _Tp >::~valarray()
    {
        std::__valarray_destroy_elements(_M_data, _M_data + _M_size);
        std::__valarray_release_memory(_M_data);
    }
    template<typename _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator =(const valarray< _Tp > & __v)
    {
        ;
        std::__valarray_copy(__v._M_data, _M_size, _M_data);
        return *this;
    }
    template<typename _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator =(const _Tp & __t)
    {
        std::__valarray_fill(_M_data, _M_size, __t);
        return *this;
    }
    template<typename _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator =(const slice_array< _Tp > & __sa)
    {
        ;
        std::__valarray_copy(__sa._M_array, __sa._M_sz, __sa._M_stride, _Array< _Tp >(_M_data));
        return *this;
    }
    template<typename _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator =(const gslice_array< _Tp > & __ga)
    {
        ;
        std::__valarray_copy(__ga._M_array, _Array< size_t >(__ga._M_index), _Array< _Tp >(_M_data), _M_size);
        return *this;
    }
    template<typename _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator =(const mask_array< _Tp > & __ma)
    {
        ;
        std::__valarray_copy(__ma._M_array, __ma._M_mask, _Array< _Tp >(_M_data), _M_size);
        return *this;
    }
    template<typename _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator =(const indirect_array< _Tp > & __ia)
    {
        ;
        std::__valarray_copy(__ia._M_array, __ia._M_index, _Array< _Tp >(_M_data), _M_size);
        return *this;
    }
    template<typename _Tp >
    template<class _Dom >
    inline valarray< _Tp > & valarray< _Tp >::operator =(const _Expr< _Dom, _Tp > & __e)
    {
        ;
        std::__valarray_copy(__e, _M_size, _Array< _Tp >(_M_data));
        return *this;
    }
    template<typename _Tp >
    inline _Expr< _SClos< _ValArray, _Tp >, _Tp > valarray< _Tp >::operator [](slice __s) const
    {
        typedef _SClos< _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(_Array< _Tp >(_M_data), __s));
    }
    template<typename _Tp >
    inline slice_array< _Tp > valarray< _Tp >::operator [](slice __s)
    {
        return slice_array< _Tp >(_Array< _Tp >(_M_data), __s);
    }
    template<typename _Tp >
    inline _Expr< _GClos< _ValArray, _Tp >, _Tp > valarray< _Tp >::operator [](const gslice & __gs) const
    {
        typedef _GClos< _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(_Array< _Tp >(_M_data), __gs._M_index->_M_index));
    }
    template<typename _Tp >
    inline gslice_array< _Tp > valarray< _Tp >::operator [](const gslice & __gs)
    {
        return gslice_array< _Tp >(_Array< _Tp >(_M_data), __gs._M_index->_M_index);
    }
    template<typename _Tp >
    inline valarray< _Tp > valarray< _Tp >::operator [](const valarray< bool > & __m) const
    {
        size_t __s = 0;
        size_t __e = __m.size();
        for (size_t __i = 0;
            __i < __e;
            ++__i)
        if (__m[__i])
            ++__s;
        return valarray< _Tp >(mask_array< _Tp >(_Array< _Tp >(_M_data), __s, _Array< bool >(__m)));
    }
    template<typename _Tp >
    inline mask_array< _Tp > valarray< _Tp >::operator [](const valarray< bool > & __m)
    {
        size_t __s = 0;
        size_t __e = __m.size();
        for (size_t __i = 0;
            __i < __e;
            ++__i)
        if (__m[__i])
            ++__s;
        return mask_array< _Tp >(_Array< _Tp >(_M_data), __s, _Array< bool >(__m));
    }
    template<typename _Tp >
    inline _Expr< _IClos< _ValArray, _Tp >, _Tp > valarray< _Tp >::operator [](const valarray< size_t > & __i) const
    {
        typedef _IClos< _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(*this, __i));
    }
    template<typename _Tp >
    inline indirect_array< _Tp > valarray< _Tp >::operator [](const valarray< size_t > & __i)
    {
        return indirect_array< _Tp >(_Array< _Tp >(_M_data), __i.size(), _Array< size_t >(__i));
    }
    template<class _Tp >
    inline size_t valarray< _Tp >::size() const
    {
        return _M_size;
    }
    template<class _Tp >
    inline _Tp valarray< _Tp >::sum() const
    {
        ;
        return std::__valarray_sum(_M_data, _M_data + _M_size);
    }
    template<class _Tp >
    inline valarray< _Tp > valarray< _Tp >::shift(int __n) const
    {
        valarray< _Tp > __ret;
        if (_M_size == 0)
            return __ret;
        _Tp *__restrict__ __tmp_M_data = std::__valarray_get_storage< _Tp >(_M_size);
        if (__n == 0)
            std::__valarray_copy_construct(_M_data, _M_data + _M_size, __tmp_M_data);
        else
            if (__n > 0)
            {
                if (size_t(__n) > _M_size)
                    __n = int(_M_size);
                std::__valarray_copy_construct(_M_data + __n, _M_data + _M_size, __tmp_M_data);
                std::__valarray_default_construct(__tmp_M_data + _M_size - __n, __tmp_M_data + _M_size);
            }
            else
            {
                if (-size_t(__n) > _M_size)
                    __n = -int(_M_size);
                std::__valarray_copy_construct(_M_data, _M_data + _M_size + __n, __tmp_M_data - __n);
                std::__valarray_default_construct(__tmp_M_data, __tmp_M_data - __n);
            }
        __ret._M_size = _M_size;
        __ret._M_data = __tmp_M_data;
        return __ret;
    }
    template<class _Tp >
    inline valarray< _Tp > valarray< _Tp >::cshift(int __n) const
    {
        valarray< _Tp > __ret;
        if (_M_size == 0)
            return __ret;
        _Tp *__restrict__ __tmp_M_data = std::__valarray_get_storage< _Tp >(_M_size);
        if (__n == 0)
            std::__valarray_copy_construct(_M_data, _M_data + _M_size, __tmp_M_data);
        else
            if (__n > 0)
            {
                if (size_t(__n) > _M_size)
                    __n = int(__n % _M_size);
                std::__valarray_copy_construct(_M_data, _M_data + __n, __tmp_M_data + _M_size - __n);
                std::__valarray_copy_construct(_M_data + __n, _M_data + _M_size, __tmp_M_data);
            }
            else
            {
                if (-size_t(__n) > _M_size)
                    __n = -int(-size_t(__n) % _M_size);
                std::__valarray_copy_construct(_M_data + _M_size + __n, _M_data + _M_size, __tmp_M_data);
                std::__valarray_copy_construct(_M_data, _M_data + _M_size + __n, __tmp_M_data - __n);
            }
        __ret._M_size = _M_size;
        __ret._M_data = __tmp_M_data;
        return __ret;
    }
    template<class _Tp >
    inline void valarray< _Tp >::resize(size_t __n, _Tp __c)
    {
        std::__valarray_destroy_elements(_M_data, _M_data + _M_size);
        if (_M_size != __n)
        {
            std::__valarray_release_memory(_M_data);
            _M_size = __n;
            _M_data = __valarray_get_storage< _Tp >(__n);
        }
        std::__valarray_fill_construct(_M_data, _M_data + __n, __c);
    }
    template<typename _Tp >
    inline _Tp valarray< _Tp >::min() const
    {
        ;
        return *std::min_element(_M_data, _M_data + _M_size);
    }
    template<typename _Tp >
    inline _Tp valarray< _Tp >::max() const
    {
        ;
        return *std::max_element(_M_data, _M_data + _M_size);
    }
    template<class _Tp >
    inline _Expr< _ValFunClos< _ValArray, _Tp >, _Tp > valarray< _Tp >::apply(_Tp func(_Tp)) const
    {
        typedef _ValFunClos< _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(*this, func));
    }
    template<class _Tp >
    inline _Expr< _RefFunClos< _ValArray, _Tp >, _Tp > valarray< _Tp >::apply(_Tp func(const _Tp &)) const
    {
        typedef _RefFunClos< _ValArray, _Tp > _Closure;
        return _Expr< _Closure, _Tp >(_Closure(*this, func));
    }
    template<typename _Tp >
    inline typename valarray< _Tp >::template _UnaryOp< __unary_plus >::_Rt valarray< _Tp >::operator +() const
    {
        typedef _UnClos< __unary_plus, _ValArray, _Tp > _Closure;
        typedef typename __fun< __unary_plus, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(*this));
    }
    template<typename _Tp >
    inline typename valarray< _Tp >::template _UnaryOp< __negate >::_Rt valarray< _Tp >::operator -() const
    {
        typedef _UnClos< __negate, _ValArray, _Tp > _Closure;
        typedef typename __fun< __negate, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(*this));
    }
    template<typename _Tp >
    inline typename valarray< _Tp >::template _UnaryOp< __bitwise_not >::_Rt valarray< _Tp >::operator ~() const
    {
        typedef _UnClos< __bitwise_not, _ValArray, _Tp > _Closure;
        typedef typename __fun< __bitwise_not, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(*this));
    }
    template<typename _Tp >
    inline typename valarray< _Tp >::template _UnaryOp< __logical_not >::_Rt valarray< _Tp >::operator !() const
    {
        typedef _UnClos< __logical_not, _ValArray, _Tp > _Closure;
        typedef typename __fun< __logical_not, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(*this));
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator +=(const _Tp & __t)
    {
        _Array_augmented___plus(_Array< _Tp >(_M_data), _M_size, __t);
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator +=(const valarray< _Tp > & __v)
    {
        ;
        _Array_augmented___plus(_Array< _Tp >(_M_data), _M_size, _Array< _Tp >(__v._M_data));
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator -=(const _Tp & __t)
    {
        _Array_augmented___minus(_Array< _Tp >(_M_data), _M_size, __t);
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator -=(const valarray< _Tp > & __v)
    {
        ;
        _Array_augmented___minus(_Array< _Tp >(_M_data), _M_size, _Array< _Tp >(__v._M_data));
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator *=(const _Tp & __t)
    {
        _Array_augmented___multiplies(_Array< _Tp >(_M_data), _M_size, __t);
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator *=(const valarray< _Tp > & __v)
    {
        ;
        _Array_augmented___multiplies(_Array< _Tp >(_M_data), _M_size, _Array< _Tp >(__v._M_data));
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator /=(const _Tp & __t)
    {
        _Array_augmented___divides(_Array< _Tp >(_M_data), _M_size, __t);
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator /=(const valarray< _Tp > & __v)
    {
        ;
        _Array_augmented___divides(_Array< _Tp >(_M_data), _M_size, _Array< _Tp >(__v._M_data));
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator %=(const _Tp & __t)
    {
        _Array_augmented___modulus(_Array< _Tp >(_M_data), _M_size, __t);
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator %=(const valarray< _Tp > & __v)
    {
        ;
        _Array_augmented___modulus(_Array< _Tp >(_M_data), _M_size, _Array< _Tp >(__v._M_data));
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator ^=(const _Tp & __t)
    {
        _Array_augmented___bitwise_xor(_Array< _Tp >(_M_data), _M_size, __t);
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator ^=(const valarray< _Tp > & __v)
    {
        ;
        _Array_augmented___bitwise_xor(_Array< _Tp >(_M_data), _M_size, _Array< _Tp >(__v._M_data));
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator &=(const _Tp & __t)
    {
        _Array_augmented___bitwise_and(_Array< _Tp >(_M_data), _M_size, __t);
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator &=(const valarray< _Tp > & __v)
    {
        ;
        _Array_augmented___bitwise_and(_Array< _Tp >(_M_data), _M_size, _Array< _Tp >(__v._M_data));
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator |=(const _Tp & __t)
    {
        _Array_augmented___bitwise_or(_Array< _Tp >(_M_data), _M_size, __t);
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator |=(const valarray< _Tp > & __v)
    {
        ;
        _Array_augmented___bitwise_or(_Array< _Tp >(_M_data), _M_size, _Array< _Tp >(__v._M_data));
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator <<=(const _Tp & __t)
    {
        _Array_augmented___shift_left(_Array< _Tp >(_M_data), _M_size, __t);
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator <<=(const valarray< _Tp > & __v)
    {
        ;
        _Array_augmented___shift_left(_Array< _Tp >(_M_data), _M_size, _Array< _Tp >(__v._M_data));
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator >>=(const _Tp & __t)
    {
        _Array_augmented___shift_right(_Array< _Tp >(_M_data), _M_size, __t);
        return *this;
    }
    template<class _Tp >
    inline valarray< _Tp > & valarray< _Tp >::operator >>=(const valarray< _Tp > & __v)
    {
        ;
        _Array_augmented___shift_right(_Array< _Tp >(_M_data), _M_size, _Array< _Tp >(__v._M_data));
        return *this;
    }
    template<class _Tp >
    template<class _Dom >
    inline valarray< _Tp > & valarray< _Tp >::operator +=(const _Expr< _Dom, _Tp > & __e)
    {
        _Array_augmented___plus(_Array< _Tp >(_M_data), __e, _M_size);
        return *this;
    }
    template<class _Tp >
    template<class _Dom >
    inline valarray< _Tp > & valarray< _Tp >::operator -=(const _Expr< _Dom, _Tp > & __e)
    {
        _Array_augmented___minus(_Array< _Tp >(_M_data), __e, _M_size);
        return *this;
    }
    template<class _Tp >
    template<class _Dom >
    inline valarray< _Tp > & valarray< _Tp >::operator *=(const _Expr< _Dom, _Tp > & __e)
    {
        _Array_augmented___multiplies(_Array< _Tp >(_M_data), __e, _M_size);
        return *this;
    }
    template<class _Tp >
    template<class _Dom >
    inline valarray< _Tp > & valarray< _Tp >::operator /=(const _Expr< _Dom, _Tp > & __e)
    {
        _Array_augmented___divides(_Array< _Tp >(_M_data), __e, _M_size);
        return *this;
    }
    template<class _Tp >
    template<class _Dom >
    inline valarray< _Tp > & valarray< _Tp >::operator %=(const _Expr< _Dom, _Tp > & __e)
    {
        _Array_augmented___modulus(_Array< _Tp >(_M_data), __e, _M_size);
        return *this;
    }
    template<class _Tp >
    template<class _Dom >
    inline valarray< _Tp > & valarray< _Tp >::operator ^=(const _Expr< _Dom, _Tp > & __e)
    {
        _Array_augmented___bitwise_xor(_Array< _Tp >(_M_data), __e, _M_size);
        return *this;
    }
    template<class _Tp >
    template<class _Dom >
    inline valarray< _Tp > & valarray< _Tp >::operator &=(const _Expr< _Dom, _Tp > & __e)
    {
        _Array_augmented___bitwise_and(_Array< _Tp >(_M_data), __e, _M_size);
        return *this;
    }
    template<class _Tp >
    template<class _Dom >
    inline valarray< _Tp > & valarray< _Tp >::operator |=(const _Expr< _Dom, _Tp > & __e)
    {
        _Array_augmented___bitwise_or(_Array< _Tp >(_M_data), __e, _M_size);
        return *this;
    }
    template<class _Tp >
    template<class _Dom >
    inline valarray< _Tp > & valarray< _Tp >::operator <<=(const _Expr< _Dom, _Tp > & __e)
    {
        _Array_augmented___shift_left(_Array< _Tp >(_M_data), __e, _M_size);
        return *this;
    }
    template<class _Tp >
    template<class _Dom >
    inline valarray< _Tp > & valarray< _Tp >::operator >>=(const _Expr< _Dom, _Tp > & __e)
    {
        _Array_augmented___shift_right(_Array< _Tp >(_M_data), __e, _M_size);
        return *this;
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __plus, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __plus, _Tp >::result_type > operator +(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __plus, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __plus, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __plus, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __plus, _Tp >::result_type > operator +(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __plus, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __plus, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __plus, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __plus, _Tp >::result_type > operator +(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __plus, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __plus, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __minus, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __minus, _Tp >::result_type > operator -(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __minus, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __minus, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __minus, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __minus, _Tp >::result_type > operator -(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __minus, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __minus, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __minus, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __minus, _Tp >::result_type > operator -(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __minus, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __minus, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __multiplies, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __multiplies, _Tp >::result_type > operator *(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __multiplies, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __multiplies, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __multiplies, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __multiplies, _Tp >::result_type > operator *(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __multiplies, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __multiplies, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __multiplies, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __multiplies, _Tp >::result_type > operator *(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __multiplies, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __multiplies, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __divides, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __divides, _Tp >::result_type > operator /(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __divides, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __divides, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __divides, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __divides, _Tp >::result_type > operator /(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __divides, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __divides, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __divides, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __divides, _Tp >::result_type > operator /(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __divides, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __divides, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __modulus, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __modulus, _Tp >::result_type > operator %(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __modulus, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __modulus, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __modulus, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __modulus, _Tp >::result_type > operator %(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __modulus, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __modulus, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __modulus, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __modulus, _Tp >::result_type > operator %(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __modulus, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __modulus, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __bitwise_xor, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __bitwise_xor, _Tp >::result_type > operator ^(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __bitwise_xor, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __bitwise_xor, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __bitwise_xor, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __bitwise_xor, _Tp >::result_type > operator ^(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __bitwise_xor, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __bitwise_xor, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __bitwise_xor, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __bitwise_xor, _Tp >::result_type > operator ^(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __bitwise_xor, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __bitwise_xor, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __bitwise_and, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __bitwise_and, _Tp >::result_type > operator &(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __bitwise_and, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __bitwise_and, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __bitwise_and, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __bitwise_and, _Tp >::result_type > operator &(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __bitwise_and, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __bitwise_and, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __bitwise_and, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __bitwise_and, _Tp >::result_type > operator &(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __bitwise_and, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __bitwise_and, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __bitwise_or, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __bitwise_or, _Tp >::result_type > operator |(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __bitwise_or, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __bitwise_or, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __bitwise_or, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __bitwise_or, _Tp >::result_type > operator |(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __bitwise_or, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __bitwise_or, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __bitwise_or, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __bitwise_or, _Tp >::result_type > operator |(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __bitwise_or, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __bitwise_or, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __shift_left, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __shift_left, _Tp >::result_type > operator <<(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __shift_left, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __shift_left, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __shift_left, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __shift_left, _Tp >::result_type > operator <<(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __shift_left, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __shift_left, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __shift_left, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __shift_left, _Tp >::result_type > operator <<(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __shift_left, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __shift_left, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __shift_right, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __shift_right, _Tp >::result_type > operator >>(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __shift_right, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __shift_right, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __shift_right, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __shift_right, _Tp >::result_type > operator >>(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __shift_right, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __shift_right, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __shift_right, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __shift_right, _Tp >::result_type > operator >>(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __shift_right, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __shift_right, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __logical_and, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __logical_and, _Tp >::result_type > operator &&(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __logical_and, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __logical_and, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __logical_and, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __logical_and, _Tp >::result_type > operator &&(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __logical_and, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __logical_and, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __logical_and, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __logical_and, _Tp >::result_type > operator &&(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __logical_and, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __logical_and, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __logical_or, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __logical_or, _Tp >::result_type > operator ||(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __logical_or, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __logical_or, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __logical_or, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __logical_or, _Tp >::result_type > operator ||(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __logical_or, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __logical_or, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __logical_or, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __logical_or, _Tp >::result_type > operator ||(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __logical_or, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __logical_or, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __equal_to, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __equal_to, _Tp >::result_type > operator ==(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __equal_to, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __equal_to, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __equal_to, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __equal_to, _Tp >::result_type > operator ==(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __equal_to, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __equal_to, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __equal_to, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __equal_to, _Tp >::result_type > operator ==(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __equal_to, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __equal_to, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __not_equal_to, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __not_equal_to, _Tp >::result_type > operator !=(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __not_equal_to, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __not_equal_to, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __not_equal_to, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __not_equal_to, _Tp >::result_type > operator !=(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __not_equal_to, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __not_equal_to, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __not_equal_to, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __not_equal_to, _Tp >::result_type > operator !=(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __not_equal_to, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __not_equal_to, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __less, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __less, _Tp >::result_type > operator <(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __less, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __less, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __less, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __less, _Tp >::result_type > operator <(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __less, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __less, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __less, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __less, _Tp >::result_type > operator <(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __less, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __less, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __greater, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __greater, _Tp >::result_type > operator >(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __greater, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __greater, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __greater, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __greater, _Tp >::result_type > operator >(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __greater, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __greater, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __greater, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __greater, _Tp >::result_type > operator >(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __greater, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __greater, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __less_equal, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __less_equal, _Tp >::result_type > operator <=(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __less_equal, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __less_equal, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __less_equal, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __less_equal, _Tp >::result_type > operator <=(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __less_equal, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __less_equal, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __less_equal, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __less_equal, _Tp >::result_type > operator <=(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __less_equal, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __less_equal, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __greater_equal, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __greater_equal, _Tp >::result_type > operator >=(const valarray< _Tp > & __v, const valarray< _Tp > & __w)
    {
        ;
        typedef _BinClos< __greater_equal, _ValArray, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __greater_equal, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __w));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __greater_equal, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __greater_equal, _Tp >::result_type > operator >=(const valarray< _Tp > & __v, const _Tp & __t)
    {
        typedef _BinClos< __greater_equal, _ValArray, _Constant, _Tp, _Tp > _Closure;
        typedef typename __fun< __greater_equal, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__v, __t));
    }
    template<typename _Tp >
    inline _Expr< _BinClos< __greater_equal, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __greater_equal, _Tp >::result_type > operator >=(const _Tp & __t, const valarray< _Tp > & __v)
    {
        typedef _BinClos< __greater_equal, _Constant, _ValArray, _Tp, _Tp > _Closure;
        typedef typename __fun< __greater_equal, _Tp >::result_type _Rt;
        return _Expr< _Closure, _Rt >(_Closure(__t, __v));
    }
}
namespace Cairo {
    typedef cairo_glyph_t Glyph;
    typedef cairo_font_extents_t FontExtents;
    typedef cairo_text_extents_t TextExtents;
    typedef cairo_matrix_t Matrix;
    typedef cairo_rectangle_t Rectangle;
    class Context
    {
        protected :
            explicit Context(const RefPtr< Surface > & target);
        public :
            explicit Context(cairo_t * cobject, bool has_reference = false);
            static RefPtr< Context > create(const RefPtr< Surface > & target);
            virtual ~Context();
            void save();
            void restore();
            void set_operator(Operator op);
            void set_source(const RefPtr< const Pattern > & source);
            void set_source_rgb(double red, double green, double blue);
            void set_source_rgba(double red, double green, double blue, double alpha);
            void set_source(const RefPtr< Surface > & surface, double x, double y);
            void set_tolerance(double tolerance);
            void set_antialias(Antialias antialias);
            void set_fill_rule(FillRule fill_rule);
            void set_line_width(double width);
            void set_line_cap(LineCap line_cap);
            void set_line_join(LineJoin line_join);
            void set_dash(std::valarray< double > & dashes, double offset);
            void set_dash(std::vector< double > & dashes, double offset);
            void unset_dash();
            void set_miter_limit(double limit);
            void translate(double tx, double ty);
            void scale(double sx, double sy);
            void rotate(double angle_radians);
            void rotate_degrees(double angle_degres);
            void transform(const Matrix & matrix);
            void set_matrix(const Matrix & matrix);
            void set_identity_matrix();
            void user_to_device(double & x, double & y);
            void user_to_device_distance(double & dx, double & dy);
            void device_to_user(double & x, double & y);
            void device_to_user_distance(double & dx, double & dy);
            void begin_new_path();
            void begin_new_sub_path();
            void move_to(double x, double y);
            void line_to(double x, double y);
            void curve_to(double x1, double y1, double x2, double y2, double x3, double y3);
            void arc(double xc, double yc, double radius, double angle1, double angle2);
            void arc_negative(double xc, double yc, double radius, double angle1, double angle2);
            void rel_move_to(double dx, double dy);
            void rel_line_to(double dx, double dy);
            void rel_curve_to(double dx1, double dy1, double dx2, double dy2, double dx3, double dy3);
            void rectangle(double x, double y, double width, double height);
            void close_path();
            void paint();
            void paint_with_alpha(double alpha);
            void mask(const RefPtr< const Pattern > & pattern);
            void mask(const RefPtr< const Surface > & surface, double surface_x, double surface_y);
            void stroke();
            void stroke_preserve();
            void fill();
            void fill_preserve();
            void copy_page();
            void show_page();
            bool in_stroke(double x, double y) const;
            bool in_fill(double x, double y) const;
            void get_stroke_extents(double & x1, double & y1, double & x2, double & y2) const;
            void get_fill_extents(double & x1, double & y1, double & x2, double & y2) const;
            void reset_clip();
            void clip();
            void clip_preserve();
            void get_clip_extents(double & x1, double & y1, double & x2, double & y2) const;
            void copy_clip_rectangle_list(std::vector< Rectangle > & rectangles) const;
            void select_font_face(const std::string & family, FontSlant slant, FontWeight weight);
            void set_font_size(double size);
            void set_font_matrix(const Matrix & matrix);
            void get_font_matrix(Matrix & matrix) const;
            void set_font_options(const FontOptions & options);
            void show_text(const std::string & utf8);
            void show_glyphs(const std::vector< Glyph > & glyphs);
            RefPtr< FontFace > get_font_face();
            RefPtr< const FontFace > get_font_face() const;
            void get_font_extents(FontExtents & extents) const;
            void set_font_face(const RefPtr< const FontFace > & font_face);
            void get_text_extents(const std::string & utf8, TextExtents & extents) const;
            void get_glyph_extents(const std::vector< Glyph > & glyphs, TextExtents & extents) const;
            void text_path(const std::string & utf8);
            void glyph_path(const std::vector< Glyph > & glyphs);
            Operator get_operator() const;
            RefPtr< Pattern > get_source();
            RefPtr< const Pattern > get_source() const;
            double get_tolerance() const;
            Antialias get_antialias() const;
            void get_current_point(double & x, double & y) const;
            bool has_current_point() const;
            FillRule get_fill_rule() const;
            double get_line_width() const;
            LineCap get_line_cap() const;
            LineJoin get_line_join() const;
            double get_miter_limit() const;
            void get_dash(std::vector< double > & dashes, double & offset) const;
            void get_matrix(Matrix & matrix);
            RefPtr< Surface > get_target();
            RefPtr< const Surface > get_target() const;
            Path * copy_path() const;
            void get_path_extents(double & x1, double & y1, double & x2, double & y2) const;
            Path * copy_path_flat() const;
            void append_path(const Path & path);
            void push_group();
            void push_group_with_content(Content content);
            RefPtr< Pattern > pop_group();
            void pop_group_to_source();
            RefPtr< Surface > get_group_target();
            RefPtr< const Surface > get_group_target() const;
            typedef cairo_t cobject;
            inline cobject * cobj()
            {
                return m_cobject;
            }
            inline const cobject * cobj() const
            {
                return m_cobject;
            }
            inline ErrorStatus get_status() const
            {
                return cairo_status(const_cast<cairo_t * >(cobj()));
            }
            void reference() const;
            void unreference() const;
        protected :
            cobject * m_cobject;
    };
}
typedef struct _PangoContext PangoContext;
typedef struct _PangoContextClass PangoContextClass;
namespace Pango {
    class Context_Class;
}
namespace Pango {
    enum Direction
    {
        DIRECTION_LTR, 
        DIRECTION_RTL, 
        DIRECTION_TTB_LTR, 
        DIRECTION_TTB_RTL, 
        DIRECTION_WEAK_LTR, 
        DIRECTION_WEAK_RTL, 
        DIRECTION_NEUTRAL
    };
}
namespace Glib {
    template<>
    class Value< Pango::Direction > : public Glib::Value_Enum< Pango::Direction >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Pango {
    enum GravityHint
    {
        GRAVITY_HINT_NATURAL, 
        GRAVITY_HINT_STRONG, 
        GRAVITY_HINT_LINE
    };
}
namespace Glib {
    template<>
    class Value< Pango::GravityHint > : public Glib::Value_Enum< Pango::GravityHint >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Pango {
    class Context : public Glib::Object
    {
        public :
            typedef Context CppObjectType;
            typedef Context_Class CppClassType;
            typedef PangoContext BaseObjectType;
            typedef PangoContextClass BaseClassType;
        private :
            friend class Context_Class;
            static CppClassType context_class_;
        private :
            Context(const Context &);
            Context & operator =(const Context &);
        protected :
            explicit Context(const Glib::ConstructParams & construct_params);
            explicit Context(PangoContext * castitem);
        public :
            virtual ~Context();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            PangoContext * gobj()
            {
                return reinterpret_cast<PangoContext * >(gobject_);
            }
            const PangoContext * gobj() const
            {
                return reinterpret_cast<PangoContext * >(gobject_);
            }
            PangoContext * gobj_copy();
        private :
        protected :
            Context();
        public :
            Glib::ArrayHandle< Glib::RefPtr< FontFamily > > list_families() const;
            Glib::RefPtr< FontMap > get_font_map();
            Glib::RefPtr< const FontMap > get_font_map() const;
            Glib::RefPtr< Font > load_font(const FontDescription & desc) const;
            Glib::RefPtr< Fontset > load_fontset(const FontDescription & desc, const Language & language) const;
            FontMetrics get_metrics(const FontDescription & desc) const;
            FontMetrics get_metrics(const FontDescription & desc, const Language & language) const;
            void set_font_description(const FontDescription & desc);
            FontDescription get_font_description() const;
            Language get_language() const;
            void set_language(const Language & language);
            void set_base_dir(Direction direction);
            Direction get_base_dir() const;
            void set_base_gravity(Gravity gravity);
            Gravity get_base_gravity() const;
            Gravity get_gravity() const;
            void set_gravity_hint(GravityHint hint);
            GravityHint get_gravity_hint() const;
            void set_matrix(const Matrix & matrix);
            Matrix get_matrix() const;
            ListHandle_Item itemize(const Glib::ustring & text, const AttrList & attrs) const;
            ListHandle_Item itemize(const Glib::ustring & text, int start_index, int length, const AttrList & attrs, AttrIter & cached_iter) const;
            void update_from_cairo_context(const Cairo::RefPtr< Cairo::Context > & context);
            void set_cairo_font_options(const Cairo::FontOptions & options);
            Cairo::FontOptions get_font_options() const;
            void set_resolution(double dpi);
            double get_resolution() const;
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Pango::Context > wrap(PangoContext * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _PangoTabArray PangoTabArray;
}
namespace Pango {
    enum TabAlign
    {
        TAB_LEFT
    };
}
namespace Glib {
    template<>
    class Value< Pango::TabAlign > : public Glib::Value_Enum< Pango::TabAlign >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Pango {
    class TabArray
    {
        public :
            typedef TabArray CppObjectType;
            typedef PangoTabArray BaseObjectType;
            static GType get_type() __attribute__((__const__));
            TabArray();
            explicit TabArray(PangoTabArray * gobject, bool make_a_copy = true);
            TabArray(const TabArray & other);
            TabArray & operator =(const TabArray & other);
            ~TabArray();
            void swap(TabArray & other);
            PangoTabArray * gobj()
            {
                return gobject_;
            }
            const PangoTabArray * gobj() const
            {
                return gobject_;
            }
            PangoTabArray * gobj_copy() const;
        protected :
            PangoTabArray * gobject_;
        private :
        public :
            explicit TabArray(int initial_size, bool positions_in_pixels = true);
            int get_size() const;
            void resize(int new_size);
            void set_tab(int tab_index, TabAlign alignment, int location);
            std::pair< TabAlign, int > get_tab(int tab_index) const;
            Glib::ArrayHandle< std::pair< TabAlign, int > > get_tabs() const;
            bool get_positions_in_pixels() const;
    };
}
namespace Pango {
    inline void swap(TabArray & lhs, TabArray & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    Pango::TabArray wrap(PangoTabArray * object, bool take_copy = false);
    template<>
    class Value< Pango::TabArray > : public Glib::Value_Boxed< Pango::TabArray >
    {
    };
}
namespace Pango {
    class Layout;
    class LayoutLine
    {
        public :
            typedef LayoutLine CppObjectType;
            typedef PangoLayoutLine BaseObjectType;
            void reference() const;
            void unreference() const;
            PangoLayoutLine * gobj();
            const PangoLayoutLine * gobj() const;
            PangoLayoutLine * gobj_copy() const;
        protected :
            LayoutLine();
            void operator delete(void *, size_t);
        private :
            LayoutLine(const LayoutLine &);
            LayoutLine & operator =(const LayoutLine &);
        public :
            bool x_to_index(int x_pos, int & index, int & trailing) const;
            int index_to_x(int index, bool trailing) const;
            Glib::ArrayHandle< std::pair< int, int > > get_x_ranges(int start_index, int end_index) const;
            void get_extents(Rectangle & ink_rect, Rectangle & logical_rect) const;
            Rectangle get_ink_extents() const;
            Rectangle get_logical_extents() const;
            void get_pixel_extents(Rectangle & ink_rect, Rectangle & logical_rect) const;
            Rectangle get_pixel_ink_extents() const;
            Rectangle get_pixel_logical_extents() const;
            void show_in_cairo_context(const Cairo::RefPtr< Cairo::Context > & context);
            void add_to_cairo_context(const Cairo::RefPtr< Cairo::Context > & context);
            Glib::RefPtr< Pango::Layout > get_layout();
            Glib::RefPtr< const Pango::Layout > get_layout() const;
            int get_length() const;
            int get_start_index() const;
    };
}
namespace Glib {
    Glib::RefPtr< Pango::LayoutLine > wrap(PangoLayoutLine * object, bool take_copy);
}
namespace Pango {
    struct LayoutLineTraits
    {
            typedef Glib::RefPtr< LayoutLine > CppType;
            typedef PangoLayoutLine * CType;
            typedef PangoLayoutLine * CTypeNonConst;
            static CType to_c_type(const CppType & ptr)
            {
                return Glib::unwrap(ptr);
            }
            static CType to_c_type(CType ptr)
            {
                return ptr;
            }
            static CppType to_cpp_type(CType ptr)
            {
                return Glib::wrap(ptr, true);
            }
            static void release_c_type(CType ptr)
            {
                pango_layout_line_unref(ptr);
            }
    };
    typedef Glib::SListHandle< Glib::RefPtr< LayoutLine >, LayoutLineTraits > SListHandle_LayoutLine;
    typedef Glib::SListHandle< Glib::RefPtr< const LayoutLine >, LayoutLineTraits > SListHandle_ConstLayoutLine;
}
namespace Glib {
    Glib::RefPtr< Pango::LayoutLine > wrap(PangoLayoutLine * object, bool take_copy = false);
}
namespace Pango {
    class Item;
    class GlyphString;
    class LayoutRun
    {
        public :
            typedef LayoutRun CppObjectType;
            typedef PangoLayoutRun BaseObjectType;
        private :
        protected :
            LayoutRun();
        public :
            explicit LayoutRun(const PangoLayoutRun * src);
            Item get_item() const;
            GlyphString get_glyphs() const;
            PangoLayoutRun * gobj()
            {
                return &gobject_;
            }
            const PangoLayoutRun * gobj() const
            {
                return &gobject_;
            }
        protected :
            PangoLayoutRun gobject_;
    };
}
namespace Glib {
    Pango::LayoutRun & wrap(PangoLayoutRun * object);
    const Pango::LayoutRun & wrap(const PangoLayoutRun * object);
}
namespace Pango {
    class LayoutIter
    {
        public :
            typedef LayoutIter CppObjectType;
            typedef PangoLayoutIter BaseObjectType;
        private :
        public :
            LayoutIter();
            ~LayoutIter();
            int get_index() const;
            LayoutRun get_run() const;
            Glib::RefPtr< LayoutLine > get_line() const;
            bool at_last_line() const;
            bool next_char();
            bool next_cluster();
            bool next_run();
            bool next_line();
            Rectangle get_char_extents() const;
            void get_cluster_extents(Rectangle & ink_rect, Rectangle & logical_rect) const;
            Rectangle get_cluster_ink_extents() const;
            Rectangle get_cluster_logical_extents() const;
            void get_run_extents(Rectangle & ink_rect, Rectangle & logical_rect) const;
            Rectangle get_run_ink_extents() const;
            Rectangle get_run_logical_extents() const;
            void get_line_extents(Rectangle & ink_rect, Rectangle & logical_rect) const;
            Rectangle get_line_ink_extents() const;
            Rectangle get_line_logical_extents() const;
            void get_line_yrange(int & y0, int & y1) const;
            void get_layout_extents(Rectangle & ink_rect, Rectangle & logical_rect) const;
            Rectangle get_layout_ink_extents() const;
            Rectangle get_layout_logical_extents() const;
            int get_baseline() const;
            PangoLayoutIter * gobj()
            {
                return gobject_;
            }
            const PangoLayoutIter * gobj() const
            {
                return gobject_;
            }
            void assign_gobj(PangoLayoutIter * src);
        protected :
            PangoLayoutIter * gobject_;
        private :
            LayoutIter(const LayoutIter &);
            LayoutIter & operator =(const LayoutIter &);
    };
}
typedef struct _PangoLayout PangoLayout;
typedef struct _PangoLayoutClass PangoLayoutClass;
namespace Pango {
    class Layout_Class;
}
namespace Pango {
    enum Alignment
    {
        ALIGN_LEFT, 
        ALIGN_CENTER, 
        ALIGN_RIGHT
    };
}
namespace Glib {
    template<>
    class Value< Pango::Alignment > : public Glib::Value_Enum< Pango::Alignment >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Pango {
    enum WrapMode
    {
        WRAP_WORD, 
        WRAP_CHAR, 
        WRAP_WORD_CHAR
    };
}
namespace Glib {
    template<>
    class Value< Pango::WrapMode > : public Glib::Value_Enum< Pango::WrapMode >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Pango {
    enum EllipsizeMode
    {
        ELLIPSIZE_NONE, 
        ELLIPSIZE_START, 
        ELLIPSIZE_MIDDLE, 
        ELLIPSIZE_END
    };
}
namespace Glib {
    template<>
    class Value< Pango::EllipsizeMode > : public Glib::Value_Enum< Pango::EllipsizeMode >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Pango {
    class Layout : public Glib::Object
    {
        public :
            typedef Layout CppObjectType;
            typedef Layout_Class CppClassType;
            typedef PangoLayout BaseObjectType;
            typedef PangoLayoutClass BaseClassType;
        private :
            friend class Layout_Class;
            static CppClassType layout_class_;
        private :
            Layout(const Layout &);
            Layout & operator =(const Layout &);
        protected :
            explicit Layout(const Glib::ConstructParams & construct_params);
            explicit Layout(PangoLayout * castitem);
        public :
            virtual ~Layout();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            PangoLayout * gobj()
            {
                return reinterpret_cast<PangoLayout * >(gobject_);
            }
            const PangoLayout * gobj() const
            {
                return reinterpret_cast<PangoLayout * >(gobject_);
            }
            PangoLayout * gobj_copy();
        private :
        protected :
            explicit Layout(const Glib::RefPtr< Context > & context);
        public :
            static Glib::RefPtr< Layout > create(const Glib::RefPtr< Context > & context);
            static Glib::RefPtr< Layout > create(const Cairo::RefPtr< Cairo::Context > & context);
            void update_from_cairo_context(const Cairo::RefPtr< Cairo::Context > & context);
            Glib::RefPtr< Layout > copy();
            Glib::RefPtr< Context > get_context() const;
            void set_attributes(AttrList & attrs);
            AttrList get_attributes() const;
            void set_text(const Glib::ustring & text);
            Glib::ustring get_text() const;
            void set_markup(const Glib::ustring & markup);
            void set_markup(const Glib::ustring & markup, gunichar accel_marker, gunichar & accel_char);
            void set_font_description(const FontDescription & desc);
            void unset_font_description();
            FontDescription get_font_description() const;
            void set_width(int width);
            int get_width() const;
            void set_wrap(WrapMode wrap);
            WrapMode get_wrap() const;
            bool is_wrapped() const;
            void set_indent(int indent);
            int get_indent() const;
            void set_spacing(int spacing);
            int get_spacing() const;
            void set_justify(bool justify = true);
            bool get_justify() const;
            bool get_auto_dir() const;
            void set_auto_dir(bool auto_dir = true);
            void set_alignment(Alignment alignment);
            Alignment get_alignment() const;
            void set_tabs(TabArray & tabs);
            TabArray get_tabs() const;
            void set_single_paragraph_mode(bool setting = true);
            bool get_single_paragraph_mode() const;
            void set_ellipsize(EllipsizeMode ellipsize);
            EllipsizeMode get_ellipsize() const;
            bool is_ellipsized() const;
            int get_unknown_glyphs_count() const;
            void context_changed();
            Glib::ArrayHandle< LogAttr > get_log_attrs() const;
            Rectangle index_to_pos(int index) const;
            void index_to_line_x(int index_, bool trailing, int & line, int & x_pos) const;
            void get_cursor_pos(int index, Rectangle & strong_pos, Rectangle & weak_pos) const;
            Rectangle get_cursor_strong_pos(int index) const;
            Rectangle get_cursor_weak_pos(int index) const;
            void move_cursor_visually(bool strong, int old_index, int old_trailing, int direction, int & new_index, int & new_trailing) const;
            bool xy_to_index(int x, int y, int & index, int & trailing) const;
            void get_extents(Rectangle & ink_rect, Rectangle & logical_rect) const;
            Rectangle get_ink_extents() const;
            Rectangle get_logical_extents() const;
            void get_pixel_extents(Rectangle & ink_rect, Rectangle & logical_rect) const;
            Rectangle get_pixel_ink_extents() const;
            Rectangle get_pixel_logical_extents() const;
            void get_size(int & width, int & height) const;
            void get_pixel_size(int & width, int & height) const;
            int get_line_count() const;
            Glib::RefPtr< LayoutLine > get_line(int line);
            Glib::RefPtr< const LayoutLine > get_line(int line) const;
            SListHandle_LayoutLine get_lines();
            SListHandle_ConstLayoutLine get_lines() const;
            void get_iter(LayoutIter & iter);
            void add_to_cairo_context(const Cairo::RefPtr< Cairo::Context > & context);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Pango::Layout > wrap(PangoLayout * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _PangoGlyphString PangoGlyphString;
}
namespace Pango {
    class GlyphString
    {
        public :
            typedef GlyphString CppObjectType;
            typedef PangoGlyphString BaseObjectType;
            static GType get_type() __attribute__((__const__));
            GlyphString();
            explicit GlyphString(PangoGlyphString * gobject, bool make_a_copy = true);
            GlyphString(const GlyphString & other);
            GlyphString & operator =(const GlyphString & other);
            ~GlyphString();
            void swap(GlyphString & other);
            PangoGlyphString * gobj()
            {
                return gobject_;
            }
            const PangoGlyphString * gobj() const
            {
                return gobject_;
            }
            PangoGlyphString * gobj_copy() const;
        protected :
            PangoGlyphString * gobject_;
        private :
        public :
            GlyphString(const Glib::ustring & text, const Analysis & analysis);
            void set_size(int new_len);
            void get_extents(const Glib::RefPtr< const Font > & font, Rectangle & ink_rect, Rectangle & logical_rect) const;
            void get_extents(int start, int end, const Glib::RefPtr< const Font > & font, Rectangle & ink_rect, Rectangle & logical_rect) const;
            int get_width() const;
            Rectangle get_ink_extents(const Glib::RefPtr< const Font > & font) const;
            Rectangle get_ink_extents(int start, int end, const Glib::RefPtr< const Font > & font) const;
            Rectangle get_logical_extents(const Glib::RefPtr< const Font > & font) const;
            Rectangle get_logical_extents(int start, int end, const Glib::RefPtr< const Font > & font) const;
            Glib::ArrayHandle< int > get_logical_widths(const Glib::ustring & text, int embedding_level) const;
            int index_to_x(const Glib::ustring & text, const Analysis & analysis, int index, bool trailing) const;
            void x_to_index(const Glib::ustring & text, const Analysis & analysis, int x_pos, int & index, bool & trailing) const;
            Glib::ArrayHandle< GlyphInfo > get_glyphs() const;
    };
}
namespace Pango {
    inline void swap(GlyphString & lhs, GlyphString & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    Pango::GlyphString wrap(PangoGlyphString * object, bool take_copy = false);
    template<>
    class Value< Pango::GlyphString > : public Glib::Value_Boxed< Pango::GlyphString >
    {
    };
}
extern "C"
{
    typedef struct _GdkColor GdkColor;
}
namespace Gdk {
    class Colormap;
    class Color
    {
        public :
            typedef Color CppObjectType;
            typedef GdkColor BaseObjectType;
            static GType get_type() __attribute__((__const__));
            explicit Color(GdkColor * gobject, bool make_a_copy = true);
            Color(const Color & other);
            Color & operator =(const Color & other);
            ~Color();
            void swap(Color & other);
            GdkColor * gobj()
            {
                return gobject_;
            }
            const GdkColor * gobj() const
            {
                return gobject_;
            }
            GdkColor * gobj_copy() const;
        protected :
            GdkColor * gobject_;
        private :
        public :
            Color();
            explicit Color(const Glib::ustring & value);
            void set_grey(gushort value);
            void set_grey_p(double g);
            void set_rgb(gushort red_, gushort green_, gushort blue_);
            void set_rgb_p(double red_, double green_, double blue_);
            void set_hsv(double h, double s, double v);
            void set_hsl(double h, double s, double l);
            bool set(const Glib::ustring & value);
            bool parse(const Glib::ustring & spec);
            gushort get_red() const;
            gushort get_green() const;
            gushort get_blue() const;
            void set_red(gushort value);
            void set_green(gushort value);
            void set_blue(gushort value);
            void rgb_find_color(const Glib::RefPtr< Gdk::Colormap > & map);
            guint get_pixel() const;
            double get_red_p() const;
            double get_green_p() const;
            double get_blue_p() const;
    };
    struct ColorTraits
    {
            typedef Gdk::Color CppType;
            typedef GdkColor CType;
            typedef GdkColor CTypeNonConst;
            static CType to_c_type(const CppType & obj)
            {
                return *obj.gobj();
            }
            static CType to_c_type(const CType & obj)
            {
                return obj;
            }
            static CppType to_cpp_type(const CType & obj)
            {
                return CppType(const_cast<CType * >(&obj), true);
            }
            static void release_c_type(const CType &)
            {
            }
    };
    typedef Glib::ArrayHandle< Color, ColorTraits > ArrayHandle_Color;
}
namespace Gdk {
    bool operator ==(const Color & lhs, const Color & rhs);
    bool operator !=(const Color & lhs, const Color & rhs);
}
namespace Gdk {
    inline void swap(Color & lhs, Color & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    Gdk::Color wrap(GdkColor * object, bool take_copy = false);
    template<>
    class Value< Gdk::Color > : public Glib::Value_Boxed< Gdk::Color >
    {
    };
}
typedef struct _GdkColormap GdkColormap;
typedef struct _GdkColormapClass GdkColormapClass;
namespace Gdk {
    class Colormap_Class;
}
namespace Gdk {
    class Colormap : public Glib::Object
    {
        public :
            typedef Colormap CppObjectType;
            typedef Colormap_Class CppClassType;
            typedef GdkColormap BaseObjectType;
            typedef GdkColormapClass BaseClassType;
        private :
            friend class Colormap_Class;
            static CppClassType colormap_class_;
        private :
            Colormap(const Colormap &);
            Colormap & operator =(const Colormap &);
        protected :
            explicit Colormap(const Glib::ConstructParams & construct_params);
            explicit Colormap(GdkColormap * castitem);
        public :
            virtual ~Colormap();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GdkColormap * gobj()
            {
                return reinterpret_cast<GdkColormap * >(gobject_);
            }
            const GdkColormap * gobj() const
            {
                return reinterpret_cast<GdkColormap * >(gobject_);
            }
            GdkColormap * gobj_copy();
        private :
        protected :
            explicit Colormap(const Glib::RefPtr< Visual > & visual, bool allocate);
        public :
            static Glib::RefPtr< Colormap > create(const Glib::RefPtr< Visual > & visual, bool allocate);
            static Glib::RefPtr< Colormap > get_system();
            int alloc_colors(ArrayHandle_Color & colors, int ncolors, bool writeable, bool best_match, Glib::ArrayHandle< bool > & success);
            void free_colors(Color & colors, int ncolors);
            bool alloc_color(Color & color, bool writeable = false, bool best_match = true);
            void free_color(Color & color);
            void query_color(gulong pixel, Color & result);
            Glib::RefPtr< Visual > get_visual();
            Glib::RefPtr< const Visual > get_visual() const;
            Glib::RefPtr< Screen > get_screen();
            Glib::RefPtr< const Screen > get_screen() const;
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gdk::Colormap > wrap(GdkColormap * object, bool take_copy = false);
}
typedef struct _GdkImage GdkImage;
typedef struct _GdkImageClass GdkImageClass;
namespace Gdk {
    class Image_Class;
}
namespace Gdk {
    enum ImageType
    {
        IMAGE_NORMAL, 
        IMAGE_SHARED, 
        IMAGE_FASTEST
    };
}
namespace Glib {
    template<>
    class Value< Gdk::ImageType > : public Glib::Value_Enum< Gdk::ImageType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    class Image : public Glib::Object
    {
        public :
            typedef Image CppObjectType;
            typedef Image_Class CppClassType;
            typedef GdkImage BaseObjectType;
            typedef GdkImageClass BaseClassType;
        private :
            friend class Image_Class;
            static CppClassType image_class_;
        private :
            Image(const Image &);
            Image & operator =(const Image &);
        protected :
            explicit Image(const Glib::ConstructParams & construct_params);
            explicit Image(GdkImage * castitem);
        public :
            virtual ~Image();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GdkImage * gobj()
            {
                return reinterpret_cast<GdkImage * >(gobject_);
            }
            const GdkImage * gobj() const
            {
                return reinterpret_cast<GdkImage * >(gobject_);
            }
            GdkImage * gobj_copy();
        private :
        protected :
            Image(ImageType type, const Glib::RefPtr< Visual > & visual, int width, int height);
        public :
            static Glib::RefPtr< Image > create(ImageType type, const Glib::RefPtr< Visual > & visual, int width, int height);
            void put_pixel(int x, int y, guint32 pixel);
            guint32 get_pixel(int x, int y) const;
            void set_colormap(const Glib::RefPtr< Colormap > & colormap);
            Glib::RefPtr< Colormap > get_colormap();
            Glib::RefPtr< const Colormap > get_colormap() const;
            ImageType get_image_type() const;
            Glib::RefPtr< Visual > get_visual();
            Glib::RefPtr< const Visual > get_visual() const;
            ByteOrder get_byte_order() const;
            int get_width() const;
            int get_height() const;
            guint16 get_bpp() const;
            guint16 get_bpl() const;
            guint16 get_bits_per_pixel() const;
            void * get_mem();
            const void * get_mem() const;
            void * get_windowing_data() const;
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gdk::Image > wrap(GdkImage * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GdkRegion GdkRegion;
}
namespace Gdk {
    enum FillRule
    {
        EVEN_ODD_RULE, 
        WINDING_RULE
    };
}
namespace Glib {
    template<>
    class Value< Gdk::FillRule > : public Glib::Value_Enum< Gdk::FillRule >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum OverlapType
    {
        OVERLAP_RECTANGLE_IN, 
        OVERLAP_RECTANGLE_OUT, 
        OVERLAP_RECTANGLE_PART
    };
}
namespace Glib {
    template<>
    class Value< Gdk::OverlapType > : public Glib::Value_Enum< Gdk::OverlapType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    class Region
    {
        public :
            typedef Region CppObjectType;
            typedef GdkRegion BaseObjectType;
            Region();
            explicit Region(GdkRegion * castitem, bool make_a_copy = false);
            Region(const Region & src);
            Region & operator =(const Region & src);
            ~Region();
            GdkRegion * gobj()
            {
                return gobject_;
            }
            const GdkRegion * gobj() const
            {
                return gobject_;
            }
            GdkRegion * gobj_copy() const;
        protected :
            GdkRegion * gobject_;
        private :
        public :
            Region(const Glib::ArrayHandle< Gdk::Point > & points, FillRule fill_rule);
            explicit Region(const Rectangle & rectangle);
            void get_clipbox(const Rectangle & rectangle);
            Glib::ArrayHandle< Rectangle > get_rectangles() const;
            bool empty();
            bool point_in(int x, int y);
            OverlapType rect_in(const Rectangle & rect);
            void offset(int dx, int dy);
            void shrink(int dx, int dy);
            void union_with_rect(const Rectangle & rect);
            void intersect(const Region & source2);
            void union_(const Region & source2);
            void subtract(const Region & source2);
            void xor_(const Region & source2);
            void spans_intersect_foreach(GdkSpan * spans, int n_spans, bool sorted, GdkSpanFunc function, gpointer data);
    };
}
namespace Gdk {
    bool operator ==(const Region & lhs, const Region & rhs);
    bool operator !=(const Region & lhs, const Region & rhs);
}
namespace Glib {
    Gdk::Region wrap(GdkRegion * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GdkRgbCmap GdkRgbCmap;
}
namespace Gdk {
    class RgbCmap
    {
        public :
            typedef RgbCmap CppObjectType;
            typedef GdkRgbCmap BaseObjectType;
        private :
        public :
            explicit RgbCmap(const Glib::ArrayHandle< guint32 > & colors);
            virtual ~RgbCmap();
            unsigned long size() const;
            guint32 & operator [](unsigned long index);
            const guint32 & operator [](unsigned long index) const;
            GdkRgbCmap * gobj()
            {
                return gobject_;
            }
            const GdkRgbCmap * gobj() const
            {
                return gobject_;
            }
        protected :
            GdkRgbCmap * gobject_;
        private :
            RgbCmap(const RgbCmap &);
            RgbCmap & operator =(const RgbCmap &);
    };
}
typedef struct _GdkDrawable GdkDrawable;
typedef struct _GdkDrawableClass GdkDrawableClass;
namespace Gdk {
    class Drawable_Class;
}
namespace Gdk {
    enum RgbDither
    {
        RGB_DITHER_NONE, 
        RGB_DITHER_NORMAL, 
        RGB_DITHER_MAX
    };
}
namespace Glib {
    template<>
    class Value< Gdk::RgbDither > : public Glib::Value_Enum< Gdk::RgbDither >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    class GC;
    class Pixbuf;
    class Drawable : public Glib::Object
    {
        public :
            typedef Drawable CppObjectType;
            typedef Drawable_Class CppClassType;
            typedef GdkDrawable BaseObjectType;
            typedef GdkDrawableClass BaseClassType;
        private :
            friend class Drawable_Class;
            static CppClassType drawable_class_;
        private :
            Drawable(const Drawable &);
            Drawable & operator =(const Drawable &);
        protected :
            explicit Drawable(const Glib::ConstructParams & construct_params);
            explicit Drawable(GdkDrawable * castitem);
        public :
            virtual ~Drawable();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GdkDrawable * gobj()
            {
                return reinterpret_cast<GdkDrawable * >(gobject_);
            }
            const GdkDrawable * gobj() const
            {
                return reinterpret_cast<GdkDrawable * >(gobject_);
            }
            GdkDrawable * gobj_copy();
        private :
        protected :
            Drawable();
        public :
            static Glib::RefPtr< Drawable > create();
            void get_size(int & width, int & height);
            int get_depth() const;
            void set_colormap(const Glib::RefPtr< Colormap > & colormap);
            Glib::RefPtr< Colormap > get_colormap();
            Glib::RefPtr< Visual > get_visual();
            void draw_point(const Glib::RefPtr< const GC > & gc, int x, int y);
            void draw_points(const Glib::RefPtr< const GC > & gc, const Glib::ArrayHandle< Point > & points);
            void draw_line(const Glib::RefPtr< const GC > & gc, int x1, int y1, int x2, int y2);
            void draw_lines(const Glib::RefPtr< const GC > & gc, const Glib::ArrayHandle< Point > & points);
            void draw_rectangle(const Glib::RefPtr< const GC > & gc, bool filled, int x, int y, int width, int height);
            void draw_arc(const Glib::RefPtr< const GC > & gc, bool filled, int x, int y, int width, int height, int angle1, int angle2);
            void draw_polygon(const Glib::RefPtr< const GC > & gc, bool filled, const Glib::ArrayHandle< Point > & points);
            void draw_drawable(const Glib::RefPtr< const GC > & gc, const Glib::RefPtr< const Drawable > & src, int xsrc, int ysrc, int xdest, int ydest, int width = -1, int height = -1);
            void draw_image(const Glib::RefPtr< const GC > & gc, const Glib::RefPtr< const Image > & image, int xsrc, int ysrc, int xdest, int ydest, int width = -1, int height = -1);
            void draw_segments(const Glib::RefPtr< const GC > & gc, GdkSegment * segs, int nsegs);
            void draw_glyphs(const Glib::RefPtr< const GC > & gc, const Glib::RefPtr< const Pango::Font > & font, int x, int y, const Pango::GlyphString & glyphs);
            void draw_layout_line(const Glib::RefPtr< const GC > & gc, int x, int y, const Glib::RefPtr< const Pango::LayoutLine > & line);
            void draw_layout_line(const Glib::RefPtr< const GC > & gc, int x, int y, const Glib::RefPtr< const Pango::LayoutLine > & line, const Color & foreground, const Color & background);
            void draw_layout(const Glib::RefPtr< const GC > & gc, int x, int y, const Glib::RefPtr< const Pango::Layout > & layout);
            void draw_layout(const Glib::RefPtr< const GC > & gc, int x, int y, const Glib::RefPtr< const Pango::Layout > & layout, const Color & foreground, const Color & background);
            void draw_pixbuf(const Glib::RefPtr< const GC > & gc, const Glib::RefPtr< Pixbuf > & pixbuf, int src_x, int src_y, int dest_x, int dest_y, int width, int height, RgbDither dither, int x_dither, int y_dither);
            Glib::RefPtr< Image > get_image(int x, int y, int width, int height) const;
            void copy_to_image(const Glib::RefPtr< Image > & image, int src_x, int src_y, int dest_x, int dest_y, int width, int height) const;
            Region get_clip_region() const;
            Region get_visible_region() const;
            void draw_rgb_image(const Glib::RefPtr< const GC > & gc, int x, int y, int width, int height, RgbDither dith, const guchar * rgb_buf, int rowstride);
            void draw_rgb_image_dithalign(const Glib::RefPtr< const GC > & gc, int x, int y, int width, int height, RgbDither dith, const guchar * rgb_buf, int rowstride, int xdith, int ydith);
            void draw_rgb_32_image(const Glib::RefPtr< const GC > & gc, int x, int y, int width, int height, RgbDither dith, const guchar * rgb_buf, int rowstride);
            void draw_rgb_32_image_dithalign(const Glib::RefPtr< const GC > & gc, int x, int y, int width, int height, RgbDither dith, const guchar * buf, int rowstride, int xdith, int ydith);
            void draw_gray_image(const Glib::RefPtr< const GC > & gc, int x, int y, int width, int height, RgbDither dith, const guchar * rgb_buf, int rowstride);
            void draw_indexed_image(const Glib::RefPtr< const GC > & gc, int x, int y, int width, int height, RgbDither dith, const guchar * rgb_buf, int rowstride, const RgbCmap & cmap);
            Glib::RefPtr< Screen > get_screen();
            Glib::RefPtr< const Screen > get_screen() const;
            Glib::RefPtr< Display > get_display();
            Glib::RefPtr< const Display > get_display() const;
            Cairo::RefPtr< Cairo::Context > create_cairo_context();
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gdk::Drawable > wrap(GdkDrawable * object, bool take_copy = false);
}
typedef struct _GdkGC GdkGC;
typedef struct _GdkGCClass GdkGCClass;
namespace Gdk {
    class GC_Class;
}
namespace Gdk {
    enum LineStyle
    {
        LINE_SOLID, 
        LINE_ON_OFF_DASH, 
        LINE_DOUBLE_DASH
    };
}
namespace Glib {
    template<>
    class Value< Gdk::LineStyle > : public Glib::Value_Enum< Gdk::LineStyle >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum CapStyle
    {
        CAP_NOT_LAST, 
        CAP_BUTT, 
        CAP_ROUND, 
        CAP_PROJECTING
    };
}
namespace Glib {
    template<>
    class Value< Gdk::CapStyle > : public Glib::Value_Enum< Gdk::CapStyle >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum JoinStyle
    {
        JOIN_MITER, 
        JOIN_ROUND, 
        JOIN_BEVEL
    };
}
namespace Glib {
    template<>
    class Value< Gdk::JoinStyle > : public Glib::Value_Enum< Gdk::JoinStyle >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum Fill
    {
        SOLID, 
        TILED, 
        STIPPLED, 
        OPAQUE_STIPPLED
    };
}
namespace Glib {
    template<>
    class Value< Gdk::Fill > : public Glib::Value_Enum< Gdk::Fill >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum Function
    {
        COPY, 
        INVERT, 
        XOR, 
        CLEAR, 
        AND, 
        AND_REVERSE, 
        AND_INVERT, 
        NOOP, 
        OR, 
        EQUIV, 
        OR_REVERSE, 
        COPY_INVERT, 
        OR_INVERT, 
        NAND, 
        NOR, 
        SET
    };
}
namespace Glib {
    template<>
    class Value< Gdk::Function > : public Glib::Value_Enum< Gdk::Function >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum SubwindowMode
    {
        CLIP_BY_CHILDREN, 
        INCLUDE_INFERIORS
    };
}
namespace Glib {
    template<>
    class Value< Gdk::SubwindowMode > : public Glib::Value_Enum< Gdk::SubwindowMode >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum GCValuesMask
    {
        GC_FOREGROUND = 1 << 0, 
        GC_BACKGROUND = 1 << 1, 
        GC_FONT = 1 << 2, 
        GC_FUNCTION = 1 << 3, 
        GC_FILL = 1 << 4, 
        GC_TILE = 1 << 5, 
        GC_STIPPLE = 1 << 6, 
        GC_CLIP_MASK = 1 << 7, 
        GC_SUBWINDOW = 1 << 8, 
        GC_TS_X_ORIGIN = 1 << 9, 
        GC_TS_Y_ORIGIN = 1 << 10, 
        GC_CLIP_X_ORIGIN = 1 << 11, 
        GC_CLIP_Y_ORIGIN = 1 << 12, 
        GC_EXPOSURES = 1 << 13, 
        GC_LINE_WIDTH = 1 << 14, 
        GC_LINE_STYLE = 1 << 15, 
        GC_CAP_STYLE = 1 << 16, 
        GC_JOIN_STYLE = 1 << 17
    };
    inline GCValuesMask operator |(GCValuesMask lhs, GCValuesMask rhs)
    {
        return static_cast<GCValuesMask >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline GCValuesMask operator &(GCValuesMask lhs, GCValuesMask rhs)
    {
        return static_cast<GCValuesMask >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline GCValuesMask operator ^(GCValuesMask lhs, GCValuesMask rhs)
    {
        return static_cast<GCValuesMask >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline GCValuesMask operator ~(GCValuesMask flags)
    {
        return static_cast<GCValuesMask >(~static_cast<unsigned >(flags));
    }
    inline GCValuesMask & operator |=(GCValuesMask & lhs, GCValuesMask rhs)
    {
        return (lhs = static_cast<GCValuesMask >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline GCValuesMask & operator &=(GCValuesMask & lhs, GCValuesMask rhs)
    {
        return (lhs = static_cast<GCValuesMask >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline GCValuesMask & operator ^=(GCValuesMask & lhs, GCValuesMask rhs)
    {
        return (lhs = static_cast<GCValuesMask >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gdk::GCValuesMask > : public Glib::Value_Flags< Gdk::GCValuesMask >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    class Drawable;
    class GC : public Glib::Object
    {
        public :
            typedef GC CppObjectType;
            typedef GC_Class CppClassType;
            typedef GdkGC BaseObjectType;
            typedef GdkGCClass BaseClassType;
        private :
            friend class GC_Class;
            static CppClassType gc_class_;
        private :
            GC(const GC &);
            GC & operator =(const GC &);
        protected :
            explicit GC(const Glib::ConstructParams & construct_params);
            explicit GC(GdkGC * castitem);
        public :
            virtual ~GC();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GdkGC * gobj()
            {
                return reinterpret_cast<GdkGC * >(gobject_);
            }
            const GdkGC * gobj() const
            {
                return reinterpret_cast<GdkGC * >(gobject_);
            }
            GdkGC * gobj_copy();
        private :
        protected :
            GC();
            explicit GC(const Glib::RefPtr< Drawable > & drawable);
        public :
            static Glib::RefPtr< GC > create();
            static Glib::RefPtr< GC > create(const Glib::RefPtr< Drawable > & drawable);
            void set_foreground(const Color & color);
            void set_background(const Color & color);
            void set_function(Function function);
            void set_fill(Fill fill);
            void set_tile(const Glib::RefPtr< Pixmap > & tile);
            void set_stipple(const Glib::RefPtr< Pixmap > & stipple);
            void set_ts_origin(int x, int y);
            void set_clip_origin(int x, int y);
            void set_clip_mask(const Glib::RefPtr< Bitmap > & mask);
            void set_clip_rectangle(Rectangle & rectangle);
            void set_clip_rectangle(const Rectangle & rectangle);
            void set_clip_region(const Region & region);
            void set_subwindow(SubwindowMode mode);
            void set_exposures(bool exposures);
            void set_line_attributes(int line_width, LineStyle line_style, CapStyle cap_style, JoinStyle join_style);
            void set_dashes(int dash_offset, gint8 * dash_list, int n);
            void offset(int x_offset, int y_offset);
            void set_colormap(const Glib::RefPtr< Colormap > & colormap);
            Glib::RefPtr< Colormap > get_colormap();
            void set_rgb_fg_color(const Color & color);
            void set_rgb_bg_color(const Color & color);
            Glib::RefPtr< Screen > get_screen();
            Glib::RefPtr< const Screen > get_screen() const;
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gdk::GC > wrap(GdkGC * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GdkDrawable GdkPixmap;
    typedef struct _GdkPixmapClass GdkPixmapClass;
}
namespace Gdk {
    class Pixmap_Class;
}
namespace Gdk {
    class Window;
    class Pixmap : public Gdk::Drawable
    {
        public :
            typedef Pixmap CppObjectType;
            typedef Pixmap_Class CppClassType;
            typedef GdkPixmap BaseObjectType;
            typedef GdkPixmapObjectClass BaseClassType;
        private :
            friend class Pixmap_Class;
            static CppClassType pixmap_class_;
        private :
            Pixmap(const Pixmap &);
            Pixmap & operator =(const Pixmap &);
        protected :
            explicit Pixmap(const Glib::ConstructParams & construct_params);
            explicit Pixmap(GdkPixmap * castitem);
        public :
            virtual ~Pixmap();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GdkPixmap * gobj()
            {
                return reinterpret_cast<GdkPixmap * >(gobject_);
            }
            const GdkPixmap * gobj() const
            {
                return reinterpret_cast<GdkPixmap * >(gobject_);
            }
            GdkPixmap * gobj_copy();
        private :
        protected :
            Pixmap();
            Pixmap(const Glib::RefPtr< Drawable > & drawable, int width, int height, int depth = -1);
            Pixmap(const Glib::RefPtr< Drawable > & drawable, const char * data, int width, int height, int depth, const Color & fg, const Color & bg);
            Pixmap(const Glib::RefPtr< Display > & display, NativeWindow anid);
        public :
            static Glib::RefPtr< Pixmap > create(const Glib::RefPtr< Drawable > & drawable, int width, int height, int depth = -1);
            static Glib::RefPtr< Pixmap > create(const Glib::RefPtr< Drawable > & drawable, const char * data, int width, int height, int depth, const Color & fg, const Color & bg);
            static Glib::RefPtr< Pixmap > create(const Glib::RefPtr< Display > & display, NativeWindow anid);
            static Glib::RefPtr< Pixmap > create_from_data(const Glib::RefPtr< const Drawable > & drawable, const char * data, int width, int height, int depth, const Color & fg, const Color & bg);
            static Glib::RefPtr< Pixmap > create_from_xpm(const Glib::RefPtr< const Drawable > & drawable, const Color & transparent_color, const std::string & filename);
            static Glib::RefPtr< Pixmap > create_from_xpm(const Glib::RefPtr< const Drawable > & drawable, Glib::RefPtr< Bitmap > & mask, const Color & transparent_color, const std::string & filename);
            static Glib::RefPtr< Pixmap > create_from_xpm(const Glib::RefPtr< const Drawable > & drawable, const Glib::RefPtr< Colormap > & colormap, Glib::RefPtr< Bitmap > & mask, const Color & transparent_color, const std::string & filename);
            static Glib::RefPtr< Pixmap > create_from_xpm(const Glib::RefPtr< const Drawable > & drawable, Glib::RefPtr< Bitmap > & mask, const Color & transparent_color, const char *const * data);
            static Glib::RefPtr< Pixmap > create_from_xpm(const Glib::RefPtr< const Drawable > & drawable, const Glib::RefPtr< Colormap > & colormap, Glib::RefPtr< Bitmap > & mask, const Color & transparent_color, const char *const * data);
            static Glib::RefPtr< Pixmap > create_from_xpm(const Glib::RefPtr< Colormap > & colormap, Glib::RefPtr< Bitmap > & mask, const Color & transparent_color, const char *const * data);
            static Glib::RefPtr< Pixmap > create_from_xpm(const Glib::RefPtr< Colormap > & colormap, Glib::RefPtr< Bitmap > & mask, const char *const * data);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gdk::Pixmap > wrap(GdkPixmapObject * object, bool take_copy = false);
}
namespace Gdk {
    class Window;
    class Bitmap : public Gdk::Pixmap
    {
        public :
            typedef Bitmap CppObjectType;
            typedef GdkBitmap BaseObjectType;
        private :
        protected :
            explicit Bitmap(GdkBitmap * castitem);
            friend class Gdk::Pixmap_Class;
            Bitmap(const char * data, int width, int height);
            Bitmap(const Glib::RefPtr< Gdk::Drawable > & drawable, const char * data, int width, int height);
        public :
            static Glib::RefPtr< Bitmap > create(const char * data, int width, int height);
            static Glib::RefPtr< Bitmap > create(const Glib::RefPtr< Gdk::Drawable > & drawable, const char * data, int width, int height);
    };
}
extern "C"
{
    typedef struct _GdkDrawable GdkWindow;
}
namespace Gdk {
    class Window_Class;
}
namespace Gdk {
    enum EventMask
    {
        EXPOSURE_MASK = 1 << 1, 
        POINTER_MOTION_MASK = 1 << 2, 
        POINTER_MOTION_HINT_MASK = 1 << 3, 
        BUTTON_MOTION_MASK = 1 << 4, 
        BUTTON1_MOTION_MASK = 1 << 5, 
        BUTTON2_MOTION_MASK = 1 << 6, 
        BUTTON3_MOTION_MASK = 1 << 7, 
        BUTTON_PRESS_MASK = 1 << 8, 
        BUTTON_RELEASE_MASK = 1 << 9, 
        KEY_PRESS_MASK = 1 << 10, 
        KEY_RELEASE_MASK = 1 << 11, 
        ENTER_NOTIFY_MASK = 1 << 12, 
        LEAVE_NOTIFY_MASK = 1 << 13, 
        FOCUS_CHANGE_MASK = 1 << 14, 
        STRUCTURE_MASK = 1 << 15, 
        PROPERTY_CHANGE_MASK = 1 << 16, 
        VISIBILITY_NOTIFY_MASK = 1 << 17, 
        PROXIMITY_IN_MASK = 1 << 18, 
        PROXIMITY_OUT_MASK = 1 << 19, 
        SUBSTRUCTURE_MASK = 1 << 20, 
        SCROLL_MASK = 1 << 21, 
        ALL_EVENTS_MASK = 0x3FFFFE
    };
    inline EventMask operator |(EventMask lhs, EventMask rhs)
    {
        return static_cast<EventMask >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline EventMask operator &(EventMask lhs, EventMask rhs)
    {
        return static_cast<EventMask >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline EventMask operator ^(EventMask lhs, EventMask rhs)
    {
        return static_cast<EventMask >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline EventMask operator ~(EventMask flags)
    {
        return static_cast<EventMask >(~static_cast<unsigned >(flags));
    }
    inline EventMask & operator |=(EventMask & lhs, EventMask rhs)
    {
        return (lhs = static_cast<EventMask >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline EventMask & operator &=(EventMask & lhs, EventMask rhs)
    {
        return (lhs = static_cast<EventMask >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline EventMask & operator ^=(EventMask & lhs, EventMask rhs)
    {
        return (lhs = static_cast<EventMask >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gdk::EventMask > : public Glib::Value_Flags< Gdk::EventMask >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum WindowState
    {
        WINDOW_STATE_WITHDRAWN = 1 << 0, 
        WINDOW_STATE_ICONIFIED = 1 << 1, 
        WINDOW_STATE_MAXIMIZED = 1 << 2, 
        WINDOW_STATE_STICKY = 1 << 3, 
        WINDOW_STATE_FULLSCREEN = 1 << 4, 
        WINDOW_STATE_ABOVE = 1 << 5, 
        WINDOW_STATE_BELOW = 1 << 6
    };
    inline WindowState operator |(WindowState lhs, WindowState rhs)
    {
        return static_cast<WindowState >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline WindowState operator &(WindowState lhs, WindowState rhs)
    {
        return static_cast<WindowState >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline WindowState operator ^(WindowState lhs, WindowState rhs)
    {
        return static_cast<WindowState >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline WindowState operator ~(WindowState flags)
    {
        return static_cast<WindowState >(~static_cast<unsigned >(flags));
    }
    inline WindowState & operator |=(WindowState & lhs, WindowState rhs)
    {
        return (lhs = static_cast<WindowState >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline WindowState & operator &=(WindowState & lhs, WindowState rhs)
    {
        return (lhs = static_cast<WindowState >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline WindowState & operator ^=(WindowState & lhs, WindowState rhs)
    {
        return (lhs = static_cast<WindowState >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gdk::WindowState > : public Glib::Value_Flags< Gdk::WindowState >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum WindowType
    {
        WINDOW_ROOT, 
        WINDOW_TOPLEVEL, 
        WINDOW_CHILD, 
        WINDOW_DIALOG, 
        WINDOW_TEMP, 
        WINDOW_FOREIGN
    };
}
namespace Glib {
    template<>
    class Value< Gdk::WindowType > : public Glib::Value_Enum< Gdk::WindowType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum WindowAttributesType
    {
        WA_TITLE = 1 << 1, 
        WA_X = 1 << 2, 
        WA_Y = 1 << 3, 
        WA_CURSOR = 1 << 4, 
        WA_COLORMAP = 1 << 5, 
        WA_VISUAL = 1 << 6, 
        WA_WMCLASS = 1 << 7, 
        WA_NOREDIR = 1 << 8, 
        WA_TYPE_HINT = 1 << 9
    };
    inline WindowAttributesType operator |(WindowAttributesType lhs, WindowAttributesType rhs)
    {
        return static_cast<WindowAttributesType >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline WindowAttributesType operator &(WindowAttributesType lhs, WindowAttributesType rhs)
    {
        return static_cast<WindowAttributesType >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline WindowAttributesType operator ^(WindowAttributesType lhs, WindowAttributesType rhs)
    {
        return static_cast<WindowAttributesType >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline WindowAttributesType operator ~(WindowAttributesType flags)
    {
        return static_cast<WindowAttributesType >(~static_cast<unsigned >(flags));
    }
    inline WindowAttributesType & operator |=(WindowAttributesType & lhs, WindowAttributesType rhs)
    {
        return (lhs = static_cast<WindowAttributesType >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline WindowAttributesType & operator &=(WindowAttributesType & lhs, WindowAttributesType rhs)
    {
        return (lhs = static_cast<WindowAttributesType >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline WindowAttributesType & operator ^=(WindowAttributesType & lhs, WindowAttributesType rhs)
    {
        return (lhs = static_cast<WindowAttributesType >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gdk::WindowAttributesType > : public Glib::Value_Flags< Gdk::WindowAttributesType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum WindowHints
    {
        HINT_POS = 1 << 0, 
        HINT_MIN_SIZE = 1 << 1, 
        HINT_MAX_SIZE = 1 << 2, 
        HINT_BASE_SIZE = 1 << 3, 
        HINT_ASPECT = 1 << 4, 
        HINT_RESIZE_INC = 1 << 5, 
        HINT_WIN_GRAVITY = 1 << 6, 
        HINT_USER_POS = 1 << 7, 
        HINT_USER_SIZE = 1 << 8
    };
    inline WindowHints operator |(WindowHints lhs, WindowHints rhs)
    {
        return static_cast<WindowHints >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline WindowHints operator &(WindowHints lhs, WindowHints rhs)
    {
        return static_cast<WindowHints >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline WindowHints operator ^(WindowHints lhs, WindowHints rhs)
    {
        return static_cast<WindowHints >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline WindowHints operator ~(WindowHints flags)
    {
        return static_cast<WindowHints >(~static_cast<unsigned >(flags));
    }
    inline WindowHints & operator |=(WindowHints & lhs, WindowHints rhs)
    {
        return (lhs = static_cast<WindowHints >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline WindowHints & operator &=(WindowHints & lhs, WindowHints rhs)
    {
        return (lhs = static_cast<WindowHints >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline WindowHints & operator ^=(WindowHints & lhs, WindowHints rhs)
    {
        return (lhs = static_cast<WindowHints >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gdk::WindowHints > : public Glib::Value_Flags< Gdk::WindowHints >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum WindowTypeHint
    {
        WINDOW_TYPE_HINT_NORMAL, 
        WINDOW_TYPE_HINT_DIALOG, 
        WINDOW_TYPE_HINT_MENU, 
        WINDOW_TYPE_HINT_TOOLBAR, 
        WINDOW_TYPE_HINT_SPLASHSCREEN, 
        WINDOW_TYPE_HINT_UTILITY, 
        WINDOW_TYPE_HINT_DOCK, 
        WINDOW_TYPE_HINT_DESKTOP, 
        WINDOW_TYPE_HINT_DROPDOWN_MENU, 
        WINDOW_TYPE_HINT_POPUP_MENU, 
        WINDOW_TYPE_HINT_TOOLTIP, 
        WINDOW_TYPE_HINT_NOTIFICATION, 
        WINDOW_TYPE_HINT_COMBO, 
        WINDOW_TYPE_HINT_DND
    };
}
namespace Glib {
    template<>
    class Value< Gdk::WindowTypeHint > : public Glib::Value_Enum< Gdk::WindowTypeHint >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum WMDecoration
    {
        DECOR_ALL = 1 << 0, 
        DECOR_BORDER = 1 << 1, 
        DECOR_RESIZEH = 1 << 2, 
        DECOR_TITLE = 1 << 3, 
        DECOR_MENU = 1 << 4, 
        DECOR_MINIMIZE = 1 << 5, 
        DECOR_MAXIMIZE = 1 << 6
    };
    inline WMDecoration operator |(WMDecoration lhs, WMDecoration rhs)
    {
        return static_cast<WMDecoration >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline WMDecoration operator &(WMDecoration lhs, WMDecoration rhs)
    {
        return static_cast<WMDecoration >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline WMDecoration operator ^(WMDecoration lhs, WMDecoration rhs)
    {
        return static_cast<WMDecoration >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline WMDecoration operator ~(WMDecoration flags)
    {
        return static_cast<WMDecoration >(~static_cast<unsigned >(flags));
    }
    inline WMDecoration & operator |=(WMDecoration & lhs, WMDecoration rhs)
    {
        return (lhs = static_cast<WMDecoration >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline WMDecoration & operator &=(WMDecoration & lhs, WMDecoration rhs)
    {
        return (lhs = static_cast<WMDecoration >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline WMDecoration & operator ^=(WMDecoration & lhs, WMDecoration rhs)
    {
        return (lhs = static_cast<WMDecoration >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gdk::WMDecoration > : public Glib::Value_Flags< Gdk::WMDecoration >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum WMFunction
    {
        FUNC_ALL = 1 << 0, 
        FUNC_RESIZE = 1 << 1, 
        FUNC_MOVE = 1 << 2, 
        FUNC_MINIMIZE = 1 << 3, 
        FUNC_MAXIMIZE = 1 << 4, 
        FUNC_CLOSE = 1 << 5
    };
    inline WMFunction operator |(WMFunction lhs, WMFunction rhs)
    {
        return static_cast<WMFunction >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline WMFunction operator &(WMFunction lhs, WMFunction rhs)
    {
        return static_cast<WMFunction >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline WMFunction operator ^(WMFunction lhs, WMFunction rhs)
    {
        return static_cast<WMFunction >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline WMFunction operator ~(WMFunction flags)
    {
        return static_cast<WMFunction >(~static_cast<unsigned >(flags));
    }
    inline WMFunction & operator |=(WMFunction & lhs, WMFunction rhs)
    {
        return (lhs = static_cast<WMFunction >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline WMFunction & operator &=(WMFunction & lhs, WMFunction rhs)
    {
        return (lhs = static_cast<WMFunction >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline WMFunction & operator ^=(WMFunction & lhs, WMFunction rhs)
    {
        return (lhs = static_cast<WMFunction >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gdk::WMFunction > : public Glib::Value_Flags< Gdk::WMFunction >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum WindowEdge
    {
        WINDOW_EDGE_NORTH_WEST, 
        WINDOW_EDGE_NORTH, 
        WINDOW_EDGE_NORTH_EAST, 
        WINDOW_EDGE_WEST, 
        WINDOW_EDGE_EAST, 
        WINDOW_EDGE_SOUTH_WEST, 
        WINDOW_EDGE_SOUTH, 
        WINDOW_EDGE_SOUTH_EAST
    };
}
namespace Glib {
    template<>
    class Value< Gdk::WindowEdge > : public Glib::Value_Enum< Gdk::WindowEdge >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum Gravity
    {
        GRAVITY_NORTH_WEST = 1, 
        GRAVITY_NORTH, 
        GRAVITY_NORTH_EAST, 
        GRAVITY_WEST, 
        GRAVITY_CENTER, 
        GRAVITY_EAST, 
        GRAVITY_SOUTH_WEST, 
        GRAVITY_SOUTH, 
        GRAVITY_SOUTH_EAST, 
        GRAVITY_STATIC
    };
}
namespace Glib {
    template<>
    class Value< Gdk::Gravity > : public Glib::Value_Enum< Gdk::Gravity >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum GrabStatus
    {
        GRAB_SUCCESS, 
        GRAB_ALREADY_GRABBED, 
        GRAB_INVALID_TIME, 
        GRAB_NOT_VIEWABLE, 
        GRAB_FROZEN
    };
}
namespace Glib {
    template<>
    class Value< Gdk::GrabStatus > : public Glib::Value_Enum< Gdk::GrabStatus >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    class Cursor;
    class Window : public Gdk::Drawable
    {
        public :
            typedef Window CppObjectType;
            typedef Window_Class CppClassType;
            typedef GdkWindow BaseObjectType;
            typedef GdkWindowObjectClass BaseClassType;
        private :
            friend class Window_Class;
            static CppClassType window_class_;
        private :
            Window(const Window &);
            Window & operator =(const Window &);
        protected :
            explicit Window(const Glib::ConstructParams & construct_params);
            explicit Window(GdkWindow * castitem);
        public :
            virtual ~Window();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GdkWindow * gobj()
            {
                return reinterpret_cast<GdkWindow * >(gobject_);
            }
            const GdkWindow * gobj() const
            {
                return reinterpret_cast<GdkWindow * >(gobject_);
            }
            GdkWindow * gobj_copy();
        private :
        protected :
            Window(const Glib::RefPtr< Window > & parent, GdkWindowAttr * attributes, int attributes_mask);
        public :
            static Glib::RefPtr< Window > create(const Glib::RefPtr< Window > & parent, GdkWindowAttr * attributes, int attributes_mask);
            WindowType get_window_type() const;
            void show();
            void hide();
            void withdraw();
            void show_unraised();
            void move(int x, int y);
            void resize(int width, int height);
            void move_resize(int x, int y, int width, int height);
            void reparent(const Glib::RefPtr< Window > & new_parent, int x, int y);
            void clear();
            void clear_area(int x, int y, int width, int height);
            void clear_area_e(int x, int y, int width, int height);
            void raise();
            void lower();
            void focus(guint32 timestamp);
            void set_user_data(gpointer user_data);
            void set_override_redirect(bool override_redirect = true);
            void add_filter(GdkFilterFunc function, gpointer data);
            void remove_filter(GdkFilterFunc function, gpointer data);
            void scroll(int dx, int dy);
            void move_region(const Region & region, int dx, int dy);
            void shape_combine_mask(const Glib::RefPtr< Bitmap > & mask, int x, int y);
            void unset_shape_combine_mask();
            void shape_combine_region(const Region & shape_region, int offset_x, int offset_y);
            void set_child_shapes();
            void set_composited(bool composited = (!(0)));
            void merge_child_shapes();
            void input_shape_combine_mask(const Glib::RefPtr< Bitmap > & mask, int x, int y);
            void input_shape_combine_region(const Region & shape_region, int offset_x, int offset_y);
            void set_child_input_shapes();
            void merge_child_input_shapes();
            bool is_visible() const;
            bool is_viewable() const;
            WindowState get_state() const;
            bool set_static_gravities(bool use_static = true);
            void set_type_hint(WindowTypeHint hint);
            WindowTypeHint get_type_hint();
            void set_modal_hint(bool modal = true);
            void set_geometry_hints(const Geometry & geometry, WindowHints geom_mask);
            static void set_sm_client_id(const Glib::ustring & sm_client_id);
            static void unset_sm_client_id();
            void begin_paint_rect(Rectangle & rectangle);
            void begin_paint_region(const Region & region);
            void end_paint();
            void set_title(const Glib::ustring & title);
            void set_role(const Glib::ustring & role);
            void set_startup_id(const Glib::ustring & startup_id);
            void set_transient_for(const Glib::RefPtr< Window > & parent);
            void set_background(const Color & color);
            void set_back_pixmap(const Glib::RefPtr< Pixmap > & pixmap, bool parent_relative);
            void set_cursor(const Cursor & cursor);
            void set_cursor();
            void get_user_data(gpointer * data);
            void get_geometry(int & x, int & y, int & width, int & height, int & depth) const;
            void get_position(int & x, int & y) const;
            int get_origin(int & x, int & y) const;
            void get_root_origin(int & x, int & y) const;
            void get_frame_extents(Rectangle & rect);
            Glib::RefPtr< Window > get_pointer(int & x, int & y, ModifierType & mask);
            Glib::RefPtr< Window > get_parent();
            Glib::RefPtr< const Window > get_parent() const;
            Glib::RefPtr< Window > get_toplevel();
            Glib::RefPtr< const Window > get_toplevel() const;
            Glib::ListHandle< Glib::RefPtr< Window > > get_children();
            Glib::ListHandle< Glib::RefPtr< const Window > > get_children() const;
            EventMask get_events() const;
            void set_events(EventMask event_mask);
            void set_icon_list(const Glib::ListHandle< Glib::RefPtr< Gdk::Pixbuf > > & pixbufs);
            void set_icon(const Glib::RefPtr< Window > & icon_window, const Glib::RefPtr< Pixmap > & pixmap, const Glib::RefPtr< Bitmap > & mask);
            void set_icon(const Glib::RefPtr< Window > & icon_window, const Glib::RefPtr< Pixmap > & pixmap);
            void unset_icon();
            void set_icon_name(const Glib::ustring & name);
            void set_group(const Glib::RefPtr< Window > & leader);
            Glib::RefPtr< Window > get_group();
            Glib::RefPtr< const Window > get_group() const;
            void set_decorations(WMDecoration decorations);
            bool get_decorations(WMDecoration & decorations) const;
            void set_functions(WMFunction functions);
            static Glib::ListHandle< Glib::RefPtr< Window > > get_toplevels();
            void beep();
            void iconify();
            void deiconify();
            void stick();
            void unstick();
            void maximize();
            void unmaximize();
            void register_dnd();
            void begin_resize_drag(WindowEdge edge, int button, int root_x, int root_y, guint32 timestamp);
            void begin_move_drag(int button, int root_x, int root_y, guint32 timestamp);
            void invalidate_rect(const Rectangle & rect, bool invalidate_children);
            void invalidate_region(const Region & region, bool invalidate_children = true);
            Region get_update_area();
            void freeze_updates();
            void thaw_updates();
            static void process_all_updates();
            void process_updates(bool update_children);
            static void set_debug_updates(bool setting = true);
            static void constrain_size(const Geometry & geometry, guint flags, int width, int height, int & new_width, int & new_height);
            void get_internal_paint_info(Glib::RefPtr< Drawable > & real_drawable, int & x_offset, int & y_offset) const;
            void enable_synchronized_configure();
            void configure_finished();
            void set_skip_taskbar_hint(bool skips_taskbar = true);
            void set_skip_pager_hint(bool skips_pager = true);
            void set_urgency_hint(bool urgent = true);
            void fullscreen();
            void unfullscreen();
            GrabStatus pointer_grab(bool owner_events, EventMask event_mask, const Glib::RefPtr< const Window > & confine_to, const Cursor & cursor, guint32 time_);
            GrabStatus pointer_grab(bool owner_events, EventMask event_mask, const Cursor & cursor, guint32 timestamp);
            GrabStatus pointer_grab(bool owner_events, EventMask event_mask, guint32 timestamp);
            static void pointer_ungrab(guint32 timestamp);
            GrabStatus keyboard_grab(bool owner_events, guint32 timestamp);
            static void keyboard_ungrab(guint32 timestamp);
            void set_keep_above(bool setting = true);
            void set_keep_below(bool setting = true);
            void set_opacity(double opacity);
            void set_accept_focus(bool accept_focus = true);
            void set_focus_on_map(bool focus_on_map);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gdk::Window > wrap(GdkWindowObject * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GdkPixbufFormat GdkPixbufFormat;
}
namespace Gdk {
    class PixbufFormat
    {
        public :
            typedef PixbufFormat CppObjectType;
            typedef GdkPixbufFormat BaseObjectType;
        private :
        public :
            PixbufFormat();
            explicit PixbufFormat(const GdkPixbufFormat * gobject);
            virtual ~PixbufFormat();
            PixbufFormat(const PixbufFormat & src);
            PixbufFormat & operator =(const PixbufFormat & src);
            Glib::ustring get_name() const;
            Glib::ustring get_description() const;
            Glib::StringArrayHandle get_mime_types() const;
            Glib::StringArrayHandle get_extensions() const;
            bool is_writable() const;
            bool is_scalable() const;
            bool is_disabled() const;
            void set_disabled(bool disabled = true);
            Glib::ustring get_license() const;
            GdkPixbufFormat * gobj()
            {
                return const_cast<GdkPixbufFormat * >(gobject_);
            }
            const GdkPixbufFormat * gobj() const
            {
                return gobject_;
            }
        protected :
            const GdkPixbufFormat * gobject_;
    };
}
typedef struct _GdkPixbuf GdkPixbuf;
typedef struct _GdkPixbufClass GdkPixbufClass;
namespace Gdk {
    class Pixbuf_Class;
}
namespace Gdk {
    enum Colorspace
    {
        COLORSPACE_RGB
    };
}
namespace Glib {
    template<>
    class Value< Gdk::Colorspace > : public Glib::Value_Enum< Gdk::Colorspace >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum InterpType
    {
        INTERP_NEAREST, 
        INTERP_TILES, 
        INTERP_BILINEAR, 
        INTERP_HYPER
    };
}
namespace Glib {
    template<>
    class Value< Gdk::InterpType > : public Glib::Value_Enum< Gdk::InterpType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum PixbufAlphaMode
    {
        PIXBUF_ALPHA_BILEVEL, 
        PIXBUF_ALPHA_FULL
    };
}
namespace Glib {
    template<>
    class Value< Gdk::PixbufAlphaMode > : public Glib::Value_Enum< Gdk::PixbufAlphaMode >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum PixbufRotation
    {
        PIXBUF_ROTATE_NONE = 0, 
        PIXBUF_ROTATE_COUNTERCLOCKWISE = 90, 
        PIXBUF_ROTATE_UPSIDEDOWN = 180, 
        PIXBUF_ROTATE_CLOCKWISE = 270
    };
}
namespace Glib {
    template<>
    class Value< Gdk::PixbufRotation > : public Glib::Value_Enum< Gdk::PixbufRotation >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    class PixbufError : public Glib::Error
    {
        public :
            enum Code
            {
                CORRUPT_IMAGE, 
                INSUFFICIENT_MEMORY, 
                BAD_OPTION, 
                UNKNOWN_TYPE, 
                UNSUPPORTED_OPERATION, 
                FAILED
            };
            PixbufError(Code error_code, const Glib::ustring & error_message);
            explicit PixbufError(GError * gobject);
            Code code() const;
        private :
            static void throw_func(GError * gobject);
            friend void wrap_init();
    };
}
namespace Glib {
    template<>
    class Value< Gdk::PixbufError::Code > : public Glib::Value_Enum< Gdk::PixbufError::Code >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    struct PixbufFormatTraits
    {
            typedef PixbufFormat CppType;
            typedef const GdkPixbufFormat * CType;
            typedef GdkPixbufFormat * CTypeNonConst;
            static CType to_c_type(const CppType & obj)
            {
                return obj.gobj();
            }
            static CType to_c_type(CType ptr)
            {
                return ptr;
            }
            static CppType to_cpp_type(CType ptr)
            {
                return PixbufFormat(ptr);
            }
            static void release_c_type(CType)
            {
            }
    };
    class Pixbuf : public Glib::Object
    {
        public :
            typedef Pixbuf CppObjectType;
            typedef Pixbuf_Class CppClassType;
            typedef GdkPixbuf BaseObjectType;
            typedef GdkPixbufClass BaseClassType;
        private :
            friend class Pixbuf_Class;
            static CppClassType pixbuf_class_;
        private :
            Pixbuf(const Pixbuf &);
            Pixbuf & operator =(const Pixbuf &);
        protected :
            explicit Pixbuf(const Glib::ConstructParams & construct_params);
            explicit Pixbuf(GdkPixbuf * castitem);
        public :
            virtual ~Pixbuf();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GdkPixbuf * gobj()
            {
                return reinterpret_cast<GdkPixbuf * >(gobject_);
            }
            const GdkPixbuf * gobj() const
            {
                return reinterpret_cast<GdkPixbuf * >(gobject_);
            }
            GdkPixbuf * gobj_copy();
        private :
        protected :
            Pixbuf(const Glib::RefPtr< Drawable > & src, const Glib::RefPtr< Colormap > & cmap, int src_x, int src_y, int width, int height);
            Pixbuf(const Glib::RefPtr< Drawable > & src, int src_x, int src_y, int width, int height);
            Pixbuf(const Glib::RefPtr< Drawable > & src, const Glib::RefPtr< Colormap > & cmap, int src_x, int src_y, int dest_x, int dest_y, int width, int height);
            Pixbuf(const Glib::RefPtr< Image > & src, const Glib::RefPtr< Colormap > & cmap, int src_x, int src_y, int width, int height);
            Pixbuf(const Glib::RefPtr< Image > & src, int src_x, int src_y, int width, int height);
            Pixbuf(const Glib::RefPtr< Image > & src, const Glib::RefPtr< Colormap > & cmap, int src_x, int src_y, int dest_x, int dest_y, int width, int height);
        public :
            typedef sigc::slot< void, const guint8 * > SlotDestroyData;
            static Glib::RefPtr< Gdk::Pixbuf > create(const Glib::RefPtr< Drawable > & src, const Glib::RefPtr< Colormap > & cmap, int src_x, int src_y, int dest_x, int dest_y, int width, int height);
            static Glib::RefPtr< Gdk::Pixbuf > create(const Glib::RefPtr< Image > & src, const Glib::RefPtr< Colormap > & cmap, int src_x, int src_y, int dest_x, int dest_y, int width, int height);
            static Glib::RefPtr< Pixbuf > create(const Glib::RefPtr< Drawable > & src, const Glib::RefPtr< Colormap > & cmap, int src_x, int src_y, int width, int height);
            static Glib::RefPtr< Pixbuf > create(const Glib::RefPtr< Drawable > & src, int src_x, int src_y, int width, int height);
            static Glib::RefPtr< Pixbuf > create(const Glib::RefPtr< Image > & src, const Glib::RefPtr< Colormap > & cmap, int src_x, int src_y, int width, int height);
            static Glib::RefPtr< Pixbuf > create(const Glib::RefPtr< Image > & src, int src_x, int src_y, int width, int height);
            Glib::RefPtr< Pixbuf > copy() const;
            static Glib::RefPtr< Pixbuf > create(Colorspace colorspace, bool has_alpha, int bits_per_sample, int width, int height);
            static Glib::RefPtr< Pixbuf > create_subpixbuf(const Glib::RefPtr< Pixbuf > & src_pixbuf, int src_x, int src_y, int width, int height);
            static Glib::RefPtr< Pixbuf > create_from_file(const std::string & filename);
            static Glib::RefPtr< Pixbuf > create_from_file(const std::string & filename, int width, int height, bool preserve_aspect_ratio = true);
            static Glib::RefPtr< Pixbuf > create_from_data(const guint8 * data, Colorspace colorspace, bool has_alpha, int bits_per_sample, int width, int height, int rowstride);
            static Glib::RefPtr< Pixbuf > create_from_data(const guint8 * data, Colorspace colorspace, bool has_alpha, int bits_per_sample, int width, int height, int rowstride, const SlotDestroyData & destroy_slot);
            static Glib::RefPtr< Pixbuf > create_from_xpm_data(const char *const * data);
            static Glib::RefPtr< Pixbuf > create_from_inline(int data_length, const guint8 * data, bool copy_pixels = false);
            Colorspace get_colorspace() const;
            int get_n_channels() const;
            bool get_has_alpha() const;
            int get_bits_per_sample() const;
            guint8 * get_pixels() const;
            int get_width() const;
            int get_height() const;
            int get_rowstride() const;
            void fill(guint32 pixel);
            void save(const std::string & filename, const Glib::ustring & type);
            void save(const std::string & filename, const Glib::ustring & type, const Glib::StringArrayHandle & option_keys, const Glib::StringArrayHandle & option_values);
            void save_to_buffer(gchar * & buffer, gsize & buffer_size, const Glib::ustring & type = "png");
            void save_to_buffer(gchar * & buffer, gsize & buffer_size, const Glib::ustring & type, const Glib::StringArrayHandle & option_keys, const Glib::StringArrayHandle & option_values);
            Glib::RefPtr< Gdk::Pixbuf > add_alpha(bool substitute_color, guint8 r, guint8 g, guint8 b) const;
            void copy_area(int src_x, int src_y, int width, int height, const Glib::RefPtr< Gdk::Pixbuf > & dest_pixbuf, int dest_x, int dest_y) const;
            void saturate_and_pixelate(const Glib::RefPtr< Gdk::Pixbuf > & dest, float saturation, bool pixelate) const;
            void scale(const Glib::RefPtr< Gdk::Pixbuf > & dest, int dest_x, int dest_y, int dest_width, int dest_height, double offset_x, double offset_y, double scale_x, double scale_y, InterpType interp_type) const;
            void composite(const Glib::RefPtr< Gdk::Pixbuf > & dest, int dest_x, int dest_y, int dest_width, int dest_height, double offset_x, double offset_y, double scale_x, double scale_y, InterpType interp_type, int overall_alpha) const;
            void composite_color(const Glib::RefPtr< Gdk::Pixbuf > & dest, int dest_x, int dest_y, int dest_width, int dest_height, double offset_x, double offset_y, double scale_x, double scale_y, InterpType interp_type, int overall_alpha, int check_x, int check_y, int check_size, guint32 color1, guint32 color2) const;
            Glib::RefPtr< Gdk::Pixbuf > scale_simple(int dest_width, int dest_height, InterpType interp_type) const;
            Glib::RefPtr< Gdk::Pixbuf > composite_color_simple(int dest_width, int dest_height, InterpType interp_type, int overall_alpha, int check_size, guint32 color1, guint32 color2) const;
            Glib::RefPtr< Gdk::Pixbuf > rotate_simple(PixbufRotation angle) const;
            Glib::RefPtr< Gdk::Pixbuf > flip(bool horizontal = true) const;
            void render_threshold_alpha(const Glib::RefPtr< Gdk::Bitmap > & bitmap, int src_x, int src_y, int dest_x, int dest_y, int width, int height, int alpha_threshold);
            void render_to_drawable(const Glib::RefPtr< Drawable > & drawable, const Glib::RefPtr< Gdk::GC > & gc, int src_x, int src_y, int dest_x, int dest_y, int width, int height, RgbDither dither, int x_dither, int y_dither);
            void render_to_drawable_alpha(const Glib::RefPtr< Drawable > & drawable, int src_x, int src_y, int dest_x, int dest_y, int width, int height, PixbufAlphaMode alpha_mode, int alpha_threshold, RgbDither dither, int x_dither, int y_dither);
            void render_pixmap_and_mask_for_colormap(const Glib::RefPtr< Colormap > & colormap, Glib::RefPtr< Pixmap > & pixmap_return, Glib::RefPtr< Bitmap > & mask_return, int alpha_threshold);
            void render_pixmap_and_mask(Glib::RefPtr< Pixmap > & pixmap_return, Glib::RefPtr< Bitmap > & mask_return, int alpha_threshold);
            Glib::ustring get_option(const Glib::ustring & key) const;
            typedef Glib::SListHandle< Glib::RefPtr< PixbufFormat >, PixbufFormatTraits > SListHandle_PixbufFormat;
            static SListHandle_PixbufFormat get_formats();
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gdk::Pixbuf > wrap(GdkPixbuf * object, bool take_copy = false);
}
typedef struct _GdkPixbufAnimationIter GdkPixbufAnimationIter;
typedef struct _GdkPixbufAnimationIterClass GdkPixbufAnimationIterClass;
namespace Gdk {
    class PixbufAnimationIter_Class;
}
namespace Gdk {
    class PixbufAnimationIter : public Glib::Object
    {
        public :
            typedef PixbufAnimationIter CppObjectType;
            typedef PixbufAnimationIter_Class CppClassType;
            typedef GdkPixbufAnimationIter BaseObjectType;
            typedef GdkPixbufAnimationIterClass BaseClassType;
        private :
            friend class PixbufAnimationIter_Class;
            static CppClassType pixbufanimationiter_class_;
        private :
            PixbufAnimationIter(const PixbufAnimationIter &);
            PixbufAnimationIter & operator =(const PixbufAnimationIter &);
        protected :
            explicit PixbufAnimationIter(const Glib::ConstructParams & construct_params);
            explicit PixbufAnimationIter(GdkPixbufAnimationIter * castitem);
        public :
            virtual ~PixbufAnimationIter();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GdkPixbufAnimationIter * gobj()
            {
                return reinterpret_cast<GdkPixbufAnimationIter * >(gobject_);
            }
            const GdkPixbufAnimationIter * gobj() const
            {
                return reinterpret_cast<GdkPixbufAnimationIter * >(gobject_);
            }
            GdkPixbufAnimationIter * gobj_copy();
        private :
        protected :
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gdk::PixbufAnimationIter > wrap(GdkPixbufAnimationIter * object, bool take_copy = false);
}
typedef struct _GdkPixbufAnimation GdkPixbufAnimation;
typedef struct _GdkPixbufAnimationClass GdkPixbufAnimationClass;
namespace Gdk {
    class PixbufAnimation_Class;
}
namespace Gdk {
    class PixbufAnimation : public Glib::Object
    {
        public :
            typedef PixbufAnimation CppObjectType;
            typedef PixbufAnimation_Class CppClassType;
            typedef GdkPixbufAnimation BaseObjectType;
            typedef GdkPixbufAnimationClass BaseClassType;
        private :
            friend class PixbufAnimation_Class;
            static CppClassType pixbufanimation_class_;
        private :
            PixbufAnimation(const PixbufAnimation &);
            PixbufAnimation & operator =(const PixbufAnimation &);
        protected :
            explicit PixbufAnimation(const Glib::ConstructParams & construct_params);
            explicit PixbufAnimation(GdkPixbufAnimation * castitem);
        public :
            virtual ~PixbufAnimation();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GdkPixbufAnimation * gobj()
            {
                return reinterpret_cast<GdkPixbufAnimation * >(gobject_);
            }
            const GdkPixbufAnimation * gobj() const
            {
                return reinterpret_cast<GdkPixbufAnimation * >(gobject_);
            }
            GdkPixbufAnimation * gobj_copy();
        private :
        protected :
        public :
            static Glib::RefPtr< PixbufAnimation > create_from_file(const Glib::ustring & filename);
            int get_width() const;
            int get_height() const;
            bool is_static_image() const;
            Glib::RefPtr< Pixbuf > get_static_image();
            Glib::RefPtr< PixbufAnimationIter > get_iter(const GTimeVal * start_time);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gdk::PixbufAnimation > wrap(GdkPixbufAnimation * object, bool take_copy = false);
}
typedef struct _GdkPixbufLoader GdkPixbufLoader;
typedef struct _GdkPixbufLoaderClass GdkPixbufLoaderClass;
namespace Gdk {
    class PixbufLoader_Class;
}
namespace Gdk {
    class PixbufLoader : public Glib::Object
    {
        public :
            typedef PixbufLoader CppObjectType;
            typedef PixbufLoader_Class CppClassType;
            typedef GdkPixbufLoader BaseObjectType;
            typedef GdkPixbufLoaderClass BaseClassType;
        private :
            friend class PixbufLoader_Class;
            static CppClassType pixbufloader_class_;
        private :
            PixbufLoader(const PixbufLoader &);
            PixbufLoader & operator =(const PixbufLoader &);
        protected :
            explicit PixbufLoader(const Glib::ConstructParams & construct_params);
            explicit PixbufLoader(GdkPixbufLoader * castitem);
        public :
            virtual ~PixbufLoader();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GdkPixbufLoader * gobj()
            {
                return reinterpret_cast<GdkPixbufLoader * >(gobject_);
            }
            const GdkPixbufLoader * gobj() const
            {
                return reinterpret_cast<GdkPixbufLoader * >(gobject_);
            }
            GdkPixbufLoader * gobj_copy();
        private :
        protected :
            PixbufLoader();
            explicit PixbufLoader(const Glib::ustring & image_type, bool mime_type = false);
        public :
            static Glib::RefPtr< PixbufLoader > create();
            static Glib::RefPtr< PixbufLoader > create(const Glib::ustring & image_type, bool mime_type = false);
            void set_size(int width, int height);
            void write(const guint8 * buf, gsize count);
            void close();
            Glib::RefPtr< Gdk::Pixbuf > get_pixbuf();
            Glib::RefPtr< Gdk::PixbufAnimation > get_animation();
            PixbufFormat get_format() const;
            Glib::SignalProxy0< void > signal_area_prepared();
            Glib::SignalProxy4< void, int, int, int, int > signal_area_updated();
            Glib::SignalProxy0< void > signal_closed();
            Glib::SignalProxy2< void, int, int > signal_size_prepared();
        public :
        public :
        protected :
            virtual void on_area_prepared();
            virtual void on_area_updated(int x, int y, int width, int height);
            virtual void on_closed();
    };
}
namespace Glib {
    Glib::RefPtr< Gdk::PixbufLoader > wrap(GdkPixbufLoader * object, bool take_copy = false);
}
extern "C"
{
    typedef union _GdkEvent GdkEvent;
}
namespace Gdk {
    enum EventType
    {
        NOTHING = -1, 
        DELETE, 
        DESTROY, 
        EXPOSE, 
        MOTION_NOTIFY, 
        BUTTON_PRESS, 
        DOUBLE_BUTTON_PRESS, 
        TRIPLE_BUTTON_PRESS, 
        BUTTON_RELEASE, 
        KEY_PRESS, 
        KEY_RELEASE, 
        ENTER_NOTIFY, 
        LEAVE_NOTIFY, 
        FOCUS_CHANGE, 
        CONFIGURE, 
        MAP, 
        UNMAP, 
        PROPERTY_NOTIFY, 
        SELECTION_CLEAR, 
        SELECTION_REQUEST, 
        SELECTION_NOTIFY, 
        PROXIMITY_IN, 
        PROXIMITY_OUT, 
        DRAG_ENTER, 
        DRAG_LEAVE, 
        DRAG_MOTION, 
        DRAG_STATUS, 
        DROP_START, 
        DROP_FINISHED, 
        CLIENT_EVENT, 
        VISIBILITY_NOTIFY, 
        NO_EXPOSE, 
        SCROLL, 
        WINDOW_STATE, 
        SETTING, 
        OWNER_CHANGE, 
        GRAB_BROKEN
    };
}
namespace Glib {
    template<>
    class Value< Gdk::EventType > : public Glib::Value_Enum< Gdk::EventType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum ExtensionMode
    {
        EXTENSION_EVENTS_NONE, 
        EXTENSION_EVENTS_ALL, 
        EXTENSION_EVENTS_CURSOR
    };
}
namespace Glib {
    template<>
    class Value< Gdk::ExtensionMode > : public Glib::Value_Enum< Gdk::ExtensionMode >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum AxisUse
    {
        AXIS_IGNORE, 
        AXIS_X, 
        AXIS_Y, 
        AXIS_PRESSURE, 
        AXIS_XTILT, 
        AXIS_YTILT, 
        AXIS_WHEEL, 
        AXIS_LAST
    };
}
namespace Glib {
    template<>
    class Value< Gdk::AxisUse > : public Glib::Value_Enum< Gdk::AxisUse >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    class Event
    {
        public :
            typedef Event CppObjectType;
            typedef GdkEvent BaseObjectType;
            static GType get_type() __attribute__((__const__));
            Event();
            explicit Event(GdkEvent * gobject, bool make_a_copy = true);
            Event(const Event & other);
            Event & operator =(const Event & other);
            ~Event();
            void swap(Event & other);
            GdkEvent * gobj()
            {
                return gobject_;
            }
            const GdkEvent * gobj() const
            {
                return gobject_;
            }
            GdkEvent * gobj_copy() const;
        protected :
            GdkEvent * gobject_;
        private :
        public :
            static Event get();
            static Event peek();
            static Event get_graphics_expose(const Glib::RefPtr< Window > & window);
            void put();
            static bool events_pending();
            guint32 get_time() const;
            bool get_state(ModifierType & state) const;
            bool get_coords(double & x_win, double & y_win) const;
            bool get_root_coords(double & x_root, double & y_root) const;
            bool get_axis(AxisUse axis_use, double & value) const;
            static void set_show_events(bool show_events);
            static bool get_show_events();
            void set_screen(const Glib::RefPtr< Screen > & screen);
            Glib::RefPtr< Screen > get_screen();
            Glib::RefPtr< const Screen > get_screen() const;
            bool send_client_message(NativeWindow winid);
            bool send_client_message(const Glib::RefPtr< Display > & display, NativeWindow winid);
    };
}
namespace Gdk {
    inline void swap(Event & lhs, Event & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    Gdk::Event wrap(GdkEvent * object, bool take_copy = false);
    template<>
    class Value< Gdk::Event > : public Glib::Value_Boxed< Gdk::Event >
    {
    };
}
typedef struct _GdkDevice GdkDevice;
typedef struct _GdkDeviceClass GdkDeviceClass;
namespace Gdk {
    class Device_Class;
}
namespace Gdk {
    enum InputMode
    {
        MODE_DISABLED, 
        MODE_SCREEN, 
        MODE_WINDOW
    };
}
namespace Glib {
    template<>
    class Value< Gdk::InputMode > : public Glib::Value_Enum< Gdk::InputMode >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum InputSource
    {
        SOURCE_MOUSE, 
        SOURCE_PEN, 
        SOURCE_ERASER, 
        SOURCE_CURSOR
    };
}
namespace Glib {
    template<>
    class Value< Gdk::InputSource > : public Glib::Value_Enum< Gdk::InputSource >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    class Device : public Glib::Object
    {
        public :
            typedef Device CppObjectType;
            typedef Device_Class CppClassType;
            typedef GdkDevice BaseObjectType;
            typedef GdkDeviceClass BaseClassType;
        private :
            friend class Device_Class;
            static CppClassType device_class_;
        private :
            Device(const Device &);
            Device & operator =(const Device &);
        protected :
            explicit Device(const Glib::ConstructParams & construct_params);
            explicit Device(GdkDevice * castitem);
        public :
            virtual ~Device();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GdkDevice * gobj()
            {
                return reinterpret_cast<GdkDevice * >(gobject_);
            }
            const GdkDevice * gobj() const
            {
                return reinterpret_cast<GdkDevice * >(gobject_);
            }
            GdkDevice * gobj_copy();
        private :
        protected :
            Device();
        public :
            void set_source(InputSource source);
            bool set_mode(InputMode mode);
            void set_key(guint index_, guint keyval, ModifierType modifiers);
            void set_axis_use(guint index_, AxisUse use);
            void get_state(const Glib::RefPtr< Window > & window, double & axes, ModifierType & mask);
            bool get_history(const Glib::RefPtr< Window > & window, guint32 start, guint32 stop, GdkTimeCoord * * & events, int & n_events);
            bool get_axis(double & axes, AxisUse use, double & value) const;
            Glib::ustring get_name() const;
            InputSource get_source() const;
            InputMode get_mode() const;
            bool get_has_cursor() const;
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gdk::Device > wrap(GdkDevice * object, bool take_copy = false);
}
typedef struct _GdkDisplay GdkDisplay;
typedef struct _GdkDisplayClass GdkDisplayClass;
namespace Gdk {
    class Display_Class;
}
namespace Gdk {
    class Drawable;
    class Display : public Glib::Object
    {
        public :
            typedef Display CppObjectType;
            typedef Display_Class CppClassType;
            typedef GdkDisplay BaseObjectType;
            typedef GdkDisplayClass BaseClassType;
        private :
            friend class Display_Class;
            static CppClassType display_class_;
        private :
            Display(const Display &);
            Display & operator =(const Display &);
        protected :
            explicit Display(const Glib::ConstructParams & construct_params);
            explicit Display(GdkDisplay * castitem);
        public :
            virtual ~Display();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GdkDisplay * gobj()
            {
                return reinterpret_cast<GdkDisplay * >(gobject_);
            }
            const GdkDisplay * gobj() const
            {
                return reinterpret_cast<GdkDisplay * >(gobject_);
            }
            GdkDisplay * gobj_copy();
        private :
        protected :
            Display();
        public :
            static Glib::RefPtr< Display > open(const Glib::ustring & display_name);
            Glib::ustring get_name() const;
            int get_n_screens() const;
            Glib::RefPtr< Screen > get_screen(int screen_num);
            Glib::RefPtr< const Screen > get_screen(int screen_num) const;
            Glib::RefPtr< Screen > get_default_screen();
            Glib::RefPtr< const Screen > get_default_screen() const;
            void pointer_ungrab(guint32 timestamp);
            void keyboard_ungrab(guint32 timestamp);
            bool pointer_is_grabbed() const;
            void beep();
            void sync();
            void close();
            Glib::ListHandle< Glib::RefPtr< Device > > list_devices();
            Glib::ListHandle< Glib::RefPtr< const Device > > list_devices() const;
            GdkEvent * get_event();
            const GdkEvent * get_event() const;
            GdkEvent * peek_event();
            GdkEvent * peek_event() const;
            void put_event(GdkEvent * event);
            void add_client_message_filter(Glib::ustring & message_type, GdkFilterFunc func, gpointer data);
            void set_double_click_time(guint msec);
            void set_double_click_distance(guint distance);
            static Glib::RefPtr< Display > get_default();
            Glib::RefPtr< Device > get_core_pointer();
            Glib::RefPtr< const Device > get_core_pointer() const;
            void get_pointer(Glib::RefPtr< Screen > & screen, int & x, int & y, ModifierType & mask);
            void get_pointer(int & x, int & y, ModifierType & mask);
            Glib::RefPtr< Window > get_window_at_pointer(int & win_x, int & win_y);
            Glib::RefPtr< const Window > get_window_at_pointer(int & win_x, int & win_y) const;
            Glib::RefPtr< Window > get_window_at_pointer();
            Glib::RefPtr< const Window > get_window_at_pointer() const;
            void warp_pointer(const Glib::RefPtr< Screen > & screen, int x, int y);
            GdkDisplayPointerHooks * set_pointer_hooks(const GdkDisplayPointerHooks * new_hooks);
            GdkDisplayPointerHooks * unset_pointer_hooks();
            static Glib::RefPtr< Display > open_default_libgtk_only();
            guint32 get_drag_protocol(guint32 xid, GdkDragProtocol & protocol);
            GdkKeymap * get_keymap();
            const GdkKeymap * get_keymap() const;
            bool set_selection_owner(const Glib::RefPtr< Window > & owner, Glib::ustring & selection, guint32 time_, bool send_event);
            Glib::RefPtr< Window > get_selection_owner(const Glib::ustring & selection);
            void selection_send_notify(guint32 requestor, Glib::ustring & selection, Glib::ustring & target, Glib::ustring & property, guint32 time_);
            Glib::RefPtr< Pixmap > lookup_pixmap(NativeWindow anid);
            Glib::RefPtr< const Pixmap > lookup_pixmap(NativeWindow anid) const;
            void flush();
            bool supports_cursor_alpha() const;
            bool supports_cursor_color() const;
            guint get_default_cursor_size() const;
            void get_maximal_cursor_size(guint & width, guint & height);
            Glib::RefPtr< Window > get_default_group();
            Glib::RefPtr< const Window > get_default_group() const;
            bool supports_selection_notification() const;
            bool request_selection_notification(const Glib::ustring & selection);
            bool supports_clipboard_persistence() const;
            void store_clipboard(const Glib::RefPtr< Gdk::Window > & clipboard_window, guint32 time_);
            void store_clipboard(const Glib::RefPtr< Gdk::Window > & clipboard_window, guint32 time_, const Glib::StringArrayHandle & targets);
            bool supports_shapes() const;
            bool supports_input_shapes() const;
            bool supports_composite() const;
            Glib::SignalProxy1< void, bool > signal_closed();
        public :
        public :
        protected :
            virtual void on_closed(bool is_error);
    };
}
namespace Glib {
    Glib::RefPtr< Gdk::Display > wrap(GdkDisplay * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GdkCursor GdkCursor;
}
namespace Gdk {
    enum CursorType
    {
        X_CURSOR = 0, 
        ARROW = 2, 
        BASED_ARROW_DOWN = 4, 
        BASED_ARROW_UP = 6, 
        BOAT = 8, 
        BOGOSITY = 10, 
        BOTTOM_LEFT_CORNER = 12, 
        BOTTOM_RIGHT_CORNER = 14, 
        BOTTOM_SIDE = 16, 
        BOTTOM_TEE = 18, 
        BOX_SPIRAL = 20, 
        CENTER_PTR = 22, 
        CIRCLE = 24, 
        CLOCK = 26, 
        COFFEE_MUG = 28, 
        CROSS = 30, 
        CROSS_REVERSE = 32, 
        CROSSHAIR = 34, 
        DIAMOND_CROSS = 36, 
        DOT = 38, 
        DOTBOX = 40, 
        DOUBLE_ARROW = 42, 
        DRAFT_LARGE = 44, 
        DRAFT_SMALL = 46, 
        DRAPED_BOX = 48, 
        EXCHANGE = 50, 
        FLEUR = 52, 
        GOBBLER = 54, 
        GUMBY = 56, 
        HAND1 = 58, 
        HAND2 = 60, 
        HEART = 62, 
        ICON = 64, 
        IRON_CROSS = 66, 
        LEFT_PTR = 68, 
        LEFT_SIDE = 70, 
        LEFT_TEE = 72, 
        LEFTBUTTON = 74, 
        LL_ANGLE = 76, 
        LR_ANGLE = 78, 
        MAN = 80, 
        MIDDLEBUTTON = 82, 
        MOUSE = 84, 
        PENCIL = 86, 
        PIRATE = 88, 
        PLUS = 90, 
        QUESTION_ARROW = 92, 
        RIGHT_PTR = 94, 
        RIGHT_SIDE = 96, 
        RIGHT_TEE = 98, 
        RIGHTBUTTON = 100, 
        RTL_LOGO = 102, 
        SAILBOAT = 104, 
        SB_DOWN_ARROW = 106, 
        SB_H_DOUBLE_ARROW = 108, 
        SB_LEFT_ARROW = 110, 
        SB_RIGHT_ARROW = 112, 
        SB_UP_ARROW = 114, 
        SB_V_DOUBLE_ARROW = 116, 
        SHUTTLE = 118, 
        SIZING = 120, 
        SPIDER = 122, 
        SPRAYCAN = 124, 
        STAR = 126, 
        TARGET = 128, 
        TCROSS = 130, 
        TOP_LEFT_ARROW = 132, 
        TOP_LEFT_CORNER = 134, 
        TOP_RIGHT_CORNER = 136, 
        TOP_SIDE = 138, 
        TOP_TEE = 140, 
        TREK = 142, 
        UL_ANGLE = 144, 
        UMBRELLA = 146, 
        UR_ANGLE = 148, 
        WATCH = 150, 
        XTERM = 152, 
        LAST_CURSOR = 153, 
        CURSOR_IS_PIXMAP = -1
    };
}
namespace Glib {
    template<>
    class Value< Gdk::CursorType > : public Glib::Value_Enum< Gdk::CursorType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    class Cursor
    {
        public :
            typedef Cursor CppObjectType;
            typedef GdkCursor BaseObjectType;
            static GType get_type() __attribute__((__const__));
            Cursor();
            explicit Cursor(GdkCursor * gobject, bool make_a_copy = true);
            Cursor(const Cursor & other);
            Cursor & operator =(const Cursor & other);
            ~Cursor();
            void swap(Cursor & other);
            GdkCursor * gobj()
            {
                return gobject_;
            }
            const GdkCursor * gobj() const
            {
                return gobject_;
            }
            GdkCursor * gobj_copy() const;
        protected :
            GdkCursor * gobject_;
        private :
        public :
            explicit Cursor(CursorType cursor_type);
            Cursor(const Glib::RefPtr< Pixmap > & source, const Glib::RefPtr< Pixmap > & mask, const Color & fg, const Color & bg, int x, int y);
            explicit Cursor(const Glib::RefPtr< Display > & display, CursorType cursor_type);
            Cursor(const Glib::RefPtr< Display > & display, const Glib::RefPtr< Pixbuf > & pixbuf, int x, int y);
            explicit Cursor(const Glib::RefPtr< Display > & display, const Glib::ustring & name);
            Glib::RefPtr< Display > get_display();
            Glib::RefPtr< const Display > get_display() const;
            Glib::RefPtr< Gdk::Pixbuf > get_image();
            Glib::RefPtr< const Gdk::Pixbuf > get_image() const;
    };
}
namespace Gdk {
    inline void swap(Cursor & lhs, Cursor & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    Gdk::Cursor wrap(GdkCursor * object, bool take_copy = false);
    template<>
    class Value< Gdk::Cursor > : public Glib::Value_Boxed< Gdk::Cursor >
    {
    };
}
typedef struct _GdkDisplayManager GdkDisplayManager;
typedef struct _GdkDisplayManagerClass GdkDisplayManagerClass;
namespace Gdk {
    class DisplayManager_Class;
}
namespace Gdk {
    class DisplayManager : public Glib::Object
    {
        public :
            typedef DisplayManager CppObjectType;
            typedef DisplayManager_Class CppClassType;
            typedef GdkDisplayManager BaseObjectType;
            typedef GdkDisplayManagerClass BaseClassType;
        private :
            friend class DisplayManager_Class;
            static CppClassType displaymanager_class_;
        private :
            DisplayManager(const DisplayManager &);
            DisplayManager & operator =(const DisplayManager &);
        protected :
            explicit DisplayManager(const Glib::ConstructParams & construct_params);
            explicit DisplayManager(GdkDisplayManager * castitem);
        public :
            virtual ~DisplayManager();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GdkDisplayManager * gobj()
            {
                return reinterpret_cast<GdkDisplayManager * >(gobject_);
            }
            const GdkDisplayManager * gobj() const
            {
                return reinterpret_cast<GdkDisplayManager * >(gobject_);
            }
            GdkDisplayManager * gobj_copy();
        private :
        protected :
        public :
            static Glib::RefPtr< DisplayManager > get();
            Glib::RefPtr< Display > get_default_display();
            Glib::RefPtr< const Display > get_default_display() const;
            void set_default_display(const Glib::RefPtr< Display > & display);
            Glib::SListHandle< Glib::RefPtr< Display > > list_displays();
            Glib::PropertyProxy< Glib::RefPtr< Display > > property_default_display();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Display > > property_default_display() const;
            Glib::SignalProxy1< void, const Glib::RefPtr< Display > & > signal_display_opened();
        public :
        public :
        protected :
            virtual void on_display_opened(const Glib::RefPtr< Display > & display);
    };
}
namespace Glib {
    Glib::RefPtr< Gdk::DisplayManager > wrap(GdkDisplayManager * object, bool take_copy = false);
}
namespace Gdk {
    int screen_width();
    int screen_height();
    int screen_width_mm();
    int screen_height_mm();
    void flush();
    namespace Cairo {
        void set_source_color(::Cairo::RefPtr< ::Cairo::Context > & context, const Gdk::Color & color);
        void set_source_color(const ::Cairo::RefPtr< ::Cairo::Context > & context, const Gdk::Color & color);
        void set_source_pixbuf(::Cairo::RefPtr< ::Cairo::Context > & context, const Glib::RefPtr< Gdk::Pixbuf > & pixbuf, double pixbuf_x, double pixbuf_y);
        void set_source_pixbuf(const ::Cairo::RefPtr< ::Cairo::Context > & context, const Glib::RefPtr< Gdk::Pixbuf > & pixbuf, double pixbuf_x, double pixbuf_y);
        void set_source_pixmap(::Cairo::RefPtr< ::Cairo::Context > & context, const Glib::RefPtr< Gdk::Pixmap > & pixmap, double pixmap_x, double pixmap_y);
        void set_source_pixmap(const ::Cairo::RefPtr< ::Cairo::Context > & context, const Glib::RefPtr< Gdk::Pixmap > & pixmap, double pixmap_x, double pixmap_y);
        void rectangle(::Cairo::RefPtr< ::Cairo::Context > & context, const Gdk::Rectangle & rectangle);
        void add_rectangle_to_path(const ::Cairo::RefPtr< ::Cairo::Context > & context, const Gdk::Rectangle & rectangle);
        void region(::Cairo::RefPtr< ::Cairo::Context > & context, const Gdk::Region & region);
        void add_region_to_path(const ::Cairo::RefPtr< ::Cairo::Context > & context, const Gdk::Region & region);
    }
}
namespace Gdk {
    Glib::RefPtr< Colormap > rgb_get_colormap();
    Glib::RefPtr< Visual > rgb_get_visual();
    bool rgb_ditherable();
}
namespace Gtk {
    using Glib::unconst;
}
typedef struct _GtkObject GtkObject;
typedef struct _GtkObjectClass GtkObjectClass;
namespace Gtk {
    class Object_Class;
}
namespace Gtk {
    class Object;
    template<class T >
    T * manage(T * obj)
    {
        obj->set_manage();
        return obj;
    }
    class Object : public Glib::Object
    {
        public :
            typedef Object CppObjectType;
            typedef Object_Class CppClassType;
            typedef GtkObject BaseObjectType;
            typedef GtkObjectClass BaseClassType;
            virtual ~Object();
        private :
            friend class Object_Class;
            static CppClassType object_class_;
            Object(const Object &);
            Object & operator =(const Object &);
        protected :
            explicit Object(const Glib::ConstructParams & construct_params);
            explicit Object(GtkObject * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkObject * gobj()
            {
                return reinterpret_cast<GtkObject * >(gobject_);
            }
            const GtkObject * gobj() const
            {
                return reinterpret_cast<GtkObject * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            virtual void set_manage();
            Glib::PropertyProxy< void * > property_user_data();
            Glib::PropertyProxy_ReadOnly< void * > property_user_data() const;
            bool is_managed_() const;
        protected :
            void destroy_();
            void _init_unmanage(bool is_toplevel = false);
            virtual void destroy_notify_();
            void disconnect_cpp_wrapper();
            void _destroy_c_instance();
            static void callback_destroy_(GObject * gobject, void * data);
            bool referenced_;
            bool gobject_disposed_;
    };
}
namespace Glib {
    Gtk::Object * wrap(GtkObject * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _AtkComponentIface AtkComponentIface;
    typedef struct _AtkObject AtkObject;
    typedef void (* AtkFocusHandler)(AtkObject *, gboolean);
}
typedef struct _AtkComponent AtkComponent;
typedef struct _AtkComponentClass AtkComponentClass;
namespace Atk {
    class Component_Class;
}
namespace Atk {
    enum CoordType
    {
        XY_SCREEN, 
        XY_WINDOW
    };
}
namespace Glib {
    template<>
    class Value< Atk::CoordType > : public Glib::Value_Enum< Atk::CoordType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Atk {
    enum Layer
    {
        LAYER_INVALID, 
        LAYER_BACKGROUND, 
        LAYER_CANVAS, 
        LAYER_WIDGET, 
        LAYER_MDI, 
        LAYER_POPUP, 
        LAYER_OVERLAY, 
        LAYER_WINDOW
    };
}
namespace Glib {
    template<>
    class Value< Atk::Layer > : public Glib::Value_Enum< Atk::Layer >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Atk {
    class Object;
    class Component : public Glib::Interface
    {
        public :
            typedef Component CppObjectType;
            typedef Component_Class CppClassType;
            typedef AtkComponent BaseObjectType;
            typedef AtkComponentIface BaseClassType;
        private :
            friend class Component_Class;
            static CppClassType component_class_;
            Component(const Component &);
            Component & operator =(const Component &);
        protected :
            Component();
            explicit Component(const Glib::Interface_Class & interface_class);
        public :
            explicit Component(AtkComponent * castitem);
        protected :
        public :
            virtual ~Component();
            static void add_interface(GType gtype_implementer);
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            AtkComponent * gobj()
            {
                return reinterpret_cast<AtkComponent * >(gobject_);
            }
            const AtkComponent * gobj() const
            {
                return reinterpret_cast<AtkComponent * >(gobject_);
            }
        private :
        public :
            guint add_focus_handler(AtkFocusHandler handler);
            bool contains(int x, int y, CoordType coord_type) const;
            Glib::RefPtr< Atk::Object > get_accessible_at_point(int x, int y, CoordType coord_type);
            void get_extents(int & x, int & y, int & width, int & height, CoordType coord_type) const;
            void get_position(int & x, int & y, CoordType coord_type) const;
            void get_size(int & width, int & height) const;
            Layer get_layer() const;
            int get_mdi_zorder() const;
            bool grab_focus();
            void remove_focus_handler(guint handler_id);
            bool set_extents(int x, int y, int width, int height, CoordType coord_type);
            bool set_position(int x, int y, CoordType coord_type);
            bool set_size(int width, int height);
        protected :
            virtual guint add_focus_handler_vfunc(AtkFocusHandler handler);
            virtual bool contains_vfunc(int x, int y, CoordType coord_type) const;
            virtual Glib::RefPtr< Atk::Object > get_accessible_at_point_vfunc(int x, int y, CoordType coord_type);
            virtual void get_extents_vfunc(int & x, int & y, int & width, int & height, CoordType coord_type) const;
            virtual void get_position_vfunc(int & x, int & y, CoordType coord_type) const;
            virtual void get_size_vfunc(int & width, int & height) const;
            virtual Layer get_layer_vfunc() const;
            virtual int get_mdi_zorder_vfunc() const;
            virtual bool grab_focus_vfunc();
            virtual void remove_focus_handler_vfunc(guint handler_id);
            virtual bool set_extents_vfunc(int x, int y, int width, int height, CoordType coord_type);
            virtual bool set_position_vfunc(int x, int y, CoordType coord_type);
            virtual bool set_size_vfunc(int width, int height);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Atk::Component > wrap(AtkComponent * object, bool take_copy = false);
}
typedef struct _AtkRelation AtkRelation;
typedef struct _AtkRelationClass AtkRelationClass;
namespace Atk {
    class Relation_Class;
}
namespace Atk {
    enum RelationType
    {
        RELATION_NULL, 
        RELATION_CONTROLLED_BY, 
        RELATION_CONTROLLER_FOR, 
        RELATION_LABEL_FOR, 
        RELATION_LABELLED_BY, 
        RELATION_MEMBER_OF, 
        RELATION_NODE_CHILD_OF, 
        RELATION_FLOWS_TO, 
        RELATION_FLOWS_FROM, 
        RELATION_SUBWINDOW_OF, 
        RELATION_EMBEDS, 
        RELATION_EMBEDDED_BY, 
        RELATION_POPUP_FOR, 
        RELATION_PARENT_WINDOW_OF, 
        RELATION_LAST_DEFINED
    };
}
namespace Glib {
    template<>
    class Value< Atk::RelationType > : public Glib::Value_Enum< Atk::RelationType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Atk {
    class Object;
    class Relation : public Glib::Object
    {
        public :
            typedef Relation CppObjectType;
            typedef Relation_Class CppClassType;
            typedef AtkRelation BaseObjectType;
            typedef AtkRelationClass BaseClassType;
        private :
            friend class Relation_Class;
            static CppClassType relation_class_;
        private :
            Relation(const Relation &);
            Relation & operator =(const Relation &);
        protected :
            explicit Relation(const Glib::ConstructParams & construct_params);
            explicit Relation(AtkRelation * castitem);
        public :
            virtual ~Relation();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            AtkRelation * gobj()
            {
                return reinterpret_cast<AtkRelation * >(gobject_);
            }
            const AtkRelation * gobj() const
            {
                return reinterpret_cast<AtkRelation * >(gobject_);
            }
            AtkRelation * gobj_copy();
        private :
        protected :
            explicit Relation(const Glib::ArrayHandle< Glib::RefPtr< Atk::Object > > & targets, RelationType relationship);
        public :
            static Glib::RefPtr< Relation > create(const Glib::ArrayHandle< Glib::RefPtr< Atk::Object > > & targets, RelationType relationship = RELATION_NULL);
            RelationType get_relation_type() const;
            Glib::ArrayHandle< Glib::RefPtr< Atk::Object > > get_target();
            Glib::ArrayHandle< Glib::RefPtr< const Atk::Object > > get_target() const;
            void add_target(const Glib::RefPtr< Atk::Object > & target);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Atk::Relation > wrap(AtkRelation * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _AtkPropertyValues AtkPropertyValues;
}
typedef struct _AtkObject AtkObject;
typedef struct _AtkObjectClass AtkObjectClass;
namespace Atk {
    class Object_Class;
}
namespace Atk {
    enum Role
    {
        ROLE_INVALID, 
        ROLE_ACCEL_LABEL, 
        ROLE_ALERT, 
        ROLE_ANIMATION, 
        ROLE_ARROW, 
        ROLE_CALENDAR, 
        ROLE_CANVAS, 
        ROLE_CHECK_BOX, 
        ROLE_CHECK_MENU_ITEM, 
        ROLE_COLOR_CHOOSER, 
        ROLE_COLUMN_HEADER, 
        ROLE_COMBO_BOX, 
        ROLE_DATE_EDITOR, 
        ROLE_DESKTOP_ICON, 
        ROLE_DESKTOP_FRAME, 
        ROLE_DIAL, 
        ROLE_DIALOG, 
        ROLE_DIRECTORY_PANE, 
        ROLE_DRAWING_AREA, 
        ROLE_FILE_CHOOSER, 
        ROLE_FILLER, 
        ROLE_FONT_CHOOSER, 
        ROLE_FRAME, 
        ROLE_GLASS_PANE, 
        ROLE_HTML_CONTAINER, 
        ROLE_ICON, 
        ROLE_IMAGE, 
        ROLE_INTERNAL_FRAME, 
        ROLE_LABEL, 
        ROLE_LAYERED_PANE, 
        ROLE_LIST, 
        ROLE_LIST_ITEM, 
        ROLE_MENU, 
        ROLE_MENU_BAR, 
        ROLE_MENU_ITEM, 
        ROLE_OPTION_PANE, 
        ROLE_PAGE_TAB, 
        ROLE_PAGE_TAB_LIST, 
        ROLE_PANEL, 
        ROLE_PASSWORD_TEXT, 
        ROLE_POPUP_MENU, 
        ROLE_PROGRESS_BAR, 
        ROLE_PUSH_BUTTON, 
        ROLE_RADIO_BUTTON, 
        ROLE_RADIO_MENU_ITEM, 
        ROLE_ROOT_PANE, 
        ROLE_ROW_HEADER, 
        ROLE_SCROLL_BAR, 
        ROLE_SCROLL_PANE, 
        ROLE_SEPARATOR, 
        ROLE_SLIDER, 
        ROLE_SPLIT_PANE, 
        ROLE_SPIN_BUTTON, 
        ROLE_STATUSBAR, 
        ROLE_TABLE, 
        ROLE_TABLE_CELL, 
        ROLE_TABLE_COLUMN_HEADER, 
        ROLE_TABLE_ROW_HEADER, 
        ROLE_TEAR_OFF_MENU_ITEM, 
        ROLE_TERMINAL, 
        ROLE_TEXT, 
        ROLE_TOGGLE_BUTTON, 
        ROLE_TOOL_BAR, 
        ROLE_TOOL_TIP, 
        ROLE_TREE, 
        ROLE_TREE_TABLE, 
        ROLE_UNKNOWN, 
        ROLE_VIEWPORT, 
        ROLE_WINDOW, 
        ROLE_HEADER, 
        ROLE_FOOTER, 
        ROLE_PARAGRAPH, 
        ROLE_RULER, 
        ROLE_APPLICATION, 
        ROLE_AUTOCOMPLETE, 
        ROLE_EDITBAR, 
        ROLE_EMBEDDED, 
        ROLE_LAST_DEFINED
    };
}
namespace Glib {
    template<>
    class Value< Atk::Role > : public Glib::Value_Enum< Atk::Role >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Atk {
    class RelationSet;
    class Relation;
    class StateSet;
    typedef guint64 State;
    class Object : public Glib::Object
    {
        public :
            typedef Object CppObjectType;
            typedef Object_Class CppClassType;
            typedef AtkObject BaseObjectType;
            typedef AtkObjectClass BaseClassType;
        private :
            friend class Object_Class;
            static CppClassType object_class_;
        private :
            Object(const Object &);
            Object & operator =(const Object &);
        protected :
            explicit Object(const Glib::ConstructParams & construct_params);
            explicit Object(AtkObject * castitem);
        public :
            virtual ~Object();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            AtkObject * gobj()
            {
                return reinterpret_cast<AtkObject * >(gobject_);
            }
            const AtkObject * gobj() const
            {
                return reinterpret_cast<AtkObject * >(gobject_);
            }
            AtkObject * gobj_copy();
        private :
        public :
            Glib::ustring get_name() const;
            Glib::ustring get_description() const;
            Glib::RefPtr< Atk::Object > get_parent();
            int get_n_accessible_children() const;
            Glib::RefPtr< Atk::Object > get_accessible_child(int i);
            Glib::RefPtr< RelationSet > get_relation_set();
            Role get_role() const;
            Glib::RefPtr< StateSet > get_state_set();
            int get_index_in_parent();
            void set_name(const Glib::ustring & name);
            void set_description(const Glib::ustring & description);
            void set_parent(const Glib::RefPtr< Atk::Object > & parent);
            void set_role(Role role);
            void notify_state_change(State state, bool value);
            bool add_relationship(RelationType relationship, const Glib::RefPtr< Object > & target);
            bool remove_relationship(RelationType relationship, const Glib::RefPtr< Object > & target);
            Glib::SignalProxy2< void, guint, gpointer > signal_children_changed();
            Glib::SignalProxy1< void, bool > signal_focus_event();
            Glib::SignalProxy1< void, AtkPropertyValues * > signal_property_change();
            Glib::SignalProxy2< void, const Glib::ustring &, bool > signal_state_change();
            Glib::SignalProxy0< void > signal_visible_data_changed();
            Glib::SignalProxy1< void, void ** > signal_active_descendant_changed();
            Glib::PropertyProxy< Glib::ustring > property_accessible_name();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_accessible_name() const;
            Glib::PropertyProxy< Glib::ustring > property_accessible_description();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_accessible_description() const;
            Glib::PropertyProxy< Glib::RefPtr< Atk::Object > > property_accessible_parent();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Atk::Object > > property_accessible_parent() const;
            Glib::PropertyProxy< double > property_accessible_value();
            Glib::PropertyProxy_ReadOnly< double > property_accessible_value() const;
            Glib::PropertyProxy< int > property_accessible_role();
            Glib::PropertyProxy_ReadOnly< int > property_accessible_role() const;
            Glib::PropertyProxy_ReadOnly< int > property_accessible_component_layer() const;
            Glib::PropertyProxy_ReadOnly< int > property_accessible_component_mdi_zorder() const;
            Glib::PropertyProxy< Glib::ustring > property_accessible_table_caption();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_accessible_table_caption() const;
            Glib::PropertyProxy< Glib::ustring > property_accessible_table_column_description();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_accessible_table_column_description() const;
            Glib::PropertyProxy< Glib::RefPtr< Atk::Object > > property_accessible_table_column_header();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Atk::Object > > property_accessible_table_column_header() const;
            Glib::PropertyProxy< Glib::ustring > property_accessible_table_row_description();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_accessible_table_row_description() const;
            Glib::PropertyProxy< Glib::RefPtr< Atk::Object > > property_accessible_table_row_header();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Atk::Object > > property_accessible_table_row_header() const;
            Glib::PropertyProxy< Glib::RefPtr< Atk::Object > > property_accessible_table_summary();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Atk::Object > > property_accessible_table_summary() const;
        public :
        public :
        protected :
            virtual void on_children_changed(guint change_index, gpointer changed_child);
            virtual void on_focus_event(bool focus_in);
            virtual void on_property_change(AtkPropertyValues * values);
            virtual void on_state_change(const Glib::ustring & name, bool state_set);
            virtual void on_visible_data_changed();
            virtual void on_active_descendant_changed(void * * child);
    };
}
namespace Glib {
    Glib::RefPtr< Atk::Object > wrap(AtkObject * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _AtkImplementorIface AtkImplementorIface;
    typedef struct _AtkImplementor AtkImplementor;
}
typedef struct _AtkImplementor AtkImplementor;
typedef struct _AtkImplementorClass AtkImplementorClass;
namespace Atk {
    class Implementor_Class;
}
namespace Atk {
    class Implementor : public Glib::Interface
    {
        public :
            typedef Implementor CppObjectType;
            typedef Implementor_Class CppClassType;
            typedef AtkImplementor BaseObjectType;
            typedef AtkImplementorIface BaseClassType;
        private :
            friend class Implementor_Class;
            static CppClassType implementor_class_;
            Implementor(const Implementor &);
            Implementor & operator =(const Implementor &);
        protected :
            Implementor();
            explicit Implementor(const Glib::Interface_Class & interface_class);
        public :
            explicit Implementor(AtkImplementor * castitem);
        protected :
        public :
            virtual ~Implementor();
            static void add_interface(GType gtype_implementer);
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            AtkImplementor * gobj()
            {
                return reinterpret_cast<AtkImplementor * >(gobject_);
            }
            const AtkImplementor * gobj() const
            {
                return reinterpret_cast<AtkImplementor * >(gobject_);
            }
        private :
        protected :
            virtual Glib::RefPtr< Object > ref_accessibile_vfunc();
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Atk::Implementor > wrap(AtkImplementor * object, bool take_copy = false);
}
namespace Gtk {
    struct BuiltinStockID;
    class StockID
    {
        public :
            StockID();
            StockID(const BuiltinStockID & id);
            explicit StockID(const Glib::ustring & id);
            explicit StockID(const char * id);
            ~StockID();
            StockID(const StockID & other);
            StockID & operator =(const StockID & other);
            bool equal(const StockID & rhs) const;
            Glib::ustring get_string() const;
            const char * get_c_str() const;
        protected :
            Glib::ustring id_;
    };
    inline bool operator ==(const StockID & lhs, const StockID & rhs)
    {
        return lhs.equal(rhs);
    }
    inline bool operator !=(const StockID & lhs, const StockID & rhs)
    {
        return !lhs.equal(rhs);
    }
    struct StockID_Traits : public Glib::Container_Helpers::TypeTraits< Glib::ustring >
    {
            typedef Gtk::StockID CppType;
            static const char * to_c_type(const StockID & id)
            {
                return id.get_c_str();
            }
            static StockID to_cpp_type(const char * str)
            {
                return StockID(str);
            }
    };
}
namespace Glib {
    template<>
    class Value< Gtk::StockID > : public Glib::ValueBase_String
    {
        public :
            typedef Gtk::StockID CppType;
            void set(const Gtk::StockID & data)
            {
                set_cstring(data.get_c_str());
            }
            Gtk::StockID get() const
            {
                return Gtk::StockID(get_cstring());
            }
    };
}
typedef struct _GdkDragContext GdkDragContext;
typedef struct _GdkDragContextClass GdkDragContextClass;
namespace Gdk {
    class DragContext_Class;
}
namespace Gtk {
    class Widget;
}
namespace Gdk {
    enum DragAction
    {
        ACTION_DEFAULT = 1 << 0, 
        ACTION_COPY = 1 << 1, 
        ACTION_MOVE = 1 << 2, 
        ACTION_LINK = 1 << 3, 
        ACTION_PRIVATE = 1 << 4, 
        ACTION_ASK = 1 << 5
    };
    inline DragAction operator |(DragAction lhs, DragAction rhs)
    {
        return static_cast<DragAction >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline DragAction operator &(DragAction lhs, DragAction rhs)
    {
        return static_cast<DragAction >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline DragAction operator ^(DragAction lhs, DragAction rhs)
    {
        return static_cast<DragAction >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline DragAction operator ~(DragAction flags)
    {
        return static_cast<DragAction >(~static_cast<unsigned >(flags));
    }
    inline DragAction & operator |=(DragAction & lhs, DragAction rhs)
    {
        return (lhs = static_cast<DragAction >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline DragAction & operator &=(DragAction & lhs, DragAction rhs)
    {
        return (lhs = static_cast<DragAction >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline DragAction & operator ^=(DragAction & lhs, DragAction rhs)
    {
        return (lhs = static_cast<DragAction >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gdk::DragAction > : public Glib::Value_Flags< Gdk::DragAction >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    enum DragProtocol
    {
        DRAG_PROTO_MOTIF, 
        DRAG_PROTO_XDND, 
        DRAG_PROTO_NONE, 
        DRAG_PROTO_WIN32_DROPFILES, 
        DRAG_PROTO_OLE2, 
        DRAG_PROTO_LOCAL
    };
}
namespace Glib {
    template<>
    class Value< Gdk::DragProtocol > : public Glib::Value_Enum< Gdk::DragProtocol >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gdk {
    class DragContext : public Glib::Object
    {
        public :
            typedef DragContext CppObjectType;
            typedef DragContext_Class CppClassType;
            typedef GdkDragContext BaseObjectType;
            typedef GdkDragContextClass BaseClassType;
        private :
            friend class DragContext_Class;
            static CppClassType dragcontext_class_;
        private :
            DragContext(const DragContext &);
            DragContext & operator =(const DragContext &);
        protected :
            explicit DragContext(const Glib::ConstructParams & construct_params);
            explicit DragContext(GdkDragContext * castitem);
        public :
            virtual ~DragContext();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GdkDragContext * gobj()
            {
                return reinterpret_cast<GdkDragContext * >(gobject_);
            }
            const GdkDragContext * gobj() const
            {
                return reinterpret_cast<GdkDragContext * >(gobject_);
            }
            GdkDragContext * gobj_copy();
        private :
        protected :
            DragContext();
        public :
            static Glib::RefPtr< DragContext > create();
            void drag_status(DragAction action, guint32 time);
            void drag_refuse(guint32 time);
            void drop_reply(bool ok, guint32 time);
            void drop_finish(bool success, guint32 time);
            Glib::ustring get_selection() const;
            void drag_finish(bool success, bool del, guint32 time);
            void set_icon(const Glib::RefPtr< Gdk::Colormap > & colormap, const Glib::RefPtr< Gdk::Pixmap > & pixmap, const Glib::RefPtr< Gdk::Bitmap > & mask, int hot_x, int hot_y);
            void set_icon(const Glib::RefPtr< Gdk::Pixbuf > & pixbuf, int hot_x, int hot_y);
            void set_icon(const Glib::ustring & stock_id, int hot_x, int hot_y);
            void set_icon_name(const Glib::ustring & name, int hot_x, int hot_y);
            void set_icon();
            Glib::RefPtr< Window > get_source_window();
            Glib::RefPtr< const Window > get_source_window() const;
            Glib::RefPtr< Window > get_destination_window();
            Glib::RefPtr< const Window > get_destination_window() const;
            Gdk::ListHandle_AtomString get_targets() const;
            DragProtocol get_protocol() const;
            bool get_is_source() const;
            DragAction get_actions() const;
            DragAction get_suggested_action() const;
            DragAction get_action() const;
            guint32 get_start_time() const;
            void find_window_for_screen(const Glib::RefPtr< Window > & drag_window, const Glib::RefPtr< Screen > & screen, int x_root, int y_root, Glib::RefPtr< Window > & dest_window, DragProtocol * protocol) const;
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gdk::DragContext > wrap(GdkDragContext * object, bool take_copy = false);
}
namespace Gtk {
    enum AccelFlags
    {
        ACCEL_VISIBLE = 1 << 0, 
        ACCEL_LOCKED = 1 << 1, 
        ACCEL_MASK = 0x07
    };
    inline AccelFlags operator |(AccelFlags lhs, AccelFlags rhs)
    {
        return static_cast<AccelFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline AccelFlags operator &(AccelFlags lhs, AccelFlags rhs)
    {
        return static_cast<AccelFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline AccelFlags operator ^(AccelFlags lhs, AccelFlags rhs)
    {
        return static_cast<AccelFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline AccelFlags operator ~(AccelFlags flags)
    {
        return static_cast<AccelFlags >(~static_cast<unsigned >(flags));
    }
    inline AccelFlags & operator |=(AccelFlags & lhs, AccelFlags rhs)
    {
        return (lhs = static_cast<AccelFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline AccelFlags & operator &=(AccelFlags & lhs, AccelFlags rhs)
    {
        return (lhs = static_cast<AccelFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline AccelFlags & operator ^=(AccelFlags & lhs, AccelFlags rhs)
    {
        return (lhs = static_cast<AccelFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gtk::AccelFlags > : public Glib::Value_Flags< Gtk::AccelFlags >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum AnchorType
    {
        ANCHOR_CENTER, 
        ANCHOR_NORTH, 
        ANCHOR_NORTH_WEST, 
        ANCHOR_NORTH_EAST, 
        ANCHOR_SOUTH, 
        ANCHOR_SOUTH_WEST, 
        ANCHOR_SOUTH_EAST, 
        ANCHOR_WEST, 
        ANCHOR_EAST, 
        ANCHOR_N = ANCHOR_NORTH, 
        ANCHOR_NW = ANCHOR_NORTH_WEST, 
        ANCHOR_NE = ANCHOR_NORTH_EAST, 
        ANCHOR_S = ANCHOR_SOUTH, 
        ANCHOR_SW = ANCHOR_SOUTH_WEST, 
        ANCHOR_SE = ANCHOR_SOUTH_EAST, 
        ANCHOR_W = ANCHOR_WEST, 
        ANCHOR_E = ANCHOR_EAST
    };
}
namespace Glib {
    template<>
    class Value< Gtk::AnchorType > : public Glib::Value_Enum< Gtk::AnchorType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum ArrowType
    {
        ARROW_UP, 
        ARROW_DOWN, 
        ARROW_LEFT, 
        ARROW_RIGHT, 
        ARROW_NONE
    };
}
namespace Glib {
    template<>
    class Value< Gtk::ArrowType > : public Glib::Value_Enum< Gtk::ArrowType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum AttachOptions
    {
        EXPAND = 1 << 0, 
        SHRINK = 1 << 1, 
        FILL = 1 << 2
    };
    inline AttachOptions operator |(AttachOptions lhs, AttachOptions rhs)
    {
        return static_cast<AttachOptions >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline AttachOptions operator &(AttachOptions lhs, AttachOptions rhs)
    {
        return static_cast<AttachOptions >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline AttachOptions operator ^(AttachOptions lhs, AttachOptions rhs)
    {
        return static_cast<AttachOptions >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline AttachOptions operator ~(AttachOptions flags)
    {
        return static_cast<AttachOptions >(~static_cast<unsigned >(flags));
    }
    inline AttachOptions & operator |=(AttachOptions & lhs, AttachOptions rhs)
    {
        return (lhs = static_cast<AttachOptions >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline AttachOptions & operator &=(AttachOptions & lhs, AttachOptions rhs)
    {
        return (lhs = static_cast<AttachOptions >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline AttachOptions & operator ^=(AttachOptions & lhs, AttachOptions rhs)
    {
        return (lhs = static_cast<AttachOptions >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gtk::AttachOptions > : public Glib::Value_Flags< Gtk::AttachOptions >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum ButtonBoxStyle
    {
        BUTTONBOX_DEFAULT_STYLE, 
        BUTTONBOX_SPREAD, 
        BUTTONBOX_EDGE, 
        BUTTONBOX_START, 
        BUTTONBOX_END, 
        BUTTONBOX_CENTER
    };
}
namespace Glib {
    template<>
    class Value< Gtk::ButtonBoxStyle > : public Glib::Value_Enum< Gtk::ButtonBoxStyle >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum CurveType
    {
        CURVE_TYPE_LINEAR, 
        CURVE_TYPE_SPLINE, 
        CURVE_TYPE_FREE
    };
}
namespace Glib {
    template<>
    class Value< Gtk::CurveType > : public Glib::Value_Enum< Gtk::CurveType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum DeleteType
    {
        DELETE_CHARS, 
        DELETE_WORDS, 
        DELETE_DISPLAY_LINES, 
        DELETE_DISPLAY_LINE_ENDS, 
        DELETE_PARAGRAPH_ENDS, 
        DELETE_PARAGRAPHS, 
        DELETE_WHITESPACE
    };
}
namespace Glib {
    template<>
    class Value< Gtk::DeleteType > : public Glib::Value_Enum< Gtk::DeleteType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum DirectionType
    {
        DIR_TAB_FORWARD, 
        DIR_TAB_BACKWARD, 
        DIR_UP, 
        DIR_DOWN, 
        DIR_LEFT, 
        DIR_RIGHT
    };
}
namespace Glib {
    template<>
    class Value< Gtk::DirectionType > : public Glib::Value_Enum< Gtk::DirectionType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum ExpanderStyle
    {
        EXPANDER_COLLAPSED, 
        EXPANDER_SEMI_COLLAPSED, 
        EXPANDER_SEMI_EXPANDED, 
        EXPANDER_EXPANDED
    };
}
namespace Glib {
    template<>
    class Value< Gtk::ExpanderStyle > : public Glib::Value_Enum< Gtk::ExpanderStyle >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum BuiltinIconSize
    {
        ICON_SIZE_INVALID, 
        ICON_SIZE_MENU, 
        ICON_SIZE_SMALL_TOOLBAR, 
        ICON_SIZE_LARGE_TOOLBAR, 
        ICON_SIZE_BUTTON, 
        ICON_SIZE_DND, 
        ICON_SIZE_DIALOG
    };
}
namespace Glib {
    template<>
    class Value< Gtk::BuiltinIconSize > : public Glib::Value_Enum< Gtk::BuiltinIconSize >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum TextDirection
    {
        TEXT_DIR_NONE, 
        TEXT_DIR_LTR, 
        TEXT_DIR_RTL
    };
}
namespace Glib {
    template<>
    class Value< Gtk::TextDirection > : public Glib::Value_Enum< Gtk::TextDirection >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum Justification
    {
        JUSTIFY_LEFT, 
        JUSTIFY_RIGHT, 
        JUSTIFY_CENTER, 
        JUSTIFY_FILL
    };
}
namespace Glib {
    template<>
    class Value< Gtk::Justification > : public Glib::Value_Enum< Gtk::Justification >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum MenuDirectionType
    {
        MENU_DIR_PARENT, 
        MENU_DIR_CHILD, 
        MENU_DIR_NEXT, 
        MENU_DIR_PREV
    };
}
namespace Glib {
    template<>
    class Value< Gtk::MenuDirectionType > : public Glib::Value_Enum< Gtk::MenuDirectionType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum MetricType
    {
        PIXELS, 
        INCHES, 
        CENTIMETERS
    };
}
namespace Glib {
    template<>
    class Value< Gtk::MetricType > : public Glib::Value_Enum< Gtk::MetricType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum MovementStep
    {
        MOVEMENT_LOGICAL_POSITIONS, 
        MOVEMENT_VISUAL_POSITIONS, 
        MOVEMENT_WORDS, 
        MOVEMENT_DISPLAY_LINES, 
        MOVEMENT_DISPLAY_LINE_ENDS, 
        MOVEMENT_PARAGRAPHS, 
        MOVEMENT_PARAGRAPH_ENDS, 
        MOVEMENT_PAGES, 
        MOVEMENT_BUFFER_ENDS, 
        MOVEMENT_HORIZONTAL_PAGES
    };
}
namespace Glib {
    template<>
    class Value< Gtk::MovementStep > : public Glib::Value_Enum< Gtk::MovementStep >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum Orientation
    {
        ORIENTATION_HORIZONTAL, 
        ORIENTATION_VERTICAL
    };
}
namespace Glib {
    template<>
    class Value< Gtk::Orientation > : public Glib::Value_Enum< Gtk::Orientation >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum CornerType
    {
        CORNER_TOP_LEFT, 
        CORNER_BOTTOM_LEFT, 
        CORNER_TOP_RIGHT, 
        CORNER_BOTTOM_RIGHT
    };
}
namespace Glib {
    template<>
    class Value< Gtk::CornerType > : public Glib::Value_Enum< Gtk::CornerType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum PackType
    {
        PACK_START, 
        PACK_END
    };
}
namespace Glib {
    template<>
    class Value< Gtk::PackType > : public Glib::Value_Enum< Gtk::PackType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum PathPriorityType
    {
        PATH_PRIO_LOWEST = 0, 
        PATH_PRIO_GTK = 4, 
        PATH_PRIO_APPLICATION = 8, 
        PATH_PRIO_THEME = 10, 
        PATH_PRIO_RC = 12, 
        PATH_PRIO_HIGHEST = 15
    };
}
namespace Glib {
    template<>
    class Value< Gtk::PathPriorityType > : public Glib::Value_Enum< Gtk::PathPriorityType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum PathType
    {
        PATH_WIDGET, 
        PATH_WIDGET_CLASS, 
        PATH_CLASS
    };
}
namespace Glib {
    template<>
    class Value< Gtk::PathType > : public Glib::Value_Enum< Gtk::PathType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum PolicyType
    {
        POLICY_ALWAYS, 
        POLICY_AUTOMATIC, 
        POLICY_NEVER
    };
}
namespace Glib {
    template<>
    class Value< Gtk::PolicyType > : public Glib::Value_Enum< Gtk::PolicyType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum PositionType
    {
        POS_LEFT, 
        POS_RIGHT, 
        POS_TOP, 
        POS_BOTTOM
    };
}
namespace Glib {
    template<>
    class Value< Gtk::PositionType > : public Glib::Value_Enum< Gtk::PositionType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum ReliefStyle
    {
        RELIEF_NORMAL, 
        RELIEF_HALF, 
        RELIEF_NONE
    };
}
namespace Glib {
    template<>
    class Value< Gtk::ReliefStyle > : public Glib::Value_Enum< Gtk::ReliefStyle >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum ResizeMode
    {
        RESIZE_PARENT, 
        RESIZE_QUEUE, 
        RESIZE_IMMEDIATE
    };
}
namespace Glib {
    template<>
    class Value< Gtk::ResizeMode > : public Glib::Value_Enum< Gtk::ResizeMode >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum ScrollType
    {
        SCROLL_NONE, 
        SCROLL_JUMP, 
        SCROLL_STEP_BACKWARD, 
        SCROLL_STEP_FORWARD, 
        SCROLL_PAGE_BACKWARD, 
        SCROLL_PAGE_FORWARD, 
        SCROLL_STEP_UP, 
        SCROLL_STEP_DOWN, 
        SCROLL_PAGE_UP, 
        SCROLL_PAGE_DOWN, 
        SCROLL_STEP_LEFT, 
        SCROLL_STEP_RIGHT, 
        SCROLL_PAGE_LEFT, 
        SCROLL_PAGE_RIGHT, 
        SCROLL_START, 
        SCROLL_END
    };
}
namespace Glib {
    template<>
    class Value< Gtk::ScrollType > : public Glib::Value_Enum< Gtk::ScrollType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum SelectionMode
    {
        SELECTION_NONE, 
        SELECTION_SINGLE, 
        SELECTION_BROWSE, 
        SELECTION_MULTIPLE, 
        SELECTION_EXTENDED = SELECTION_MULTIPLE
    };
}
namespace Glib {
    template<>
    class Value< Gtk::SelectionMode > : public Glib::Value_Enum< Gtk::SelectionMode >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum ShadowType
    {
        SHADOW_NONE, 
        SHADOW_IN, 
        SHADOW_OUT, 
        SHADOW_ETCHED_IN, 
        SHADOW_ETCHED_OUT
    };
}
namespace Glib {
    template<>
    class Value< Gtk::ShadowType > : public Glib::Value_Enum< Gtk::ShadowType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum StateType
    {
        STATE_NORMAL, 
        STATE_ACTIVE, 
        STATE_PRELIGHT, 
        STATE_SELECTED, 
        STATE_INSENSITIVE
    };
}
namespace Glib {
    template<>
    class Value< Gtk::StateType > : public Glib::Value_Enum< Gtk::StateType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum TargetFlags
    {
        TARGET_SAME_APP = 1 << 0, 
        TARGET_SAME_WIDGET = 1 << 1, 
        TARGET_OTHER_APP = 1 << 2, 
        TARGET_OTHER_WIDGET = 1 << 3
    };
    inline TargetFlags operator |(TargetFlags lhs, TargetFlags rhs)
    {
        return static_cast<TargetFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline TargetFlags operator &(TargetFlags lhs, TargetFlags rhs)
    {
        return static_cast<TargetFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline TargetFlags operator ^(TargetFlags lhs, TargetFlags rhs)
    {
        return static_cast<TargetFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline TargetFlags operator ~(TargetFlags flags)
    {
        return static_cast<TargetFlags >(~static_cast<unsigned >(flags));
    }
    inline TargetFlags & operator |=(TargetFlags & lhs, TargetFlags rhs)
    {
        return (lhs = static_cast<TargetFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline TargetFlags & operator &=(TargetFlags & lhs, TargetFlags rhs)
    {
        return (lhs = static_cast<TargetFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline TargetFlags & operator ^=(TargetFlags & lhs, TargetFlags rhs)
    {
        return (lhs = static_cast<TargetFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gtk::TargetFlags > : public Glib::Value_Flags< Gtk::TargetFlags >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum ToolbarStyle
    {
        TOOLBAR_ICONS, 
        TOOLBAR_TEXT, 
        TOOLBAR_BOTH, 
        TOOLBAR_BOTH_HORIZ
    };
}
namespace Glib {
    template<>
    class Value< Gtk::ToolbarStyle > : public Glib::Value_Enum< Gtk::ToolbarStyle >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum UpdateType
    {
        UPDATE_CONTINUOUS, 
        UPDATE_DISCONTINUOUS, 
        UPDATE_DELAYED
    };
}
namespace Glib {
    template<>
    class Value< Gtk::UpdateType > : public Glib::Value_Enum< Gtk::UpdateType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum Visibility
    {
        VISIBILITY_NONE, 
        VISIBILITY_PARTIAL, 
        VISIBILITY_FULL
    };
}
namespace Glib {
    template<>
    class Value< Gtk::Visibility > : public Glib::Value_Enum< Gtk::Visibility >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum WindowPosition
    {
        WIN_POS_NONE, 
        WIN_POS_CENTER, 
        WIN_POS_MOUSE, 
        WIN_POS_CENTER_ALWAYS, 
        WIN_POS_CENTER_ON_PARENT
    };
}
namespace Glib {
    template<>
    class Value< Gtk::WindowPosition > : public Glib::Value_Enum< Gtk::WindowPosition >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum WindowType
    {
        WINDOW_TOPLEVEL, 
        WINDOW_POPUP
    };
}
namespace Glib {
    template<>
    class Value< Gtk::WindowType > : public Glib::Value_Enum< Gtk::WindowType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum WrapMode
    {
        WRAP_NONE, 
        WRAP_CHAR, 
        WRAP_WORD, 
        WRAP_WORD_CHAR
    };
}
namespace Glib {
    template<>
    class Value< Gtk::WrapMode > : public Glib::Value_Enum< Gtk::WrapMode >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum SortType
    {
        SORT_ASCENDING, 
        SORT_DESCENDING
    };
}
namespace Glib {
    template<>
    class Value< Gtk::SortType > : public Glib::Value_Enum< Gtk::SortType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum PageOrientation
    {
        PAGE_ORIENTATION_PORTRAIT, 
        PAGE_ORIENTATION_LANDSCAPE, 
        PAGE_ORIENTATION_REVERSE_PORTRAIT, 
        PAGE_ORIENTATION_REVERSE_LANDSCAPE
    };
}
namespace Glib {
    template<>
    class Value< Gtk::PageOrientation > : public Glib::Value_Enum< Gtk::PageOrientation >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class IconSize
    {
        private :
            int size_;
        public :
            IconSize()
                : size_(0) 
            {
            }
            IconSize(BuiltinIconSize size)
                : size_(size) 
            {
            }
            explicit IconSize(int size)
                : size_(size) 
            {
            }
            operator int() const
            {
                return size_;
            }
            static bool lookup(IconSize size, int & width, int & height);
            static IconSize register_new(const Glib::ustring & name, int width, int height);
            static void register_alias(const Glib::ustring & alias, IconSize target);
            static IconSize from_name(const Glib::ustring & name);
            static Glib::ustring get_name(IconSize size);
    };
}
namespace Glib {
    template<>
    class Value< Gtk::IconSize > : public Glib::Value_Enum< Gtk::IconSize >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum AlignmentEnum
    {
        ALIGN_LEFT, 
        ALIGN_CENTER, 
        ALIGN_RIGHT, 
        ALIGN_TOP, 
        ALIGN_BOTTOM
    };
    float _gtkmm_align_float_from_enum(AlignmentEnum value);
}
extern "C"
{
    typedef enum 
    {
        GTK_ANCHOR_CENTER, 
        GTK_ANCHOR_NORTH, 
        GTK_ANCHOR_NORTH_WEST, 
        GTK_ANCHOR_NORTH_EAST, 
        GTK_ANCHOR_SOUTH, 
        GTK_ANCHOR_SOUTH_WEST, 
        GTK_ANCHOR_SOUTH_EAST, 
        GTK_ANCHOR_WEST, 
        GTK_ANCHOR_EAST, 
        GTK_ANCHOR_N = GTK_ANCHOR_NORTH, 
        GTK_ANCHOR_NW = GTK_ANCHOR_NORTH_WEST, 
        GTK_ANCHOR_NE = GTK_ANCHOR_NORTH_EAST, 
        GTK_ANCHOR_S = GTK_ANCHOR_SOUTH, 
        GTK_ANCHOR_SW = GTK_ANCHOR_SOUTH_WEST, 
        GTK_ANCHOR_SE = GTK_ANCHOR_SOUTH_EAST, 
        GTK_ANCHOR_W = GTK_ANCHOR_WEST, 
        GTK_ANCHOR_E = GTK_ANCHOR_EAST
    } GtkAnchorType;
    typedef enum 
    {
        GTK_ARROW_UP, 
        GTK_ARROW_DOWN, 
        GTK_ARROW_LEFT, 
        GTK_ARROW_RIGHT, 
        GTK_ARROW_NONE
    } GtkArrowType;
    typedef enum 
    {
        GTK_EXPAND = 1 << 0, 
        GTK_SHRINK = 1 << 1, 
        GTK_FILL = 1 << 2
    } GtkAttachOptions;
    typedef enum 
    {
        GTK_BUTTONBOX_DEFAULT_STYLE, 
        GTK_BUTTONBOX_SPREAD, 
        GTK_BUTTONBOX_EDGE, 
        GTK_BUTTONBOX_START, 
        GTK_BUTTONBOX_END, 
        GTK_BUTTONBOX_CENTER
    } GtkButtonBoxStyle;
    typedef enum 
    {
        GTK_CURVE_TYPE_LINEAR, 
        GTK_CURVE_TYPE_SPLINE, 
        GTK_CURVE_TYPE_FREE
    } GtkCurveType;
    typedef enum 
    {
        GTK_DELETE_CHARS, 
        GTK_DELETE_WORD_ENDS, 
        GTK_DELETE_WORDS, 
        GTK_DELETE_DISPLAY_LINES, 
        GTK_DELETE_DISPLAY_LINE_ENDS, 
        GTK_DELETE_PARAGRAPH_ENDS, 
        GTK_DELETE_PARAGRAPHS, 
        GTK_DELETE_WHITESPACE
    } GtkDeleteType;
    typedef enum 
    {
        GTK_DIR_TAB_FORWARD, 
        GTK_DIR_TAB_BACKWARD, 
        GTK_DIR_UP, 
        GTK_DIR_DOWN, 
        GTK_DIR_LEFT, 
        GTK_DIR_RIGHT
    } GtkDirectionType;
    typedef enum 
    {
        GTK_EXPANDER_COLLAPSED, 
        GTK_EXPANDER_SEMI_COLLAPSED, 
        GTK_EXPANDER_SEMI_EXPANDED, 
        GTK_EXPANDER_EXPANDED
    } GtkExpanderStyle;
    typedef enum 
    {
        GTK_ICON_SIZE_INVALID, 
        GTK_ICON_SIZE_MENU, 
        GTK_ICON_SIZE_SMALL_TOOLBAR, 
        GTK_ICON_SIZE_LARGE_TOOLBAR, 
        GTK_ICON_SIZE_BUTTON, 
        GTK_ICON_SIZE_DND, 
        GTK_ICON_SIZE_DIALOG
    } GtkIconSize;
    typedef enum 
    {
        GTK_SENSITIVITY_AUTO, 
        GTK_SENSITIVITY_ON, 
        GTK_SENSITIVITY_OFF
    } GtkSensitivityType;
    typedef enum 
    {
        GTK_SIDE_TOP, 
        GTK_SIDE_BOTTOM, 
        GTK_SIDE_LEFT, 
        GTK_SIDE_RIGHT
    } GtkSideType;
    typedef enum 
    {
        GTK_TEXT_DIR_NONE, 
        GTK_TEXT_DIR_LTR, 
        GTK_TEXT_DIR_RTL
    } GtkTextDirection;
    typedef enum 
    {
        GTK_JUSTIFY_LEFT, 
        GTK_JUSTIFY_RIGHT, 
        GTK_JUSTIFY_CENTER, 
        GTK_JUSTIFY_FILL
    } GtkJustification;
    typedef enum 
    {
        GTK_MATCH_ALL, 
        GTK_MATCH_ALL_TAIL, 
        GTK_MATCH_HEAD, 
        GTK_MATCH_TAIL, 
        GTK_MATCH_EXACT, 
        GTK_MATCH_LAST
    } GtkMatchType;
    typedef enum 
    {
        GTK_MENU_DIR_PARENT, 
        GTK_MENU_DIR_CHILD, 
        GTK_MENU_DIR_NEXT, 
        GTK_MENU_DIR_PREV
    } GtkMenuDirectionType;
    typedef enum 
    {
        GTK_PIXELS, 
        GTK_INCHES, 
        GTK_CENTIMETERS
    } GtkMetricType;
    typedef enum 
    {
        GTK_MOVEMENT_LOGICAL_POSITIONS, 
        GTK_MOVEMENT_VISUAL_POSITIONS, 
        GTK_MOVEMENT_WORDS, 
        GTK_MOVEMENT_DISPLAY_LINES, 
        GTK_MOVEMENT_DISPLAY_LINE_ENDS, 
        GTK_MOVEMENT_PARAGRAPHS, 
        GTK_MOVEMENT_PARAGRAPH_ENDS, 
        GTK_MOVEMENT_PAGES, 
        GTK_MOVEMENT_BUFFER_ENDS, 
        GTK_MOVEMENT_HORIZONTAL_PAGES
    } GtkMovementStep;
    typedef enum 
    {
        GTK_SCROLL_STEPS, 
        GTK_SCROLL_PAGES, 
        GTK_SCROLL_ENDS, 
        GTK_SCROLL_HORIZONTAL_STEPS, 
        GTK_SCROLL_HORIZONTAL_PAGES, 
        GTK_SCROLL_HORIZONTAL_ENDS
    } GtkScrollStep;
    typedef enum 
    {
        GTK_ORIENTATION_HORIZONTAL, 
        GTK_ORIENTATION_VERTICAL
    } GtkOrientation;
    typedef enum 
    {
        GTK_CORNER_TOP_LEFT, 
        GTK_CORNER_BOTTOM_LEFT, 
        GTK_CORNER_TOP_RIGHT, 
        GTK_CORNER_BOTTOM_RIGHT
    } GtkCornerType;
    typedef enum 
    {
        GTK_PACK_START, 
        GTK_PACK_END
    } GtkPackType;
    typedef enum 
    {
        GTK_PATH_PRIO_LOWEST = 0, 
        GTK_PATH_PRIO_GTK = 4, 
        GTK_PATH_PRIO_APPLICATION = 8, 
        GTK_PATH_PRIO_THEME = 10, 
        GTK_PATH_PRIO_RC = 12, 
        GTK_PATH_PRIO_HIGHEST = 15
    } GtkPathPriorityType;
    typedef enum 
    {
        GTK_PATH_WIDGET, 
        GTK_PATH_WIDGET_CLASS, 
        GTK_PATH_CLASS
    } GtkPathType;
    typedef enum 
    {
        GTK_POLICY_ALWAYS, 
        GTK_POLICY_AUTOMATIC, 
        GTK_POLICY_NEVER
    } GtkPolicyType;
    typedef enum 
    {
        GTK_POS_LEFT, 
        GTK_POS_RIGHT, 
        GTK_POS_TOP, 
        GTK_POS_BOTTOM
    } GtkPositionType;
    typedef enum 
    {
        GTK_PREVIEW_COLOR, 
        GTK_PREVIEW_GRAYSCALE
    } GtkPreviewType;
    typedef enum 
    {
        GTK_RELIEF_NORMAL, 
        GTK_RELIEF_HALF, 
        GTK_RELIEF_NONE
    } GtkReliefStyle;
    typedef enum 
    {
        GTK_RESIZE_PARENT, 
        GTK_RESIZE_QUEUE, 
        GTK_RESIZE_IMMEDIATE
    } GtkResizeMode;
    typedef enum 
    {
        GTK_RUN_FIRST = G_SIGNAL_RUN_FIRST, 
        GTK_RUN_LAST = G_SIGNAL_RUN_LAST, 
        GTK_RUN_BOTH = (GTK_RUN_FIRST | GTK_RUN_LAST), 
        GTK_RUN_NO_RECURSE = G_SIGNAL_NO_RECURSE, 
        GTK_RUN_ACTION = G_SIGNAL_ACTION, 
        GTK_RUN_NO_HOOKS = G_SIGNAL_NO_HOOKS
    } GtkSignalRunType;
    typedef enum 
    {
        GTK_SCROLL_NONE, 
        GTK_SCROLL_JUMP, 
        GTK_SCROLL_STEP_BACKWARD, 
        GTK_SCROLL_STEP_FORWARD, 
        GTK_SCROLL_PAGE_BACKWARD, 
        GTK_SCROLL_PAGE_FORWARD, 
        GTK_SCROLL_STEP_UP, 
        GTK_SCROLL_STEP_DOWN, 
        GTK_SCROLL_PAGE_UP, 
        GTK_SCROLL_PAGE_DOWN, 
        GTK_SCROLL_STEP_LEFT, 
        GTK_SCROLL_STEP_RIGHT, 
        GTK_SCROLL_PAGE_LEFT, 
        GTK_SCROLL_PAGE_RIGHT, 
        GTK_SCROLL_START, 
        GTK_SCROLL_END
    } GtkScrollType;
    typedef enum 
    {
        GTK_SELECTION_NONE, 
        GTK_SELECTION_SINGLE, 
        GTK_SELECTION_BROWSE, 
        GTK_SELECTION_MULTIPLE, 
        GTK_SELECTION_EXTENDED = GTK_SELECTION_MULTIPLE
    } GtkSelectionMode;
    typedef enum 
    {
        GTK_SHADOW_NONE, 
        GTK_SHADOW_IN, 
        GTK_SHADOW_OUT, 
        GTK_SHADOW_ETCHED_IN, 
        GTK_SHADOW_ETCHED_OUT
    } GtkShadowType;
    typedef enum 
    {
        GTK_STATE_NORMAL, 
        GTK_STATE_ACTIVE, 
        GTK_STATE_PRELIGHT, 
        GTK_STATE_SELECTED, 
        GTK_STATE_INSENSITIVE
    } GtkStateType;
    typedef enum 
    {
        GTK_DIRECTION_LEFT, 
        GTK_DIRECTION_RIGHT
    } GtkSubmenuDirection;
    typedef enum 
    {
        GTK_TOP_BOTTOM, 
        GTK_LEFT_RIGHT
    } GtkSubmenuPlacement;
    typedef enum 
    {
        GTK_TOOLBAR_ICONS, 
        GTK_TOOLBAR_TEXT, 
        GTK_TOOLBAR_BOTH, 
        GTK_TOOLBAR_BOTH_HORIZ
    } GtkToolbarStyle;
    typedef enum 
    {
        GTK_UPDATE_CONTINUOUS, 
        GTK_UPDATE_DISCONTINUOUS, 
        GTK_UPDATE_DELAYED
    } GtkUpdateType;
    typedef enum 
    {
        GTK_VISIBILITY_NONE, 
        GTK_VISIBILITY_PARTIAL, 
        GTK_VISIBILITY_FULL
    } GtkVisibility;
    typedef enum 
    {
        GTK_WIN_POS_NONE, 
        GTK_WIN_POS_CENTER, 
        GTK_WIN_POS_MOUSE, 
        GTK_WIN_POS_CENTER_ALWAYS, 
        GTK_WIN_POS_CENTER_ON_PARENT
    } GtkWindowPosition;
    typedef enum 
    {
        GTK_WINDOW_TOPLEVEL, 
        GTK_WINDOW_POPUP
    } GtkWindowType;
    typedef enum 
    {
        GTK_WRAP_NONE, 
        GTK_WRAP_CHAR, 
        GTK_WRAP_WORD, 
        GTK_WRAP_WORD_CHAR
    } GtkWrapMode;
    typedef enum 
    {
        GTK_SORT_ASCENDING, 
        GTK_SORT_DESCENDING
    } GtkSortType;
    typedef enum 
    {
        GTK_IM_PREEDIT_NOTHING, 
        GTK_IM_PREEDIT_CALLBACK, 
        GTK_IM_PREEDIT_NONE
    } GtkIMPreeditStyle;
    typedef enum 
    {
        GTK_IM_STATUS_NOTHING, 
        GTK_IM_STATUS_CALLBACK, 
        GTK_IM_STATUS_NONE
    } GtkIMStatusStyle;
    typedef enum 
    {
        GTK_PACK_DIRECTION_LTR, 
        GTK_PACK_DIRECTION_RTL, 
        GTK_PACK_DIRECTION_TTB, 
        GTK_PACK_DIRECTION_BTT
    } GtkPackDirection;
    typedef enum 
    {
        GTK_PRINT_PAGES_ALL, 
        GTK_PRINT_PAGES_CURRENT, 
        GTK_PRINT_PAGES_RANGES
    } GtkPrintPages;
    typedef enum 
    {
        GTK_PAGE_SET_ALL, 
        GTK_PAGE_SET_EVEN, 
        GTK_PAGE_SET_ODD
    } GtkPageSet;
    typedef enum 
    {
        GTK_PAGE_ORIENTATION_PORTRAIT, 
        GTK_PAGE_ORIENTATION_LANDSCAPE, 
        GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT, 
        GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE
    } GtkPageOrientation;
    typedef enum 
    {
        GTK_PRINT_QUALITY_LOW, 
        GTK_PRINT_QUALITY_NORMAL, 
        GTK_PRINT_QUALITY_HIGH, 
        GTK_PRINT_QUALITY_DRAFT
    } GtkPrintQuality;
    typedef enum 
    {
        GTK_PRINT_DUPLEX_SIMPLEX, 
        GTK_PRINT_DUPLEX_HORIZONTAL, 
        GTK_PRINT_DUPLEX_VERTICAL
    } GtkPrintDuplex;
    typedef enum 
    {
        GTK_UNIT_PIXEL, 
        GTK_UNIT_POINTS, 
        GTK_UNIT_INCH, 
        GTK_UNIT_MM
    } GtkUnit;
    typedef enum 
    {
        GTK_TREE_VIEW_GRID_LINES_NONE, 
        GTK_TREE_VIEW_GRID_LINES_HORIZONTAL, 
        GTK_TREE_VIEW_GRID_LINES_VERTICAL, 
        GTK_TREE_VIEW_GRID_LINES_BOTH
    } GtkTreeViewGridLines;
    typedef enum 
    {
        GTK_DRAG_RESULT_SUCCESS, 
        GTK_DRAG_RESULT_NO_TARGET, 
        GTK_DRAG_RESULT_USER_CANCELLED, 
        GTK_DRAG_RESULT_TIMEOUT_EXPIRED, 
        GTK_DRAG_RESULT_GRAB_BROKEN, 
        GTK_DRAG_RESULT_ERROR
    } GtkDragResult;
}
extern "C"
{
    typedef enum 
    {
        GTK_ACCEL_VISIBLE = 1 << 0, 
        GTK_ACCEL_LOCKED = 1 << 1, 
        GTK_ACCEL_MASK = 0x07
    } GtkAccelFlags;
    typedef struct _GtkAccelGroup GtkAccelGroup;
    typedef struct _GtkAccelGroupClass GtkAccelGroupClass;
    typedef struct _GtkAccelKey GtkAccelKey;
    typedef struct _GtkAccelGroupEntry GtkAccelGroupEntry;
    typedef gboolean (* GtkAccelGroupActivate)(GtkAccelGroup * accel_group, GObject * acceleratable, guint keyval, GdkModifierType modifier);
    typedef gboolean (* GtkAccelGroupFindFunc)(GtkAccelKey * key, GClosure * closure, gpointer data);
    struct _GtkAccelGroup
    {
            GObject parent;
            guint lock_count;
            GdkModifierType modifier_mask;
            GSList * acceleratables;
            guint n_accels;
            GtkAccelGroupEntry * priv_accels;
    };
    struct _GtkAccelGroupClass
    {
            GObjectClass parent_class;
            void (* accel_changed)(GtkAccelGroup * accel_group, guint keyval, GdkModifierType modifier, GClosure * accel_closure);
            void (* _gtk_reserved1)(void);
            void (* _gtk_reserved2)(void);
            void (* _gtk_reserved3)(void);
            void (* _gtk_reserved4)(void);
    };
    struct _GtkAccelKey
    {
            guint accel_key;
            GdkModifierType accel_mods;
            guint accel_flags : 16;
    };
    GType gtk_accel_group_get_type(void) __attribute__((__const__));
    GtkAccelGroup * gtk_accel_group_new(void);
    void gtk_accel_group_lock(GtkAccelGroup * accel_group);
    void gtk_accel_group_unlock(GtkAccelGroup * accel_group);
    void gtk_accel_group_connect(GtkAccelGroup * accel_group, guint accel_key, GdkModifierType accel_mods, GtkAccelFlags accel_flags, GClosure * closure);
    void gtk_accel_group_connect_by_path(GtkAccelGroup * accel_group, const gchar * accel_path, GClosure * closure);
    gboolean gtk_accel_group_disconnect(GtkAccelGroup * accel_group, GClosure * closure);
    gboolean gtk_accel_group_disconnect_key(GtkAccelGroup * accel_group, guint accel_key, GdkModifierType accel_mods);
    gboolean gtk_accel_group_activate(GtkAccelGroup * accel_group, GQuark accel_quark, GObject * acceleratable, guint accel_key, GdkModifierType accel_mods);
    void _gtk_accel_group_attach(GtkAccelGroup * accel_group, GObject * object);
    void _gtk_accel_group_detach(GtkAccelGroup * accel_group, GObject * object);
    gboolean gtk_accel_groups_activate(GObject * object, guint accel_key, GdkModifierType accel_mods);
    GSList * gtk_accel_groups_from_object(GObject * object);
    GtkAccelKey * gtk_accel_group_find(GtkAccelGroup * accel_group, GtkAccelGroupFindFunc find_func, gpointer data);
    GtkAccelGroup * gtk_accel_group_from_accel_closure(GClosure * closure);
    gboolean gtk_accelerator_valid(guint keyval, GdkModifierType modifiers) __attribute__((__const__));
    void gtk_accelerator_parse(const gchar * accelerator, guint * accelerator_key, GdkModifierType * accelerator_mods);
    gchar * gtk_accelerator_name(guint accelerator_key, GdkModifierType accelerator_mods);
    gchar * gtk_accelerator_get_label(guint accelerator_key, GdkModifierType accelerator_mods);
    void gtk_accelerator_set_default_mod_mask(GdkModifierType default_mod_mask);
    guint gtk_accelerator_get_default_mod_mask(void);
    GtkAccelGroupEntry * gtk_accel_group_query(GtkAccelGroup * accel_group, guint accel_key, GdkModifierType accel_mods, guint * n_entries);
    void _gtk_accel_group_reconnect(GtkAccelGroup * accel_group, GQuark accel_path_quark);
    struct _GtkAccelGroupEntry
    {
            GtkAccelKey key;
            GClosure * closure;
            GQuark accel_path_quark;
    };
}
extern "C"
{
    typedef GType GtkFundamentalType;
    typedef GType GtkType;
    typedef GTypeInstance GtkTypeObject;
    typedef GTypeClass GtkTypeClass;
    typedef GBaseInitFunc GtkClassInitFunc;
    typedef GInstanceInitFunc GtkObjectInitFunc;
}
extern "C"
{
    GType gtk_accel_flags_get_type(void) __attribute__((__const__));
    GType gtk_assistant_page_type_get_type(void) __attribute__((__const__));
    GType gtk_builder_error_get_type(void) __attribute__((__const__));
    GType gtk_calendar_display_options_get_type(void) __attribute__((__const__));
    GType gtk_cell_renderer_state_get_type(void) __attribute__((__const__));
    GType gtk_cell_renderer_mode_get_type(void) __attribute__((__const__));
    GType gtk_cell_renderer_accel_mode_get_type(void) __attribute__((__const__));
    GType gtk_cell_type_get_type(void) __attribute__((__const__));
    GType gtk_clist_drag_pos_get_type(void) __attribute__((__const__));
    GType gtk_button_action_get_type(void) __attribute__((__const__));
    GType gtk_ctree_pos_get_type(void) __attribute__((__const__));
    GType gtk_ctree_line_style_get_type(void) __attribute__((__const__));
    GType gtk_ctree_expander_style_get_type(void) __attribute__((__const__));
    GType gtk_ctree_expansion_type_get_type(void) __attribute__((__const__));
    GType gtk_debug_flag_get_type(void) __attribute__((__const__));
    GType gtk_dialog_flags_get_type(void) __attribute__((__const__));
    GType gtk_response_type_get_type(void) __attribute__((__const__));
    GType gtk_dest_defaults_get_type(void) __attribute__((__const__));
    GType gtk_target_flags_get_type(void) __attribute__((__const__));
    GType gtk_anchor_type_get_type(void) __attribute__((__const__));
    GType gtk_arrow_type_get_type(void) __attribute__((__const__));
    GType gtk_attach_options_get_type(void) __attribute__((__const__));
    GType gtk_button_box_style_get_type(void) __attribute__((__const__));
    GType gtk_curve_type_get_type(void) __attribute__((__const__));
    GType gtk_delete_type_get_type(void) __attribute__((__const__));
    GType gtk_direction_type_get_type(void) __attribute__((__const__));
    GType gtk_expander_style_get_type(void) __attribute__((__const__));
    GType gtk_icon_size_get_type(void) __attribute__((__const__));
    GType gtk_sensitivity_type_get_type(void) __attribute__((__const__));
    GType gtk_side_type_get_type(void) __attribute__((__const__));
    GType gtk_text_direction_get_type(void) __attribute__((__const__));
    GType gtk_justification_get_type(void) __attribute__((__const__));
    GType gtk_match_type_get_type(void) __attribute__((__const__));
    GType gtk_menu_direction_type_get_type(void) __attribute__((__const__));
    GType gtk_metric_type_get_type(void) __attribute__((__const__));
    GType gtk_movement_step_get_type(void) __attribute__((__const__));
    GType gtk_scroll_step_get_type(void) __attribute__((__const__));
    GType gtk_orientation_get_type(void) __attribute__((__const__));
    GType gtk_corner_type_get_type(void) __attribute__((__const__));
    GType gtk_pack_type_get_type(void) __attribute__((__const__));
    GType gtk_path_priority_type_get_type(void) __attribute__((__const__));
    GType gtk_path_type_get_type(void) __attribute__((__const__));
    GType gtk_policy_type_get_type(void) __attribute__((__const__));
    GType gtk_position_type_get_type(void) __attribute__((__const__));
    GType gtk_preview_type_get_type(void) __attribute__((__const__));
    GType gtk_relief_style_get_type(void) __attribute__((__const__));
    GType gtk_resize_mode_get_type(void) __attribute__((__const__));
    GType gtk_signal_run_type_get_type(void) __attribute__((__const__));
    GType gtk_scroll_type_get_type(void) __attribute__((__const__));
    GType gtk_selection_mode_get_type(void) __attribute__((__const__));
    GType gtk_shadow_type_get_type(void) __attribute__((__const__));
    GType gtk_state_type_get_type(void) __attribute__((__const__));
    GType gtk_submenu_direction_get_type(void) __attribute__((__const__));
    GType gtk_submenu_placement_get_type(void) __attribute__((__const__));
    GType gtk_toolbar_style_get_type(void) __attribute__((__const__));
    GType gtk_update_type_get_type(void) __attribute__((__const__));
    GType gtk_visibility_get_type(void) __attribute__((__const__));
    GType gtk_window_position_get_type(void) __attribute__((__const__));
    GType gtk_window_type_get_type(void) __attribute__((__const__));
    GType gtk_wrap_mode_get_type(void) __attribute__((__const__));
    GType gtk_sort_type_get_type(void) __attribute__((__const__));
    GType gtk_im_preedit_style_get_type(void) __attribute__((__const__));
    GType gtk_im_status_style_get_type(void) __attribute__((__const__));
    GType gtk_pack_direction_get_type(void) __attribute__((__const__));
    GType gtk_print_pages_get_type(void) __attribute__((__const__));
    GType gtk_page_set_get_type(void) __attribute__((__const__));
    GType gtk_page_orientation_get_type(void) __attribute__((__const__));
    GType gtk_print_quality_get_type(void) __attribute__((__const__));
    GType gtk_print_duplex_get_type(void) __attribute__((__const__));
    GType gtk_unit_get_type(void) __attribute__((__const__));
    GType gtk_tree_view_grid_lines_get_type(void) __attribute__((__const__));
    GType gtk_drag_result_get_type(void) __attribute__((__const__));
    GType gtk_file_chooser_action_get_type(void) __attribute__((__const__));
    GType gtk_file_chooser_confirmation_get_type(void) __attribute__((__const__));
    GType gtk_file_chooser_error_get_type(void) __attribute__((__const__));
    GType gtk_file_filter_flags_get_type(void) __attribute__((__const__));
    GType gtk_icon_lookup_flags_get_type(void) __attribute__((__const__));
    GType gtk_icon_theme_error_get_type(void) __attribute__((__const__));
    GType gtk_icon_view_drop_position_get_type(void) __attribute__((__const__));
    GType gtk_image_type_get_type(void) __attribute__((__const__));
    GType gtk_message_type_get_type(void) __attribute__((__const__));
    GType gtk_buttons_type_get_type(void) __attribute__((__const__));
    GType gtk_notebook_tab_get_type(void) __attribute__((__const__));
    GType gtk_object_flags_get_type(void) __attribute__((__const__));
    GType gtk_arg_flags_get_type(void) __attribute__((__const__));
    GType gtk_print_status_get_type(void) __attribute__((__const__));
    GType gtk_print_operation_result_get_type(void) __attribute__((__const__));
    GType gtk_print_operation_action_get_type(void) __attribute__((__const__));
    GType gtk_print_error_get_type(void) __attribute__((__const__));
    GType gtk_private_flags_get_type(void) __attribute__((__const__));
    GType gtk_progress_bar_style_get_type(void) __attribute__((__const__));
    GType gtk_progress_bar_orientation_get_type(void) __attribute__((__const__));
    GType gtk_rc_flags_get_type(void) __attribute__((__const__));
    GType gtk_rc_token_type_get_type(void) __attribute__((__const__));
    GType gtk_recent_sort_type_get_type(void) __attribute__((__const__));
    GType gtk_recent_chooser_error_get_type(void) __attribute__((__const__));
    GType gtk_recent_filter_flags_get_type(void) __attribute__((__const__));
    GType gtk_recent_manager_error_get_type(void) __attribute__((__const__));
    GType gtk_size_group_mode_get_type(void) __attribute__((__const__));
    GType gtk_spin_button_update_policy_get_type(void) __attribute__((__const__));
    GType gtk_spin_type_get_type(void) __attribute__((__const__));
    GType gtk_text_buffer_target_info_get_type(void) __attribute__((__const__));
    GType gtk_text_search_flags_get_type(void) __attribute__((__const__));
    GType gtk_text_window_type_get_type(void) __attribute__((__const__));
    GType gtk_toolbar_child_type_get_type(void) __attribute__((__const__));
    GType gtk_toolbar_space_style_get_type(void) __attribute__((__const__));
    GType gtk_tree_view_mode_get_type(void) __attribute__((__const__));
    GType gtk_tree_model_flags_get_type(void) __attribute__((__const__));
    GType gtk_tree_view_drop_position_get_type(void) __attribute__((__const__));
    GType gtk_tree_view_column_sizing_get_type(void) __attribute__((__const__));
    GType gtk_ui_manager_item_type_get_type(void) __attribute__((__const__));
    GType gtk_widget_flags_get_type(void) __attribute__((__const__));
    GType gtk_widget_help_type_get_type(void) __attribute__((__const__));
}
extern "C"
{
    GType gtk_identifier_get_type(void) __attribute__((__const__));
    typedef struct _GtkArg GtkArg;
    typedef struct _GtkObject GtkObject;
    typedef gboolean (* GtkFunction)(gpointer data);
    typedef void (* GtkDestroyNotify)(gpointer data);
    typedef void (* GtkCallbackMarshal)(GtkObject * object, gpointer data, guint n_args, GtkArg * args);
    typedef void (* GtkSignalFunc)(void);
    typedef struct _GtkTypeInfo GtkTypeInfo;
    typedef GSignalCMarshaller GtkSignalMarshaller;
    struct _GtkArg
    {
            GtkType type;
            gchar * name;
            union 
            {
                    gchar char_data;
                    guchar uchar_data;
                    gboolean bool_data;
                    gint int_data;
                    guint uint_data;
                    glong long_data;
                    gulong ulong_data;
                    gfloat float_data;
                    gdouble double_data;
                    gchar * string_data;
                    GtkObject * object_data;
                    gpointer pointer_data;
                    struct 
                    {
                            GtkSignalFunc f;
                            gpointer d;
                    } signal_data;
            } d;
    };
    struct _GtkTypeInfo
    {
            gchar * type_name;
            guint object_size;
            guint class_size;
            GtkClassInitFunc class_init_func;
            GtkObjectInitFunc object_init_func;
            gpointer reserved_1;
            gpointer reserved_2;
            GtkClassInitFunc base_class_init_func;
    };
    gpointer gtk_type_class(GtkType type);
    GtkType gtk_type_unique(GtkType parent_type, const GtkTypeInfo * gtkinfo);
    gpointer gtk_type_new(GtkType type);
    typedef GEnumValue GtkEnumValue;
    typedef GFlagsValue GtkFlagValue;
    GtkEnumValue * gtk_type_enum_get_values(GtkType enum_type);
    GtkFlagValue * gtk_type_flags_get_values(GtkType flags_type);
    GtkEnumValue * gtk_type_enum_find_value(GtkType enum_type, const gchar * value_name);
    GtkFlagValue * gtk_type_flags_find_value(GtkType flags_type, const gchar * value_name);
    void gtk_type_init(GTypeDebugFlags debug_flags);
}
extern "C"
{
    typedef enum 
    {
        GTK_DEBUG_MISC = 1 << 0, 
        GTK_DEBUG_PLUGSOCKET = 1 << 1, 
        GTK_DEBUG_TEXT = 1 << 2, 
        GTK_DEBUG_TREE = 1 << 3, 
        GTK_DEBUG_UPDATES = 1 << 4, 
        GTK_DEBUG_KEYBINDINGS = 1 << 5, 
        GTK_DEBUG_MULTIHEAD = 1 << 6, 
        GTK_DEBUG_MODULES = 1 << 7, 
        GTK_DEBUG_GEOMETRY = 1 << 8, 
        GTK_DEBUG_ICONTHEME = 1 << 9, 
        GTK_DEBUG_PRINTING = 1 << 10, 
        GTK_DEBUG_BUILDER = 1 << 11
    } GtkDebugFlag;
    extern guint gtk_debug_flags;
}
extern "C"
{
    typedef enum 
    {
        GTK_IN_DESTRUCTION = 1 << 0, 
        GTK_FLOATING = 1 << 1, 
        GTK_RESERVED_1 = 1 << 2, 
        GTK_RESERVED_2 = 1 << 3
    } GtkObjectFlags;
    typedef struct _GtkObjectClass GtkObjectClass;
    struct _GtkObject
    {
            GInitiallyUnowned parent_instance;
            guint32 flags;
    };
    struct _GtkObjectClass
    {
            GInitiallyUnownedClass parent_class;
            void (* set_arg)(GtkObject * object, GtkArg * arg, guint arg_id);
            void (* get_arg)(GtkObject * object, GtkArg * arg, guint arg_id);
            void (* destroy)(GtkObject * object);
    };
    GtkType gtk_object_get_type(void) __attribute__((__const__));
    void gtk_object_sink(GtkObject * object);
    void gtk_object_destroy(GtkObject * object);
    GtkObject * gtk_object_new(GtkType type, const gchar * first_property_name, ...);
    GtkObject * gtk_object_ref(GtkObject * object);
    void gtk_object_unref(GtkObject * object);
    void gtk_object_weakref(GtkObject * object, GtkDestroyNotify notify, gpointer data);
    void gtk_object_weakunref(GtkObject * object, GtkDestroyNotify notify, gpointer data);
    void gtk_object_set_data(GtkObject * object, const gchar * key, gpointer data);
    void gtk_object_set_data_full(GtkObject * object, const gchar * key, gpointer data, GtkDestroyNotify destroy);
    void gtk_object_remove_data(GtkObject * object, const gchar * key);
    gpointer gtk_object_get_data(GtkObject * object, const gchar * key);
    void gtk_object_remove_no_notify(GtkObject * object, const gchar * key);
    void gtk_object_set_user_data(GtkObject * object, gpointer data);
    gpointer gtk_object_get_user_data(GtkObject * object);
    void gtk_object_set_data_by_id(GtkObject * object, GQuark data_id, gpointer data);
    void gtk_object_set_data_by_id_full(GtkObject * object, GQuark data_id, gpointer data, GtkDestroyNotify destroy);
    gpointer gtk_object_get_data_by_id(GtkObject * object, GQuark data_id);
    void gtk_object_remove_data_by_id(GtkObject * object, GQuark data_id);
    void gtk_object_remove_no_notify_by_id(GtkObject * object, GQuark key_id);
    typedef enum 
    {
        GTK_ARG_READABLE = G_PARAM_READABLE, 
        GTK_ARG_WRITABLE = G_PARAM_WRITABLE, 
        GTK_ARG_CONSTRUCT = G_PARAM_CONSTRUCT, 
        GTK_ARG_CONSTRUCT_ONLY = G_PARAM_CONSTRUCT_ONLY, 
        GTK_ARG_CHILD_ARG = 1 << 4
    } GtkArgFlags;
    void gtk_object_get(GtkObject * object, const gchar * first_property_name, ...) __attribute__((__sentinel__));
    void gtk_object_set(GtkObject * object, const gchar * first_property_name, ...) __attribute__((__sentinel__));
    void gtk_object_add_arg_type(const gchar * arg_name, GtkType arg_type, guint arg_flags, guint arg_id);
}
extern "C"
{
    typedef struct _GtkAdjustment GtkAdjustment;
    typedef struct _GtkAdjustmentClass GtkAdjustmentClass;
    struct _GtkAdjustment
    {
            GtkObject parent_instance;
            gdouble lower;
            gdouble upper;
            gdouble value;
            gdouble step_increment;
            gdouble page_increment;
            gdouble page_size;
    };
    struct _GtkAdjustmentClass
    {
            GtkObjectClass parent_class;
            void (* changed)(GtkAdjustment * adjustment);
            void (* value_changed)(GtkAdjustment * adjustment);
            void (* _gtk_reserved1)(void);
            void (* _gtk_reserved2)(void);
            void (* _gtk_reserved3)(void);
            void (* _gtk_reserved4)(void);
    };
    GType gtk_adjustment_get_type(void) __attribute__((__const__));
    GtkObject * gtk_adjustment_new(gdouble value, gdouble lower, gdouble upper, gdouble step_increment, gdouble page_increment, gdouble page_size);
    void gtk_adjustment_changed(GtkAdjustment * adjustment);
    void gtk_adjustment_value_changed(GtkAdjustment * adjustment);
    void gtk_adjustment_clamp_page(GtkAdjustment * adjustment, gdouble lower, gdouble upper);
    gdouble gtk_adjustment_get_value(GtkAdjustment * adjustment);
    void gtk_adjustment_set_value(GtkAdjustment * adjustment, gdouble value);
}
extern "C"
{
    typedef struct _GtkBorder GtkBorder;
    typedef struct _GtkStyle GtkStyle;
    typedef struct _GtkStyleClass GtkStyleClass;
    typedef struct _GtkThemeEngine GtkThemeEngine;
    typedef struct _GtkRcStyle GtkRcStyle;
    typedef struct _GtkIconSet GtkIconSet;
    typedef struct _GtkIconSource GtkIconSource;
    typedef struct _GtkRcProperty GtkRcProperty;
    typedef struct _GtkSettings GtkSettings;
    typedef gboolean (* GtkRcPropertyParser)(const GParamSpec * pspec, const GString * rc_string, GValue * property_value);
    typedef struct _GtkWidget GtkWidget;
    struct _GtkStyle
    {
            GObject parent_instance;
            GdkColor fg[5];
            GdkColor bg[5];
            GdkColor light[5];
            GdkColor dark[5];
            GdkColor mid[5];
            GdkColor text[5];
            GdkColor base[5];
            GdkColor text_aa[5];
            GdkColor black;
            GdkColor white;
            PangoFontDescription * font_desc;
            gint xthickness;
            gint ythickness;
            GdkGC * fg_gc[5];
            GdkGC * bg_gc[5];
            GdkGC * light_gc[5];
            GdkGC * dark_gc[5];
            GdkGC * mid_gc[5];
            GdkGC * text_gc[5];
            GdkGC * base_gc[5];
            GdkGC * text_aa_gc[5];
            GdkGC * black_gc;
            GdkGC * white_gc;
            GdkPixmap * bg_pixmap[5];
            gint attach_count;
            gint depth;
            GdkColormap * colormap;
            GdkFont * private_font;
            PangoFontDescription * private_font_desc;
            GtkRcStyle * rc_style;
            GSList * styles;
            GArray * property_cache;
            GSList * icon_factories;
    };
    struct _GtkStyleClass
    {
            GObjectClass parent_class;
            void (* realize)(GtkStyle * style);
            void (* unrealize)(GtkStyle * style);
            void (* copy)(GtkStyle * style, GtkStyle * src);
            GtkStyle * (* clone)(GtkStyle * style);
            void (* init_from_rc)(GtkStyle * style, GtkRcStyle * rc_style);
            void (* set_background)(GtkStyle * style, GdkWindow * window, GtkStateType state_type);
            GdkPixbuf * (* render_icon)(GtkStyle * style, const GtkIconSource * source, GtkTextDirection direction, GtkStateType state, GtkIconSize size, GtkWidget * widget, const gchar * detail);
            void (* draw_hline)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x1, gint x2, gint y);
            void (* draw_vline)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint y1_, gint y2_, gint x);
            void (* draw_shadow)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height);
            void (* draw_polygon)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, GdkPoint * point, gint npoints, gboolean fill);
            void (* draw_arrow)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, GtkArrowType arrow_type, gboolean fill, gint x, gint y, gint width, gint height);
            void (* draw_diamond)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height);
            void (* draw_string)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, const gchar * string);
            void (* draw_box)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height);
            void (* draw_flat_box)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height);
            void (* draw_check)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height);
            void (* draw_option)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height);
            void (* draw_tab)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height);
            void (* draw_shadow_gap)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height, GtkPositionType gap_side, gint gap_x, gint gap_width);
            void (* draw_box_gap)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height, GtkPositionType gap_side, gint gap_x, gint gap_width);
            void (* draw_extension)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height, GtkPositionType gap_side);
            void (* draw_focus)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height);
            void (* draw_slider)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height, GtkOrientation orientation);
            void (* draw_handle)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height, GtkOrientation orientation);
            void (* draw_expander)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, GtkExpanderStyle expander_style);
            void (* draw_layout)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, gboolean use_text, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, PangoLayout * layout);
            void (* draw_resize_grip)(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, GdkWindowEdge edge, gint x, gint y, gint width, gint height);
            void (* _gtk_reserved1)(void);
            void (* _gtk_reserved2)(void);
            void (* _gtk_reserved3)(void);
            void (* _gtk_reserved4)(void);
            void (* _gtk_reserved5)(void);
            void (* _gtk_reserved6)(void);
            void (* _gtk_reserved7)(void);
            void (* _gtk_reserved8)(void);
            void (* _gtk_reserved9)(void);
            void (* _gtk_reserved10)(void);
            void (* _gtk_reserved11)(void);
            void (* _gtk_reserved12)(void);
    };
    struct _GtkBorder
    {
            gint left;
            gint right;
            gint top;
            gint bottom;
    };
    GType gtk_style_get_type(void) __attribute__((__const__));
    GtkStyle * gtk_style_new(void);
    GtkStyle * gtk_style_copy(GtkStyle * style);
    GtkStyle * gtk_style_attach(GtkStyle * style, GdkWindow * window) __attribute__((warn_unused_result));
    void gtk_style_detach(GtkStyle * style);
    GtkStyle * gtk_style_ref(GtkStyle * style);
    void gtk_style_unref(GtkStyle * style);
    GdkFont * gtk_style_get_font(GtkStyle * style);
    void gtk_style_set_font(GtkStyle * style, GdkFont * font);
    void gtk_style_set_background(GtkStyle * style, GdkWindow * window, GtkStateType state_type);
    void gtk_style_apply_default_background(GtkStyle * style, GdkWindow * window, gboolean set_bg, GtkStateType state_type, GdkRectangle * area, gint x, gint y, gint width, gint height);
    GtkIconSet * gtk_style_lookup_icon_set(GtkStyle * style, const gchar * stock_id);
    gboolean gtk_style_lookup_color(GtkStyle * style, const gchar * color_name, GdkColor * color);
    GdkPixbuf * gtk_style_render_icon(GtkStyle * style, const GtkIconSource * source, GtkTextDirection direction, GtkStateType state, GtkIconSize size, GtkWidget * widget, const gchar * detail);
    void gtk_draw_hline(GtkStyle * style, GdkWindow * window, GtkStateType state_type, gint x1, gint x2, gint y);
    void gtk_draw_vline(GtkStyle * style, GdkWindow * window, GtkStateType state_type, gint y1_, gint y2_, gint x);
    void gtk_draw_shadow(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height);
    void gtk_draw_polygon(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkPoint * points, gint npoints, gboolean fill);
    void gtk_draw_arrow(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GtkArrowType arrow_type, gboolean fill, gint x, gint y, gint width, gint height);
    void gtk_draw_diamond(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height);
    void gtk_draw_box(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height);
    void gtk_draw_flat_box(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height);
    void gtk_draw_check(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height);
    void gtk_draw_option(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height);
    void gtk_draw_tab(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height);
    void gtk_draw_shadow_gap(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height, GtkPositionType gap_side, gint gap_x, gint gap_width);
    void gtk_draw_box_gap(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height, GtkPositionType gap_side, gint gap_x, gint gap_width);
    void gtk_draw_extension(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height, GtkPositionType gap_side);
    void gtk_draw_focus(GtkStyle * style, GdkWindow * window, gint x, gint y, gint width, gint height);
    void gtk_draw_slider(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height, GtkOrientation orientation);
    void gtk_draw_handle(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height, GtkOrientation orientation);
    void gtk_draw_expander(GtkStyle * style, GdkWindow * window, GtkStateType state_type, gint x, gint y, GtkExpanderStyle expander_style);
    void gtk_draw_layout(GtkStyle * style, GdkWindow * window, GtkStateType state_type, gboolean use_text, gint x, gint y, PangoLayout * layout);
    void gtk_draw_resize_grip(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GdkWindowEdge edge, gint x, gint y, gint width, gint height);
    void gtk_paint_hline(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x1, gint x2, gint y);
    void gtk_paint_vline(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint y1_, gint y2_, gint x);
    void gtk_paint_shadow(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height);
    void gtk_paint_polygon(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, GdkPoint * points, gint npoints, gboolean fill);
    void gtk_paint_arrow(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, GtkArrowType arrow_type, gboolean fill, gint x, gint y, gint width, gint height);
    void gtk_paint_diamond(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height);
    void gtk_paint_box(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height);
    void gtk_paint_flat_box(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height);
    void gtk_paint_check(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height);
    void gtk_paint_option(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height);
    void gtk_paint_tab(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height);
    void gtk_paint_shadow_gap(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, gchar * detail, gint x, gint y, gint width, gint height, GtkPositionType gap_side, gint gap_x, gint gap_width);
    void gtk_paint_box_gap(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, gchar * detail, gint x, gint y, gint width, gint height, GtkPositionType gap_side, gint gap_x, gint gap_width);
    void gtk_paint_extension(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, gchar * detail, gint x, gint y, gint width, gint height, GtkPositionType gap_side);
    void gtk_paint_focus(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height);
    void gtk_paint_slider(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height, GtkOrientation orientation);
    void gtk_paint_handle(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GtkShadowType shadow_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, gint width, gint height, GtkOrientation orientation);
    void gtk_paint_expander(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, GtkExpanderStyle expander_style);
    void gtk_paint_layout(GtkStyle * style, GdkWindow * window, GtkStateType state_type, gboolean use_text, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, PangoLayout * layout);
    void gtk_paint_resize_grip(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, GdkWindowEdge edge, gint x, gint y, gint width, gint height);
    GType gtk_border_get_type(void) __attribute__((__const__));
    GtkBorder * gtk_border_copy(const GtkBorder * border_);
    void gtk_border_free(GtkBorder * border_);
    const GValue * _gtk_style_peek_property_value(GtkStyle * style, GType widget_type, GParamSpec * pspec, GtkRcPropertyParser parser);
    void _gtk_style_init_for_settings(GtkStyle * style, GtkSettings * settings);
    void _gtk_style_shade(GdkColor * a, GdkColor * b, gdouble k);
    void gtk_draw_string(GtkStyle * style, GdkWindow * window, GtkStateType state_type, gint x, gint y, const gchar * string);
    void gtk_paint_string(GtkStyle * style, GdkWindow * window, GtkStateType state_type, GdkRectangle * area, GtkWidget * widget, const gchar * detail, gint x, gint y, const gchar * string);
    void gtk_draw_insertion_cursor(GtkWidget * widget, GdkDrawable * drawable, GdkRectangle * area, GdkRectangle * location, gboolean is_primary, GtkTextDirection direction, gboolean draw_arrow);
    GdkGC * _gtk_widget_get_cursor_gc(GtkWidget * widget);
    void _gtk_widget_get_cursor_color(GtkWidget * widget, GdkColor * color);
}
extern "C"
{
    typedef struct _GtkIconFactory GtkIconFactory;
    typedef struct _GtkRcContext GtkRcContext;
    typedef struct _GtkRcStyleClass GtkRcStyleClass;
    typedef enum 
    {
        GTK_RC_FG = 1 << 0, 
        GTK_RC_BG = 1 << 1, 
        GTK_RC_TEXT = 1 << 2, 
        GTK_RC_BASE = 1 << 3
    } GtkRcFlags;
    struct _GtkRcStyle
    {
            GObject parent_instance;
            gchar * name;
            gchar * bg_pixmap_name[5];
            PangoFontDescription * font_desc;
            GtkRcFlags color_flags[5];
            GdkColor fg[5];
            GdkColor bg[5];
            GdkColor text[5];
            GdkColor base[5];
            gint xthickness;
            gint ythickness;
            GArray * rc_properties;
            GSList * rc_style_lists;
            GSList * icon_factories;
            guint engine_specified : 1;
    };
    struct _GtkRcStyleClass
    {
            GObjectClass parent_class;
            GtkRcStyle * (* create_rc_style)(GtkRcStyle * rc_style);
            guint (* parse)(GtkRcStyle * rc_style, GtkSettings * settings, GScanner * scanner);
            void (* merge)(GtkRcStyle * dest, GtkRcStyle * src);
            GtkStyle * (* create_style)(GtkRcStyle * rc_style);
            void (* _gtk_reserved1)(void);
            void (* _gtk_reserved2)(void);
            void (* _gtk_reserved3)(void);
            void (* _gtk_reserved4)(void);
    };
    void _gtk_rc_init(void);
    GSList * _gtk_rc_parse_widget_class_path(const gchar * pattern);
    void _gtk_rc_free_widget_class_path(GSList * list);
    gboolean _gtk_rc_match_widget_class(GSList * list, gint length, gchar * path, gchar * path_reversed);
    void gtk_rc_add_default_file(const gchar * filename);
    void gtk_rc_set_default_files(gchar * * filenames);
    gchar * * gtk_rc_get_default_files(void);
    GtkStyle * gtk_rc_get_style(GtkWidget * widget);
    GtkStyle * gtk_rc_get_style_by_paths(GtkSettings * settings, const char * widget_path, const char * class_path, GType type);
    gboolean gtk_rc_reparse_all_for_settings(GtkSettings * settings, gboolean force_load);
    void gtk_rc_reset_styles(GtkSettings * settings);
    gchar * gtk_rc_find_pixmap_in_path(GtkSettings * settings, GScanner * scanner, const gchar * pixmap_file);
    void gtk_rc_parse(const gchar * filename);
    void gtk_rc_parse_string(const gchar * rc_string);
    gboolean gtk_rc_reparse_all(void);
    void gtk_rc_add_widget_name_style(GtkRcStyle * rc_style, const gchar * pattern);
    void gtk_rc_add_widget_class_style(GtkRcStyle * rc_style, const gchar * pattern);
    void gtk_rc_add_class_style(GtkRcStyle * rc_style, const gchar * pattern);
    GType gtk_rc_style_get_type(void) __attribute__((__const__));
    GtkRcStyle * gtk_rc_style_new(void);
    GtkRcStyle * gtk_rc_style_copy(GtkRcStyle * orig);
    void gtk_rc_style_ref(GtkRcStyle * rc_style);
    void gtk_rc_style_unref(GtkRcStyle * rc_style);
    gchar * gtk_rc_find_module_in_path(const gchar * module_file);
    gchar * gtk_rc_get_theme_dir(void);
    gchar * gtk_rc_get_module_dir(void);
    gchar * gtk_rc_get_im_module_path(void);
    gchar * gtk_rc_get_im_module_file(void);
    typedef enum 
    {
        GTK_RC_TOKEN_INVALID = G_TOKEN_LAST, 
        GTK_RC_TOKEN_INCLUDE, 
        GTK_RC_TOKEN_NORMAL, 
        GTK_RC_TOKEN_ACTIVE, 
        GTK_RC_TOKEN_PRELIGHT, 
        GTK_RC_TOKEN_SELECTED, 
        GTK_RC_TOKEN_INSENSITIVE, 
        GTK_RC_TOKEN_FG, 
        GTK_RC_TOKEN_BG, 
        GTK_RC_TOKEN_TEXT, 
        GTK_RC_TOKEN_BASE, 
        GTK_RC_TOKEN_XTHICKNESS, 
        GTK_RC_TOKEN_YTHICKNESS, 
        GTK_RC_TOKEN_FONT, 
        GTK_RC_TOKEN_FONTSET, 
        GTK_RC_TOKEN_FONT_NAME, 
        GTK_RC_TOKEN_BG_PIXMAP, 
        GTK_RC_TOKEN_PIXMAP_PATH, 
        GTK_RC_TOKEN_STYLE, 
        GTK_RC_TOKEN_BINDING, 
        GTK_RC_TOKEN_BIND, 
        GTK_RC_TOKEN_WIDGET, 
        GTK_RC_TOKEN_WIDGET_CLASS, 
        GTK_RC_TOKEN_CLASS, 
        GTK_RC_TOKEN_LOWEST, 
        GTK_RC_TOKEN_GTK, 
        GTK_RC_TOKEN_APPLICATION, 
        GTK_RC_TOKEN_THEME, 
        GTK_RC_TOKEN_RC, 
        GTK_RC_TOKEN_HIGHEST, 
        GTK_RC_TOKEN_ENGINE, 
        GTK_RC_TOKEN_MODULE_PATH, 
        GTK_RC_TOKEN_IM_MODULE_PATH, 
        GTK_RC_TOKEN_IM_MODULE_FILE, 
        GTK_RC_TOKEN_STOCK, 
        GTK_RC_TOKEN_LTR, 
        GTK_RC_TOKEN_RTL, 
        GTK_RC_TOKEN_COLOR, 
        GTK_RC_TOKEN_UNBIND, 
        GTK_RC_TOKEN_LAST
    } GtkRcTokenType;
    GScanner * gtk_rc_scanner_new(void);
    guint gtk_rc_parse_color(GScanner * scanner, GdkColor * color);
    guint gtk_rc_parse_color_full(GScanner * scanner, GtkRcStyle * style, GdkColor * color);
    guint gtk_rc_parse_state(GScanner * scanner, GtkStateType * state);
    guint gtk_rc_parse_priority(GScanner * scanner, GtkPathPriorityType * priority);
    struct _GtkRcProperty
    {
            GQuark type_name;
            GQuark property_name;
            gchar * origin;
            GValue value;
    };
    const GtkRcProperty * _gtk_rc_style_lookup_rc_property(GtkRcStyle * rc_style, GQuark type_name, GQuark property_name);
    void _gtk_rc_style_set_rc_property(GtkRcStyle * rc_style, GtkRcProperty * property);
    void _gtk_rc_style_unset_rc_property(GtkRcStyle * rc_style, GQuark type_name, GQuark property_name);
    GSList * _gtk_rc_style_get_color_hashes(GtkRcStyle * rc_style);
    const gchar * _gtk_rc_context_get_default_font_name(GtkSettings * settings);
    void _gtk_rc_context_destroy(GtkSettings * settings);
}
extern "C"
{
    typedef struct _GtkSettingsClass GtkSettingsClass;
    typedef struct _GtkSettingsValue GtkSettingsValue;
    typedef struct _GtkSettingsPropertyValue GtkSettingsPropertyValue;
    struct _GtkSettings
    {
            GObject parent_instance;
            GData * queued_settings;
            GtkSettingsPropertyValue * property_values;
            GtkRcContext * rc_context;
            GdkScreen * screen;
    };
    struct _GtkSettingsClass
    {
            GObjectClass parent_class;
    };
    struct _GtkSettingsValue
    {
            gchar * origin;
            GValue value;
    };
    GType gtk_settings_get_type(void) __attribute__((__const__));
    GtkSettings * gtk_settings_get_default(void);
    GtkSettings * gtk_settings_get_for_screen(GdkScreen * screen);
    void gtk_settings_install_property(GParamSpec * pspec);
    void gtk_settings_install_property_parser(GParamSpec * pspec, GtkRcPropertyParser parser);
    gboolean gtk_rc_property_parse_color(const GParamSpec * pspec, const GString * gstring, GValue * property_value);
    gboolean gtk_rc_property_parse_enum(const GParamSpec * pspec, const GString * gstring, GValue * property_value);
    gboolean gtk_rc_property_parse_flags(const GParamSpec * pspec, const GString * gstring, GValue * property_value);
    gboolean gtk_rc_property_parse_requisition(const GParamSpec * pspec, const GString * gstring, GValue * property_value);
    gboolean gtk_rc_property_parse_border(const GParamSpec * pspec, const GString * gstring, GValue * property_value);
    void gtk_settings_set_property_value(GtkSettings * settings, const gchar * name, const GtkSettingsValue * svalue);
    void gtk_settings_set_string_property(GtkSettings * settings, const gchar * name, const gchar * v_string, const gchar * origin);
    void gtk_settings_set_long_property(GtkSettings * settings, const gchar * name, glong v_long, const gchar * origin);
    void gtk_settings_set_double_property(GtkSettings * settings, const gchar * name, gdouble v_double, const gchar * origin);
    void _gtk_settings_set_property_value_from_rc(GtkSettings * settings, const gchar * name, const GtkSettingsValue * svalue);
    void _gtk_settings_reset_rc_values(GtkSettings * settings);
    void _gtk_settings_handle_event(GdkEventSetting * event);
    GtkRcPropertyParser _gtk_rc_property_parser_from_type(GType type);
    gboolean _gtk_settings_parse_convert(GtkRcPropertyParser parser, const GValue * src_value, GParamSpec * pspec, GValue * dest_value);
}
extern "C"
{
    extern "C"
    {
        typedef enum 
        {
            ATK_STATE_INVALID, 
            ATK_STATE_ACTIVE, 
            ATK_STATE_ARMED, 
            ATK_STATE_BUSY, 
            ATK_STATE_CHECKED, 
            ATK_STATE_DEFUNCT, 
            ATK_STATE_EDITABLE, 
            ATK_STATE_ENABLED, 
            ATK_STATE_EXPANDABLE, 
            ATK_STATE_EXPANDED, 
            ATK_STATE_FOCUSABLE, 
            ATK_STATE_FOCUSED, 
            ATK_STATE_HORIZONTAL, 
            ATK_STATE_ICONIFIED, 
            ATK_STATE_MODAL, 
            ATK_STATE_MULTI_LINE, 
            ATK_STATE_MULTISELECTABLE, 
            ATK_STATE_OPAQUE, 
            ATK_STATE_PRESSED, 
            ATK_STATE_RESIZABLE, 
            ATK_STATE_SELECTABLE, 
            ATK_STATE_SELECTED, 
            ATK_STATE_SENSITIVE, 
            ATK_STATE_SHOWING, 
            ATK_STATE_SINGLE_LINE, 
            ATK_STATE_STALE, 
            ATK_STATE_TRANSIENT, 
            ATK_STATE_VERTICAL, 
            ATK_STATE_VISIBLE, 
            ATK_STATE_MANAGES_DESCENDANTS, 
            ATK_STATE_INDETERMINATE, 
            ATK_STATE_TRUNCATED, 
            ATK_STATE_REQUIRED, 
            ATK_STATE_INVALID_ENTRY, 
            ATK_STATE_SUPPORTS_AUTOCOMPLETION, 
            ATK_STATE_SELECTABLE_TEXT, 
            ATK_STATE_DEFAULT, 
            ATK_STATE_ANIMATED, 
            ATK_STATE_VISITED, 
            ATK_STATE_LAST_DEFINED
        } AtkStateType;
        typedef guint64 AtkState;
        AtkStateType atk_state_type_register(const gchar * name);
        const gchar * atk_state_type_get_name(AtkStateType type);
        AtkStateType atk_state_type_for_name(const gchar * name);
    }
    extern "C"
    {
        typedef enum 
        {
            ATK_RELATION_NULL = 0, 
            ATK_RELATION_CONTROLLED_BY, 
            ATK_RELATION_CONTROLLER_FOR, 
            ATK_RELATION_LABEL_FOR, 
            ATK_RELATION_LABELLED_BY, 
            ATK_RELATION_MEMBER_OF, 
            ATK_RELATION_NODE_CHILD_OF, 
            ATK_RELATION_FLOWS_TO, 
            ATK_RELATION_FLOWS_FROM, 
            ATK_RELATION_SUBWINDOW_OF, 
            ATK_RELATION_EMBEDS, 
            ATK_RELATION_EMBEDDED_BY, 
            ATK_RELATION_POPUP_FOR, 
            ATK_RELATION_PARENT_WINDOW_OF, 
            ATK_RELATION_DESCRIBED_BY, 
            ATK_RELATION_DESCRIPTION_FOR, 
            ATK_RELATION_LAST_DEFINED
        } AtkRelationType;
    }
    typedef enum 
    {
        ATK_ROLE_INVALID = 0, 
        ATK_ROLE_ACCEL_LABEL, 
        ATK_ROLE_ALERT, 
        ATK_ROLE_ANIMATION, 
        ATK_ROLE_ARROW, 
        ATK_ROLE_CALENDAR, 
        ATK_ROLE_CANVAS, 
        ATK_ROLE_CHECK_BOX, 
        ATK_ROLE_CHECK_MENU_ITEM, 
        ATK_ROLE_COLOR_CHOOSER, 
        ATK_ROLE_COLUMN_HEADER, 
        ATK_ROLE_COMBO_BOX, 
        ATK_ROLE_DATE_EDITOR, 
        ATK_ROLE_DESKTOP_ICON, 
        ATK_ROLE_DESKTOP_FRAME, 
        ATK_ROLE_DIAL, 
        ATK_ROLE_DIALOG, 
        ATK_ROLE_DIRECTORY_PANE, 
        ATK_ROLE_DRAWING_AREA, 
        ATK_ROLE_FILE_CHOOSER, 
        ATK_ROLE_FILLER, 
        ATK_ROLE_FONT_CHOOSER, 
        ATK_ROLE_FRAME, 
        ATK_ROLE_GLASS_PANE, 
        ATK_ROLE_HTML_CONTAINER, 
        ATK_ROLE_ICON, 
        ATK_ROLE_IMAGE, 
        ATK_ROLE_INTERNAL_FRAME, 
        ATK_ROLE_LABEL, 
        ATK_ROLE_LAYERED_PANE, 
        ATK_ROLE_LIST, 
        ATK_ROLE_LIST_ITEM, 
        ATK_ROLE_MENU, 
        ATK_ROLE_MENU_BAR, 
        ATK_ROLE_MENU_ITEM, 
        ATK_ROLE_OPTION_PANE, 
        ATK_ROLE_PAGE_TAB, 
        ATK_ROLE_PAGE_TAB_LIST, 
        ATK_ROLE_PANEL, 
        ATK_ROLE_PASSWORD_TEXT, 
        ATK_ROLE_POPUP_MENU, 
        ATK_ROLE_PROGRESS_BAR, 
        ATK_ROLE_PUSH_BUTTON, 
        ATK_ROLE_RADIO_BUTTON, 
        ATK_ROLE_RADIO_MENU_ITEM, 
        ATK_ROLE_ROOT_PANE, 
        ATK_ROLE_ROW_HEADER, 
        ATK_ROLE_SCROLL_BAR, 
        ATK_ROLE_SCROLL_PANE, 
        ATK_ROLE_SEPARATOR, 
        ATK_ROLE_SLIDER, 
        ATK_ROLE_SPLIT_PANE, 
        ATK_ROLE_SPIN_BUTTON, 
        ATK_ROLE_STATUSBAR, 
        ATK_ROLE_TABLE, 
        ATK_ROLE_TABLE_CELL, 
        ATK_ROLE_TABLE_COLUMN_HEADER, 
        ATK_ROLE_TABLE_ROW_HEADER, 
        ATK_ROLE_TEAR_OFF_MENU_ITEM, 
        ATK_ROLE_TERMINAL, 
        ATK_ROLE_TEXT, 
        ATK_ROLE_TOGGLE_BUTTON, 
        ATK_ROLE_TOOL_BAR, 
        ATK_ROLE_TOOL_TIP, 
        ATK_ROLE_TREE, 
        ATK_ROLE_TREE_TABLE, 
        ATK_ROLE_UNKNOWN, 
        ATK_ROLE_VIEWPORT, 
        ATK_ROLE_WINDOW, 
        ATK_ROLE_HEADER, 
        ATK_ROLE_FOOTER, 
        ATK_ROLE_PARAGRAPH, 
        ATK_ROLE_RULER, 
        ATK_ROLE_APPLICATION, 
        ATK_ROLE_AUTOCOMPLETE, 
        ATK_ROLE_EDITBAR, 
        ATK_ROLE_EMBEDDED, 
        ATK_ROLE_ENTRY, 
        ATK_ROLE_CHART, 
        ATK_ROLE_CAPTION, 
        ATK_ROLE_DOCUMENT_FRAME, 
        ATK_ROLE_HEADING, 
        ATK_ROLE_PAGE, 
        ATK_ROLE_SECTION, 
        ATK_ROLE_REDUNDANT_OBJECT, 
        ATK_ROLE_FORM, 
        ATK_ROLE_LINK, 
        ATK_ROLE_INPUT_METHOD_WINDOW, 
        ATK_ROLE_LAST_DEFINED
    } AtkRole;
    AtkRole atk_role_register(const gchar * name);
    typedef enum 
    {
        ATK_LAYER_INVALID, 
        ATK_LAYER_BACKGROUND, 
        ATK_LAYER_CANVAS, 
        ATK_LAYER_WIDGET, 
        ATK_LAYER_MDI, 
        ATK_LAYER_POPUP, 
        ATK_LAYER_OVERLAY, 
        ATK_LAYER_WINDOW
    } AtkLayer;
    typedef GSList AtkAttributeSet;
    typedef struct _AtkAttribute AtkAttribute;
    struct _AtkAttribute
    {
            gchar * name;
            gchar * value;
    };
    typedef struct _AtkImplementor AtkImplementor;
    typedef struct _AtkImplementorIface AtkImplementorIface;
    typedef struct _AtkObject AtkObject;
    typedef struct _AtkObjectClass AtkObjectClass;
    typedef struct _AtkRelationSet AtkRelationSet;
    typedef struct _AtkStateSet AtkStateSet;
    struct _AtkPropertyValues
    {
            const gchar * property_name;
            GValue old_value;
            GValue new_value;
    };
    typedef struct _AtkPropertyValues AtkPropertyValues;
    typedef gboolean (* AtkFunction)(gpointer data);
    typedef void (* AtkPropertyChangeHandler)(AtkObject *, AtkPropertyValues *);
    struct _AtkObject
    {
            GObject parent;
            gchar * description;
            gchar * name;
            AtkObject * accessible_parent;
            AtkRole role;
            AtkRelationSet * relation_set;
            AtkLayer layer;
    };
    struct _AtkObjectClass
    {
            GObjectClass parent;
            const gchar * (* get_name)(AtkObject * accessible);
            const gchar * (* get_description)(AtkObject * accessible);
            AtkObject * (* get_parent)(AtkObject * accessible);
            gint (* get_n_children)(AtkObject * accessible);
            AtkObject * (* ref_child)(AtkObject * accessible, gint i);
            gint (* get_index_in_parent)(AtkObject * accessible);
            AtkRelationSet * (* ref_relation_set)(AtkObject * accessible);
            AtkRole (* get_role)(AtkObject * accessible);
            AtkLayer (* get_layer)(AtkObject * accessible);
            gint (* get_mdi_zorder)(AtkObject * accessible);
            AtkStateSet * (* ref_state_set)(AtkObject * accessible);
            void (* set_name)(AtkObject * accessible, const gchar * name);
            void (* set_description)(AtkObject * accessible, const gchar * description);
            void (* set_parent)(AtkObject * accessible, AtkObject * parent);
            void (* set_role)(AtkObject * accessible, AtkRole role);
            guint (* connect_property_change_handler)(AtkObject * accessible, AtkPropertyChangeHandler * handler);
            void (* remove_property_change_handler)(AtkObject * accessible, guint handler_id);
            void (* initialize)(AtkObject * accessible, gpointer data);
            void (* children_changed)(AtkObject * accessible, guint change_index, gpointer changed_child);
            void (* focus_event)(AtkObject * accessible, gboolean focus_in);
            void (* property_change)(AtkObject * accessible, AtkPropertyValues * values);
            void (* state_change)(AtkObject * accessible, const gchar * name, gboolean state_set);
            void (* visible_data_changed)(AtkObject * accessible);
            void (* active_descendant_changed)(AtkObject * accessible, gpointer * child);
            AtkAttributeSet * (* get_attributes)(AtkObject * accessible);
            AtkFunction pad1;
            AtkFunction pad2;
    };
    GType atk_object_get_type(void);
    struct _AtkImplementorIface
    {
            GTypeInterface parent;
            AtkObject * (* ref_accessible)(AtkImplementor * implementor);
    };
    GType atk_implementor_get_type(void);
    AtkObject * atk_implementor_ref_accessible(AtkImplementor * implementor);
    const gchar * atk_object_get_name(AtkObject * accessible);
    const gchar * atk_object_get_description(AtkObject * accessible);
    AtkObject * atk_object_get_parent(AtkObject * accessible);
    gint atk_object_get_n_accessible_children(AtkObject * accessible);
    AtkObject * atk_object_ref_accessible_child(AtkObject * accessible, gint i);
    AtkRelationSet * atk_object_ref_relation_set(AtkObject * accessible);
    AtkRole atk_object_get_role(AtkObject * accessible);
    AtkLayer atk_object_get_layer(AtkObject * accessible);
    gint atk_object_get_mdi_zorder(AtkObject * accessible);
    AtkAttributeSet * atk_object_get_attributes(AtkObject * accessible);
    AtkStateSet * atk_object_ref_state_set(AtkObject * accessible);
    gint atk_object_get_index_in_parent(AtkObject * accessible);
    void atk_object_set_name(AtkObject * accessible, const gchar * name);
    void atk_object_set_description(AtkObject * accessible, const gchar * description);
    void atk_object_set_parent(AtkObject * accessible, AtkObject * parent);
    void atk_object_set_role(AtkObject * accessible, AtkRole role);
    guint atk_object_connect_property_change_handler(AtkObject * accessible, AtkPropertyChangeHandler * handler);
    void atk_object_remove_property_change_handler(AtkObject * accessible, guint handler_id);
    void atk_object_notify_state_change(AtkObject * accessible, AtkState state, gboolean value);
    void atk_object_initialize(AtkObject * accessible, gpointer data);
    const gchar * atk_role_get_name(AtkRole role);
    AtkRole atk_role_for_name(const gchar * name);
    gboolean atk_object_add_relationship(AtkObject * object, AtkRelationType relationship, AtkObject * target);
    gboolean atk_object_remove_relationship(AtkObject * object, AtkRelationType relationship, AtkObject * target);
    const gchar * atk_role_get_localized_name(AtkRole role);
}
extern "C"
{
    typedef enum 
    {
        GTK_TOPLEVEL = 1 << 4, 
        GTK_NO_WINDOW = 1 << 5, 
        GTK_REALIZED = 1 << 6, 
        GTK_MAPPED = 1 << 7, 
        GTK_VISIBLE = 1 << 8, 
        GTK_SENSITIVE = 1 << 9, 
        GTK_PARENT_SENSITIVE = 1 << 10, 
        GTK_CAN_FOCUS = 1 << 11, 
        GTK_HAS_FOCUS = 1 << 12, 
        GTK_CAN_DEFAULT = 1 << 13, 
        GTK_HAS_DEFAULT = 1 << 14, 
        GTK_HAS_GRAB = 1 << 15, 
        GTK_RC_STYLE = 1 << 16, 
        GTK_COMPOSITE_CHILD = 1 << 17, 
        GTK_NO_REPARENT = 1 << 18, 
        GTK_APP_PAINTABLE = 1 << 19, 
        GTK_RECEIVES_DEFAULT = 1 << 20, 
        GTK_DOUBLE_BUFFERED = 1 << 21, 
        GTK_NO_SHOW_ALL = 1 << 22
    } GtkWidgetFlags;
    typedef enum 
    {
        GTK_WIDGET_HELP_TOOLTIP, 
        GTK_WIDGET_HELP_WHATS_THIS
    } GtkWidgetHelpType;
    typedef struct _GtkRequisition GtkRequisition;
    typedef GdkRectangle GtkAllocation;
    typedef struct _GtkSelectionData GtkSelectionData;
    typedef struct _GtkWidgetClass GtkWidgetClass;
    typedef struct _GtkWidgetAuxInfo GtkWidgetAuxInfo;
    typedef struct _GtkWidgetShapeInfo GtkWidgetShapeInfo;
    typedef struct _GtkClipboard GtkClipboard;
    typedef struct _GtkTooltip GtkTooltip;
    typedef struct _GtkWindow GtkWindow;
    typedef void (* GtkCallback)(GtkWidget * widget, gpointer data);
    struct _GtkRequisition
    {
            gint width;
            gint height;
    };
    struct _GtkWidget
    {
            GtkObject object;
            guint16 private_flags;
            guint8 state;
            guint8 saved_state;
            gchar * name;
            GtkStyle * style;
            GtkRequisition requisition;
            GtkAllocation allocation;
            GdkWindow * window;
            GtkWidget * parent;
    };
    struct _GtkWidgetClass
    {
            GtkObjectClass parent_class;
            guint activate_signal;
            guint set_scroll_adjustments_signal;
            void (* dispatch_child_properties_changed)(GtkWidget * widget, guint n_pspecs, GParamSpec * * pspecs);
            void (* show)(GtkWidget * widget);
            void (* show_all)(GtkWidget * widget);
            void (* hide)(GtkWidget * widget);
            void (* hide_all)(GtkWidget * widget);
            void (* map)(GtkWidget * widget);
            void (* unmap)(GtkWidget * widget);
            void (* realize)(GtkWidget * widget);
            void (* unrealize)(GtkWidget * widget);
            void (* size_request)(GtkWidget * widget, GtkRequisition * requisition);
            void (* size_allocate)(GtkWidget * widget, GtkAllocation * allocation);
            void (* state_changed)(GtkWidget * widget, GtkStateType previous_state);
            void (* parent_set)(GtkWidget * widget, GtkWidget * previous_parent);
            void (* hierarchy_changed)(GtkWidget * widget, GtkWidget * previous_toplevel);
            void (* style_set)(GtkWidget * widget, GtkStyle * previous_style);
            void (* direction_changed)(GtkWidget * widget, GtkTextDirection previous_direction);
            void (* grab_notify)(GtkWidget * widget, gboolean was_grabbed);
            void (* child_notify)(GtkWidget * widget, GParamSpec * pspec);
            gboolean (* mnemonic_activate)(GtkWidget * widget, gboolean group_cycling);
            void (* grab_focus)(GtkWidget * widget);
            gboolean (* focus)(GtkWidget * widget, GtkDirectionType direction);
            gboolean (* event)(GtkWidget * widget, GdkEvent * event);
            gboolean (* button_press_event)(GtkWidget * widget, GdkEventButton * event);
            gboolean (* button_release_event)(GtkWidget * widget, GdkEventButton * event);
            gboolean (* scroll_event)(GtkWidget * widget, GdkEventScroll * event);
            gboolean (* motion_notify_event)(GtkWidget * widget, GdkEventMotion * event);
            gboolean (* delete_event)(GtkWidget * widget, GdkEventAny * event);
            gboolean (* destroy_event)(GtkWidget * widget, GdkEventAny * event);
            gboolean (* expose_event)(GtkWidget * widget, GdkEventExpose * event);
            gboolean (* key_press_event)(GtkWidget * widget, GdkEventKey * event);
            gboolean (* key_release_event)(GtkWidget * widget, GdkEventKey * event);
            gboolean (* enter_notify_event)(GtkWidget * widget, GdkEventCrossing * event);
            gboolean (* leave_notify_event)(GtkWidget * widget, GdkEventCrossing * event);
            gboolean (* configure_event)(GtkWidget * widget, GdkEventConfigure * event);
            gboolean (* focus_in_event)(GtkWidget * widget, GdkEventFocus * event);
            gboolean (* focus_out_event)(GtkWidget * widget, GdkEventFocus * event);
            gboolean (* map_event)(GtkWidget * widget, GdkEventAny * event);
            gboolean (* unmap_event)(GtkWidget * widget, GdkEventAny * event);
            gboolean (* property_notify_event)(GtkWidget * widget, GdkEventProperty * event);
            gboolean (* selection_clear_event)(GtkWidget * widget, GdkEventSelection * event);
            gboolean (* selection_request_event)(GtkWidget * widget, GdkEventSelection * event);
            gboolean (* selection_notify_event)(GtkWidget * widget, GdkEventSelection * event);
            gboolean (* proximity_in_event)(GtkWidget * widget, GdkEventProximity * event);
            gboolean (* proximity_out_event)(GtkWidget * widget, GdkEventProximity * event);
            gboolean (* visibility_notify_event)(GtkWidget * widget, GdkEventVisibility * event);
            gboolean (* client_event)(GtkWidget * widget, GdkEventClient * event);
            gboolean (* no_expose_event)(GtkWidget * widget, GdkEventAny * event);
            gboolean (* window_state_event)(GtkWidget * widget, GdkEventWindowState * event);
            void (* selection_get)(GtkWidget * widget, GtkSelectionData * selection_data, guint info, guint time_);
            void (* selection_received)(GtkWidget * widget, GtkSelectionData * selection_data, guint time_);
            void (* drag_begin)(GtkWidget * widget, GdkDragContext * context);
            void (* drag_end)(GtkWidget * widget, GdkDragContext * context);
            void (* drag_data_get)(GtkWidget * widget, GdkDragContext * context, GtkSelectionData * selection_data, guint info, guint time_);
            void (* drag_data_delete)(GtkWidget * widget, GdkDragContext * context);
            void (* drag_leave)(GtkWidget * widget, GdkDragContext * context, guint time_);
            gboolean (* drag_motion)(GtkWidget * widget, GdkDragContext * context, gint x, gint y, guint time_);
            gboolean (* drag_drop)(GtkWidget * widget, GdkDragContext * context, gint x, gint y, guint time_);
            void (* drag_data_received)(GtkWidget * widget, GdkDragContext * context, gint x, gint y, GtkSelectionData * selection_data, guint info, guint time_);
            gboolean (* popup_menu)(GtkWidget * widget);
            gboolean (* show_help)(GtkWidget * widget, GtkWidgetHelpType help_type);
            AtkObject * (* get_accessible)(GtkWidget * widget);
            void (* screen_changed)(GtkWidget * widget, GdkScreen * previous_screen);
            gboolean (* can_activate_accel)(GtkWidget * widget, guint signal_id);
            gboolean (* grab_broken_event)(GtkWidget * widget, GdkEventGrabBroken * event);
            void (* composited_changed)(GtkWidget * widget);
            gboolean (* query_tooltip)(GtkWidget * widget, gint x, gint y, gboolean keyboard_tooltip, GtkTooltip * tooltip);
            void (* _gtk_reserved5)(void);
            void (* _gtk_reserved6)(void);
            void (* _gtk_reserved7)(void);
    };
    struct _GtkWidgetAuxInfo
    {
            gint x;
            gint y;
            gint width;
            gint height;
            guint x_set : 1;
            guint y_set : 1;
    };
    struct _GtkWidgetShapeInfo
    {
            gint16 offset_x;
            gint16 offset_y;
            GdkBitmap * shape_mask;
    };
    GType gtk_widget_get_type(void) __attribute__((__const__));
    GtkWidget * gtk_widget_new(GType type, const gchar * first_property_name, ...);
    void gtk_widget_destroy(GtkWidget * widget);
    void gtk_widget_destroyed(GtkWidget * widget, GtkWidget * * widget_pointer);
    GtkWidget * gtk_widget_ref(GtkWidget * widget);
    void gtk_widget_unref(GtkWidget * widget);
    void gtk_widget_set(GtkWidget * widget, const gchar * first_property_name, ...) __attribute__((__sentinel__));
    void gtk_widget_unparent(GtkWidget * widget);
    void gtk_widget_show(GtkWidget * widget);
    void gtk_widget_show_now(GtkWidget * widget);
    void gtk_widget_hide(GtkWidget * widget);
    void gtk_widget_show_all(GtkWidget * widget);
    void gtk_widget_hide_all(GtkWidget * widget);
    void gtk_widget_set_no_show_all(GtkWidget * widget, gboolean no_show_all);
    gboolean gtk_widget_get_no_show_all(GtkWidget * widget);
    void gtk_widget_map(GtkWidget * widget);
    void gtk_widget_unmap(GtkWidget * widget);
    void gtk_widget_realize(GtkWidget * widget);
    void gtk_widget_unrealize(GtkWidget * widget);
    void gtk_widget_queue_draw(GtkWidget * widget);
    void gtk_widget_queue_draw_area(GtkWidget * widget, gint x, gint y, gint width, gint height);
    void gtk_widget_queue_clear(GtkWidget * widget);
    void gtk_widget_queue_clear_area(GtkWidget * widget, gint x, gint y, gint width, gint height);
    void gtk_widget_queue_resize(GtkWidget * widget);
    void gtk_widget_queue_resize_no_redraw(GtkWidget * widget);
    void gtk_widget_draw(GtkWidget * widget, GdkRectangle * area);
    void gtk_widget_size_request(GtkWidget * widget, GtkRequisition * requisition);
    void gtk_widget_size_allocate(GtkWidget * widget, GtkAllocation * allocation);
    void gtk_widget_get_child_requisition(GtkWidget * widget, GtkRequisition * requisition);
    void gtk_widget_add_accelerator(GtkWidget * widget, const gchar * accel_signal, GtkAccelGroup * accel_group, guint accel_key, GdkModifierType accel_mods, GtkAccelFlags accel_flags);
    gboolean gtk_widget_remove_accelerator(GtkWidget * widget, GtkAccelGroup * accel_group, guint accel_key, GdkModifierType accel_mods);
    void gtk_widget_set_accel_path(GtkWidget * widget, const gchar * accel_path, GtkAccelGroup * accel_group);
    const gchar * _gtk_widget_get_accel_path(GtkWidget * widget, gboolean * locked);
    GList * gtk_widget_list_accel_closures(GtkWidget * widget);
    gboolean gtk_widget_can_activate_accel(GtkWidget * widget, guint signal_id);
    gboolean gtk_widget_mnemonic_activate(GtkWidget * widget, gboolean group_cycling);
    gboolean gtk_widget_event(GtkWidget * widget, GdkEvent * event);
    gint gtk_widget_send_expose(GtkWidget * widget, GdkEvent * event);
    gboolean gtk_widget_activate(GtkWidget * widget);
    gboolean gtk_widget_set_scroll_adjustments(GtkWidget * widget, GtkAdjustment * hadjustment, GtkAdjustment * vadjustment);
    void gtk_widget_reparent(GtkWidget * widget, GtkWidget * new_parent);
    gboolean gtk_widget_intersect(GtkWidget * widget, GdkRectangle * area, GdkRectangle * intersection);
    GdkRegion * gtk_widget_region_intersect(GtkWidget * widget, GdkRegion * region);
    void gtk_widget_freeze_child_notify(GtkWidget * widget);
    void gtk_widget_child_notify(GtkWidget * widget, const gchar * child_property);
    void gtk_widget_thaw_child_notify(GtkWidget * widget);
    gboolean gtk_widget_is_focus(GtkWidget * widget);
    void gtk_widget_grab_focus(GtkWidget * widget);
    void gtk_widget_grab_default(GtkWidget * widget);
    void gtk_widget_set_name(GtkWidget * widget, const gchar * name);
    const gchar * gtk_widget_get_name(GtkWidget * widget);
    void gtk_widget_set_state(GtkWidget * widget, GtkStateType state);
    void gtk_widget_set_sensitive(GtkWidget * widget, gboolean sensitive);
    void gtk_widget_set_app_paintable(GtkWidget * widget, gboolean app_paintable);
    void gtk_widget_set_double_buffered(GtkWidget * widget, gboolean double_buffered);
    void gtk_widget_set_redraw_on_allocate(GtkWidget * widget, gboolean redraw_on_allocate);
    void gtk_widget_set_parent(GtkWidget * widget, GtkWidget * parent);
    void gtk_widget_set_parent_window(GtkWidget * widget, GdkWindow * parent_window);
    void gtk_widget_set_child_visible(GtkWidget * widget, gboolean is_visible);
    gboolean gtk_widget_get_child_visible(GtkWidget * widget);
    GtkWidget * gtk_widget_get_parent(GtkWidget * widget);
    GdkWindow * gtk_widget_get_parent_window(GtkWidget * widget);
    gboolean gtk_widget_child_focus(GtkWidget * widget, GtkDirectionType direction);
    gboolean gtk_widget_keynav_failed(GtkWidget * widget, GtkDirectionType direction);
    void gtk_widget_error_bell(GtkWidget * widget);
    void gtk_widget_set_size_request(GtkWidget * widget, gint width, gint height);
    void gtk_widget_get_size_request(GtkWidget * widget, gint * width, gint * height);
    void gtk_widget_set_uposition(GtkWidget * widget, gint x, gint y);
    void gtk_widget_set_usize(GtkWidget * widget, gint width, gint height);
    void gtk_widget_set_events(GtkWidget * widget, gint events);
    void gtk_widget_add_events(GtkWidget * widget, gint events);
    void gtk_widget_set_extension_events(GtkWidget * widget, GdkExtensionMode mode);
    GdkExtensionMode gtk_widget_get_extension_events(GtkWidget * widget);
    GtkWidget * gtk_widget_get_toplevel(GtkWidget * widget);
    GtkWidget * gtk_widget_get_ancestor(GtkWidget * widget, GType widget_type);
    GdkColormap * gtk_widget_get_colormap(GtkWidget * widget);
    GdkVisual * gtk_widget_get_visual(GtkWidget * widget);
    GdkScreen * gtk_widget_get_screen(GtkWidget * widget);
    gboolean gtk_widget_has_screen(GtkWidget * widget);
    GdkDisplay * gtk_widget_get_display(GtkWidget * widget);
    GdkWindow * gtk_widget_get_root_window(GtkWidget * widget);
    GtkSettings * gtk_widget_get_settings(GtkWidget * widget);
    GtkClipboard * gtk_widget_get_clipboard(GtkWidget * widget, GdkAtom selection);
    AtkObject * gtk_widget_get_accessible(GtkWidget * widget);
    void gtk_widget_set_colormap(GtkWidget * widget, GdkColormap * colormap);
    gint gtk_widget_get_events(GtkWidget * widget);
    void gtk_widget_get_pointer(GtkWidget * widget, gint * x, gint * y);
    gboolean gtk_widget_is_ancestor(GtkWidget * widget, GtkWidget * ancestor);
    gboolean gtk_widget_translate_coordinates(GtkWidget * src_widget, GtkWidget * dest_widget, gint src_x, gint src_y, gint * dest_x, gint * dest_y);
    gboolean gtk_widget_hide_on_delete(GtkWidget * widget);
    void gtk_widget_set_style(GtkWidget * widget, GtkStyle * style);
    void gtk_widget_ensure_style(GtkWidget * widget);
    GtkStyle * gtk_widget_get_style(GtkWidget * widget);
    void gtk_widget_modify_style(GtkWidget * widget, GtkRcStyle * style);
    GtkRcStyle * gtk_widget_get_modifier_style(GtkWidget * widget);
    void gtk_widget_modify_fg(GtkWidget * widget, GtkStateType state, const GdkColor * color);
    void gtk_widget_modify_bg(GtkWidget * widget, GtkStateType state, const GdkColor * color);
    void gtk_widget_modify_text(GtkWidget * widget, GtkStateType state, const GdkColor * color);
    void gtk_widget_modify_base(GtkWidget * widget, GtkStateType state, const GdkColor * color);
    void gtk_widget_modify_cursor(GtkWidget * widget, const GdkColor * primary, const GdkColor * secondary);
    void gtk_widget_modify_font(GtkWidget * widget, PangoFontDescription * font_desc);
    PangoContext * gtk_widget_create_pango_context(GtkWidget * widget);
    PangoContext * gtk_widget_get_pango_context(GtkWidget * widget);
    PangoLayout * gtk_widget_create_pango_layout(GtkWidget * widget, const gchar * text);
    GdkPixbuf * gtk_widget_render_icon(GtkWidget * widget, const gchar * stock_id, GtkIconSize size, const gchar * detail);
    void gtk_widget_set_composite_name(GtkWidget * widget, const gchar * name);
    gchar * gtk_widget_get_composite_name(GtkWidget * widget);
    void gtk_widget_reset_rc_styles(GtkWidget * widget);
    void gtk_widget_push_colormap(GdkColormap * cmap);
    void gtk_widget_push_composite_child(void);
    void gtk_widget_pop_composite_child(void);
    void gtk_widget_pop_colormap(void);
    void gtk_widget_class_install_style_property(GtkWidgetClass * klass, GParamSpec * pspec);
    void gtk_widget_class_install_style_property_parser(GtkWidgetClass * klass, GParamSpec * pspec, GtkRcPropertyParser parser);
    GParamSpec * gtk_widget_class_find_style_property(GtkWidgetClass * klass, const gchar * property_name);
    GParamSpec * * gtk_widget_class_list_style_properties(GtkWidgetClass * klass, guint * n_properties);
    void gtk_widget_style_get_property(GtkWidget * widget, const gchar * property_name, GValue * value);
    void gtk_widget_style_get_valist(GtkWidget * widget, const gchar * first_property_name, va_list var_args);
    void gtk_widget_style_get(GtkWidget * widget, const gchar * first_property_name, ...) __attribute__((__sentinel__));
    void gtk_widget_set_default_colormap(GdkColormap * colormap);
    GtkStyle * gtk_widget_get_default_style(void);
    GdkColormap * gtk_widget_get_default_colormap(void);
    GdkVisual * gtk_widget_get_default_visual(void);
    void gtk_widget_set_direction(GtkWidget * widget, GtkTextDirection dir);
    GtkTextDirection gtk_widget_get_direction(GtkWidget * widget);
    void gtk_widget_set_default_direction(GtkTextDirection dir);
    GtkTextDirection gtk_widget_get_default_direction(void);
    gboolean gtk_widget_is_composited(GtkWidget * widget);
    void gtk_widget_shape_combine_mask(GtkWidget * widget, GdkBitmap * shape_mask, gint offset_x, gint offset_y);
    void gtk_widget_input_shape_combine_mask(GtkWidget * widget, GdkBitmap * shape_mask, gint offset_x, gint offset_y);
    void gtk_widget_reset_shapes(GtkWidget * widget);
    void gtk_widget_path(GtkWidget * widget, guint * path_length, gchar * * path, gchar * * path_reversed);
    void gtk_widget_class_path(GtkWidget * widget, guint * path_length, gchar * * path, gchar * * path_reversed);
    GList * gtk_widget_list_mnemonic_labels(GtkWidget * widget);
    void gtk_widget_add_mnemonic_label(GtkWidget * widget, GtkWidget * label);
    void gtk_widget_remove_mnemonic_label(GtkWidget * widget, GtkWidget * label);
    void gtk_widget_set_tooltip_window(GtkWidget * widget, GtkWindow * custom_window);
    GtkWindow * gtk_widget_get_tooltip_window(GtkWidget * widget);
    void gtk_widget_trigger_tooltip_query(GtkWidget * widget);
    void gtk_widget_set_tooltip_text(GtkWidget * widget, const gchar * text);
    gchar * gtk_widget_get_tooltip_text(GtkWidget * widget);
    void gtk_widget_set_tooltip_markup(GtkWidget * widget, const gchar * markup);
    gchar * gtk_widget_get_tooltip_markup(GtkWidget * widget);
    void gtk_widget_set_has_tooltip(GtkWidget * widget, gboolean has_tooltip);
    gboolean gtk_widget_get_has_tooltip(GtkWidget * widget);
    GType gtk_requisition_get_type(void) __attribute__((__const__));
    GtkRequisition * gtk_requisition_copy(const GtkRequisition * requisition);
    void gtk_requisition_free(GtkRequisition * requisition);
    void _gtk_widget_grab_notify(GtkWidget * widget, gboolean was_grabbed);
    GtkWidgetAuxInfo * _gtk_widget_get_aux_info(GtkWidget * widget, gboolean create);
    void _gtk_widget_propagate_hierarchy_changed(GtkWidget * widget, GtkWidget * previous_toplevel);
    void _gtk_widget_propagate_screen_changed(GtkWidget * widget, GdkScreen * previous_screen);
    void _gtk_widget_propagate_composited_changed(GtkWidget * widget);
    GdkColormap * _gtk_widget_peek_colormap(void);
}
extern "C"
{
    typedef struct _GtkTextIter GtkTextIter;
    typedef struct _GtkTextTagTable GtkTextTagTable;
    typedef struct _GtkTextAttributes GtkTextAttributes;
    typedef struct _GtkTextTag GtkTextTag;
    typedef struct _GtkTextTagClass GtkTextTagClass;
    struct _GtkTextTag
    {
            GObject parent_instance;
            GtkTextTagTable * table;
            char * name;
            int priority;
            GtkTextAttributes * values;
            guint bg_color_set : 1;
            guint bg_stipple_set : 1;
            guint fg_color_set : 1;
            guint scale_set : 1;
            guint fg_stipple_set : 1;
            guint justification_set : 1;
            guint left_margin_set : 1;
            guint indent_set : 1;
            guint rise_set : 1;
            guint strikethrough_set : 1;
            guint right_margin_set : 1;
            guint pixels_above_lines_set : 1;
            guint pixels_below_lines_set : 1;
            guint pixels_inside_wrap_set : 1;
            guint tabs_set : 1;
            guint underline_set : 1;
            guint wrap_mode_set : 1;
            guint bg_full_height_set : 1;
            guint invisible_set : 1;
            guint editable_set : 1;
            guint language_set : 1;
            guint pg_bg_color_set : 1;
            guint accumulative_margin : 1;
            guint pad1 : 1;
    };
    struct _GtkTextTagClass
    {
            GObjectClass parent_class;
            gboolean (* event)(GtkTextTag * tag, GObject * event_object, GdkEvent * event, const GtkTextIter * iter);
            void (* _gtk_reserved1)(void);
            void (* _gtk_reserved2)(void);
            void (* _gtk_reserved3)(void);
            void (* _gtk_reserved4)(void);
    };
    GType gtk_text_tag_get_type(void) __attribute__((__const__));
    GtkTextTag * gtk_text_tag_new(const gchar * name);
    gint gtk_text_tag_get_priority(GtkTextTag * tag);
    void gtk_text_tag_set_priority(GtkTextTag * tag, gint priority);
    gboolean gtk_text_tag_event(GtkTextTag * tag, GObject * event_object, GdkEvent * event, const GtkTextIter * iter);
    typedef struct _GtkTextAppearance GtkTextAppearance;
    struct _GtkTextAppearance
    {
            GdkColor bg_color;
            GdkColor fg_color;
            GdkBitmap * bg_stipple;
            GdkBitmap * fg_stipple;
            gint rise;
            gpointer padding1;
            guint underline : 4;
            guint strikethrough : 1;
            guint draw_bg : 1;
            guint inside_selection : 1;
            guint is_text : 1;
            guint pad1 : 1;
            guint pad2 : 1;
            guint pad3 : 1;
            guint pad4 : 1;
    };
    struct _GtkTextAttributes
    {
            guint refcount;
            GtkTextAppearance appearance;
            GtkJustification justification;
            GtkTextDirection direction;
            PangoFontDescription * font;
            gdouble font_scale;
            gint left_margin;
            gint indent;
            gint right_margin;
            gint pixels_above_lines;
            gint pixels_below_lines;
            gint pixels_inside_wrap;
            PangoTabArray * tabs;
            GtkWrapMode wrap_mode;
            PangoLanguage * language;
            GdkColor * pg_bg_color;
            guint invisible : 1;
            guint bg_full_height : 1;
            guint editable : 1;
            guint realized : 1;
            guint pad1 : 1;
            guint pad2 : 1;
            guint pad3 : 1;
            guint pad4 : 1;
    };
    GtkTextAttributes * gtk_text_attributes_new(void);
    GtkTextAttributes * gtk_text_attributes_copy(GtkTextAttributes * src);
    void gtk_text_attributes_copy_values(GtkTextAttributes * src, GtkTextAttributes * dest);
    void gtk_text_attributes_unref(GtkTextAttributes * values);
    GtkTextAttributes * gtk_text_attributes_ref(GtkTextAttributes * values);
    GType gtk_text_attributes_get_type(void) __attribute__((__const__));
}
extern "C"
{
    typedef struct _GtkTextChildAnchor GtkTextChildAnchor;
    typedef struct _GtkTextChildAnchorClass GtkTextChildAnchorClass;
    struct _GtkTextChildAnchor
    {
            GObject parent_instance;
            gpointer segment;
    };
    struct _GtkTextChildAnchorClass
    {
            GObjectClass parent_class;
            void (* _gtk_reserved1)(void);
            void (* _gtk_reserved2)(void);
            void (* _gtk_reserved3)(void);
            void (* _gtk_reserved4)(void);
    };
    GType gtk_text_child_anchor_get_type(void) __attribute__((__const__));
    GtkTextChildAnchor * gtk_text_child_anchor_new(void);
    GList * gtk_text_child_anchor_get_widgets(GtkTextChildAnchor * anchor);
    gboolean gtk_text_child_anchor_get_deleted(GtkTextChildAnchor * anchor);
}
extern "C"
{
    typedef enum 
    {
        GTK_TEXT_SEARCH_VISIBLE_ONLY = 1 << 0, 
        GTK_TEXT_SEARCH_TEXT_ONLY = 1 << 1
    } GtkTextSearchFlags;
    typedef struct _GtkTextBuffer GtkTextBuffer;
    struct _GtkTextIter
    {
            gpointer dummy1;
            gpointer dummy2;
            gint dummy3;
            gint dummy4;
            gint dummy5;
            gint dummy6;
            gint dummy7;
            gint dummy8;
            gpointer dummy9;
            gpointer dummy10;
            gint dummy11;
            gint dummy12;
            gint dummy13;
            gpointer dummy14;
    };
    GtkTextBuffer * gtk_text_iter_get_buffer(const GtkTextIter * iter);
    GtkTextIter * gtk_text_iter_copy(const GtkTextIter * iter);
    void gtk_text_iter_free(GtkTextIter * iter);
    GType gtk_text_iter_get_type(void) __attribute__((__const__));
    gint gtk_text_iter_get_offset(const GtkTextIter * iter);
    gint gtk_text_iter_get_line(const GtkTextIter * iter);
    gint gtk_text_iter_get_line_offset(const GtkTextIter * iter);
    gint gtk_text_iter_get_line_index(const GtkTextIter * iter);
    gint gtk_text_iter_get_visible_line_offset(const GtkTextIter * iter);
    gint gtk_text_iter_get_visible_line_index(const GtkTextIter * iter);
    gunichar gtk_text_iter_get_char(const GtkTextIter * iter);
    gchar * gtk_text_iter_get_slice(const GtkTextIter * start, const GtkTextIter * end);
    gchar * gtk_text_iter_get_text(const GtkTextIter * start, const GtkTextIter * end);
    gchar * gtk_text_iter_get_visible_slice(const GtkTextIter * start, const GtkTextIter * end);
    gchar * gtk_text_iter_get_visible_text(const GtkTextIter * start, const GtkTextIter * end);
    GdkPixbuf * gtk_text_iter_get_pixbuf(const GtkTextIter * iter);
    GSList * gtk_text_iter_get_marks(const GtkTextIter * iter);
    GtkTextChildAnchor * gtk_text_iter_get_child_anchor(const GtkTextIter * iter);
    GSList * gtk_text_iter_get_toggled_tags(const GtkTextIter * iter, gboolean toggled_on);
    gboolean gtk_text_iter_begins_tag(const GtkTextIter * iter, GtkTextTag * tag);
    gboolean gtk_text_iter_ends_tag(const GtkTextIter * iter, GtkTextTag * tag);
    gboolean gtk_text_iter_toggles_tag(const GtkTextIter * iter, GtkTextTag * tag);
    gboolean gtk_text_iter_has_tag(const GtkTextIter * iter, GtkTextTag * tag);
    GSList * gtk_text_iter_get_tags(const GtkTextIter * iter);
    gboolean gtk_text_iter_editable(const GtkTextIter * iter, gboolean default_setting);
    gboolean gtk_text_iter_can_insert(const GtkTextIter * iter, gboolean default_editability);
    gboolean gtk_text_iter_starts_word(const GtkTextIter * iter);
    gboolean gtk_text_iter_ends_word(const GtkTextIter * iter);
    gboolean gtk_text_iter_inside_word(const GtkTextIter * iter);
    gboolean gtk_text_iter_starts_sentence(const GtkTextIter * iter);
    gboolean gtk_text_iter_ends_sentence(const GtkTextIter * iter);
    gboolean gtk_text_iter_inside_sentence(const GtkTextIter * iter);
    gboolean gtk_text_iter_starts_line(const GtkTextIter * iter);
    gboolean gtk_text_iter_ends_line(const GtkTextIter * iter);
    gboolean gtk_text_iter_is_cursor_position(const GtkTextIter * iter);
    gint gtk_text_iter_get_chars_in_line(const GtkTextIter * iter);
    gint gtk_text_iter_get_bytes_in_line(const GtkTextIter * iter);
    gboolean gtk_text_iter_get_attributes(const GtkTextIter * iter, GtkTextAttributes * values);
    PangoLanguage * gtk_text_iter_get_language(const GtkTextIter * iter);
    gboolean gtk_text_iter_is_end(const GtkTextIter * iter);
    gboolean gtk_text_iter_is_start(const GtkTextIter * iter);
    gboolean gtk_text_iter_forward_char(GtkTextIter * iter);
    gboolean gtk_text_iter_backward_char(GtkTextIter * iter);
    gboolean gtk_text_iter_forward_chars(GtkTextIter * iter, gint count);
    gboolean gtk_text_iter_backward_chars(GtkTextIter * iter, gint count);
    gboolean gtk_text_iter_forward_line(GtkTextIter * iter);
    gboolean gtk_text_iter_backward_line(GtkTextIter * iter);
    gboolean gtk_text_iter_forward_lines(GtkTextIter * iter, gint count);
    gboolean gtk_text_iter_backward_lines(GtkTextIter * iter, gint count);
    gboolean gtk_text_iter_forward_word_end(GtkTextIter * iter);
    gboolean gtk_text_iter_backward_word_start(GtkTextIter * iter);
    gboolean gtk_text_iter_forward_word_ends(GtkTextIter * iter, gint count);
    gboolean gtk_text_iter_backward_word_starts(GtkTextIter * iter, gint count);
    gboolean gtk_text_iter_forward_visible_line(GtkTextIter * iter);
    gboolean gtk_text_iter_backward_visible_line(GtkTextIter * iter);
    gboolean gtk_text_iter_forward_visible_lines(GtkTextIter * iter, gint count);
    gboolean gtk_text_iter_backward_visible_lines(GtkTextIter * iter, gint count);
    gboolean gtk_text_iter_forward_visible_word_end(GtkTextIter * iter);
    gboolean gtk_text_iter_backward_visible_word_start(GtkTextIter * iter);
    gboolean gtk_text_iter_forward_visible_word_ends(GtkTextIter * iter, gint count);
    gboolean gtk_text_iter_backward_visible_word_starts(GtkTextIter * iter, gint count);
    gboolean gtk_text_iter_forward_sentence_end(GtkTextIter * iter);
    gboolean gtk_text_iter_backward_sentence_start(GtkTextIter * iter);
    gboolean gtk_text_iter_forward_sentence_ends(GtkTextIter * iter, gint count);
    gboolean gtk_text_iter_backward_sentence_starts(GtkTextIter * iter, gint count);
    gboolean gtk_text_iter_forward_cursor_position(GtkTextIter * iter);
    gboolean gtk_text_iter_backward_cursor_position(GtkTextIter * iter);
    gboolean gtk_text_iter_forward_cursor_positions(GtkTextIter * iter, gint count);
    gboolean gtk_text_iter_backward_cursor_positions(GtkTextIter * iter, gint count);
    gboolean gtk_text_iter_forward_visible_cursor_position(GtkTextIter * iter);
    gboolean gtk_text_iter_backward_visible_cursor_position(GtkTextIter * iter);
    gboolean gtk_text_iter_forward_visible_cursor_positions(GtkTextIter * iter, gint count);
    gboolean gtk_text_iter_backward_visible_cursor_positions(GtkTextIter * iter, gint count);
    void gtk_text_iter_set_offset(GtkTextIter * iter, gint char_offset);
    void gtk_text_iter_set_line(GtkTextIter * iter, gint line_number);
    void gtk_text_iter_set_line_offset(GtkTextIter * iter, gint char_on_line);
    void gtk_text_iter_set_line_index(GtkTextIter * iter, gint byte_on_line);
    void gtk_text_iter_forward_to_end(GtkTextIter * iter);
    gboolean gtk_text_iter_forward_to_line_end(GtkTextIter * iter);
    void gtk_text_iter_set_visible_line_offset(GtkTextIter * iter, gint char_on_line);
    void gtk_text_iter_set_visible_line_index(GtkTextIter * iter, gint byte_on_line);
    gboolean gtk_text_iter_forward_to_tag_toggle(GtkTextIter * iter, GtkTextTag * tag);
    gboolean gtk_text_iter_backward_to_tag_toggle(GtkTextIter * iter, GtkTextTag * tag);
    typedef gboolean (* GtkTextCharPredicate)(gunichar ch, gpointer user_data);
    gboolean gtk_text_iter_forward_find_char(GtkTextIter * iter, GtkTextCharPredicate pred, gpointer user_data, const GtkTextIter * limit);
    gboolean gtk_text_iter_backward_find_char(GtkTextIter * iter, GtkTextCharPredicate pred, gpointer user_data, const GtkTextIter * limit);
    gboolean gtk_text_iter_forward_search(const GtkTextIter * iter, const gchar * str, GtkTextSearchFlags flags, GtkTextIter * match_start, GtkTextIter * match_end, const GtkTextIter * limit);
    gboolean gtk_text_iter_backward_search(const GtkTextIter * iter, const gchar * str, GtkTextSearchFlags flags, GtkTextIter * match_start, GtkTextIter * match_end, const GtkTextIter * limit);
    gboolean gtk_text_iter_equal(const GtkTextIter * lhs, const GtkTextIter * rhs);
    gint gtk_text_iter_compare(const GtkTextIter * lhs, const GtkTextIter * rhs);
    gboolean gtk_text_iter_in_range(const GtkTextIter * iter, const GtkTextIter * start, const GtkTextIter * end);
    void gtk_text_iter_order(GtkTextIter * first, GtkTextIter * second);
}
extern "C"
{
    typedef struct _GtkTargetList GtkTargetList;
    typedef struct _GtkTargetEntry GtkTargetEntry;
    struct _GtkSelectionData
    {
            GdkAtom selection;
            GdkAtom target;
            GdkAtom type;
            gint format;
            guchar * data;
            gint length;
            GdkDisplay * display;
    };
    struct _GtkTargetEntry
    {
            gchar * target;
            guint flags;
            guint info;
    };
    typedef struct _GtkTargetPair GtkTargetPair;
    struct _GtkTargetList
    {
            GList * list;
            guint ref_count;
    };
    struct _GtkTargetPair
    {
            GdkAtom target;
            guint flags;
            guint info;
    };
    GtkTargetList * gtk_target_list_new(const GtkTargetEntry * targets, guint ntargets);
    GtkTargetList * gtk_target_list_ref(GtkTargetList * list);
    void gtk_target_list_unref(GtkTargetList * list);
    void gtk_target_list_add(GtkTargetList * list, GdkAtom target, guint flags, guint info);
    void gtk_target_list_add_text_targets(GtkTargetList * list, guint info);
    void gtk_target_list_add_rich_text_targets(GtkTargetList * list, guint info, gboolean deserializable, GtkTextBuffer * buffer);
    void gtk_target_list_add_image_targets(GtkTargetList * list, guint info, gboolean writable);
    void gtk_target_list_add_uri_targets(GtkTargetList * list, guint info);
    void gtk_target_list_add_table(GtkTargetList * list, const GtkTargetEntry * targets, guint ntargets);
    void gtk_target_list_remove(GtkTargetList * list, GdkAtom target);
    gboolean gtk_target_list_find(GtkTargetList * list, GdkAtom target, guint * info);
    GtkTargetEntry * gtk_target_table_new_from_list(GtkTargetList * list, gint * n_targets);
    void gtk_target_table_free(GtkTargetEntry * targets, gint n_targets);
    gboolean gtk_selection_owner_set(GtkWidget * widget, GdkAtom selection, guint32 time_);
    gboolean gtk_selection_owner_set_for_display(GdkDisplay * display, GtkWidget * widget, GdkAtom selection, guint32 time_);
    void gtk_selection_add_target(GtkWidget * widget, GdkAtom selection, GdkAtom target, guint info);
    void gtk_selection_add_targets(GtkWidget * widget, GdkAtom selection, const GtkTargetEntry * targets, guint ntargets);
    void gtk_selection_clear_targets(GtkWidget * widget, GdkAtom selection);
    gboolean gtk_selection_convert(GtkWidget * widget, GdkAtom selection, GdkAtom target, guint32 time_);
    void gtk_selection_data_set(GtkSelectionData * selection_data, GdkAtom type, gint format, const guchar * data, gint length);
    gboolean gtk_selection_data_set_text(GtkSelectionData * selection_data, const gchar * str, gint len);
    guchar * gtk_selection_data_get_text(GtkSelectionData * selection_data);
    gboolean gtk_selection_data_set_pixbuf(GtkSelectionData * selection_data, GdkPixbuf * pixbuf);
    GdkPixbuf * gtk_selection_data_get_pixbuf(GtkSelectionData * selection_data);
    gboolean gtk_selection_data_set_uris(GtkSelectionData * selection_data, gchar * * uris);
    gchar * * gtk_selection_data_get_uris(GtkSelectionData * selection_data);
    gboolean gtk_selection_data_get_targets(GtkSelectionData * selection_data, GdkAtom * * targets, gint * n_atoms);
    gboolean gtk_selection_data_targets_include_text(GtkSelectionData * selection_data);
    gboolean gtk_selection_data_targets_include_rich_text(GtkSelectionData * selection_data, GtkTextBuffer * buffer);
    gboolean gtk_selection_data_targets_include_image(GtkSelectionData * selection_data, gboolean writable);
    gboolean gtk_selection_data_targets_include_uri(GtkSelectionData * selection_data);
    gboolean gtk_targets_include_text(GdkAtom * targets, gint n_targets);
    gboolean gtk_targets_include_rich_text(GdkAtom * targets, gint n_targets, GtkTextBuffer * buffer);
    gboolean gtk_targets_include_image(GdkAtom * targets, gint n_targets, gboolean writable);
    gboolean gtk_targets_include_uri(GdkAtom * targets, gint n_targets);
    void gtk_selection_remove_all(GtkWidget * widget);
    gboolean gtk_selection_clear(GtkWidget * widget, GdkEventSelection * event);
    gboolean _gtk_selection_request(GtkWidget * widget, GdkEventSelection * event);
    gboolean _gtk_selection_incr_event(GdkWindow * window, GdkEventProperty * event);
    gboolean _gtk_selection_notify(GtkWidget * widget, GdkEventSelection * event);
    gboolean _gtk_selection_property_notify(GtkWidget * widget, GdkEventProperty * event);
    GType gtk_selection_data_get_type(void) __attribute__((__const__));
    GtkSelectionData * gtk_selection_data_copy(GtkSelectionData * data);
    void gtk_selection_data_free(GtkSelectionData * data);
    GType gtk_target_list_get_type(void) __attribute__((__const__));
}
extern "C"
{
    typedef struct _GtkTargetEntry GtkTargetEntry;
}
namespace Gtk {
    class TargetEntry
    {
        public :
            TargetEntry();
            explicit TargetEntry(const Glib::ustring & target, Gtk::TargetFlags flags = Gtk::TargetFlags(0), guint info = 0);
            explicit TargetEntry(const GtkTargetEntry & gobject);
            TargetEntry(const TargetEntry & src);
            virtual ~TargetEntry();
            TargetEntry & operator =(const TargetEntry & src);
            Glib::ustring get_target() const;
            void set_target(const Glib::ustring & target);
            Gtk::TargetFlags get_flags() const;
            void set_flags(Gtk::TargetFlags flags);
            guint get_info() const;
            void set_info(guint info);
            GtkTargetEntry * gobj();
            const GtkTargetEntry * gobj() const;
        protected :
            GtkTargetEntry gobject_;
    };
    struct TargetEntry_Traits
    {
            typedef TargetEntry CppType;
            typedef GtkTargetEntry CType;
            typedef GtkTargetEntry CTypeNonConst;
            static const CType & to_c_type(const CppType & item)
            {
                return *item.gobj();
            }
            static const CType & to_c_type(const CType & item)
            {
                return item;
            }
            static CppType to_cpp_type(const CType & item)
            {
                return TargetEntry(item);
            }
            static void release_c_type(const CType &)
            {
            }
    };
    typedef Glib::ArrayHandle< TargetEntry, TargetEntry_Traits > ArrayHandle_TargetEntry;
}
namespace Gtk {
    class TargetList
    {
        public :
            typedef TargetList CppObjectType;
            typedef GtkTargetList BaseObjectType;
            void reference() const;
            void unreference() const;
            GtkTargetList * gobj();
            const GtkTargetList * gobj() const;
            GtkTargetList * gobj_copy() const;
        protected :
            TargetList();
            void operator delete(void *, size_t);
        private :
            TargetList(const TargetList &);
            TargetList & operator =(const TargetList &);
        public :
            static Glib::RefPtr< Gtk::TargetList > create(const ArrayHandle_TargetEntry & targets);
            void add(const Glib::ustring & target, TargetFlags flags = TargetFlags(0), guint info = 0);
            void add(const ArrayHandle_TargetEntry & targets);
            void remove(const Glib::ustring & target);
            bool find(const Glib::ustring & target, guint * info) const;
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::TargetList > wrap(GtkTargetList * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkIconSource GtkIconSource;
}
namespace Gtk {
    class IconSource
    {
        public :
            typedef IconSource CppObjectType;
            typedef GtkIconSource BaseObjectType;
            static GType get_type() __attribute__((__const__));
            IconSource();
            explicit IconSource(GtkIconSource * gobject, bool make_a_copy = true);
            IconSource(const IconSource & other);
            IconSource & operator =(const IconSource & other);
            ~IconSource();
            void swap(IconSource & other);
            GtkIconSource * gobj()
            {
                return gobject_;
            }
            const GtkIconSource * gobj() const
            {
                return gobject_;
            }
            GtkIconSource * gobj_copy() const;
        protected :
            GtkIconSource * gobject_;
        private :
        public :
            void set_filename(const Glib::ustring & filename);
            void set_pixbuf(const Glib::RefPtr< Gdk::Pixbuf > & pixbuf);
            Glib::ustring get_filename() const;
            Glib::RefPtr< Gdk::Pixbuf > get_pixbuf();
            Glib::RefPtr< const Gdk::Pixbuf > get_pixbuf() const;
            void set_direction_wildcarded(bool setting = true);
            void set_state_wildcarded(bool setting = true);
            void set_size_wildcarded(bool setting = true);
            bool get_size_wildcarded() const;
            bool get_state_wildcarded() const;
            bool get_direction_wildcarded() const;
            void set_direction(TextDirection direction);
            void set_state(Gtk::StateType state);
            void set_size(IconSize size);
            TextDirection get_direction() const;
            Gtk::StateType get_state() const;
            IconSize get_size() const;
            void set_icon_name(const Glib::ustring & icon_name);
            Glib::ustring get_icon_name() const;
    };
}
namespace Gtk {
    inline void swap(IconSource & lhs, IconSource & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    Gtk::IconSource wrap(GtkIconSource * object, bool take_copy = false);
    template<>
    class Value< Gtk::IconSource > : public Glib::Value_Boxed< Gtk::IconSource >
    {
    };
}
extern "C"
{
    typedef struct _GtkIconSet GtkIconSet;
}
namespace Gtk {
    class Style;
    class Widget;
    class IconSet
    {
        public :
            typedef IconSet CppObjectType;
            typedef GtkIconSet BaseObjectType;
            static GType get_type() __attribute__((__const__));
            IconSet();
            explicit IconSet(GtkIconSet * gobject, bool make_a_copy = true);
            IconSet(const IconSet & other);
            IconSet & operator =(const IconSet & other);
            ~IconSet();
            void swap(IconSet & other);
            GtkIconSet * gobj()
            {
                return gobject_;
            }
            const GtkIconSet * gobj() const
            {
                return gobject_;
            }
            GtkIconSet * gobj_copy() const;
        protected :
            GtkIconSet * gobject_;
        private :
        public :
            explicit IconSet(const Glib::RefPtr< Gdk::Pixbuf > & pixbuf);
            IconSet copy() const;
            Glib::RefPtr< Gdk::Pixbuf > render_icon(const Glib::RefPtr< Style > & style, TextDirection direction, Gtk::StateType state, IconSize size, Widget & widget, const Glib::ustring & detail);
            void add_source(const IconSource & source);
            Glib::ArrayHandle< IconSize > get_sizes() const;
            static IconSet lookup_default(const Gtk::StockID & stock_id);
    };
}
namespace Gtk {
    inline void swap(IconSet & lhs, IconSet & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    Gtk::IconSet wrap(GtkIconSet * object, bool take_copy = false);
    template<>
    class Value< Gtk::IconSet > : public Glib::Value_Boxed< Gtk::IconSet >
    {
    };
}
typedef struct _GtkStyle GtkStyle;
typedef struct _GtkStyleClass GtkStyleClass;
namespace Gtk {
    class Style_Class;
}
namespace Gtk {
    class Widget;
    class RcStyle;
    class Style : public Glib::Object
    {
        public :
            typedef Style CppObjectType;
            typedef Style_Class CppClassType;
            typedef GtkStyle BaseObjectType;
            typedef GtkStyleClass BaseClassType;
        private :
            friend class Style_Class;
            static CppClassType style_class_;
        private :
            Style(const Style &);
            Style & operator =(const Style &);
        protected :
            explicit Style(const Glib::ConstructParams & construct_params);
            explicit Style(GtkStyle * castitem);
        public :
            virtual ~Style();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkStyle * gobj()
            {
                return reinterpret_cast<GtkStyle * >(gobject_);
            }
            const GtkStyle * gobj() const
            {
                return reinterpret_cast<GtkStyle * >(gobject_);
            }
            GtkStyle * gobj_copy();
        private :
        protected :
            Style();
        public :
            static Glib::RefPtr< Style > create();
            void set_fg(Gtk::StateType state, const Gdk::Color & color);
            Gdk::Color get_fg(Gtk::StateType state) const;
            void set_bg(Gtk::StateType state, const Gdk::Color & color);
            Gdk::Color get_bg(Gtk::StateType state) const;
            void set_light(Gtk::StateType state, const Gdk::Color & color);
            Gdk::Color get_light(Gtk::StateType state) const;
            void set_dark(Gtk::StateType state, const Gdk::Color & color);
            Gdk::Color get_dark(Gtk::StateType state) const;
            void set_mid(Gtk::StateType state, const Gdk::Color & color);
            Gdk::Color get_mid(Gtk::StateType state) const;
            void set_text(Gtk::StateType state, const Gdk::Color & color);
            Gdk::Color get_text(Gtk::StateType state) const;
            void set_base(Gtk::StateType state, const Gdk::Color & color);
            Gdk::Color get_base(Gtk::StateType state) const;
            void set_text_aa(Gtk::StateType state, const Gdk::Color & color);
            Gdk::Color get_text_aa(Gtk::StateType state) const;
            void set_black(const Gdk::Color & value);
            Gdk::Color get_black() const;
            void set_white(const Gdk::Color & value);
            Gdk::Color get_white() const;
            void set_font(const Pango::FontDescription & font_desc);
            Pango::FontDescription get_font() const;
            void set_xthickness(int xthickness);
            int get_xthickness() const;
            void set_ythickness(int ythickness);
            int get_ythickness() const;
            Glib::RefPtr< Gdk::GC > get_fg_gc(Gtk::StateType state_type);
            Glib::RefPtr< const Gdk::GC > get_fg_gc(Gtk::StateType state_type) const;
            Glib::RefPtr< Gdk::GC > get_bg_gc(Gtk::StateType state_type);
            Glib::RefPtr< const Gdk::GC > get_bg_gc(Gtk::StateType state_type) const;
            Glib::RefPtr< Gdk::GC > get_light_gc(Gtk::StateType state_type);
            Glib::RefPtr< const Gdk::GC > get_light_gc(Gtk::StateType state_type) const;
            Glib::RefPtr< Gdk::GC > get_dark_gc(Gtk::StateType state_type);
            Glib::RefPtr< const Gdk::GC > get_dark_gc(Gtk::StateType state_type) const;
            Glib::RefPtr< Gdk::GC > get_mid_gc(Gtk::StateType state_type);
            Glib::RefPtr< const Gdk::GC > get_mid_gc(Gtk::StateType state_type) const;
            Glib::RefPtr< Gdk::GC > get_text_gc(Gtk::StateType state_type);
            Glib::RefPtr< const Gdk::GC > get_text_gc(Gtk::StateType state_type) const;
            Glib::RefPtr< Gdk::GC > get_base_gc(Gtk::StateType state_type);
            Glib::RefPtr< const Gdk::GC > get_base_gc(Gtk::StateType state_type) const;
            Glib::RefPtr< Gdk::GC > get_black_gc();
            Glib::RefPtr< const Gdk::GC > get_black_gc() const;
            Glib::RefPtr< Gdk::GC > get_white_gc();
            Glib::RefPtr< const Gdk::GC > get_white_gc() const;
            Gdk::Color get_background(Gtk::StateType state_type) const;
            Glib::RefPtr< Gdk::Pixmap > get_background_pixmap(Gtk::StateType state_type);
            void set_bg_pixmap(Gtk::StateType state_type, const Glib::RefPtr< Gdk::Pixmap > & pixmap);
            void set_bg_pixmap(Gtk::StateType state_type, const Glib::RefPtr< const Gdk::Pixmap > & pixmap);
            Glib::RefPtr< Gdk::Pixmap > get_bg_pixmap(Gtk::StateType state_type);
            Glib::RefPtr< const Gdk::Pixmap > get_bg_pixmap(Gtk::StateType state_type) const;
            void paint_arrow(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, ArrowType arrow_type, bool fill, int x, int y, int width, int height) const;
            void paint_box(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, int x, int y, int width, int height) const;
            void paint_box_gap(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, int x, int y, int width, int height, PositionType gap_side, int gap_x, int gap_width) const;
            void paint_check(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, int x, int y, int width, int height) const;
            void paint_diamond(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, int x, int y, int width, int height) const;
            void paint_extension(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, int x, int y, int width, int height, PositionType gap_side) const;
            void paint_flat_box(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, int x, int y, int width, int height) const;
            void paint_focus(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, int x, int y, int width, int height) const;
            void paint_handle(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, int x, int y, int width, int height, Orientation orientation) const;
            void paint_hline(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, int x1, int x2, int y) const;
            void paint_option(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, int x, int y, int width, int height) const;
            void paint_polygon(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, const Glib::ArrayHandle< Gdk::Point > & points, bool fill) const;
            void paint_shadow(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, int x, int y, int width, int height) const;
            void paint_shadow_gap(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, int x, int y, int width, int height, PositionType gap_side, int gap_x, int gap_width) const;
            void paint_slider(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, int x, int y, int width, int height, Orientation orientation) const;
            void paint_tab(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, int x, int y, int width, int height) const;
            void paint_vline(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, int y1, int y2, int x) const;
            void paint_expander(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, int x, int y, ExpanderStyle expander_style) const;
            void paint_layout(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, bool use_text, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, int x, int y, const Glib::RefPtr< Pango::Layout > & layout) const;
            void paint_resize_grip(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, const Gdk::Rectangle & area, Widget & widget, const Glib::ustring & detail, Gdk::WindowEdge edge, int x, int y, int width, int height) const;
            Glib::RefPtr< Style > copy();
            Glib::RefPtr< Style > attach(const Glib::RefPtr< Gdk::Window > & window);
            void detach();
            void set_background(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type);
            void apply_default_background(const Glib::RefPtr< Gdk::Window > & window, bool set_bg, Gtk::StateType state_type, const Gdk::Rectangle & area, int x, int y, int width, int height);
            IconSet lookup_icon_set(const Gtk::StockID & stock_id);
            bool lookup_color(const Glib::ustring & color_name, Gdk::Color & color) const;
            Glib::RefPtr< Gdk::Pixbuf > render_icon(const IconSource & source, Gtk::TextDirection direction, Gtk::StateType state, Gtk::IconSize size, Gtk::Widget & widget, const Glib::ustring & detail);
        protected :
            virtual void realize_vfunc();
            virtual void unrealize_vfunc();
            virtual void copy_vfunc(const Glib::RefPtr< Style > & src);
            virtual Glib::RefPtr< Style > clone_vfunc();
            virtual void init_from_rc_vfunc(const Glib::RefPtr< RcStyle > & rc_style);
            virtual void set_background_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type);
            virtual Glib::RefPtr< Gdk::Pixbuf > render_icon_vfunc(const IconSource & source, TextDirection direction, Gtk::StateType state, IconSize size, Widget * widget, const Glib::ustring & detail);
            virtual void draw_hline_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int x1, int x2, int y);
            virtual void draw_vline_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int y1, int y2, int x);
            virtual void draw_shadow_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int x, int y, int width, int height);
            virtual void draw_polygon_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, GdkPoint * point, int npoints, bool fill);
            virtual void draw_arrow_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, Gtk::ArrowType arrow_type, bool fill, int x, int y, int width, int height);
            virtual void draw_diamond_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int x, int y, int width, int height);
            virtual void draw_string_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int x, int y, const Glib::ustring & string);
            virtual void draw_box_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int x, int y, int width, int height);
            virtual void draw_flat_box_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int x, int y, int width, int height);
            virtual void draw_check_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int x, int y, int width, int height);
            virtual void draw_option_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int x, int y, int width, int height);
            virtual void draw_tab_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int x, int y, int width, int height);
            virtual void draw_shadow_gap_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int x, int y, int width, int height, Gtk::PositionType gap_side, int gap_x, int gap_width);
            virtual void draw_box_gap_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int x, int y, int width, int height, Gtk::PositionType gap_side, int gap_x, int gap_width);
            virtual void draw_extension_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int x, int y, int width, int height, PositionType gap_side);
            virtual void draw_focus_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int x, int y, int width, int height);
            virtual void draw_slider_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int x, int y, int width, int height, Orientation orientation);
            virtual void draw_handle_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, ShadowType shadow_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int x, int y, int width, int height, Orientation orientation);
            virtual void draw_expander_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int x, int y, ExpanderStyle expander_style);
            virtual void draw_layout_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, bool use_text, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, int x, int y, const Glib::RefPtr< Pango::Layout > & layout);
            virtual void draw_resize_grip_vfunc(const Glib::RefPtr< Gdk::Window > & window, Gtk::StateType state_type, const Gdk::Rectangle & area, Widget * widget, const Glib::ustring & detail, Gdk::WindowEdge edge, int x, int y, int width, int height);
            Glib::SignalProxy0< void > signal_realize();
            Glib::SignalProxy0< void > signal_unrealize();
        public :
        public :
        protected :
            virtual void on_realize();
            virtual void on_unrealize();
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::Style > wrap(GtkStyle * object, bool take_copy = false);
}
typedef struct _GtkRcStyle GtkRcStyle;
typedef struct _GtkRcStyleClass GtkRcStyleClass;
namespace Gtk {
    class RcStyle_Class;
}
namespace Gtk {
    class Widget;
    class Settings;
    class Style;
    enum RcFlags
    {
        RC_FG = 1 << 0, 
        RC_BG = 1 << 1, 
        RC_TEXT = 1 << 2, 
        RC_BASE = 1 << 3
    };
    inline RcFlags operator |(RcFlags lhs, RcFlags rhs)
    {
        return static_cast<RcFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline RcFlags operator &(RcFlags lhs, RcFlags rhs)
    {
        return static_cast<RcFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline RcFlags operator ^(RcFlags lhs, RcFlags rhs)
    {
        return static_cast<RcFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline RcFlags operator ~(RcFlags flags)
    {
        return static_cast<RcFlags >(~static_cast<unsigned >(flags));
    }
    inline RcFlags & operator |=(RcFlags & lhs, RcFlags rhs)
    {
        return (lhs = static_cast<RcFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline RcFlags & operator &=(RcFlags & lhs, RcFlags rhs)
    {
        return (lhs = static_cast<RcFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline RcFlags & operator ^=(RcFlags & lhs, RcFlags rhs)
    {
        return (lhs = static_cast<RcFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gtk::RcFlags > : public Glib::Value_Flags< Gtk::RcFlags >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class RcStyle : public Glib::Object
    {
        public :
            typedef RcStyle CppObjectType;
            typedef RcStyle_Class CppClassType;
            typedef GtkRcStyle BaseObjectType;
            typedef GtkRcStyleClass BaseClassType;
        private :
            friend class RcStyle_Class;
            static CppClassType rcstyle_class_;
        private :
            RcStyle(const RcStyle &);
            RcStyle & operator =(const RcStyle &);
        protected :
            explicit RcStyle(const Glib::ConstructParams & construct_params);
            explicit RcStyle(GtkRcStyle * castitem);
        public :
            virtual ~RcStyle();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkRcStyle * gobj()
            {
                return reinterpret_cast<GtkRcStyle * >(gobject_);
            }
            const GtkRcStyle * gobj() const
            {
                return reinterpret_cast<GtkRcStyle * >(gobject_);
            }
            GtkRcStyle * gobj_copy();
        private :
        protected :
            RcStyle();
        public :
            static Glib::RefPtr< RcStyle > create();
            Glib::RefPtr< RcStyle > copy() const;
            void set_name(const Glib::ustring & name);
            Glib::ustring get_name() const;
            void set_bg_pixmap_name(Gtk::StateType state, const Glib::ustring & name);
            Glib::ustring get_bg_pixmap_name(Gtk::StateType state) const;
            void set_font(const Pango::FontDescription & font_desc);
            Pango::FontDescription get_font() const;
            void set_color_flags(Gtk::StateType state, RcFlags flags);
            void unset_color_flags(Gtk::StateType state, RcFlags flags);
            RcFlags get_color_flags(Gtk::StateType state) const;
            void set_fg(Gtk::StateType state, const Gdk::Color & color);
            Gdk::Color get_fg(Gtk::StateType state) const;
            void set_bg(Gtk::StateType state, const Gdk::Color & color);
            Gdk::Color get_bg(Gtk::StateType state) const;
            void set_text(Gtk::StateType state, const Gdk::Color & color);
            Gdk::Color get_text(Gtk::StateType state) const;
            void set_base(Gtk::StateType state, const Gdk::Color & color);
            Gdk::Color get_base(Gtk::StateType state) const;
            void set_xthickness(int xthickness);
            int get_xthickness() const;
            void set_ythickness(int ythickness);
            int get_ythickness() const;
        public :
        public :
        protected :
    };
    class RC
    {
        public :
            explicit RC(const Glib::ustring & filename);
            static Glib::RefPtr< Style > get_style(const Widget & widget);
            static void parse_string(const Glib::ustring & rc_string);
            static void add_default_file(const Glib::ustring & filename);
            static void set_default_files(const Glib::StringArrayHandle & filenames);
            static Glib::StringArrayHandle get_default_files();
            static bool reparse_all();
            static bool reparse_all(const Glib::RefPtr< Settings > & settings, bool force_load = true);
            static void reset_styles(const Glib::RefPtr< Settings > & settings);
            static Glib::ustring find_pixmap_in_path(const Glib::RefPtr< Settings > & settings, GScanner * scanner, const Glib::ustring & pixmap_file);
            static Glib::ustring find_pixmap_in_path(const Glib::RefPtr< Settings > & settings, const Glib::ustring & pixmap_file);
            static Glib::ustring find_module_in_path(const Glib::ustring & pixmap_file);
            static Glib::ustring get_theme_dir();
            static Glib::ustring get_module_dir();
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::RcStyle > wrap(GtkRcStyle * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkSelectionData GtkSelectionData;
}
namespace Gtk {
    class TextBuffer;
    class SelectionData
    {
        public :
            typedef SelectionData CppObjectType;
            typedef GtkSelectionData BaseObjectType;
            static GType get_type() __attribute__((__const__));
            SelectionData();
            explicit SelectionData(GtkSelectionData * gobject, bool make_a_copy = true);
            SelectionData(const SelectionData & other);
            SelectionData & operator =(const SelectionData & other);
            ~SelectionData();
            void swap(SelectionData & other);
            GtkSelectionData * gobj()
            {
                return gobject_;
            }
            const GtkSelectionData * gobj() const
            {
                return gobject_;
            }
            GtkSelectionData * gobj_copy() const;
        protected :
            GtkSelectionData * gobject_;
        private :
        public :
            void set(int format, const guint8 * data, int length);
            void set(const std::string & type, int format, const guint8 * data, int length);
            void set(const std::string & type, const std::string & data);
            bool set_text(const Glib::ustring & data);
            Glib::ustring get_text() const;
            bool set_pixbuf(const Glib::RefPtr< Gdk::Pixbuf > & pixbuf);
            Glib::RefPtr< Gdk::Pixbuf > get_pixbuf();
            Glib::RefPtr< const Gdk::Pixbuf > get_pixbuf() const;
            bool set_uris(const Glib::StringArrayHandle & uris);
            Glib::StringArrayHandle get_uris() const;
            const guint8 * get_data() const;
            int get_length() const;
            std::string get_data_as_string() const;
            std::string get_target() const;
            Gdk::ArrayHandle_AtomString get_targets() const;
            GdkAtom get_selection() const;
            std::string get_data_type() const;
            int get_format() const;
            Glib::RefPtr< Gdk::Display > get_display();
            Glib::RefPtr< const Gdk::Display > get_display() const;
            bool targets_include_uri() const;
            bool targets_include_text() const;
            bool targets_include_rich_text(const Glib::RefPtr< TextBuffer > & buffer) const;
            bool targets_include_image(bool writable = true) const;
    };
}
namespace Gtk {
    inline void swap(SelectionData & lhs, SelectionData & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    Gtk::SelectionData wrap(GtkSelectionData * object, bool take_copy = false);
    template<>
    class Value< Gtk::SelectionData > : public Glib::Value_Boxed< Gtk::SelectionData >
    {
    };
}
typedef struct _GtkClipboard GtkClipboard;
typedef struct _GtkClipboardClass GtkClipboardClass;
namespace Gtk {
    class Clipboard_Class;
}
namespace Gtk {
    class TextBuffer;
    class Clipboard : public Glib::Object
    {
        public :
            typedef Clipboard CppObjectType;
            typedef Clipboard_Class CppClassType;
            typedef GtkClipboard BaseObjectType;
            typedef GtkClipboardClass BaseClassType;
        private :
            friend class Clipboard_Class;
            static CppClassType clipboard_class_;
        private :
            Clipboard(const Clipboard &);
            Clipboard & operator =(const Clipboard &);
        protected :
            explicit Clipboard(const Glib::ConstructParams & construct_params);
            explicit Clipboard(GtkClipboard * castitem);
        public :
            virtual ~Clipboard();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkClipboard * gobj()
            {
                return reinterpret_cast<GtkClipboard * >(gobject_);
            }
            const GtkClipboard * gobj() const
            {
                return reinterpret_cast<GtkClipboard * >(gobject_);
            }
            GtkClipboard * gobj_copy();
        private :
        public :
            static Glib::RefPtr< Clipboard > get(GdkAtom selection = ((GdkAtom) ((gpointer) (gulong) (69))));
            static Glib::RefPtr< Clipboard > get_for_display(const Glib::RefPtr< Gdk::Display > & display, GdkAtom selection = ((GdkAtom) ((gpointer) (gulong) (69))));
            Glib::RefPtr< Gdk::Display > get_display();
            Glib::RefPtr< const Gdk::Display > get_display() const;
            typedef sigc::slot< void, SelectionData &, guint > SlotGet;
            typedef sigc::slot< void > SlotClear;
            bool set(const ArrayHandle_TargetEntry & targets, const SlotGet & slot_get, const SlotClear & slot_clear);
            Glib::RefPtr< Glib::Object > get_owner();
            Glib::RefPtr< const Glib::Object > get_owner() const;
            void clear();
            void set_text(const Glib::ustring & text);
            void set_image(const Glib::RefPtr< Gdk::Pixbuf > & pixbuf);
            typedef sigc::slot< void, const SelectionData & > SlotReceived;
            void request_contents(const Glib::ustring & target, const SlotReceived & slot);
            typedef sigc::slot< void, const Glib::ustring & > SlotTextReceived;
            void request_text(const SlotTextReceived & slot);
            typedef sigc::slot< void, const Glib::ustring &, const std::string & > SlotRichTextReceived;
            void request_rich_text(const Glib::RefPtr< TextBuffer > & buffer, const SlotRichTextReceived & slot);
            typedef sigc::slot< void, const Glib::RefPtr< Gdk::Pixbuf > & > SlotImageReceived;
            void request_image(const SlotImageReceived & slot);
            typedef sigc::slot< void, const Glib::StringArrayHandle & > SlotTargetsReceived;
            void request_targets(const SlotTargetsReceived & slot);
            SelectionData wait_for_contents(const Glib::ustring & target) const;
            Glib::ustring wait_for_text() const;
            std::string wait_for_rich_text(const Glib::RefPtr< TextBuffer > & buffer, std::string & format);
            Glib::RefPtr< Gdk::Pixbuf > wait_for_image() const;
            bool wait_is_text_available() const;
            bool wait_is_rich_text_available(const Glib::RefPtr< TextBuffer > & buffer) const;
            bool wait_is_image_available() const;
            bool wait_is_target_available(const Glib::ustring & target);
            Glib::StringArrayHandle wait_for_targets() const;
            void set_can_store(const ArrayHandle_TargetEntry & targets);
            void set_can_store();
            void store();
            Glib::SignalProxy1< void, GdkEventOwnerChange * > signal_owner_change();
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::Clipboard > wrap(GtkClipboard * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkTargetEntry GtkTargetEntry;
}
typedef struct _GtkWidget GtkWidget;
typedef struct _GtkWidgetClass GtkWidgetClass;
namespace Gtk {
    class Widget_Class;
}
namespace Gtk {
    enum DestDefaults
    {
        DEST_DEFAULT_MOTION = 1 << 0, 
        DEST_DEFAULT_HIGHLIGHT = 1 << 1, 
        DEST_DEFAULT_DROP = 1 << 2, 
        DEST_DEFAULT_ALL = 0x07
    };
    inline DestDefaults operator |(DestDefaults lhs, DestDefaults rhs)
    {
        return static_cast<DestDefaults >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline DestDefaults operator &(DestDefaults lhs, DestDefaults rhs)
    {
        return static_cast<DestDefaults >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline DestDefaults operator ^(DestDefaults lhs, DestDefaults rhs)
    {
        return static_cast<DestDefaults >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline DestDefaults operator ~(DestDefaults flags)
    {
        return static_cast<DestDefaults >(~static_cast<unsigned >(flags));
    }
    inline DestDefaults & operator |=(DestDefaults & lhs, DestDefaults rhs)
    {
        return (lhs = static_cast<DestDefaults >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline DestDefaults & operator &=(DestDefaults & lhs, DestDefaults rhs)
    {
        return (lhs = static_cast<DestDefaults >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline DestDefaults & operator ^=(DestDefaults & lhs, DestDefaults rhs)
    {
        return (lhs = static_cast<DestDefaults >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gtk::DestDefaults > : public Glib::Value_Flags< Gtk::DestDefaults >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum WidgetFlags
    {
        TOPLEVEL = 1 << 4, 
        NO_WINDOW = 1 << 5, 
        REALIZED = 1 << 6, 
        MAPPED = 1 << 7, 
        VISIBLE = 1 << 8, 
        SENSITIVE = 1 << 9, 
        PARENT_SENSITIVE = 1 << 10, 
        CAN_FOCUS = 1 << 11, 
        HAS_FOCUS = 1 << 12, 
        CAN_DEFAULT = 1 << 13, 
        HAS_DEFAULT = 1 << 14, 
        HAS_GRAB = 1 << 15, 
        RC_STYLE = 1 << 16, 
        COMPOSITE_CHILD = 1 << 17, 
        NO_REPARENT = 1 << 18, 
        APP_PAINTABLE = 1 << 19, 
        RECEIVES_DEFAULT = 1 << 20, 
        DOUBLE_BUFFERED = 1 << 21, 
        NO_SHOW_ALL = 1 << 22
    };
    inline WidgetFlags operator |(WidgetFlags lhs, WidgetFlags rhs)
    {
        return static_cast<WidgetFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline WidgetFlags operator &(WidgetFlags lhs, WidgetFlags rhs)
    {
        return static_cast<WidgetFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline WidgetFlags operator ^(WidgetFlags lhs, WidgetFlags rhs)
    {
        return static_cast<WidgetFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline WidgetFlags operator ~(WidgetFlags flags)
    {
        return static_cast<WidgetFlags >(~static_cast<unsigned >(flags));
    }
    inline WidgetFlags & operator |=(WidgetFlags & lhs, WidgetFlags rhs)
    {
        return (lhs = static_cast<WidgetFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline WidgetFlags & operator &=(WidgetFlags & lhs, WidgetFlags rhs)
    {
        return (lhs = static_cast<WidgetFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline WidgetFlags & operator ^=(WidgetFlags & lhs, WidgetFlags rhs)
    {
        return (lhs = static_cast<WidgetFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gtk::WidgetFlags > : public Glib::Value_Flags< Gtk::WidgetFlags >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum WidgetHelpType
    {
        WIDGET_HELP_TOOLTIP, 
        WIDGET_HELP_WHATS_THIS
    };
}
namespace Glib {
    template<>
    class Value< Gtk::WidgetHelpType > : public Glib::Value_Enum< Gtk::WidgetHelpType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class Action;
    class Style;
    class AccelGroup;
    class Adjustment;
    class Window;
    class Container;
    class Settings;
    class Tooltip;
    typedef GtkRequisition Requisition;
    typedef Gdk::Rectangle Allocation;
    class Widget : public Object, public Atk::Implementor
    {
        public :
            typedef Widget CppObjectType;
            typedef Widget_Class CppClassType;
            typedef GtkWidget BaseObjectType;
            typedef GtkWidgetClass BaseClassType;
            virtual ~Widget();
        private :
            friend class Widget_Class;
            static CppClassType widget_class_;
            Widget(const Widget &);
            Widget & operator =(const Widget &);
        protected :
            explicit Widget(const Glib::ConstructParams & construct_params);
            explicit Widget(GtkWidget * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkWidget * gobj()
            {
                return reinterpret_cast<GtkWidget * >(gobject_);
            }
            const GtkWidget * gobj() const
            {
                return reinterpret_cast<GtkWidget * >(gobject_);
            }
        public :
        protected :
            virtual void on_show();
            virtual void on_hide();
            virtual void on_map();
            virtual void on_unmap();
            virtual void on_realize();
            virtual void on_unrealize();
            virtual void on_size_request(Requisition * requisition);
            virtual void on_size_allocate(Allocation & allocation);
            virtual void on_state_changed(Gtk::StateType previous_state);
            virtual void on_parent_changed(Widget * previous_parent);
            virtual void on_hierarchy_changed(Widget * previous_toplevel);
            virtual void on_style_changed(const Glib::RefPtr< Gtk::Style > & previous_style);
            virtual void on_direction_changed(TextDirection direction);
            virtual void on_grab_notify(bool was_grabbed);
            virtual void on_child_notify(GParamSpec * pspec);
            virtual bool on_mnemonic_activate(bool group_cycling);
            virtual void on_grab_focus();
            virtual bool on_focus(DirectionType direction);
            virtual bool on_event(GdkEvent * event);
            virtual bool on_button_press_event(GdkEventButton * event);
            virtual bool on_button_release_event(GdkEventButton * event);
            virtual bool on_scroll_event(GdkEventScroll * event);
            virtual bool on_motion_notify_event(GdkEventMotion * event);
            virtual bool on_delete_event(GdkEventAny * event);
            virtual bool on_expose_event(GdkEventExpose * event);
            virtual bool on_key_press_event(GdkEventKey * event);
            virtual bool on_key_release_event(GdkEventKey * event);
            virtual bool on_enter_notify_event(GdkEventCrossing * event);
            virtual bool on_leave_notify_event(GdkEventCrossing * event);
            virtual bool on_configure_event(GdkEventConfigure * event);
            virtual bool on_focus_in_event(GdkEventFocus * event);
            virtual bool on_focus_out_event(GdkEventFocus * event);
            virtual bool on_map_event(GdkEventAny * event);
            virtual bool on_unmap_event(GdkEventAny * event);
            virtual bool on_property_notify_event(GdkEventProperty * event);
            virtual bool on_selection_clear_event(GdkEventSelection * event);
            virtual bool on_selection_request_event(GdkEventSelection * event);
            virtual bool on_selection_notify_event(GdkEventSelection * event);
            virtual bool on_proximity_in_event(GdkEventProximity * event);
            virtual bool on_proximity_out_event(GdkEventProximity * event);
            virtual bool on_visibility_notify_event(GdkEventVisibility * event);
            virtual bool on_client_event(GdkEventClient * event);
            virtual bool on_no_expose_event(GdkEventAny * event);
            virtual bool on_window_state_event(GdkEventWindowState * event);
            virtual void on_selection_get(SelectionData & selection_data, guint info, guint time);
            virtual void on_selection_received(const SelectionData & selection_data, guint time);
            virtual void on_drag_begin(const Glib::RefPtr< Gdk::DragContext > & context);
            virtual void on_drag_end(const Glib::RefPtr< Gdk::DragContext > & context);
            virtual void on_drag_data_get(const Glib::RefPtr< Gdk::DragContext > & context, SelectionData & selection_data, guint info, guint time);
            virtual void on_drag_data_delete(const Glib::RefPtr< Gdk::DragContext > & context);
            virtual void on_drag_leave(const Glib::RefPtr< Gdk::DragContext > & context, guint time);
            virtual bool on_drag_motion(const Glib::RefPtr< Gdk::DragContext > & context, int x, int y, guint time);
            virtual bool on_drag_drop(const Glib::RefPtr< Gdk::DragContext > & context, int x, int y, guint time);
            virtual void on_drag_data_received(const Glib::RefPtr< Gdk::DragContext > & context, int x, int y, const SelectionData & selection_data, guint info, guint time);
            virtual Glib::RefPtr< Atk::Object > on_get_accessible();
            virtual void on_screen_changed(const Glib::RefPtr< Gdk::Screen > & previous_screen);
        private :
        public :
            friend class Main;
            bool set_scroll_adjustments(Adjustment & hadjustment, Adjustment & vadjustment);
            void show();
            void show_now();
            void hide();
            void show_all();
            void hide_all();
            void queue_draw();
            void queue_draw_area(int x, int y, int width, int height);
            void queue_resize();
            Requisition size_request() const;
            void size_request(const Requisition & requisition);
            void size_allocate(const Allocation & allocation);
            void add_accelerator(const Glib::ustring & accel_signal, const Glib::RefPtr< AccelGroup > & accel_group, guint accel_key, Gdk::ModifierType accel_mods, AccelFlags accel_flags);
            bool remove_accelerator(const Glib::RefPtr< AccelGroup > & accel_group, guint accel_key, Gdk::ModifierType accel_mods);
            void set_accel_path(const Glib::ustring & accel_path, const Glib::RefPtr< AccelGroup > & accel_group);
            bool mnemonic_activate(bool group_cycling);
            bool event(GdkEvent * event);
            int send_expose(GdkEvent * event);
            bool activate();
            void reparent(Widget & new_parent);
            bool intersect(const Gdk::Rectangle & area) const;
            bool intersect(const Gdk::Rectangle & area, Gdk::Rectangle & intersection) const;
            Gdk::Region region_intersect(const Gdk::Region & region) const;
            void freeze_child_notify();
            void child_notify(const Glib::ustring & child_property);
            void thaw_child_notify();
            bool is_focus() const;
            void grab_focus();
            void grab_default();
            void add_modal_grab();
            void remove_modal_grab();
            static Widget * get_current_modal_grab();
            void set_name(const Glib::ustring & name);
            void unset_name();
            Glib::ustring get_name() const;
            void set_state(Gtk::StateType state);
            void set_sensitive(bool sensitive = true);
            void set_app_paintable(bool app_paintable = true);
            void set_double_buffered(bool double_buffered = true);
            void set_redraw_on_allocate(bool redraw_on_allocate = true);
            void set_child_visible(bool is_visible = true);
            bool get_child_visible() const;
            Container * get_parent();
            const Container * get_parent() const;
            Glib::RefPtr< Gdk::Window > get_parent_window();
            Glib::RefPtr< const Gdk::Window > get_parent_window() const;
            void set_parent_window(const Glib::RefPtr< const Gdk::Window > & parent_window);
            bool child_focus(DirectionType direction);
            bool keynav_failed(DirectionType direction);
            void error_bell();
            void set_size_request(int width = -1, int height = -1);
            void get_size_request(int & width, int & height) const;
            void set_events(Gdk::EventMask events);
            void add_events(Gdk::EventMask events);
            void set_extension_events(Gdk::ExtensionMode mode);
            Gdk::ExtensionMode get_extension_events() const;
            Container * get_toplevel();
            const Container * get_toplevel() const;
            Widget * get_ancestor(GType widget_type);
            const Widget * get_ancestor(GType widget_type) const;
            Glib::RefPtr< Gdk::Colormap > get_colormap();
            Glib::RefPtr< Gdk::Visual > get_visual();
            Glib::RefPtr< Gdk::Screen > get_screen();
            Glib::RefPtr< const Gdk::Screen > get_screen() const;
            bool has_screen() const;
            Glib::RefPtr< Gdk::Display > get_display();
            Glib::RefPtr< const Gdk::Display > get_display() const;
            Glib::RefPtr< Gdk::Window > get_root_window();
            Glib::RefPtr< const Gdk::Window > get_root_window() const;
            Glib::RefPtr< Settings > get_settings();
            Glib::RefPtr< Clipboard > get_clipboard(const Glib::ustring & selection);
            Glib::RefPtr< const Clipboard > get_clipboard(const Glib::ustring & selection) const;
            Glib::RefPtr< Atk::Object > get_accessible();
            void set_colormap(const Glib::RefPtr< const Gdk::Colormap > & colormap);
            Gdk::EventMask get_events() const;
            void get_pointer(int & x, int & y) const;
            bool is_ancestor(Widget & ancestor) const;
            bool translate_coordinates(Widget & dest_widget, int src_x, int src_y, int & dest_x, int & dest_y);
            void set_style(const Glib::RefPtr< Style > & style);
            void unset_style();
            void ensure_style();
            Glib::RefPtr< Style > get_style();
            Glib::RefPtr< const Style > get_style() const;
            void modify_style(const Glib::RefPtr< RcStyle > & style);
            Glib::RefPtr< RcStyle > get_modifier_style();
            Glib::RefPtr< const RcStyle > get_modifier_style() const;
            void modify_fg(StateType state, const Gdk::Color & color);
            void modify_bg(StateType state, const Gdk::Color & color);
            void modify_bg_pixmap(StateType state, const Glib::ustring & pixmap_name);
            void modify_text(StateType state, const Gdk::Color & color);
            void modify_base(StateType state, const Gdk::Color & color);
            void modify_cursor(const Gdk::Color & primary, const Gdk::Color & secondary);
            void unset_cursor();
            void modify_font(const Pango::FontDescription & font_desc);
            void unset_fg(StateType state);
            void unset_bg(StateType state);
            void unset_text(StateType state);
            void unset_base(StateType state);
            void unset_font();
            template<class PropertyType >
            void get_style_property(const Glib::ustring & the_property_name, PropertyType & value) const;
            Glib::RefPtr< Pango::Context > create_pango_context();
            Glib::RefPtr< Pango::Context > get_pango_context();
            Glib::RefPtr< Pango::Layout > create_pango_layout(const Glib::ustring & text);
            Glib::RefPtr< Gdk::Pixbuf > render_icon(const StockID & stock_id, IconSize size, const Glib::ustring & detail = Glib::ustring());
            void set_composite_name(const Glib::ustring & name);
            void unset_composite_name();
            Glib::ustring get_composite_name() const;
            void reset_rc_styles();
            static void push_colormap(const Glib::RefPtr< const Gdk::Colormap > & cmap);
            static void pop_colormap();
            static void push_composite_child();
            static void pop_composite_child();
            static void set_default_colormap(const Glib::RefPtr< const Gdk::Colormap > & colormap);
            static Glib::RefPtr< Style > get_default_style();
            static Glib::RefPtr< Gdk::Colormap > get_default_colormap();
            static Glib::RefPtr< Gdk::Visual > get_default_visual();
            void set_direction(TextDirection dir);
            TextDirection get_direction();
            static void set_default_direction(TextDirection dir);
            static TextDirection get_default_direction();
            void shape_combine_mask(const Glib::RefPtr< const Gdk::Bitmap > & shape_mask, int offset_x, int offset_y);
            void unset_shape_combine_mask();
            void input_shape_combine_mask(const Glib::RefPtr< const Gdk::Bitmap > & shape_mask, int offset_x, int offset_y);
            void unset_input_shape_combine_mask();
            void reset_shapes();
            void path(Glib::ustring & path, Glib::ustring & path_reversed);
            void class_path(Glib::ustring & path, Glib::ustring & path_reversed);
            Glib::ListHandle< Widget * > list_mnemonic_labels();
            Glib::ListHandle< const Widget * > list_mnemonic_labels() const;
            void add_mnemonic_label(Widget & label);
            void remove_mnemonic_label(Widget & label);
            void drag_get_data(const Glib::RefPtr< Gdk::DragContext > & context, Glib::ustring & target, guint32 time);
            void drag_highlight();
            void drag_unhighlight();
            void drag_dest_set(DestDefaults flags = DestDefaults(0), Gdk::DragAction actions = Gdk::DragAction(0));
            void drag_dest_set(const ArrayHandle_TargetEntry & targets, DestDefaults flags = DEST_DEFAULT_ALL, Gdk::DragAction actions = Gdk::ACTION_COPY);
            void drag_dest_set_proxy(const Glib::RefPtr< Gdk::Window > & proxy_window, Gdk::DragProtocol protocol, bool use_coordinates);
            void drag_dest_unset();
            Glib::ustring drag_dest_find_target(const Glib::RefPtr< Gdk::DragContext > & context, const Glib::RefPtr< TargetList > & target_list) const;
            Glib::ustring drag_dest_find_target(const Glib::RefPtr< Gdk::DragContext > & context) const;
            Glib::RefPtr< TargetList > drag_dest_get_target_list();
            Glib::RefPtr< const TargetList > drag_dest_get_target_list() const;
            void drag_dest_set_target_list(const Glib::RefPtr< TargetList > & target_list);
            void drag_dest_add_text_targets();
            void drag_dest_add_image_targets();
            void drag_dest_add_uri_targets();
            void drag_source_set(const ArrayHandle_TargetEntry & targets, Gdk::ModifierType start_button_mask = Gdk::MODIFIER_MASK, Gdk::DragAction actions = Gdk::ACTION_COPY);
            void drag_source_unset();
            void drag_source_set_icon(const Glib::RefPtr< Gdk::Colormap > & colormap, const Glib::RefPtr< Gdk::Pixmap > & pixmap, const Glib::RefPtr< Gdk::Bitmap > & mask);
            void drag_source_set_icon(const Glib::RefPtr< Gdk::Pixbuf > & pixbuf);
            void drag_source_set_icon(const StockID & stock_id);
            void drag_source_set_icon(const Glib::ustring & icon_name);
            void drag_source_add_text_targets();
            void drag_source_add_uri_targets();
            void drag_source_add_image_targets();
            Glib::RefPtr< Gdk::DragContext > drag_begin(const Glib::RefPtr< TargetList > & targets, Gdk::DragAction actions, int button, GdkEvent * event);
            bool drag_check_threshold(int start_x, int start_y, int current_x, int current_y);
            static Widget * drag_get_source_widget(const Glib::RefPtr< Gdk::DragContext > & context);
            void drag_set_as_icon(const Glib::RefPtr< Gdk::DragContext > & context, int hot_x, int hot_y);
            void queue_resize_no_redraw();
            bool get_no_show_all() const;
            void set_no_show_all(bool no_show_all = true);
            void set_parent(Widget & parent);
            void unparent();
            void map();
            void unmap();
            void draw_insertion_cursor(Glib::RefPtr< Gdk::Drawable > drawable, const Gdk::Rectangle & area, const Gdk::Rectangle & location, bool is_primary, TextDirection direction, bool draw_arrow = true);
            void set_tooltip_window(Window & widget);
            Window * get_tooltip_window();
            void trigger_tooltip_query();
            void set_tooltip_text(const Glib::ustring & text);
            Glib::ustring get_tooltip_text() const;
            void set_tooltip_markup(const Glib::ustring & markup);
            Glib::ustring get_tooltip_markup() const;
            void set_has_tooltip(bool has_tooltip = (!(0)));
            bool get_has_tooltip() const;
            bool is_toplevel() const;
            bool has_no_window() const;
            bool is_realized() const;
            bool is_mapped() const;
            bool is_visible() const;
            bool is_drawable() const;
            bool sensitive() const;
            bool parent_sensitive() const;
            bool is_sensitive() const;
            bool can_focus() const;
            bool has_focus() const;
            bool can_default() const;
            bool has_default() const;
            bool has_grab() const;
            bool rc_style() const;
            bool is_composite_child() const;
            bool app_paintable() const;
            bool receives_default() const;
            bool double_buffered() const;
            WidgetFlags get_flags() const;
            void set_flags(WidgetFlags flags);
            void unset_flags(WidgetFlags flags);
            int get_width() const;
            int get_height() const;
            bool is_composited() const;
            Glib::RefPtr< Action > get_action();
            Glib::RefPtr< const Action > get_action() const;
            Gtk::StateType get_state() const;
            Gtk::StateType get_saved_state() const;
            Requisition get_requisition() const;
            Allocation get_allocation() const;
            Glib::RefPtr< Gdk::Window > get_window();
            Glib::RefPtr< const Gdk::Window > get_window() const;
            Glib::SignalProxy0< void > signal_show();
            Glib::SignalProxy0< void > signal_hide();
            Glib::SignalProxy0< void > signal_map();
            Glib::SignalProxy0< void > signal_unmap();
            Glib::SignalProxy0< void > signal_realize();
            Glib::SignalProxy0< void > signal_unrealize();
            Glib::SignalProxy1< void, Requisition * > signal_size_request();
            Glib::SignalProxy1< void, Allocation & > signal_size_allocate();
            Glib::SignalProxy1< void, Gtk::StateType > signal_state_changed();
            Glib::SignalProxy1< void, Widget * > signal_parent_changed();
            Glib::SignalProxy1< void, Widget * > signal_hierarchy_changed();
            Glib::SignalProxy1< void, const Glib::RefPtr< Gtk::Style > & > signal_style_changed();
            Glib::SignalProxy1< void, TextDirection > signal_direction_changed();
            Glib::SignalProxy1< void, bool > signal_grab_notify();
            Glib::SignalProxy1< void, GParamSpec * > signal_child_notify();
            Glib::SignalProxy1< bool, bool > signal_mnemonic_activate();
            Glib::SignalProxy0< void > signal_grab_focus();
            Glib::SignalProxy1< bool, DirectionType > signal_focus();
            Glib::SignalProxy1< bool, GdkEvent * > signal_event();
            Glib::SignalProxy1< void, GdkEvent * > signal_event_after();
            Glib::SignalProxy1< bool, GdkEventButton * > signal_button_press_event();
            Glib::SignalProxy1< bool, GdkEventButton * > signal_button_release_event();
            Glib::SignalProxy1< bool, GdkEventScroll * > signal_scroll_event();
            Glib::SignalProxy1< bool, GdkEventMotion * > signal_motion_notify_event();
            Glib::SignalProxy1< bool, GdkEventAny * > signal_delete_event();
            Glib::SignalProxy1< bool, GdkEventExpose * > signal_expose_event();
            Glib::SignalProxy1< bool, GdkEventKey * > signal_key_press_event();
            Glib::SignalProxy1< bool, GdkEventKey * > signal_key_release_event();
            Glib::SignalProxy1< bool, GdkEventCrossing * > signal_enter_notify_event();
            Glib::SignalProxy1< bool, GdkEventCrossing * > signal_leave_notify_event();
            Glib::SignalProxy1< bool, GdkEventConfigure * > signal_configure_event();
            Glib::SignalProxy1< bool, GdkEventFocus * > signal_focus_in_event();
            Glib::SignalProxy1< bool, GdkEventFocus * > signal_focus_out_event();
            Glib::SignalProxy1< bool, GdkEventAny * > signal_map_event();
            Glib::SignalProxy1< bool, GdkEventAny * > signal_unmap_event();
            Glib::SignalProxy1< bool, GdkEventProperty * > signal_property_notify_event();
            Glib::SignalProxy1< bool, GdkEventSelection * > signal_selection_clear_event();
            Glib::SignalProxy1< bool, GdkEventSelection * > signal_selection_request_event();
            Glib::SignalProxy1< bool, GdkEventSelection * > signal_selection_notify_event();
            Glib::SignalProxy1< bool, GdkEventProximity * > signal_proximity_in_event();
            Glib::SignalProxy1< bool, GdkEventProximity * > signal_proximity_out_event();
            Glib::SignalProxy1< bool, GdkEventVisibility * > signal_visibility_notify_event();
            Glib::SignalProxy1< bool, GdkEventClient * > signal_client_event();
            Glib::SignalProxy1< bool, GdkEventAny * > signal_no_expose_event();
            Glib::SignalProxy1< bool, GdkEventWindowState * > signal_window_state_event();
            Glib::SignalProxy3< void, SelectionData &, guint, guint > signal_selection_get();
            Glib::SignalProxy2< void, const SelectionData &, guint > signal_selection_received();
            Glib::SignalProxy1< void, const Glib::RefPtr< Gdk::DragContext > & > signal_drag_begin();
            Glib::SignalProxy1< void, const Glib::RefPtr< Gdk::DragContext > & > signal_drag_end();
            Glib::SignalProxy4< void, const Glib::RefPtr< Gdk::DragContext > &, SelectionData &, guint, guint > signal_drag_data_get();
            Glib::SignalProxy1< void, const Glib::RefPtr< Gdk::DragContext > & > signal_drag_data_delete();
            Glib::SignalProxy2< void, const Glib::RefPtr< Gdk::DragContext > &, guint > signal_drag_leave();
            Glib::SignalProxy4< bool, const Glib::RefPtr< Gdk::DragContext > &, int, int, guint > signal_drag_motion();
            Glib::SignalProxy4< bool, const Glib::RefPtr< Gdk::DragContext > &, int, int, guint > signal_drag_drop();
            Glib::SignalProxy6< void, const Glib::RefPtr< Gdk::DragContext > &, int, int, const SelectionData &, guint, guint > signal_drag_data_received();
            Glib::SignalProxy0< Glib::RefPtr< Atk::Object > > signal_get_accessible();
            Glib::SignalProxy1< void, const Glib::RefPtr< Gdk::Screen > & > signal_screen_changed();
            Glib::SignalProxy0< void > signal_composited_changed();
            Glib::SignalProxy4< bool, int, int, bool, const Glib::RefPtr< Tooltip > & > signal_query_tooltip();
            Glib::PropertyProxy< Glib::ustring > property_name();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_name() const;
            Glib::PropertyProxy< Container * > property_parent();
            Glib::PropertyProxy_ReadOnly< Container * > property_parent() const;
            Glib::PropertyProxy< int > property_width_request();
            Glib::PropertyProxy_ReadOnly< int > property_width_request() const;
            Glib::PropertyProxy< int > property_height_request();
            Glib::PropertyProxy_ReadOnly< int > property_height_request() const;
            Glib::PropertyProxy< bool > property_visible();
            Glib::PropertyProxy_ReadOnly< bool > property_visible() const;
            Glib::PropertyProxy< bool > property_sensitive();
            Glib::PropertyProxy_ReadOnly< bool > property_sensitive() const;
            Glib::PropertyProxy< bool > property_app_paintable();
            Glib::PropertyProxy_ReadOnly< bool > property_app_paintable() const;
            Glib::PropertyProxy< bool > property_can_focus();
            Glib::PropertyProxy_ReadOnly< bool > property_can_focus() const;
            Glib::PropertyProxy< bool > property_has_focus();
            Glib::PropertyProxy_ReadOnly< bool > property_has_focus() const;
            Glib::PropertyProxy< bool > property_can_default();
            Glib::PropertyProxy_ReadOnly< bool > property_can_default() const;
            Glib::PropertyProxy< bool > property_has_default();
            Glib::PropertyProxy_ReadOnly< bool > property_has_default() const;
            Glib::PropertyProxy< bool > property_receives_default();
            Glib::PropertyProxy_ReadOnly< bool > property_receives_default() const;
            Glib::PropertyProxy_ReadOnly< bool > property_composite_child() const;
            Glib::PropertyProxy< Glib::RefPtr< Style > > property_style();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Style > > property_style() const;
            Glib::PropertyProxy< Gdk::EventMask > property_events();
            Glib::PropertyProxy_ReadOnly< Gdk::EventMask > property_events() const;
            Glib::PropertyProxy< Gdk::ExtensionMode > property_extension_events();
            Glib::PropertyProxy_ReadOnly< Gdk::ExtensionMode > property_extension_events() const;
            Glib::PropertyProxy< bool > property_has_tooltip();
            Glib::PropertyProxy_ReadOnly< bool > property_has_tooltip() const;
            Glib::PropertyProxy< Glib::ustring > property_tooltip_markup();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_tooltip_markup() const;
            Glib::PropertyProxy< Glib::ustring > property_tooltip_text();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_tooltip_text() const;
        protected :
            virtual void dispatch_child_properties_changed_vfunc(guint p1, GParamSpec * * p2);
            virtual void show_all_vfunc();
            virtual void hide_all_vfunc();
            virtual Glib::RefPtr< Atk::Object > get_accessible_vfunc();
        protected :
            Widget();
            void realize();
            void unrealize();
            void get_child_requisition(Requisition & requisition) const;
            void get_style_property_value(const Glib::ustring & the_property_name, Glib::ValueBase & value) const;
            void realize_if_needed();
            void set_allocation(const Allocation & value);
            void set_window(const Glib::RefPtr< Gdk::Window > & value);
    };
    template<class PropertyType >
    void Widget::get_style_property(const Glib::ustring & the_property_name, PropertyType & value) const
    {
        Glib::Value< PropertyType > property_value;
        property_value.init(Glib::Value< PropertyType >::value_type());
        this->get_style_property_value(the_property_name, property_value);
        value = property_value.get();
    }
}
namespace Glib {
    Gtk::Widget * wrap(GtkWidget * object, bool take_copy = false);
}
typedef struct _GtkContainer GtkContainer;
typedef struct _GtkContainerClass GtkContainerClass;
namespace Gtk {
    class Container_Class;
}
namespace Gtk {
    class Adjustment;
    class Label;
    class Container : public Widget
    {
        public :
            typedef Container CppObjectType;
            typedef Container_Class CppClassType;
            typedef GtkContainer BaseObjectType;
            typedef GtkContainerClass BaseClassType;
            virtual ~Container();
        private :
            friend class Container_Class;
            static CppClassType container_class_;
            Container(const Container &);
            Container & operator =(const Container &);
        protected :
            explicit Container(const Glib::ConstructParams & construct_params);
            explicit Container(GtkContainer * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkContainer * gobj()
            {
                return reinterpret_cast<GtkContainer * >(gobject_);
            }
            const GtkContainer * gobj() const
            {
                return reinterpret_cast<GtkContainer * >(gobject_);
            }
        public :
        protected :
            virtual void on_add(Widget * widget);
            virtual void on_remove(Widget * widget);
            virtual void on_check_resize();
            virtual void on_set_focus_child(Widget * widget);
        private :
        public :
            void set_border_width(guint border_width);
            guint get_border_width() const;
            virtual void add(Widget & widget);
            void remove(Widget & widget);
            void set_resize_mode(ResizeMode resize_mode);
            ResizeMode get_resize_mode() const;
            void check_resize();
            typedef sigc::slot< void, Widget & > ForeachSlot;
            void foreach(const ForeachSlot & slot);
            Glib::ListHandle< Widget * > get_children();
            Glib::ListHandle< const Widget * > get_children() const;
            void propagate_expose(Widget & child, GdkEventExpose * event);
            void set_focus_chain(const Glib::ListHandle< Widget * > & focusable_widgets);
            bool has_focus_chain() const;
            Glib::ListHandle< Widget * > get_focus_chain();
            Glib::ListHandle< const Widget * > get_focus_chain() const;
            void unset_focus_chain();
            void set_reallocate_redraws(bool needs_redraws = true);
            void set_focus_child(Widget & widget);
            void set_focus_vadjustment(Adjustment & adjustment);
            Adjustment * get_focus_vadjustment();
            const Adjustment * get_focus_vadjustment() const;
            void set_focus_hadjustment(Adjustment & adjustment);
            Adjustment * get_focus_hadjustment();
            const Adjustment * get_focus_hadjustment() const;
            void resize_children();
            GType child_type() const;
            Glib::SignalProxy1< void, Widget * > signal_add();
            Glib::SignalProxy1< void, Widget * > signal_remove();
            Glib::SignalProxy0< void > signal_check_resize();
            Glib::SignalProxy1< void, Widget * > signal_set_focus_child();
            void show_all_children(bool recursive = true);
        protected :
            Container();
            virtual GtkType child_type_vfunc() const;
            virtual void forall_vfunc(gboolean include_internals, GtkCallback callback, gpointer callback_data);
            virtual char * composite_name_vfunc(GtkWidget * child);
            virtual void set_child_property_vfunc(GtkWidget * child, guint property_id, const GValue * value, GParamSpec * pspec);
            virtual void get_child_property_vfunc(GtkWidget * child, guint property_id, GValue * value, GParamSpec * pspec) const;
            Glib::PropertyProxy< guint > property_border_width();
            Glib::PropertyProxy_ReadOnly< guint > property_border_width() const;
            Glib::PropertyProxy< ResizeMode > property_resize_mode();
            Glib::PropertyProxy_ReadOnly< ResizeMode > property_resize_mode() const;
            Glib::PropertyProxy_WriteOnly< Widget * > property_child();
    };
}
namespace Glib {
    Gtk::Container * wrap(GtkContainer * object, bool take_copy = false);
}
typedef struct _GtkBin GtkBin;
typedef struct _GtkBinClass GtkBinClass;
namespace Gtk {
    class Bin_Class;
}
namespace Gtk {
    class Bin : public Container
    {
        public :
            typedef Bin CppObjectType;
            typedef Bin_Class CppClassType;
            typedef GtkBin BaseObjectType;
            typedef GtkBinClass BaseClassType;
            virtual ~Bin();
        private :
            friend class Bin_Class;
            static CppClassType bin_class_;
            Bin(const Bin &);
            Bin & operator =(const Bin &);
        protected :
            explicit Bin(const Glib::ConstructParams & construct_params);
            explicit Bin(GtkBin * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkBin * gobj()
            {
                return reinterpret_cast<GtkBin * >(gobject_);
            }
            const GtkBin * gobj() const
            {
                return reinterpret_cast<GtkBin * >(gobject_);
            }
        public :
        protected :
        private :
        protected :
            Bin();
        public :
            Widget * get_child();
            const Widget * get_child() const;
            void remove();
            void add_label(const Glib::ustring & label, bool mnemonic = false, double x_align = 0.5, double y_align = 0.5);
            void add_label(const Glib::ustring & label, bool mnemonic, AlignmentEnum x_align, AlignmentEnum y_align = ALIGN_CENTER);
            void add_pixmap(const Glib::RefPtr< Gdk::Pixmap > & pixmap, const Glib::RefPtr< Gdk::Bitmap > & mask);
            void add_pixlabel(const Glib::RefPtr< Gdk::Pixmap > & pixmap, const Glib::RefPtr< Gdk::Bitmap > & mask, const Glib::ustring & label, double x_align = 0.5, double y_align = 0.5);
            void add_pixlabel(const Glib::ustring & pixfile, const Glib::ustring & label, double x_align = 0.5, double y_align = 0.5);
    };
}
namespace Glib {
    Gtk::Bin * wrap(GtkBin * object, bool take_copy = false);
}
typedef struct _GtkWindowGroup GtkWindowGroup;
typedef struct _GtkWindowGroupClass GtkWindowGroupClass;
namespace Gtk {
    class WindowGroup_Class;
}
typedef struct _GtkWindow GtkWindow;
typedef struct _GtkWindowClass GtkWindowClass;
namespace Gtk {
    class Window_Class;
}
namespace Gtk {
    class AccelGroup;
    class WindowGroup;
    class WindowGroup : public Glib::Object
    {
        public :
            typedef WindowGroup CppObjectType;
            typedef WindowGroup_Class CppClassType;
            typedef GtkWindowGroup BaseObjectType;
            typedef GtkWindowGroupClass BaseClassType;
        private :
            friend class WindowGroup_Class;
            static CppClassType windowgroup_class_;
        private :
            WindowGroup(const WindowGroup &);
            WindowGroup & operator =(const WindowGroup &);
        protected :
            explicit WindowGroup(const Glib::ConstructParams & construct_params);
            explicit WindowGroup(GtkWindowGroup * castitem);
        public :
            virtual ~WindowGroup();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkWindowGroup * gobj()
            {
                return reinterpret_cast<GtkWindowGroup * >(gobject_);
            }
            const GtkWindowGroup * gobj() const
            {
                return reinterpret_cast<GtkWindowGroup * >(gobject_);
            }
            GtkWindowGroup * gobj_copy();
        private :
        protected :
            WindowGroup();
        public :
            static Glib::RefPtr< WindowGroup > create();
            void add_window(Window & window);
            void remove_window(Window & window);
        public :
        public :
        protected :
    };
    class Window : public Bin
    {
        public :
            typedef Window CppObjectType;
            typedef Window_Class CppClassType;
            typedef GtkWindow BaseObjectType;
            typedef GtkWindowClass BaseClassType;
            virtual ~Window();
        private :
            friend class Window_Class;
            static CppClassType window_class_;
            Window(const Window &);
            Window & operator =(const Window &);
        protected :
            explicit Window(const Glib::ConstructParams & construct_params);
            explicit Window(GtkWindow * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkWindow * gobj()
            {
                return reinterpret_cast<GtkWindow * >(gobject_);
            }
            const GtkWindow * gobj() const
            {
                return reinterpret_cast<GtkWindow * >(gobject_);
            }
        public :
        protected :
            virtual void on_set_focus(Widget * focus);
            virtual bool on_frame_event(GdkEvent * event);
        private :
        public :
            explicit Window(WindowType type = WINDOW_TOPLEVEL);
            Glib::PropertyProxy< Glib::ustring > property_title();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_title() const;
            Glib::PropertyProxy< bool > property_allow_shrink();
            Glib::PropertyProxy_ReadOnly< bool > property_allow_shrink() const;
            Glib::PropertyProxy< bool > property_allow_grow();
            Glib::PropertyProxy_ReadOnly< bool > property_allow_grow() const;
            Glib::PropertyProxy< bool > property_resizable();
            Glib::PropertyProxy_ReadOnly< bool > property_resizable() const;
            Glib::PropertyProxy< bool > property_modal();
            Glib::PropertyProxy_ReadOnly< bool > property_modal() const;
            Glib::PropertyProxy< WindowPosition > property_window_position();
            Glib::PropertyProxy_ReadOnly< WindowPosition > property_window_position() const;
            Glib::PropertyProxy< int > property_default_width();
            Glib::PropertyProxy_ReadOnly< int > property_default_width() const;
            Glib::PropertyProxy< int > property_default_height();
            Glib::PropertyProxy_ReadOnly< int > property_default_height() const;
            Glib::PropertyProxy< bool > property_destroy_with_parent();
            Glib::PropertyProxy_ReadOnly< bool > property_destroy_with_parent() const;
            Glib::PropertyProxy< Glib::RefPtr< Gdk::Pixbuf > > property_icon();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Gdk::Pixbuf > > property_icon() const;
            Glib::PropertyProxy< Glib::RefPtr< Gdk::Screen > > property_screen();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Gdk::Screen > > property_screen() const;
            Glib::PropertyProxy_ReadOnly< bool > property_is_active() const;
            Glib::PropertyProxy_ReadOnly< bool > property_has_toplevel_focus() const;
            Glib::PropertyProxy< GdkWindowTypeHint > property_type_hint();
            Glib::PropertyProxy_ReadOnly< GdkWindowTypeHint > property_type_hint() const;
            Glib::PropertyProxy< bool > property_skip_taskbar_hint();
            Glib::PropertyProxy_ReadOnly< bool > property_skip_taskbar_hint() const;
            Glib::PropertyProxy< bool > property_skip_pager_hint();
            Glib::PropertyProxy_ReadOnly< bool > property_skip_pager_hint() const;
            Glib::PropertyProxy< Glib::ustring > property_role();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_role() const;
            Glib::PropertyProxy< bool > property_decorated();
            Glib::PropertyProxy_ReadOnly< bool > property_decorated() const;
            Glib::PropertyProxy< Gdk::Gravity > property_gravity();
            Glib::PropertyProxy_ReadOnly< Gdk::Gravity > property_gravity() const;
            Glib::PropertyProxy< Window * > property_transient_for();
            Glib::PropertyProxy_ReadOnly< Window * > property_transient_for() const;
            Glib::PropertyProxy< bool > property_urgency_hint();
            Glib::PropertyProxy_ReadOnly< bool > property_urgency_hint() const;
            Glib::PropertyProxy< bool > property_deletable();
            Glib::PropertyProxy_ReadOnly< bool > property_deletable() const;
            Glib::PropertyProxy< double > property_opacity();
            Glib::PropertyProxy_ReadOnly< double > property_opacity() const;
            bool is_toplevel() const;
            bool is_dialog() const;
            bool is_popup() const;
            WindowType get_window_type() const;
            Glib::RefPtr< Gdk::Window > get_frame();
            Glib::RefPtr< const Gdk::Window > get_frame() const;
            Glib::SignalProxy1< void, Widget * > signal_set_focus();
            Glib::SignalProxy1< bool, GdkEvent * > signal_frame_event();
            void set_title(const Glib::ustring & title);
            Glib::ustring get_title() const;
            void set_wmclass(const Glib::ustring & wmclass_name, const Glib::ustring & wmclass_class);
            void set_role(const Glib::ustring & role);
            Glib::ustring get_role() const;
            void add_accel_group(const Glib::RefPtr< AccelGroup > & accel_group);
            void remove_accel_group(const Glib::RefPtr< AccelGroup > & accel_group);
            void set_position(WindowPosition position);
            bool activate_focus();
            void set_focus(Gtk::Widget & focus);
            void unset_focus();
            Widget * get_focus();
            const Widget * get_focus() const;
            void set_default(Gtk::Widget & default_widget);
            void unset_default();
            bool activate_default();
            void set_transient_for(Window & parent);
            Window * get_transient_for();
            const Window * get_transient_for() const;
            void set_opacity(double opacity);
            double get_opacity() const;
            void set_type_hint(Gdk::WindowTypeHint hint);
            Gdk::WindowTypeHint get_type_hint() const;
            void set_skip_taskbar_hint(bool setting = true);
            bool get_skip_taskbar_hint() const;
            void set_skip_pager_hint(bool setting = true);
            bool get_skip_pager_hint() const;
            void set_urgency_hint(bool setting = true);
            bool get_urgency_hint() const;
            void set_accept_focus(bool setting = true);
            bool get_accept_focus() const;
            void set_focus_on_map(bool setting = true);
            bool get_focus_on_map() const;
            bool get_destroy_with_parent() const;
            void set_resizable(bool resizable = true);
            bool get_resizable() const;
            void set_gravity(Gdk::Gravity gravity);
            Gdk::Gravity get_gravity() const;
            void set_geometry_hints(Widget & geometry_widget, const Gdk::Geometry & geometry, Gdk::WindowHints geom_mask);
            void set_screen(const Glib::RefPtr< Gdk::Screen > & screen);
            Glib::RefPtr< Gdk::Screen > get_screen();
            Glib::RefPtr< const Gdk::Screen > get_screen() const;
            void set_has_frame(bool setting = true);
            bool get_has_frame() const;
            void set_frame_dimensions(int left, int top, int right, int bottom);
            void get_frame_dimensions(int & left, int & top, int & right, int & bottom) const;
            void set_decorated(bool setting = true);
            bool get_decorated() const;
            void set_deletable(bool setting = true);
            bool get_deletable() const;
            Glib::ListHandle< Glib::RefPtr< Gdk::Pixbuf > > get_icon_list();
            Glib::ListHandle< Glib::RefPtr< const Gdk::Pixbuf > > get_icon_list() const;
            void set_icon_list(const Glib::ListHandle< Glib::RefPtr< Gdk::Pixbuf > > & list);
            void set_icon(const Glib::RefPtr< Gdk::Pixbuf > & icon);
            bool set_icon_from_file(const std::string & filename);
            Glib::RefPtr< Gdk::Pixbuf > get_icon();
            Glib::RefPtr< const Gdk::Pixbuf > get_icon() const;
            static void set_default_icon_list(const Glib::ListHandle< Glib::RefPtr< Gdk::Pixbuf > > & list);
            static Glib::ListHandle< Glib::RefPtr< Gdk::Pixbuf > > get_default_icon_list();
            static void set_default_icon(const Glib::RefPtr< Gdk::Pixbuf > & icon);
            static void set_default_icon_name(const Glib::ustring & name);
            static bool set_default_icon_from_file(const std::string & filename);
            static void set_auto_startup_notification(bool setting = true);
            void set_modal(bool modal = true);
            bool get_modal() const;
            static Glib::ListHandle< Window * > list_toplevels();
            void add_mnemonic(guint keyval, Widget & target);
            void remove_mnemonic(guint keyval, Widget & target);
            bool mnemonic_activate(guint keyval, Gdk::ModifierType modifier);
            void set_mnemonic_modifier(Gdk::ModifierType modifier);
            Gdk::ModifierType get_mnemonic_modifier();
            void present();
            void present(guint32 timestamp);
            void iconify();
            void deiconify();
            void stick();
            void unstick();
            void maximize();
            void unmaximize();
            void fullscreen();
            void unfullscreen();
            void begin_resize_drag(Gdk::WindowEdge edge, int button, int root_x, int root_y, guint32 timestamp);
            void begin_move_drag(int button, int root_x, int root_y, guint32 timestamp);
            void set_default_size(int width, int height);
            void get_default_size(int & width, int & height) const;
            void resize(int width, int height);
            void get_size(int & width, int & height) const;
            void move(int x, int y);
            void get_position(int & root_x, int & root_y) const;
            bool parse_geometry(const Glib::ustring & geometry);
            Glib::RefPtr< WindowGroup > get_group();
            Glib::RefPtr< const WindowGroup > get_group() const;
            void reshow_with_initial_size();
            void set_keep_above(bool setting = true);
            void set_keep_below(bool setting = true);
            Glib::RefPtr< AccelGroup > get_accel_group();
            virtual void raise();
            virtual void set_manage();
        protected :
            void destroy_();
            void _destroy_c_instance();
        private :
            Glib::RefPtr< AccelGroup > accel_group_;
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::WindowGroup > wrap(GtkWindowGroup * object, bool take_copy = false);
}
namespace Glib {
    Gtk::Window * wrap(GtkWindow * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkContainer GtkContainer;
    typedef struct _GtkContainerClass GtkContainerClass;
    struct _GtkContainer
    {
            GtkWidget widget;
            GtkWidget * focus_child;
            guint border_width : 16;
            guint need_resize : 1;
            guint resize_mode : 2;
            guint reallocate_redraws : 1;
            guint has_focus_chain : 1;
    };
    struct _GtkContainerClass
    {
            GtkWidgetClass parent_class;
            void (* add)(GtkContainer * container, GtkWidget * widget);
            void (* remove)(GtkContainer * container, GtkWidget * widget);
            void (* check_resize)(GtkContainer * container);
            void (* forall)(GtkContainer * container, gboolean include_internals, GtkCallback callback, gpointer callback_data);
            void (* set_focus_child)(GtkContainer * container, GtkWidget * widget);
            GType (* child_type)(GtkContainer * container);
            gchar * (* composite_name)(GtkContainer * container, GtkWidget * child);
            void (* set_child_property)(GtkContainer * container, GtkWidget * child, guint property_id, const GValue * value, GParamSpec * pspec);
            void (* get_child_property)(GtkContainer * container, GtkWidget * child, guint property_id, GValue * value, GParamSpec * pspec);
            void (* _gtk_reserved1)(void);
            void (* _gtk_reserved2)(void);
            void (* _gtk_reserved3)(void);
            void (* _gtk_reserved4)(void);
    };
    GType gtk_container_get_type(void) __attribute__((__const__));
    void gtk_container_set_border_width(GtkContainer * container, guint border_width);
    guint gtk_container_get_border_width(GtkContainer * container);
    void gtk_container_add(GtkContainer * container, GtkWidget * widget);
    void gtk_container_remove(GtkContainer * container, GtkWidget * widget);
    void gtk_container_set_resize_mode(GtkContainer * container, GtkResizeMode resize_mode);
    GtkResizeMode gtk_container_get_resize_mode(GtkContainer * container);
    void gtk_container_check_resize(GtkContainer * container);
    void gtk_container_foreach(GtkContainer * container, GtkCallback callback, gpointer callback_data);
    void gtk_container_foreach_full(GtkContainer * container, GtkCallback callback, GtkCallbackMarshal marshal, gpointer callback_data, GtkDestroyNotify notify);
    GList * gtk_container_get_children(GtkContainer * container);
    void gtk_container_propagate_expose(GtkContainer * container, GtkWidget * child, GdkEventExpose * event);
    void gtk_container_set_focus_chain(GtkContainer * container, GList * focusable_widgets);
    gboolean gtk_container_get_focus_chain(GtkContainer * container, GList * * focusable_widgets);
    void gtk_container_unset_focus_chain(GtkContainer * container);
    void gtk_container_set_reallocate_redraws(GtkContainer * container, gboolean needs_redraws);
    void gtk_container_set_focus_child(GtkContainer * container, GtkWidget * child);
    void gtk_container_set_focus_vadjustment(GtkContainer * container, GtkAdjustment * adjustment);
    GtkAdjustment * gtk_container_get_focus_vadjustment(GtkContainer * container);
    void gtk_container_set_focus_hadjustment(GtkContainer * container, GtkAdjustment * adjustment);
    GtkAdjustment * gtk_container_get_focus_hadjustment(GtkContainer * container);
    void gtk_container_resize_children(GtkContainer * container);
    GType gtk_container_child_type(GtkContainer * container);
    void gtk_container_class_install_child_property(GtkContainerClass * cclass, guint property_id, GParamSpec * pspec);
    GParamSpec * gtk_container_class_find_child_property(GObjectClass * cclass, const gchar * property_name);
    GParamSpec * * gtk_container_class_list_child_properties(GObjectClass * cclass, guint * n_properties);
    void gtk_container_add_with_properties(GtkContainer * container, GtkWidget * widget, const gchar * first_prop_name, ...) __attribute__((__sentinel__));
    void gtk_container_child_set(GtkContainer * container, GtkWidget * child, const gchar * first_prop_name, ...) __attribute__((__sentinel__));
    void gtk_container_child_get(GtkContainer * container, GtkWidget * child, const gchar * first_prop_name, ...) __attribute__((__sentinel__));
    void gtk_container_child_set_valist(GtkContainer * container, GtkWidget * child, const gchar * first_property_name, va_list var_args);
    void gtk_container_child_get_valist(GtkContainer * container, GtkWidget * child, const gchar * first_property_name, va_list var_args);
    void gtk_container_child_set_property(GtkContainer * container, GtkWidget * child, const gchar * property_name, const GValue * value);
    void gtk_container_child_get_property(GtkContainer * container, GtkWidget * child, const gchar * property_name, GValue * value);
    void gtk_container_forall(GtkContainer * container, GtkCallback callback, gpointer callback_data);
    void _gtk_container_queue_resize(GtkContainer * container);
    void _gtk_container_clear_resize_widgets(GtkContainer * container);
    gchar * _gtk_container_child_composite_name(GtkContainer * container, GtkWidget * child);
    void _gtk_container_dequeue_resize_handler(GtkContainer * container);
    GList * _gtk_container_focus_sort(GtkContainer * container, GList * children, GtkDirectionType direction, GtkWidget * old_focus);
}
extern "C"
{
    typedef struct _GtkBox GtkBox;
    typedef struct _GtkBoxClass GtkBoxClass;
    typedef struct _GtkBoxChild GtkBoxChild;
    struct _GtkBox
    {
            GtkContainer container;
            GList * children;
            gint16 spacing;
            guint homogeneous : 1;
    };
    struct _GtkBoxClass
    {
            GtkContainerClass parent_class;
    };
    struct _GtkBoxChild
    {
            GtkWidget * widget;
            guint16 padding;
            guint expand : 1;
            guint fill : 1;
            guint pack : 1;
            guint is_secondary : 1;
    };
    GType gtk_box_get_type(void) __attribute__((__const__));
    void gtk_box_pack_start(GtkBox * box, GtkWidget * child, gboolean expand, gboolean fill, guint padding);
    void gtk_box_pack_end(GtkBox * box, GtkWidget * child, gboolean expand, gboolean fill, guint padding);
    void gtk_box_pack_start_defaults(GtkBox * box, GtkWidget * widget);
    void gtk_box_pack_end_defaults(GtkBox * box, GtkWidget * widget);
    void gtk_box_set_homogeneous(GtkBox * box, gboolean homogeneous);
    gboolean gtk_box_get_homogeneous(GtkBox * box);
    void gtk_box_set_spacing(GtkBox * box, gint spacing);
    gint gtk_box_get_spacing(GtkBox * box);
    void gtk_box_reorder_child(GtkBox * box, GtkWidget * child, gint position);
    void gtk_box_query_child_packing(GtkBox * box, GtkWidget * child, gboolean * expand, gboolean * fill, guint * padding, GtkPackType * pack_type);
    void gtk_box_set_child_packing(GtkBox * box, GtkWidget * child, gboolean expand, gboolean fill, guint padding, GtkPackType pack_type);
}
typedef struct _GtkBox GtkBox;
typedef struct _GtkBoxClass GtkBoxClass;
namespace Gtk {
    class Box_Class;
}
typedef struct _GtkVBox GtkVBox;
typedef struct _GtkVBoxClass GtkVBoxClass;
namespace Gtk {
    class VBox_Class;
}
typedef struct _GtkHBox GtkHBox;
typedef struct _GtkHBoxClass GtkHBoxClass;
namespace Gtk {
    class HBox_Class;
}
namespace Gtk {
    enum PackOptions
    {
        PACK_SHRINK, 
        PACK_EXPAND_PADDING, 
        PACK_EXPAND_WIDGET
    };
    class Box;
    namespace Box_Helpers {
        class Child : protected _GtkBoxChild
        {
            private :
                Child & operator =(const Child &);
                Child(const Child &);
            public :
                inline _GtkBoxChild * gobj()
                {
                    return this;
                }
                inline const _GtkBoxChild * gobj() const
                {
                    return this;
                }
                Widget * get_widget() const;
                inline guint16 get_padding() const
                {
                    return (gobj()->padding);
                }
                inline bool get_expand() const
                {
                    return (gobj()->expand);
                }
                inline bool get_fill() const
                {
                    return (gobj()->fill);
                }
                inline bool get_pack() const
                {
                    return (gobj()->pack);
                }
                void set_options(PackOptions options, guint padding = 0);
                void set_options(bool expand, bool fill, guint padding = 0);
                void set_pack(PackType pack);
            protected :
                inline GtkBox * parent()
                {
                    return (GtkBox *) (gobj()->widget->parent);
                }
                void redraw();
                friend class Dummy_;
        };
        class Element
        {
            public :
                Element(Widget & widget, PackOptions options = PACK_EXPAND_WIDGET, guint padding = 0, PackType pack = PACK_START)
                    : widget_(&widget), options_(options), padding_(padding), pack_(pack) 
                {
                }
                Widget * widget_;
                PackOptions options_;
                guint padding_;
                PackType pack_;
        };
        typedef Element StartElem;
        struct EndElem : public Element
        {
                EndElem(Widget & widget, PackOptions options = PACK_EXPAND_WIDGET, guint padding = 0)
                    : Element(widget, options, padding, PACK_END) 
                {
                }
        };
        class BoxList : public Glib::HelperList< Child, const Element, Glib::List_Iterator< Child > >
        {
            public :
                BoxList();
                explicit BoxList(GtkBox * gparent);
                BoxList(const BoxList & src);
                virtual ~BoxList()
                {
                }
                BoxList & operator =(const BoxList & src);
                typedef Glib::HelperList< Child, const Element, Glib::List_Iterator< Child > > type_base;
                GtkBox * gparent();
                const GtkBox * gparent() const;
                virtual GList * & glist() const;
                virtual void erase(iterator start, iterator stop);
                virtual iterator erase(iterator);
                virtual void remove(const_reference);
                reference operator [](size_type l) const;
            public :
                iterator insert(iterator position, element_type & e);
                template<class InputIterator >
                inline void insert(iterator position, InputIterator first, InputIterator last)
                {
                    for (;
                        first != last;
                        ++first)
                    position = insert(position, *first);
                }
                inline void push_front(element_type & e)
                {
                    insert(begin(), e);
                }
                inline void push_back(element_type & e)
                {
                    insert(end(), e);
                }
                iterator find(const_reference c);
                iterator find(Widget &);
                virtual void remove(Widget & w);
                void reorder(iterator loc, iterator pos);
        };
    }
    class Box : public Container
    {
        public :
            typedef Box CppObjectType;
            typedef Box_Class CppClassType;
            typedef GtkBox BaseObjectType;
            typedef GtkBoxClass BaseClassType;
            virtual ~Box();
        private :
            friend class Box_Class;
            static CppClassType box_class_;
            Box(const Box &);
            Box & operator =(const Box &);
        protected :
            explicit Box(const Glib::ConstructParams & construct_params);
            explicit Box(GtkBox * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkBox * gobj()
            {
                return reinterpret_cast<GtkBox * >(gobject_);
            }
            const GtkBox * gobj() const
            {
                return reinterpret_cast<GtkBox * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            typedef Box_Helpers::BoxList BoxList;
        protected :
            Box();
        public :
            void pack_start(Widget & child, bool expand, bool fill, guint padding = 0);
            void pack_start(Widget & child, PackOptions options = PACK_EXPAND_WIDGET, guint padding = 0);
            void pack_end(Widget & child, bool expand, bool fill, guint padding = 0);
            void pack_end(Widget & child, PackOptions options = PACK_EXPAND_WIDGET, guint padding = 0);
            void set_homogeneous(bool homogeneous = true);
            bool get_homogeneous() const;
            void set_spacing(int spacing);
            int get_spacing() const;
            void reorder_child(Widget & child, int pos);
            BoxList & children();
            const BoxList & children() const;
            Glib::PropertyProxy< int > property_spacing();
            Glib::PropertyProxy_ReadOnly< int > property_spacing() const;
            Glib::PropertyProxy< bool > property_homogeneous();
            Glib::PropertyProxy_ReadOnly< bool > property_homogeneous() const;
        protected :
            mutable BoxList children_proxy_;
    };
    class VBox : public Box
    {
        public :
            typedef VBox CppObjectType;
            typedef VBox_Class CppClassType;
            typedef GtkVBox BaseObjectType;
            typedef GtkVBoxClass BaseClassType;
            virtual ~VBox();
        private :
            friend class VBox_Class;
            static CppClassType vbox_class_;
            VBox(const VBox &);
            VBox & operator =(const VBox &);
        protected :
            explicit VBox(const Glib::ConstructParams & construct_params);
            explicit VBox(GtkVBox * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkVBox * gobj()
            {
                return reinterpret_cast<GtkVBox * >(gobject_);
            }
            const GtkVBox * gobj() const
            {
                return reinterpret_cast<GtkVBox * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            explicit VBox(bool homogeneous = false, int spacing = 0);
    };
    class HBox : public Box
    {
        public :
            typedef HBox CppObjectType;
            typedef HBox_Class CppClassType;
            typedef GtkHBox BaseObjectType;
            typedef GtkHBoxClass BaseClassType;
            virtual ~HBox();
        private :
            friend class HBox_Class;
            static CppClassType hbox_class_;
            HBox(const HBox &);
            HBox & operator =(const HBox &);
        protected :
            explicit HBox(const Glib::ConstructParams & construct_params);
            explicit HBox(GtkHBox * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkHBox * gobj()
            {
                return reinterpret_cast<GtkHBox * >(gobject_);
            }
            const GtkHBox * gobj() const
            {
                return reinterpret_cast<GtkHBox * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            explicit HBox(bool homogeneous = false, int spacing = 0);
    };
}
namespace Glib {
    Gtk::Box * wrap(GtkBox * object, bool take_copy = false);
}
namespace Glib {
    Gtk::VBox * wrap(GtkVBox * object, bool take_copy = false);
}
namespace Glib {
    Gtk::HBox * wrap(GtkHBox * object, bool take_copy = false);
}
typedef struct _GtkButton GtkButton;
typedef struct _GtkButtonClass GtkButtonClass;
namespace Gtk {
    class Button_Class;
}
namespace Gtk {
    namespace Stock {
        struct BuiltinStockID;
    }
    class Button : public Bin
    {
        public :
            typedef Button CppObjectType;
            typedef Button_Class CppClassType;
            typedef GtkButton BaseObjectType;
            typedef GtkButtonClass BaseClassType;
            virtual ~Button();
        private :
            friend class Button_Class;
            static CppClassType button_class_;
            Button(const Button &);
            Button & operator =(const Button &);
        protected :
            explicit Button(const Glib::ConstructParams & construct_params);
            explicit Button(GtkButton * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkButton * gobj()
            {
                return reinterpret_cast<GtkButton * >(gobject_);
            }
            const GtkButton * gobj() const
            {
                return reinterpret_cast<GtkButton * >(gobject_);
            }
        public :
        protected :
            virtual void on_pressed();
            virtual void on_released();
            virtual void on_clicked();
            virtual void on_enter();
            virtual void on_leave();
            virtual void on_activate();
        private :
        public :
            Button();
            explicit Button(const Glib::ustring & label, bool mnemonic = false);
            explicit Button(const StockID & stock_id);
            void pressed();
            void released();
            void clicked();
            void enter();
            void leave();
            void set_relief(ReliefStyle newstyle);
            ReliefStyle get_relief() const;
            void set_label(const Glib::ustring & label);
            Glib::ustring get_label() const;
            void set_use_underline(bool use_underline = true);
            bool get_use_underline() const;
            void set_use_stock(bool use_stock = true);
            bool get_use_stock() const;
            void set_focus_on_click(bool focus_on_click = true);
            bool get_focus_on_click() const;
            void set_alignment(float xalign, float yalign);
            void get_alignment(float & xalign, float & yalign);
            void set_image(Widget & image);
            Widget * get_image();
            const Widget * get_image() const;
            void set_image_position(PositionType position);
            PositionType get_image_position() const;
            Glib::SignalProxy0< void > signal_pressed();
            Glib::SignalProxy0< void > signal_released();
            Glib::SignalProxy0< void > signal_clicked();
            Glib::SignalProxy0< void > signal_enter();
            Glib::SignalProxy0< void > signal_leave();
            Glib::SignalProxy0< void > signal_activate();
            Glib::PropertyProxy< Glib::ustring > property_label();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_label() const;
            Glib::PropertyProxy< ReliefStyle > property_relief();
            Glib::PropertyProxy_ReadOnly< ReliefStyle > property_relief() const;
            Glib::PropertyProxy< bool > property_use_underline();
            Glib::PropertyProxy_ReadOnly< bool > property_use_underline() const;
            Glib::PropertyProxy< bool > property_use_stock();
            Glib::PropertyProxy_ReadOnly< bool > property_use_stock() const;
            Glib::PropertyProxy< bool > property_focus_on_click();
            Glib::PropertyProxy_ReadOnly< bool > property_focus_on_click() const;
            Glib::PropertyProxy< float > property_xalign();
            Glib::PropertyProxy_ReadOnly< float > property_xalign() const;
            Glib::PropertyProxy< float > property_yalign();
            Glib::PropertyProxy_ReadOnly< float > property_yalign() const;
            Glib::PropertyProxy< Gtk::Widget * > property_image();
            Glib::PropertyProxy_ReadOnly< Gtk::Widget * > property_image() const;
            Glib::PropertyProxy< PositionType > property_image_position();
            Glib::PropertyProxy_ReadOnly< PositionType > property_image_position() const;
    };
}
namespace Glib {
    Gtk::Button * wrap(GtkButton * object, bool take_copy = false);
}
typedef struct _GtkButtonBox GtkButtonBox;
typedef struct _GtkButtonBoxClass GtkButtonBoxClass;
namespace Gtk {
    class ButtonBox_Class;
}
typedef struct _GtkVButtonBox GtkVButtonBox;
typedef struct _GtkVButtonBoxClass GtkVButtonBoxClass;
namespace Gtk {
    class VButtonBox_Class;
}
typedef struct _GtkHButtonBox GtkHButtonBox;
typedef struct _GtkHButtonBoxClass GtkHButtonBoxClass;
namespace Gtk {
    class HButtonBox_Class;
}
namespace Gtk {
    enum 
    {
        BUTTONBOX_DEFAULT = -1
    };
    class ButtonBox : public Box
    {
        public :
            typedef ButtonBox CppObjectType;
            typedef ButtonBox_Class CppClassType;
            typedef GtkButtonBox BaseObjectType;
            typedef GtkButtonBoxClass BaseClassType;
            virtual ~ButtonBox();
        private :
            friend class ButtonBox_Class;
            static CppClassType buttonbox_class_;
            ButtonBox(const ButtonBox &);
            ButtonBox & operator =(const ButtonBox &);
        protected :
            explicit ButtonBox(const Glib::ConstructParams & construct_params);
            explicit ButtonBox(GtkButtonBox * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkButtonBox * gobj()
            {
                return reinterpret_cast<GtkButtonBox * >(gobject_);
            }
            const GtkButtonBox * gobj() const
            {
                return reinterpret_cast<GtkButtonBox * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            ButtonBoxStyle get_layout() const;
            void set_layout(ButtonBoxStyle layout_style);
            void set_child_secondary(Widget & child, bool is_secondary = true);
            bool get_child_secondary(const Gtk::Widget & child) const;
            int get_child_min_width() const;
            void set_child_min_width(const int & value);
            int get_child_min_height() const;
            void set_child_min_height(const int & value);
            int get_child_ipadding_x() const;
            void set_child_ipadding_x(const int & value);
            int get_child_ipadding_y() const;
            void set_child_ipadding_y(const int & value);
            Glib::PropertyProxy< ButtonBoxStyle > property_layout_style();
            Glib::PropertyProxy_ReadOnly< ButtonBoxStyle > property_layout_style() const;
    };
    class VButtonBox : public ButtonBox
    {
        public :
            typedef VButtonBox CppObjectType;
            typedef VButtonBox_Class CppClassType;
            typedef GtkVButtonBox BaseObjectType;
            typedef GtkVButtonBoxClass BaseClassType;
            virtual ~VButtonBox();
        private :
            friend class VButtonBox_Class;
            static CppClassType vbuttonbox_class_;
            VButtonBox(const VButtonBox &);
            VButtonBox & operator =(const VButtonBox &);
        protected :
            explicit VButtonBox(const Glib::ConstructParams & construct_params);
            explicit VButtonBox(GtkVButtonBox * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkVButtonBox * gobj()
            {
                return reinterpret_cast<GtkVButtonBox * >(gobject_);
            }
            const GtkVButtonBox * gobj() const
            {
                return reinterpret_cast<GtkVButtonBox * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            explicit VButtonBox(ButtonBoxStyle layout = BUTTONBOX_DEFAULT_STYLE, int spacing = BUTTONBOX_DEFAULT);
    };
    class HButtonBox : public ButtonBox
    {
        public :
            typedef HButtonBox CppObjectType;
            typedef HButtonBox_Class CppClassType;
            typedef GtkHButtonBox BaseObjectType;
            typedef GtkHButtonBoxClass BaseClassType;
            virtual ~HButtonBox();
        private :
            friend class HButtonBox_Class;
            static CppClassType hbuttonbox_class_;
            HButtonBox(const HButtonBox &);
            HButtonBox & operator =(const HButtonBox &);
        protected :
            explicit HButtonBox(const Glib::ConstructParams & construct_params);
            explicit HButtonBox(GtkHButtonBox * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkHButtonBox * gobj()
            {
                return reinterpret_cast<GtkHButtonBox * >(gobject_);
            }
            const GtkHButtonBox * gobj() const
            {
                return reinterpret_cast<GtkHButtonBox * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            explicit HButtonBox(ButtonBoxStyle layout = BUTTONBOX_DEFAULT_STYLE, int spacing = BUTTONBOX_DEFAULT);
    };
}
namespace Glib {
    Gtk::ButtonBox * wrap(GtkButtonBox * object, bool take_copy = false);
}
namespace Glib {
    Gtk::VButtonBox * wrap(GtkVButtonBox * object, bool take_copy = false);
}
namespace Glib {
    Gtk::HButtonBox * wrap(GtkHButtonBox * object, bool take_copy = false);
}
typedef struct _GtkDialog GtkDialog;
typedef struct _GtkDialogClass GtkDialogClass;
namespace Gtk {
    class Dialog_Class;
}
namespace Gtk {
    enum ResponseType
    {
        RESPONSE_NONE = -1, 
        RESPONSE_REJECT = -2, 
        RESPONSE_ACCEPT = -3, 
        RESPONSE_DELETE_EVENT = -4, 
        RESPONSE_OK = -5, 
        RESPONSE_CANCEL = -6, 
        RESPONSE_CLOSE = -7, 
        RESPONSE_YES = -8, 
        RESPONSE_NO = -9, 
        RESPONSE_APPLY = -10, 
        RESPONSE_HELP = -11
    };
}
namespace Glib {
    template<>
    class Value< Gtk::ResponseType > : public Glib::Value_Enum< Gtk::ResponseType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class Dialog : public Window
    {
        public :
            typedef Dialog CppObjectType;
            typedef Dialog_Class CppClassType;
            typedef GtkDialog BaseObjectType;
            typedef GtkDialogClass BaseClassType;
            virtual ~Dialog();
        private :
            friend class Dialog_Class;
            static CppClassType dialog_class_;
            Dialog(const Dialog &);
            Dialog & operator =(const Dialog &);
        protected :
            explicit Dialog(const Glib::ConstructParams & construct_params);
            explicit Dialog(GtkDialog * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkDialog * gobj()
            {
                return reinterpret_cast<GtkDialog * >(gobject_);
            }
            const GtkDialog * gobj() const
            {
                return reinterpret_cast<GtkDialog * >(gobject_);
            }
        public :
        protected :
            virtual void on_response(int response_id);
        private :
        public :
            Dialog();
            explicit Dialog(const Glib::ustring & title, bool modal = false, bool use_separator = false);
            Dialog(const Glib::ustring & title, Gtk::Window & parent, bool modal = false, bool use_separator = false);
            void add_action_widget(Widget & child, int response_id);
            Button * add_button(const Glib::ustring & button_text, int response_id);
            Button * add_button(const Gtk::StockID & stock_id, int response_id);
            void set_response_sensitive(int response_id, bool setting = true);
            void set_default_response(int response_id);
            int get_response_for_widget(const Gtk::Widget & widget) const;
            void set_has_separator(bool setting = true);
            bool get_has_separator() const;
            static bool alternative_button_order(const Glib::RefPtr< const Gdk::Screen > & screen);
            void set_alternative_button_order_from_array(const Glib::ArrayHandle< int > & new_order);
            void response(int response_id);
            int run();
            VBox * get_vbox();
            const VBox * get_vbox() const;
            HButtonBox * get_action_area();
            const HButtonBox * get_action_area() const;
            Glib::PropertyProxy< bool > property_has_separator();
            Glib::PropertyProxy_ReadOnly< bool > property_has_separator() const;
            Glib::SignalProxy1< void, int > signal_response();
        protected :
            void construct_(bool modal, bool use_separator);
    };
}
namespace Glib {
    Gtk::Dialog * wrap(GtkDialog * object, bool take_copy = false);
}
typedef struct _GtkAboutDialog GtkAboutDialog;
typedef struct _GtkAboutDialogClass GtkAboutDialogClass;
namespace Gtk {
    class AboutDialog_Class;
}
namespace Gtk {
    class AboutDialog : public Dialog
    {
        public :
            typedef AboutDialog CppObjectType;
            typedef AboutDialog_Class CppClassType;
            typedef GtkAboutDialog BaseObjectType;
            typedef GtkAboutDialogClass BaseClassType;
            virtual ~AboutDialog();
        private :
            friend class AboutDialog_Class;
            static CppClassType aboutdialog_class_;
            AboutDialog(const AboutDialog &);
            AboutDialog & operator =(const AboutDialog &);
        protected :
            explicit AboutDialog(const Glib::ConstructParams & construct_params);
            explicit AboutDialog(GtkAboutDialog * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkAboutDialog * gobj()
            {
                return reinterpret_cast<GtkAboutDialog * >(gobject_);
            }
            const GtkAboutDialog * gobj() const
            {
                return reinterpret_cast<GtkAboutDialog * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            AboutDialog();
            Glib::ustring get_name() const;
            void set_name(const Glib::ustring & name);
            Glib::ustring get_program_name() const;
            void set_program_name(const Glib::ustring & name);
            Glib::ustring get_version() const;
            void set_version(const Glib::ustring & version);
            Glib::ustring get_copyright() const;
            void set_copyright(const Glib::ustring & copyright);
            Glib::ustring get_comments() const;
            void set_comments(const Glib::ustring & comments);
            Glib::ustring get_license() const;
            void set_license(const Glib::ustring & license);
            Glib::ustring get_website() const;
            void set_website(const Glib::ustring & website);
            Glib::ustring get_website_label() const;
            void set_website_label(const Glib::ustring & website_label);
            Glib::StringArrayHandle get_authors() const;
            void set_authors(const Glib::StringArrayHandle & authors) const;
            Glib::StringArrayHandle get_documenters() const;
            void set_documenters(const Glib::StringArrayHandle & documenters);
            Glib::StringArrayHandle get_artists() const;
            void set_artists(const Glib::StringArrayHandle & artists);
            Glib::ustring get_translator_credits() const;
            void set_translator_credits(const Glib::ustring & translator_credits);
            Glib::RefPtr< Gdk::Pixbuf > get_logo();
            Glib::RefPtr< const Gdk::Pixbuf > get_logo() const;
            void set_logo(const Glib::RefPtr< Gdk::Pixbuf > & logo);
            Glib::ustring get_logo_icon_name() const;
            void set_logo_icon_name(const Glib::ustring & icon_name);
            bool get_wrap_license() const;
            void set_wrap_license(bool wrap_license);
            typedef sigc::slot< void, AboutDialog &, const Glib::ustring & > SlotActivateLink;
            static void set_email_hook(const SlotActivateLink & slot);
            static void set_url_hook(const SlotActivateLink & slot);
            Glib::PropertyProxy< Glib::ustring > property_name();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_name() const;
            Glib::PropertyProxy< Glib::ustring > property_program_name();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_program_name() const;
            Glib::PropertyProxy< Glib::ustring > property_version();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_version() const;
            Glib::PropertyProxy< Glib::ustring > property_copyright();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_copyright() const;
            Glib::PropertyProxy< Glib::ustring > property_comments();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_comments() const;
            Glib::PropertyProxy< Glib::ustring > property_website();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_website() const;
            Glib::PropertyProxy< Glib::ustring > property_website_label();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_website_label() const;
            Glib::PropertyProxy< Glib::ustring > property_license();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_license() const;
            Glib::PropertyProxy< Glib::StringArrayHandle > property_authors();
            Glib::PropertyProxy_ReadOnly< Glib::StringArrayHandle > property_authors() const;
            Glib::PropertyProxy< Glib::StringArrayHandle > property_documenters();
            Glib::PropertyProxy_ReadOnly< Glib::StringArrayHandle > property_documenters() const;
            Glib::PropertyProxy< Glib::StringArrayHandle > property_translator_credits();
            Glib::PropertyProxy_ReadOnly< Glib::StringArrayHandle > property_translator_credits() const;
            Glib::PropertyProxy< Glib::StringArrayHandle > property_artists();
            Glib::PropertyProxy_ReadOnly< Glib::StringArrayHandle > property_artists() const;
            Glib::PropertyProxy< Glib::RefPtr< Gdk::Pixbuf > > property_logo();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Gdk::Pixbuf > > property_logo() const;
            Glib::PropertyProxy< Glib::ustring > property_logo_icon_name();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_logo_icon_name() const;
            Glib::PropertyProxy< bool > property_wrap_license();
            Glib::PropertyProxy_ReadOnly< bool > property_wrap_license() const;
    };
}
namespace Glib {
    Gtk::AboutDialog * wrap(GtkAboutDialog * object, bool take_copy = false);
}
namespace Gtk {
    class AccelKey
    {
        public :
            AccelKey();
            AccelKey(guint accel_key, Gdk::ModifierType accel_mods, const Glib::ustring & accel_path = "");
            AccelKey(const Glib::ustring & accelerator, const Glib::ustring & accel_path = Glib::ustring());
            AccelKey(const AccelKey & src);
            AccelKey & operator =(const AccelKey & src);
            bool is_null() const;
            guint get_key() const;
            Gdk::ModifierType get_mod() const;
            Glib::ustring get_path() const;
            Glib::ustring get_abbrev() const;
        protected :
            guint key_;
            Gdk::ModifierType mod_;
            Glib::ustring path_;
    };
}
typedef struct _GtkAccelGroup GtkAccelGroup;
typedef struct _GtkAccelGroupClass GtkAccelGroupClass;
namespace Gtk {
    class AccelGroup_Class;
}
namespace Gtk {
    class AccelGroup : public Glib::Object
    {
        public :
            typedef AccelGroup CppObjectType;
            typedef AccelGroup_Class CppClassType;
            typedef GtkAccelGroup BaseObjectType;
            typedef GtkAccelGroupClass BaseClassType;
        private :
            friend class AccelGroup_Class;
            static CppClassType accelgroup_class_;
        private :
            AccelGroup(const AccelGroup &);
            AccelGroup & operator =(const AccelGroup &);
        protected :
            explicit AccelGroup(const Glib::ConstructParams & construct_params);
            explicit AccelGroup(GtkAccelGroup * castitem);
        public :
            virtual ~AccelGroup();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkAccelGroup * gobj()
            {
                return reinterpret_cast<GtkAccelGroup * >(gobject_);
            }
            const GtkAccelGroup * gobj() const
            {
                return reinterpret_cast<GtkAccelGroup * >(gobject_);
            }
            GtkAccelGroup * gobj_copy();
        private :
        protected :
            AccelGroup();
        public :
            static Glib::RefPtr< AccelGroup > create();
            void lock();
            void unlock();
            bool disconnect_key(guint accel_key, Gdk::ModifierType accel_mods);
            static bool valid(guint keyval, Gdk::ModifierType modifiers);
            static void parse(const Glib::ustring & accelerator, guint & accelerator_key, Gdk::ModifierType & accelerator_mods);
            static Glib::ustring name(guint accelerator_key, Gdk::ModifierType accelerator_mods);
            static Glib::ustring get_label(guint accelerator_key, Gdk::ModifierType accelerator_mods);
            static void set_default_mod_mask(Gdk::ModifierType default_mod_mask);
            static Gdk::ModifierType get_default_mod_mask();
            bool activate(GQuark accel_quark, const Glib::RefPtr< Glib::Object > & acceleratable, guint accel_key, Gdk::ModifierType accel_mods);
            static bool activate(Gtk::Object & object, guint accel_key, Gdk::ModifierType accel_mods);
            Glib::SignalProxy3< bool, const Glib::RefPtr< Glib::Object > &, guint, Gdk::ModifierType > signal_accel_activate();
            Glib::SignalProxy3< void, guint, Gdk::ModifierType, GClosure * > signal_accel_changed();
        public :
        public :
        protected :
            virtual void on_accel_changed(guint keyval, Gdk::ModifierType modifier, GClosure * accel_closure);
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::AccelGroup > wrap(GtkAccelGroup * object, bool take_copy = false);
}
typedef struct _GtkAdjustment GtkAdjustment;
typedef struct _GtkAdjustmentClass GtkAdjustmentClass;
namespace Gtk {
    class Adjustment_Class;
}
namespace Gtk {
    class Adjustment : public Object
    {
        public :
            typedef Adjustment CppObjectType;
            typedef Adjustment_Class CppClassType;
            typedef GtkAdjustment BaseObjectType;
            typedef GtkAdjustmentClass BaseClassType;
            virtual ~Adjustment();
        private :
            friend class Adjustment_Class;
            static CppClassType adjustment_class_;
            Adjustment(const Adjustment &);
            Adjustment & operator =(const Adjustment &);
        protected :
            explicit Adjustment(const Glib::ConstructParams & construct_params);
            explicit Adjustment(GtkAdjustment * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkAdjustment * gobj()
            {
                return reinterpret_cast<GtkAdjustment * >(gobject_);
            }
            const GtkAdjustment * gobj() const
            {
                return reinterpret_cast<GtkAdjustment * >(gobject_);
            }
        public :
        protected :
            virtual void on_changed();
            virtual void on_value_changed();
        private :
        public :
            friend class Range;
            friend class HScrollbar;
            friend class VScrollbar;
            Adjustment(double value, double lower, double upper, double step_increment = 1, double page_increment = 10, double page_size = 0);
            void changed();
            void value_changed();
            void clamp_page(double lower, double upper);
            void set_value(double value);
            double get_value() const;
            double get_lower() const;
            double get_upper() const;
            double get_step_increment() const;
            double get_page_increment() const;
            double get_page_size() const;
            void set_lower(double lower);
            void set_upper(double upper);
            void set_step_increment(double incr);
            void set_page_increment(double incr);
            void set_page_size(double size);
            Glib::SignalProxy0< void > signal_changed();
            Glib::SignalProxy0< void > signal_value_changed();
    };
}
namespace Glib {
    Gtk::Adjustment * wrap(GtkAdjustment * object, bool take_copy = false);
}
typedef struct _GtkAlignment GtkAlignment;
typedef struct _GtkAlignmentClass GtkAlignmentClass;
namespace Gtk {
    class Alignment_Class;
}
namespace Gtk {
    class Alignment : public Bin
    {
        public :
            typedef Alignment CppObjectType;
            typedef Alignment_Class CppClassType;
            typedef GtkAlignment BaseObjectType;
            typedef GtkAlignmentClass BaseClassType;
            virtual ~Alignment();
        private :
            friend class Alignment_Class;
            static CppClassType alignment_class_;
            Alignment(const Alignment &);
            Alignment & operator =(const Alignment &);
        protected :
            explicit Alignment(const Glib::ConstructParams & construct_params);
            explicit Alignment(GtkAlignment * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkAlignment * gobj()
            {
                return reinterpret_cast<GtkAlignment * >(gobject_);
            }
            const GtkAlignment * gobj() const
            {
                return reinterpret_cast<GtkAlignment * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            explicit Alignment(float xalign = 0.5, float yalign = 0.5, float xscale = 1.0, float yscale = 1.0);
            explicit Alignment(AlignmentEnum xalign, AlignmentEnum yalign = Gtk::ALIGN_CENTER, float xscale = 1.0, float yscale = 1.0);
            void set(float xalign = 0.5, float yalign = 0.5, float xscale = 1.0, float yscale = 1.0);
            void set(AlignmentEnum xalign, AlignmentEnum yalign = Gtk::ALIGN_CENTER, float xscale = 1.0, float yscale = 1.0);
            void set_padding(guint padding_top, guint padding_bottom, guint padding_left, guint padding_right);
            void get_padding(guint & padding_top, guint & padding_bottom, guint & padding_left, guint & padding_right);
            Glib::PropertyProxy< float > property_xalign();
            Glib::PropertyProxy_ReadOnly< float > property_xalign() const;
            Glib::PropertyProxy< float > property_yalign();
            Glib::PropertyProxy_ReadOnly< float > property_yalign() const;
            Glib::PropertyProxy< float > property_xscale();
            Glib::PropertyProxy_ReadOnly< float > property_xscale() const;
            Glib::PropertyProxy< float > property_yscale();
            Glib::PropertyProxy_ReadOnly< float > property_yscale() const;
            Glib::PropertyProxy< guint > property_top_padding();
            Glib::PropertyProxy_ReadOnly< guint > property_top_padding() const;
            Glib::PropertyProxy< guint > property_bottom_padding();
            Glib::PropertyProxy_ReadOnly< guint > property_bottom_padding() const;
            Glib::PropertyProxy< guint > property_left_padding();
            Glib::PropertyProxy_ReadOnly< guint > property_left_padding() const;
            Glib::PropertyProxy< guint > property_right_padding();
            Glib::PropertyProxy_ReadOnly< guint > property_right_padding() const;
    };
}
namespace Glib {
    Gtk::Alignment * wrap(GtkAlignment * object, bool take_copy = false);
}
typedef struct _GtkMisc GtkMisc;
typedef struct _GtkMiscClass GtkMiscClass;
namespace Gtk {
    class Misc_Class;
}
namespace Gtk {
    class Misc : public Widget
    {
        public :
            typedef Misc CppObjectType;
            typedef Misc_Class CppClassType;
            typedef GtkMisc BaseObjectType;
            typedef GtkMiscClass BaseClassType;
            virtual ~Misc();
        private :
            friend class Misc_Class;
            static CppClassType misc_class_;
            Misc(const Misc &);
            Misc & operator =(const Misc &);
        protected :
            explicit Misc(const Glib::ConstructParams & construct_params);
            explicit Misc(GtkMisc * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkMisc * gobj()
            {
                return reinterpret_cast<GtkMisc * >(gobject_);
            }
            const GtkMisc * gobj() const
            {
                return reinterpret_cast<GtkMisc * >(gobject_);
            }
        public :
        protected :
        private :
        protected :
            Misc();
        public :
            void set_alignment(float xalign = 0.0, float yalign = 0.5);
            void set_alignment(AlignmentEnum xalign = Gtk::ALIGN_LEFT, AlignmentEnum yalign = Gtk::ALIGN_CENTER);
            void get_alignment(float & xalign, float & yalign) const;
            void set_padding(int xpad, int ypad);
            void get_padding(int & xpad, int & ypad) const;
            Glib::PropertyProxy< float > property_xalign();
            Glib::PropertyProxy_ReadOnly< float > property_xalign() const;
            Glib::PropertyProxy< float > property_yalign();
            Glib::PropertyProxy_ReadOnly< float > property_yalign() const;
            Glib::PropertyProxy< int > property_xpad();
            Glib::PropertyProxy_ReadOnly< int > property_xpad() const;
            Glib::PropertyProxy< int > property_ypad();
            Glib::PropertyProxy_ReadOnly< int > property_ypad() const;
    };
}
namespace Glib {
    Gtk::Misc * wrap(GtkMisc * object, bool take_copy = false);
}
typedef struct _GtkArrow GtkArrow;
typedef struct _GtkArrowClass GtkArrowClass;
namespace Gtk {
    class Arrow_Class;
}
namespace Gtk {
    class Arrow : public Misc
    {
        public :
            typedef Arrow CppObjectType;
            typedef Arrow_Class CppClassType;
            typedef GtkArrow BaseObjectType;
            typedef GtkArrowClass BaseClassType;
            virtual ~Arrow();
        private :
            friend class Arrow_Class;
            static CppClassType arrow_class_;
            Arrow(const Arrow &);
            Arrow & operator =(const Arrow &);
        protected :
            explicit Arrow(const Glib::ConstructParams & construct_params);
            explicit Arrow(GtkArrow * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkArrow * gobj()
            {
                return reinterpret_cast<GtkArrow * >(gobject_);
            }
            const GtkArrow * gobj() const
            {
                return reinterpret_cast<GtkArrow * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            explicit Arrow(ArrowType arrow_type, ShadowType shadow_type);
            void set(ArrowType arrow_type, ShadowType shadow_type);
            Glib::PropertyProxy< ArrowType > property_arrow_type();
            Glib::PropertyProxy_ReadOnly< ArrowType > property_arrow_type() const;
            Glib::PropertyProxy< ShadowType > property_shadow_type();
            Glib::PropertyProxy_ReadOnly< ShadowType > property_shadow_type() const;
    };
}
namespace Glib {
    Gtk::Arrow * wrap(GtkArrow * object, bool take_copy = false);
}
typedef struct _GtkFrame GtkFrame;
typedef struct _GtkFrameClass GtkFrameClass;
namespace Gtk {
    class Frame_Class;
}
namespace Gtk {
    class Frame : public Bin
    {
        public :
            typedef Frame CppObjectType;
            typedef Frame_Class CppClassType;
            typedef GtkFrame BaseObjectType;
            typedef GtkFrameClass BaseClassType;
            virtual ~Frame();
        private :
            friend class Frame_Class;
            static CppClassType frame_class_;
            Frame(const Frame &);
            Frame & operator =(const Frame &);
        protected :
            explicit Frame(const Glib::ConstructParams & construct_params);
            explicit Frame(GtkFrame * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkFrame * gobj()
            {
                return reinterpret_cast<GtkFrame * >(gobject_);
            }
            const GtkFrame * gobj() const
            {
                return reinterpret_cast<GtkFrame * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            Frame();
            explicit Frame(const Glib::ustring & label);
            void set_label(const Glib::ustring & label);
            void unset_label();
            Glib::ustring get_label() const;
            void set_label_widget(Widget & label_widget);
            Widget * get_label_widget();
            const Widget * get_label_widget() const;
            void set_label_align(float xalign = 0.0, float yalign = 0.5);
            void set_label_align(AlignmentEnum xalign, AlignmentEnum yalign = Gtk::ALIGN_CENTER);
            void get_label_align(float & xalign, float & yalign) const;
            void set_shadow_type(ShadowType type);
            ShadowType get_shadow_type() const;
            Glib::PropertyProxy< Glib::ustring > property_label();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_label() const;
            Glib::PropertyProxy< double > property_label_xalign();
            Glib::PropertyProxy_ReadOnly< double > property_label_xalign() const;
            Glib::PropertyProxy< double > property_label_yalign();
            Glib::PropertyProxy_ReadOnly< double > property_label_yalign() const;
            Glib::PropertyProxy< ShadowType > property_shadow_type();
            Glib::PropertyProxy_ReadOnly< ShadowType > property_shadow_type() const;
            Glib::PropertyProxy< Widget * > property_label_widget();
            Glib::PropertyProxy_ReadOnly< Widget * > property_label_widget() const;
        protected :
            virtual void compute_child_allocation_vfunc(Allocation & allocation);
    };
}
namespace Glib {
    Gtk::Frame * wrap(GtkFrame * object, bool take_copy = false);
}
typedef struct _GtkAspectFrame GtkAspectFrame;
typedef struct _GtkAspectFrameClass GtkAspectFrameClass;
namespace Gtk {
    class AspectFrame_Class;
}
namespace Gtk {
    class AspectFrame : public Frame
    {
        public :
            typedef AspectFrame CppObjectType;
            typedef AspectFrame_Class CppClassType;
            typedef GtkAspectFrame BaseObjectType;
            typedef GtkAspectFrameClass BaseClassType;
            virtual ~AspectFrame();
        private :
            friend class AspectFrame_Class;
            static CppClassType aspectframe_class_;
            AspectFrame(const AspectFrame &);
            AspectFrame & operator =(const AspectFrame &);
        protected :
            explicit AspectFrame(const Glib::ConstructParams & construct_params);
            explicit AspectFrame(GtkAspectFrame * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkAspectFrame * gobj()
            {
                return reinterpret_cast<GtkAspectFrame * >(gobject_);
            }
            const GtkAspectFrame * gobj() const
            {
                return reinterpret_cast<GtkAspectFrame * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            explicit AspectFrame(const Glib::ustring & label = Glib::ustring(), AlignmentEnum xalign = Gtk::ALIGN_CENTER, AlignmentEnum yalign = Gtk::ALIGN_CENTER, float ratio = 1.0, bool obey_child = false);
            explicit AspectFrame(const Glib::ustring & label, float xalign, float yalign, float ratio = 1.0, bool obey_child = false);
            void set(float xalign, float yalign, float ratio, bool obey_child = true);
            void set(AlignmentEnum xalign, AlignmentEnum yalign, float ratio, bool obey_child = true);
            Glib::PropertyProxy< float > property_xalign();
            Glib::PropertyProxy_ReadOnly< float > property_xalign() const;
            Glib::PropertyProxy< float > property_yalign();
            Glib::PropertyProxy_ReadOnly< float > property_yalign() const;
            Glib::PropertyProxy< float > property_ratio();
            Glib::PropertyProxy_ReadOnly< float > property_ratio() const;
            Glib::PropertyProxy< bool > property_obey_child();
            Glib::PropertyProxy_ReadOnly< bool > property_obey_child() const;
    };
}
namespace Glib {
    Gtk::AspectFrame * wrap(GtkAspectFrame * object, bool take_copy = false);
}
typedef struct _GtkAssistant GtkAssistant;
typedef struct _GtkAssistantClass GtkAssistantClass;
namespace Gtk {
    class Assistant_Class;
}
namespace Gtk {
    enum AssistantPageType
    {
        ASSISTANT_PAGE_CONTENT, 
        ASSISTANT_PAGE_INTRO, 
        ASSISTANT_PAGE_CONFIRM, 
        ASSISTANT_PAGE_SUMMARY, 
        ASSISTANT_PAGE_PROGRESS
    };
}
namespace Glib {
    template<>
    class Value< Gtk::AssistantPageType > : public Glib::Value_Enum< Gtk::AssistantPageType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class Assistant : public Window
    {
        public :
            typedef Assistant CppObjectType;
            typedef Assistant_Class CppClassType;
            typedef GtkAssistant BaseObjectType;
            typedef GtkAssistantClass BaseClassType;
            virtual ~Assistant();
        private :
            friend class Assistant_Class;
            static CppClassType assistant_class_;
            Assistant(const Assistant &);
            Assistant & operator =(const Assistant &);
        protected :
            explicit Assistant(const Glib::ConstructParams & construct_params);
            explicit Assistant(GtkAssistant * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkAssistant * gobj()
            {
                return reinterpret_cast<GtkAssistant * >(gobject_);
            }
            const GtkAssistant * gobj() const
            {
                return reinterpret_cast<GtkAssistant * >(gobject_);
            }
        public :
        protected :
            virtual void on_prepare(Gtk::Widget * page);
            virtual void on_apply();
            virtual void on_close();
            virtual void on_cancel();
        private :
        public :
            Assistant();
            int get_current_page() const;
            void set_current_page(int page_num);
            int get_n_pages() const;
            Widget * get_nth_page(int page_num);
            const Widget * get_nth_page(int page_num) const;
            int prepend_page(Widget & page);
            int append_page(Widget & page);
            int insert_page(Widget & page, int position);
            typedef sigc::slot< int, int > SlotForwardPage;
            void set_forward_page_func(const SlotForwardPage & slot);
            void set_page_type(const Widget & page, AssistantPageType type);
            AssistantPageType get_page_type(const Widget & page) const;
            void set_page_title(const Widget & page, const Glib::ustring & title);
            Glib::ustring get_page_title(const Widget & page) const;
            void set_page_header_image(const Widget & page, const Glib::RefPtr< Gdk::Pixbuf > & pixbuf);
            Glib::RefPtr< Gdk::Pixbuf > get_page_header_image(const Widget & page);
            Glib::RefPtr< const Gdk::Pixbuf > get_page_header_image(const Widget & page) const;
            void set_page_side_image(const Widget & page, const Glib::RefPtr< Gdk::Pixbuf > & pixbuf);
            Glib::RefPtr< Gdk::Pixbuf > get_page_side_image(const Widget & page);
            Glib::RefPtr< const Gdk::Pixbuf > get_page_side_image(const Widget & page) const;
            void set_page_complete(const Widget & page, bool complete = true);
            bool get_page_complete(const Widget & page) const;
            void add_action_widget(Widget & child);
            void remove_action_widget(Widget & child);
            void update_buttons_state();
            Glib::SignalProxy1< void, Gtk::Widget * > signal_prepare();
            Glib::SignalProxy0< void > signal_apply();
            Glib::SignalProxy0< void > signal_close();
            Glib::SignalProxy0< void > signal_cancel();
    };
}
namespace Glib {
    Gtk::Assistant * wrap(GtkAssistant * object, bool take_copy = false);
}
typedef struct _GtkBuilder GtkBuilder;
typedef struct _GtkBuilderClass GtkBuilderClass;
namespace Gtk {
    class Builder_Class;
}
namespace Gtk {
    class BuilderError : public Glib::Error
    {
        public :
            enum Code
            {
                INVALID_TYPE_FUNCTION, 
                UNHANDLED_TAG, 
                MISSING_ATTRIBUTE, 
                INVALID_ATTRIBUTE, 
                INVALID_TAG, 
                MISSING_PROPERTY_VALUE, 
                INVALID_VALUE
            };
            BuilderError(Code error_code, const Glib::ustring & error_message);
            explicit BuilderError(GError * gobject);
            Code code() const;
        private :
            static void throw_func(GError * gobject);
            friend void wrap_init();
    };
}
namespace Glib {
    template<>
    class Value< Gtk::BuilderError::Code > : public Glib::Value_Enum< Gtk::BuilderError::Code >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class Builder : public Glib::Object
    {
        public :
            typedef Builder CppObjectType;
            typedef Builder_Class CppClassType;
            typedef GtkBuilder BaseObjectType;
            typedef GtkBuilderClass BaseClassType;
        private :
            friend class Builder_Class;
            static CppClassType builder_class_;
        private :
            Builder(const Builder &);
            Builder & operator =(const Builder &);
        protected :
            explicit Builder(const Glib::ConstructParams & construct_params);
            explicit Builder(GtkBuilder * castitem);
        public :
            virtual ~Builder();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkBuilder * gobj()
            {
                return reinterpret_cast<GtkBuilder * >(gobject_);
            }
            const GtkBuilder * gobj() const
            {
                return reinterpret_cast<GtkBuilder * >(gobject_);
            }
            GtkBuilder * gobj_copy();
        private :
        protected :
            Builder();
        public :
            static Glib::RefPtr< Builder > create();
            static Glib::RefPtr< Builder > create_from_file(const std::string & filename);
            static Glib::RefPtr< Builder > create_from_string(const Glib::ustring & buffer);
            bool add_from_file(const std::string & filename);
            bool add_from_string(const Glib::ustring & buffer);
            bool add_from_string(const char * buffer, gsize length);
            Glib::RefPtr< Glib::Object > get_object(const Glib::ustring & name);
            template<class T_Widget >
            inline void get_widget(const Glib::ustring & name, T_Widget * & widget)
            {
                widget = 0;
                widget = dynamic_cast<T_Widget * >(this->get_widget_checked(name, T_Widget::get_base_type()));
                if (!widget)
                    g_log(((gchar *) 0), G_LOG_LEVEL_CRITICAL, "Gtk::Builder::get_widget(): dynamic_cast<> failed.");
            }
            template<class T_Widget >
            inline void get_widget_derived(const Glib::ustring & name, T_Widget * & widget)
            {
                widget = 0;
                typedef typename T_Widget::BaseObjectType cwidget_type;
                cwidget_type * pCWidget = (cwidget_type *) get_cwidget(name);
                if (!pCWidget)
                    return;
                Glib::ObjectBase * pObjectBase = ObjectBase::_get_current_wrapper((GObject *) pCWidget);
                if (pObjectBase)
                {
                    widget = dynamic_cast<T_Widget * >(Glib::wrap((GtkWidget *) pCWidget));
                    if (!widget)
                        g_log(((gchar *) 0), G_LOG_LEVEL_CRITICAL, "Gtk::Builder::get_widget_derived(): dynamic_cast<> failed. An existing C++ instance, of a different type, seems to exist.");
                }
                else
                {
                    Glib::RefPtr< Gtk::Builder > refThis(this);
                    refThis->reference();
                    widget = new T_Widget (pCWidget, refThis);
                }
            }
            void set_translation_domain(const Glib::ustring & domain);
            Glib::ustring get_translation_domain() const;
        protected :
            Gtk::Widget * get_widget_checked(const Glib::ustring & name, GType type);
            GtkWidget * get_cwidget(const Glib::ustring & name);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::Builder > wrap(GtkBuilder * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkCellEditableIface GtkCellEditableIface;
    typedef union _GdkEvent GdkEvent;
}
typedef struct _GtkCellEditable GtkCellEditable;
typedef struct _GtkCellEditableClass GtkCellEditableClass;
namespace Gtk {
    class CellEditable_Class;
}
namespace Gtk {
    class CellEditable : public Glib::Interface
    {
        public :
            typedef CellEditable CppObjectType;
            typedef CellEditable_Class CppClassType;
            typedef GtkCellEditable BaseObjectType;
            typedef GtkCellEditableIface BaseClassType;
        private :
            friend class CellEditable_Class;
            static CppClassType celleditable_class_;
            CellEditable(const CellEditable &);
            CellEditable & operator =(const CellEditable &);
        protected :
            CellEditable();
            explicit CellEditable(const Glib::Interface_Class & interface_class);
        public :
            explicit CellEditable(GtkCellEditable * castitem);
        protected :
        public :
            virtual ~CellEditable();
            static void add_interface(GType gtype_implementer);
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkCellEditable * gobj()
            {
                return reinterpret_cast<GtkCellEditable * >(gobject_);
            }
            const GtkCellEditable * gobj() const
            {
                return reinterpret_cast<GtkCellEditable * >(gobject_);
            }
        private :
        public :
            void start_editing(GdkEvent * event);
            void editing_done();
            void remove_widget();
            Glib::SignalProxy0< void > signal_editing_done();
            Glib::SignalProxy0< void > signal_remove_widget();
        protected :
            virtual void start_editing_vfunc(GdkEvent * event);
        public :
        public :
        protected :
            virtual void on_editing_done();
            virtual void on_remove_widget();
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::CellEditable > wrap(GtkCellEditable * object, bool take_copy = false);
}
typedef struct _GtkCellRenderer GtkCellRenderer;
typedef struct _GtkCellRendererClass GtkCellRendererClass;
namespace Gtk {
    class CellRenderer_Class;
}
namespace Gtk {
    enum CellRendererState
    {
        CELL_RENDERER_SELECTED = 1 << 0, 
        CELL_RENDERER_PRELIT = 1 << 1, 
        CELL_RENDERER_INSENSITIVE = 1 << 2, 
        CELL_RENDERER_SORTED = 1 << 3, 
        CELL_RENDERER_FOCUSED = 1 << 4
    };
    inline CellRendererState operator |(CellRendererState lhs, CellRendererState rhs)
    {
        return static_cast<CellRendererState >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline CellRendererState operator &(CellRendererState lhs, CellRendererState rhs)
    {
        return static_cast<CellRendererState >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline CellRendererState operator ^(CellRendererState lhs, CellRendererState rhs)
    {
        return static_cast<CellRendererState >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline CellRendererState operator ~(CellRendererState flags)
    {
        return static_cast<CellRendererState >(~static_cast<unsigned >(flags));
    }
    inline CellRendererState & operator |=(CellRendererState & lhs, CellRendererState rhs)
    {
        return (lhs = static_cast<CellRendererState >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline CellRendererState & operator &=(CellRendererState & lhs, CellRendererState rhs)
    {
        return (lhs = static_cast<CellRendererState >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline CellRendererState & operator ^=(CellRendererState & lhs, CellRendererState rhs)
    {
        return (lhs = static_cast<CellRendererState >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gtk::CellRendererState > : public Glib::Value_Flags< Gtk::CellRendererState >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum CellRendererMode
    {
        CELL_RENDERER_MODE_INERT, 
        CELL_RENDERER_MODE_ACTIVATABLE, 
        CELL_RENDERER_MODE_EDITABLE
    };
}
namespace Glib {
    template<>
    class Value< Gtk::CellRendererMode > : public Glib::Value_Enum< Gtk::CellRendererMode >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class CellRenderer : public Gtk::Object
    {
        public :
            typedef CellRenderer CppObjectType;
            typedef CellRenderer_Class CppClassType;
            typedef GtkCellRenderer BaseObjectType;
            typedef GtkCellRendererClass BaseClassType;
            virtual ~CellRenderer();
        private :
            friend class CellRenderer_Class;
            static CppClassType cellrenderer_class_;
            CellRenderer(const CellRenderer &);
            CellRenderer & operator =(const CellRenderer &);
        protected :
            explicit CellRenderer(const Glib::ConstructParams & construct_params);
            explicit CellRenderer(GtkCellRenderer * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkCellRenderer * gobj()
            {
                return reinterpret_cast<GtkCellRenderer * >(gobject_);
            }
            const GtkCellRenderer * gobj() const
            {
                return reinterpret_cast<GtkCellRenderer * >(gobject_);
            }
        public :
        protected :
            virtual void on_editing_canceled();
        private :
        public :
            void get_size(Widget & widget, const Gdk::Rectangle & cell_area, int & x_offset, int & y_offset, int & width, int & height) const;
            void get_size(Widget & widget, int & x_offset, int & y_offset, int & width, int & height) const;
            void render(const Glib::RefPtr< Gdk::Window > & window, Widget & widget, const Gdk::Rectangle & background_area, const Gdk::Rectangle & cell_area, const Gdk::Rectangle & expose_area, CellRendererState flags);
            bool activate(GdkEvent * event, Widget & widget, const Glib::ustring & path, const Gdk::Rectangle & background_area, const Gdk::Rectangle & cell_area, CellRendererState flags);
            CellEditable * start_editing(GdkEvent * event, Widget & widget, const Glib::ustring & path, const Gdk::Rectangle & background_area, const Gdk::Rectangle & cell_area, CellRendererState flags = CellRendererState(0));
            void set_fixed_size(int width, int height);
            void get_fixed_size(int & width, int & height) const;
            void editing_canceled();
            void stop_editing(bool canceled = false);
            virtual Glib::PropertyProxy_Base _property_renderable();
            Glib::SignalProxy0< void > signal_editing_canceled();
            Glib::SignalProxy2< void, CellEditable *, const Glib::ustring & > signal_editing_started();
            Glib::PropertyProxy< CellRendererMode > property_mode();
            Glib::PropertyProxy_ReadOnly< CellRendererMode > property_mode() const;
            Glib::PropertyProxy< bool > property_visible();
            Glib::PropertyProxy_ReadOnly< bool > property_visible() const;
            Glib::PropertyProxy< bool > property_sensitive();
            Glib::PropertyProxy_ReadOnly< bool > property_sensitive() const;
            Glib::PropertyProxy< float > property_xalign();
            Glib::PropertyProxy_ReadOnly< float > property_xalign() const;
            Glib::PropertyProxy< float > property_yalign();
            Glib::PropertyProxy_ReadOnly< float > property_yalign() const;
            Glib::PropertyProxy< unsigned int > property_xpad();
            Glib::PropertyProxy_ReadOnly< unsigned int > property_xpad() const;
            Glib::PropertyProxy< unsigned int > property_ypad();
            Glib::PropertyProxy_ReadOnly< unsigned int > property_ypad() const;
            Glib::PropertyProxy< int > property_width();
            Glib::PropertyProxy_ReadOnly< int > property_width() const;
            Glib::PropertyProxy< int > property_height();
            Glib::PropertyProxy_ReadOnly< int > property_height() const;
            Glib::PropertyProxy< bool > property_is_expander();
            Glib::PropertyProxy_ReadOnly< bool > property_is_expander() const;
            Glib::PropertyProxy< bool > property_is_expanded();
            Glib::PropertyProxy_ReadOnly< bool > property_is_expanded() const;
            Glib::PropertyProxy_WriteOnly< Glib::ustring > property_cell_background();
            Glib::PropertyProxy< Gdk::Color > property_cell_background_gdk();
            Glib::PropertyProxy_ReadOnly< Gdk::Color > property_cell_background_gdk() const;
            Glib::PropertyProxy< bool > property_cell_background_set();
            Glib::PropertyProxy_ReadOnly< bool > property_cell_background_set() const;
        protected :
            CellRenderer();
            virtual void get_size_vfunc(Widget & widget, const Gdk::Rectangle * cell_area, int * x_offset, int * y_offset, int * width, int * height) const;
            virtual void render_vfunc(const Glib::RefPtr< Gdk::Drawable > & window, Widget & widget, const Gdk::Rectangle & background_area, const Gdk::Rectangle & cell_area, const Gdk::Rectangle & expose_area, CellRendererState flags);
            virtual bool activate_vfunc(GdkEvent * event, Widget & widget, const Glib::ustring & path, const Gdk::Rectangle & background_area, const Gdk::Rectangle & cell_area, CellRendererState flags);
            virtual CellEditable * start_editing_vfunc(GdkEvent * event, Widget & widget, const Glib::ustring & path, const Gdk::Rectangle & background_area, const Gdk::Rectangle & cell_area, CellRendererState flags);
    };
}
namespace Glib {
    Gtk::CellRenderer * wrap(GtkCellRenderer * object, bool take_copy = false);
}
typedef struct _GtkCellRendererText GtkCellRendererText;
typedef struct _GtkCellRendererTextClass GtkCellRendererTextClass;
namespace Gtk {
    class CellRendererText_Class;
}
namespace Gtk {
    class CellRendererText : public CellRenderer
    {
        public :
            typedef CellRendererText CppObjectType;
            typedef CellRendererText_Class CppClassType;
            typedef GtkCellRendererText BaseObjectType;
            typedef GtkCellRendererTextClass BaseClassType;
            virtual ~CellRendererText();
        private :
            friend class CellRendererText_Class;
            static CppClassType cellrenderertext_class_;
            CellRendererText(const CellRendererText &);
            CellRendererText & operator =(const CellRendererText &);
        protected :
            explicit CellRendererText(const Glib::ConstructParams & construct_params);
            explicit CellRendererText(GtkCellRendererText * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkCellRendererText * gobj()
            {
                return reinterpret_cast<GtkCellRendererText * >(gobject_);
            }
            const GtkCellRendererText * gobj() const
            {
                return reinterpret_cast<GtkCellRendererText * >(gobject_);
            }
        public :
        protected :
            virtual void on_edited(const Glib::ustring & path, const Glib::ustring & new_text);
        private :
        public :
            CellRendererText();
            void set_fixed_height_from_font(int number_of_rows);
            Glib::SignalProxy2< void, const Glib::ustring &, const Glib::ustring & > signal_edited();
            Glib::PropertyProxy< Glib::ustring > property_text();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_text() const;
            Glib::PropertyProxy_WriteOnly< Glib::ustring > property_markup();
            Glib::PropertyProxy< Pango::AttrList > property_attributes();
            Glib::PropertyProxy_ReadOnly< Pango::AttrList > property_attributes() const;
            Glib::PropertyProxy_WriteOnly< Glib::ustring > property_background();
            Glib::PropertyProxy_WriteOnly< Glib::ustring > property_foreground();
            Glib::PropertyProxy< Gdk::Color > property_background_gdk();
            Glib::PropertyProxy_ReadOnly< Gdk::Color > property_background_gdk() const;
            Glib::PropertyProxy< Gdk::Color > property_foreground_gdk();
            Glib::PropertyProxy_ReadOnly< Gdk::Color > property_foreground_gdk() const;
            Glib::PropertyProxy< Glib::ustring > property_font();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_font() const;
            Glib::PropertyProxy< Pango::FontDescription > property_font_desc();
            Glib::PropertyProxy_ReadOnly< Pango::FontDescription > property_font_desc() const;
            Glib::PropertyProxy< Glib::ustring > property_family();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_family() const;
            Glib::PropertyProxy< Pango::Style > property_style();
            Glib::PropertyProxy_ReadOnly< Pango::Style > property_style() const;
            Glib::PropertyProxy< Pango::Variant > property_variant();
            Glib::PropertyProxy_ReadOnly< Pango::Variant > property_variant() const;
            Glib::PropertyProxy< int > property_weight();
            Glib::PropertyProxy_ReadOnly< int > property_weight() const;
            Glib::PropertyProxy< Pango::Stretch > property_stretch();
            Glib::PropertyProxy_ReadOnly< Pango::Stretch > property_stretch() const;
            Glib::PropertyProxy< int > property_size();
            Glib::PropertyProxy_ReadOnly< int > property_size() const;
            Glib::PropertyProxy< double > property_size_points();
            Glib::PropertyProxy_ReadOnly< double > property_size_points() const;
            Glib::PropertyProxy< double > property_scale();
            Glib::PropertyProxy_ReadOnly< double > property_scale() const;
            Glib::PropertyProxy< bool > property_editable();
            Glib::PropertyProxy_ReadOnly< bool > property_editable() const;
            Glib::PropertyProxy< bool > property_strikethrough();
            Glib::PropertyProxy_ReadOnly< bool > property_strikethrough() const;
            Glib::PropertyProxy< Pango::Underline > property_underline();
            Glib::PropertyProxy_ReadOnly< Pango::Underline > property_underline() const;
            Glib::PropertyProxy< int > property_rise();
            Glib::PropertyProxy_ReadOnly< int > property_rise() const;
            Glib::PropertyProxy< Glib::ustring > property_language();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_language() const;
            Glib::PropertyProxy< Pango::EllipsizeMode > property_ellipsize();
            Glib::PropertyProxy_ReadOnly< Pango::EllipsizeMode > property_ellipsize() const;
            Glib::PropertyProxy< int > property_width_chars();
            Glib::PropertyProxy_ReadOnly< int > property_width_chars() const;
            Glib::PropertyProxy< Pango::WrapMode > property_wrap_mode();
            Glib::PropertyProxy_ReadOnly< Pango::WrapMode > property_wrap_mode() const;
            Glib::PropertyProxy< int > property_wrap_width();
            Glib::PropertyProxy_ReadOnly< int > property_wrap_width() const;
            Glib::PropertyProxy< Pango::Alignment > property_alignment();
            Glib::PropertyProxy_ReadOnly< Pango::Alignment > property_alignment() const;
            Glib::PropertyProxy< bool > property_background_set();
            Glib::PropertyProxy_ReadOnly< bool > property_background_set() const;
            Glib::PropertyProxy< bool > property_foreground_set();
            Glib::PropertyProxy_ReadOnly< bool > property_foreground_set() const;
            Glib::PropertyProxy< bool > property_family_set();
            Glib::PropertyProxy_ReadOnly< bool > property_family_set() const;
            Glib::PropertyProxy< bool > property_style_set();
            Glib::PropertyProxy_ReadOnly< bool > property_style_set() const;
            Glib::PropertyProxy< bool > property_variant_set();
            Glib::PropertyProxy_ReadOnly< bool > property_variant_set() const;
            Glib::PropertyProxy< bool > property_weight_set();
            Glib::PropertyProxy_ReadOnly< bool > property_weight_set() const;
            Glib::PropertyProxy< bool > property_stretch_set();
            Glib::PropertyProxy_ReadOnly< bool > property_stretch_set() const;
            Glib::PropertyProxy< bool > property_size_set();
            Glib::PropertyProxy_ReadOnly< bool > property_size_set() const;
            Glib::PropertyProxy< bool > property_scale_set();
            Glib::PropertyProxy_ReadOnly< bool > property_scale_set() const;
            Glib::PropertyProxy< bool > property_editable_set();
            Glib::PropertyProxy_ReadOnly< bool > property_editable_set() const;
            Glib::PropertyProxy< bool > property_strikethrough_set();
            Glib::PropertyProxy_ReadOnly< bool > property_strikethrough_set() const;
            Glib::PropertyProxy< bool > property_underline_set();
            Glib::PropertyProxy_ReadOnly< bool > property_underline_set() const;
            Glib::PropertyProxy< bool > property_rise_set();
            Glib::PropertyProxy_ReadOnly< bool > property_rise_set() const;
            Glib::PropertyProxy< bool > property_language_set();
            Glib::PropertyProxy_ReadOnly< bool > property_language_set() const;
            Glib::PropertyProxy< bool > property_ellipsize_set();
            Glib::PropertyProxy_ReadOnly< bool > property_ellipsize_set() const;
            Glib::PropertyProxy< bool > property_single_paragraph_mode();
            Glib::PropertyProxy_ReadOnly< bool > property_single_paragraph_mode() const;
            virtual Glib::PropertyProxy_Base _property_renderable();
        protected :
            void edited(const Glib::ustring & path, const Glib::ustring & new_text);
    };
}
namespace Glib {
    Gtk::CellRendererText * wrap(GtkCellRendererText * object, bool take_copy = false);
}
typedef struct _GtkCellRendererPixbuf GtkCellRendererPixbuf;
typedef struct _GtkCellRendererPixbufClass GtkCellRendererPixbufClass;
namespace Gtk {
    class CellRendererPixbuf_Class;
}
namespace Gtk {
    class CellRendererPixbuf : public CellRenderer
    {
        public :
            typedef CellRendererPixbuf CppObjectType;
            typedef CellRendererPixbuf_Class CppClassType;
            typedef GtkCellRendererPixbuf BaseObjectType;
            typedef GtkCellRendererPixbufClass BaseClassType;
            virtual ~CellRendererPixbuf();
        private :
            friend class CellRendererPixbuf_Class;
            static CppClassType cellrendererpixbuf_class_;
            CellRendererPixbuf(const CellRendererPixbuf &);
            CellRendererPixbuf & operator =(const CellRendererPixbuf &);
        protected :
            explicit CellRendererPixbuf(const Glib::ConstructParams & construct_params);
            explicit CellRendererPixbuf(GtkCellRendererPixbuf * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkCellRendererPixbuf * gobj()
            {
                return reinterpret_cast<GtkCellRendererPixbuf * >(gobject_);
            }
            const GtkCellRendererPixbuf * gobj() const
            {
                return reinterpret_cast<GtkCellRendererPixbuf * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            CellRendererPixbuf();
            Glib::PropertyProxy< Glib::RefPtr< Gdk::Pixbuf > > property_pixbuf();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Gdk::Pixbuf > > property_pixbuf() const;
            Glib::PropertyProxy< Glib::RefPtr< Gdk::Pixbuf > > property_pixbuf_expander_open();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Gdk::Pixbuf > > property_pixbuf_expander_open() const;
            Glib::PropertyProxy< Glib::RefPtr< Gdk::Pixbuf > > property_pixbuf_expander_closed();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Gdk::Pixbuf > > property_pixbuf_expander_closed() const;
            Glib::PropertyProxy< Glib::ustring > property_stock_id();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_stock_id() const;
            Glib::PropertyProxy< guint > property_stock_size();
            Glib::PropertyProxy_ReadOnly< guint > property_stock_size() const;
            Glib::PropertyProxy< Glib::ustring > property_stock_detail();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_stock_detail() const;
            virtual Glib::PropertyProxy_Base _property_renderable();
    };
}
namespace Glib {
    Gtk::CellRendererPixbuf * wrap(GtkCellRendererPixbuf * object, bool take_copy = false);
}
typedef struct _GtkCellRendererToggle GtkCellRendererToggle;
typedef struct _GtkCellRendererToggleClass GtkCellRendererToggleClass;
namespace Gtk {
    class CellRendererToggle_Class;
}
namespace Gtk {
    class CellRendererToggle : public CellRenderer
    {
        public :
            typedef CellRendererToggle CppObjectType;
            typedef CellRendererToggle_Class CppClassType;
            typedef GtkCellRendererToggle BaseObjectType;
            typedef GtkCellRendererToggleClass BaseClassType;
            virtual ~CellRendererToggle();
        private :
            friend class CellRendererToggle_Class;
            static CppClassType cellrenderertoggle_class_;
            CellRendererToggle(const CellRendererToggle &);
            CellRendererToggle & operator =(const CellRendererToggle &);
        protected :
            explicit CellRendererToggle(const Glib::ConstructParams & construct_params);
            explicit CellRendererToggle(GtkCellRendererToggle * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkCellRendererToggle * gobj()
            {
                return reinterpret_cast<GtkCellRendererToggle * >(gobject_);
            }
            const GtkCellRendererToggle * gobj() const
            {
                return reinterpret_cast<GtkCellRendererToggle * >(gobject_);
            }
        public :
        protected :
            virtual void on_toggled(const Glib::ustring & path);
        private :
        public :
            CellRendererToggle();
            bool get_radio() const;
            void set_radio(bool radio = true);
            bool get_active() const;
            void set_active(bool setting = true);
            Glib::SignalProxy1< void, const Glib::ustring & > signal_toggled();
            Glib::PropertyProxy< bool > property_activatable();
            Glib::PropertyProxy_ReadOnly< bool > property_activatable() const;
            Glib::PropertyProxy< bool > property_active();
            Glib::PropertyProxy_ReadOnly< bool > property_active() const;
            Glib::PropertyProxy< bool > property_radio();
            Glib::PropertyProxy_ReadOnly< bool > property_radio() const;
            Glib::PropertyProxy< int > property_indicator_size();
            Glib::PropertyProxy_ReadOnly< int > property_indicator_size() const;
            virtual Glib::PropertyProxy_Base _property_renderable();
    };
}
namespace Glib {
    Gtk::CellRendererToggle * wrap(GtkCellRendererToggle * object, bool take_copy = false);
}
typedef struct _GtkCellRendererAccel GtkCellRendererAccel;
typedef struct _GtkCellRendererAccelClass GtkCellRendererAccelClass;
namespace Gtk {
    class CellRendererAccel_Class;
}
namespace Gtk {
    class CellRendererAccel : public CellRendererText
    {
        public :
            typedef CellRendererAccel CppObjectType;
            typedef CellRendererAccel_Class CppClassType;
            typedef GtkCellRendererAccel BaseObjectType;
            typedef GtkCellRendererAccelClass BaseClassType;
            virtual ~CellRendererAccel();
        private :
            friend class CellRendererAccel_Class;
            static CppClassType cellrendereraccel_class_;
            CellRendererAccel(const CellRendererAccel &);
            CellRendererAccel & operator =(const CellRendererAccel &);
        protected :
            explicit CellRendererAccel(const Glib::ConstructParams & construct_params);
            explicit CellRendererAccel(GtkCellRendererAccel * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkCellRendererAccel * gobj()
            {
                return reinterpret_cast<GtkCellRendererAccel * >(gobject_);
            }
            const GtkCellRendererAccel * gobj() const
            {
                return reinterpret_cast<GtkCellRendererAccel * >(gobject_);
            }
        public :
        protected :
            virtual void on_accel_edited(const Glib::ustring & path_string, guint accel_key, Gdk::ModifierType accel_mods, guint hardware_keycode);
            virtual void on_accel_cleared(const Glib::ustring & path_string);
        private :
        public :
            CellRendererAccel();
            Glib::SignalProxy4< void, const Glib::ustring &, guint, Gdk::ModifierType, guint > signal_accel_edited();
            Glib::SignalProxy1< void, const Glib::ustring & > signal_accel_cleared();
            Glib::PropertyProxy< guint > property_accel_key();
            Glib::PropertyProxy_ReadOnly< guint > property_accel_key() const;
            Glib::PropertyProxy< Gdk::ModifierType > property_accel_mods();
            Glib::PropertyProxy_ReadOnly< Gdk::ModifierType > property_accel_mods() const;
            Glib::PropertyProxy< guint > property_keycode();
            Glib::PropertyProxy_ReadOnly< guint > property_keycode() const;
            virtual Glib::PropertyProxy_Base _property_renderable();
    };
}
namespace Glib {
    Gtk::CellRendererAccel * wrap(GtkCellRendererAccel * object, bool take_copy = false);
}
namespace Gtk {
    namespace CellRenderer_Generation {
        template<class T_ModelColumnType >
        CellRenderer * generate_cellrenderer(bool editable = false)
        {
            CellRendererText * pCellRenderer = new CellRendererText ();
            pCellRenderer->property_editable() = editable;
            return pCellRenderer;
        }
        template<>
        CellRenderer * generate_cellrenderer< bool >(bool editable);
        template<>
        CellRenderer * generate_cellrenderer< Glib::RefPtr< Gdk::Pixbuf > >(bool editable);
        template<>
        CellRenderer * generate_cellrenderer< AccelKey >(bool editable);
    }
}
extern "C"
{
    typedef struct _GtkTreeIter GtkTreeIter;
    typedef struct _GtkTreePath GtkTreePath;
    typedef struct _GtkTreeRowReference GtkTreeRowReference;
    typedef struct _GtkTreeModel GtkTreeModel;
    typedef struct _GtkTreeModelIface GtkTreeModelIface;
    typedef gboolean (* GtkTreeModelForeachFunc)(GtkTreeModel * model, GtkTreePath * path, GtkTreeIter * iter, gpointer data);
    typedef enum 
    {
        GTK_TREE_MODEL_ITERS_PERSIST = 1 << 0, 
        GTK_TREE_MODEL_LIST_ONLY = 1 << 1
    } GtkTreeModelFlags;
    struct _GtkTreeIter
    {
            gint stamp;
            gpointer user_data;
            gpointer user_data2;
            gpointer user_data3;
    };
    struct _GtkTreeModelIface
    {
            GTypeInterface g_iface;
            void (* row_changed)(GtkTreeModel * tree_model, GtkTreePath * path, GtkTreeIter * iter);
            void (* row_inserted)(GtkTreeModel * tree_model, GtkTreePath * path, GtkTreeIter * iter);
            void (* row_has_child_toggled)(GtkTreeModel * tree_model, GtkTreePath * path, GtkTreeIter * iter);
            void (* row_deleted)(GtkTreeModel * tree_model, GtkTreePath * path);
            void (* rows_reordered)(GtkTreeModel * tree_model, GtkTreePath * path, GtkTreeIter * iter, gint * new_order);
            GtkTreeModelFlags (* get_flags)(GtkTreeModel * tree_model);
            gint (* get_n_columns)(GtkTreeModel * tree_model);
            GType (* get_column_type)(GtkTreeModel * tree_model, gint index_);
            gboolean (* get_iter)(GtkTreeModel * tree_model, GtkTreeIter * iter, GtkTreePath * path);
            GtkTreePath * (* get_path)(GtkTreeModel * tree_model, GtkTreeIter * iter);
            void (* get_value)(GtkTreeModel * tree_model, GtkTreeIter * iter, gint column, GValue * value);
            gboolean (* iter_next)(GtkTreeModel * tree_model, GtkTreeIter * iter);
            gboolean (* iter_children)(GtkTreeModel * tree_model, GtkTreeIter * iter, GtkTreeIter * parent);
            gboolean (* iter_has_child)(GtkTreeModel * tree_model, GtkTreeIter * iter);
            gint (* iter_n_children)(GtkTreeModel * tree_model, GtkTreeIter * iter);
            gboolean (* iter_nth_child)(GtkTreeModel * tree_model, GtkTreeIter * iter, GtkTreeIter * parent, gint n);
            gboolean (* iter_parent)(GtkTreeModel * tree_model, GtkTreeIter * iter, GtkTreeIter * child);
            void (* ref_node)(GtkTreeModel * tree_model, GtkTreeIter * iter);
            void (* unref_node)(GtkTreeModel * tree_model, GtkTreeIter * iter);
    };
    GtkTreePath * gtk_tree_path_new(void);
    GtkTreePath * gtk_tree_path_new_from_string(const gchar * path);
    GtkTreePath * gtk_tree_path_new_from_indices(gint first_index, ...);
    gchar * gtk_tree_path_to_string(GtkTreePath * path);
    GtkTreePath * gtk_tree_path_new_first(void);
    void gtk_tree_path_append_index(GtkTreePath * path, gint index_);
    void gtk_tree_path_prepend_index(GtkTreePath * path, gint index_);
    gint gtk_tree_path_get_depth(GtkTreePath * path);
    gint * gtk_tree_path_get_indices(GtkTreePath * path);
    void gtk_tree_path_free(GtkTreePath * path);
    GtkTreePath * gtk_tree_path_copy(const GtkTreePath * path);
    GType gtk_tree_path_get_type(void) __attribute__((__const__));
    gint gtk_tree_path_compare(const GtkTreePath * a, const GtkTreePath * b);
    void gtk_tree_path_next(GtkTreePath * path);
    gboolean gtk_tree_path_prev(GtkTreePath * path);
    gboolean gtk_tree_path_up(GtkTreePath * path);
    void gtk_tree_path_down(GtkTreePath * path);
    gboolean gtk_tree_path_is_ancestor(GtkTreePath * path, GtkTreePath * descendant);
    gboolean gtk_tree_path_is_descendant(GtkTreePath * path, GtkTreePath * ancestor);
    GType gtk_tree_row_reference_get_type(void) __attribute__((__const__));
    GtkTreeRowReference * gtk_tree_row_reference_new(GtkTreeModel * model, GtkTreePath * path);
    GtkTreeRowReference * gtk_tree_row_reference_new_proxy(GObject * proxy, GtkTreeModel * model, GtkTreePath * path);
    GtkTreePath * gtk_tree_row_reference_get_path(GtkTreeRowReference * reference);
    GtkTreeModel * gtk_tree_row_reference_get_model(GtkTreeRowReference * reference);
    gboolean gtk_tree_row_reference_valid(GtkTreeRowReference * reference);
    GtkTreeRowReference * gtk_tree_row_reference_copy(GtkTreeRowReference * reference);
    void gtk_tree_row_reference_free(GtkTreeRowReference * reference);
    void gtk_tree_row_reference_inserted(GObject * proxy, GtkTreePath * path);
    void gtk_tree_row_reference_deleted(GObject * proxy, GtkTreePath * path);
    void gtk_tree_row_reference_reordered(GObject * proxy, GtkTreePath * path, GtkTreeIter * iter, gint * new_order);
    GtkTreeIter * gtk_tree_iter_copy(GtkTreeIter * iter);
    void gtk_tree_iter_free(GtkTreeIter * iter);
    GType gtk_tree_iter_get_type(void) __attribute__((__const__));
    GType gtk_tree_model_get_type(void) __attribute__((__const__));
    GtkTreeModelFlags gtk_tree_model_get_flags(GtkTreeModel * tree_model);
    gint gtk_tree_model_get_n_columns(GtkTreeModel * tree_model);
    GType gtk_tree_model_get_column_type(GtkTreeModel * tree_model, gint index_);
    gboolean gtk_tree_model_get_iter(GtkTreeModel * tree_model, GtkTreeIter * iter, GtkTreePath * path);
    gboolean gtk_tree_model_get_iter_from_string(GtkTreeModel * tree_model, GtkTreeIter * iter, const gchar * path_string);
    gchar * gtk_tree_model_get_string_from_iter(GtkTreeModel * tree_model, GtkTreeIter * iter);
    gboolean gtk_tree_model_get_iter_first(GtkTreeModel * tree_model, GtkTreeIter * iter);
    GtkTreePath * gtk_tree_model_get_path(GtkTreeModel * tree_model, GtkTreeIter * iter);
    void gtk_tree_model_get_value(GtkTreeModel * tree_model, GtkTreeIter * iter, gint column, GValue * value);
    gboolean gtk_tree_model_iter_next(GtkTreeModel * tree_model, GtkTreeIter * iter);
    gboolean gtk_tree_model_iter_children(GtkTreeModel * tree_model, GtkTreeIter * iter, GtkTreeIter * parent);
    gboolean gtk_tree_model_iter_has_child(GtkTreeModel * tree_model, GtkTreeIter * iter);
    gint gtk_tree_model_iter_n_children(GtkTreeModel * tree_model, GtkTreeIter * iter);
    gboolean gtk_tree_model_iter_nth_child(GtkTreeModel * tree_model, GtkTreeIter * iter, GtkTreeIter * parent, gint n);
    gboolean gtk_tree_model_iter_parent(GtkTreeModel * tree_model, GtkTreeIter * iter, GtkTreeIter * child);
    void gtk_tree_model_ref_node(GtkTreeModel * tree_model, GtkTreeIter * iter);
    void gtk_tree_model_unref_node(GtkTreeModel * tree_model, GtkTreeIter * iter);
    void gtk_tree_model_get(GtkTreeModel * tree_model, GtkTreeIter * iter, ...);
    void gtk_tree_model_get_valist(GtkTreeModel * tree_model, GtkTreeIter * iter, va_list var_args);
    void gtk_tree_model_foreach(GtkTreeModel * model, GtkTreeModelForeachFunc func, gpointer user_data);
    void gtk_tree_model_row_changed(GtkTreeModel * tree_model, GtkTreePath * path, GtkTreeIter * iter);
    void gtk_tree_model_row_inserted(GtkTreeModel * tree_model, GtkTreePath * path, GtkTreeIter * iter);
    void gtk_tree_model_row_has_child_toggled(GtkTreeModel * tree_model, GtkTreePath * path, GtkTreeIter * iter);
    void gtk_tree_model_row_deleted(GtkTreeModel * tree_model, GtkTreePath * path);
    void gtk_tree_model_rows_reordered(GtkTreeModel * tree_model, GtkTreePath * path, GtkTreeIter * iter, gint * new_order);
}
namespace Gtk {
    class TreeModelColumnBase;
    class TreeModelColumnRecord
    {
        public :
            TreeModelColumnRecord();
            virtual ~TreeModelColumnRecord();
            void add(TreeModelColumnBase & column);
            unsigned int size() const;
            const GType * types() const;
        private :
            std::vector< GType > column_types_;
            TreeModelColumnRecord(const TreeModelColumnRecord &);
            TreeModelColumnRecord & operator =(const TreeModelColumnRecord &);
    };
    class TreeModelColumnBase
    {
        public :
            GType type() const
            {
                return type_;
            }
            int index() const
            {
                return index_;
            }
        protected :
            explicit TreeModelColumnBase(GType type);
        private :
            GType type_;
            int index_;
            friend class Gtk::TreeModelColumnRecord;
    };
    inline bool operator ==(const TreeModelColumnBase & lhs, const TreeModelColumnBase & rhs)
    {
        return (lhs.index() == rhs.index());
    }
    inline bool operator !=(const TreeModelColumnBase & lhs, const TreeModelColumnBase & rhs)
    {
        return (lhs.index() != rhs.index());
    }
    template<class T >
    class TreeModelColumn : public TreeModelColumnBase
    {
        public :
            typedef T ElementType;
            typedef Glib::Value< T > ValueType;
            TreeModelColumn()
                : TreeModelColumnBase(ValueType::value_type()) 
            {
            }
    };
}
namespace Gtk {
    class TreeModel;
    class TreeRow;
    class TreeNodeChildren;
    class TreeIterBase
    {
        public :
            typedef TreeIterBase CppObjectType;
            typedef GtkTreeIter BaseObjectType;
            static GType get_type() __attribute__((__const__));
            TreeIterBase();
            explicit TreeIterBase(const GtkTreeIter * gobject);
            GtkTreeIter * gobj()
            {
                return &gobject_;
            }
            const GtkTreeIter * gobj() const
            {
                return &gobject_;
            }
        protected :
            GtkTreeIter gobject_;
        private :
    };
    class TreeIter : public TreeIterBase
    {
        public :
            typedef std::bidirectional_iterator_tag iterator_category;
            typedef Gtk::TreeRow value_type;
            typedef int difference_type;
            typedef const Gtk::TreeRow & reference;
            typedef const Gtk::TreeRow * pointer;
            TreeIter();
            TreeIter & operator ++();
            const TreeIter operator ++(int);
            TreeIter & operator --();
            const TreeIter operator --(int);
            inline reference operator *() const;
            inline pointer operator ->() const;
            bool equal(const TreeIter & other) const;
            operator bool() const;
            int get_stamp() const;
            void set_stamp(int stamp);
            explicit TreeIter(TreeModel * model);
            TreeIter(GtkTreeModel * model, const GtkTreeIter * iter);
            void set_model_refptr(const Glib::RefPtr< TreeModel > & model);
            void set_model_gobject(GtkTreeModel * model);
            GtkTreeModel * get_model_gobject() const;
            void setup_end_iterator(const TreeIter & last_valid);
            const GtkTreeIter * get_gobject_if_not_end() const
            {
                return (!is_end_) ? &gobject_ : 0;
            }
            const GtkTreeIter * get_parent_gobject_if_end() const
            {
                return (is_end_ && gobject_.stamp) ? &gobject_ : 0;
            }
        protected :
            TreeModel * model_;
            bool is_end_;
            friend class Gtk::TreeRow;
            friend class Gtk::TreeNodeChildren;
            friend class Gtk::TreeModel;
    };
    inline bool operator ==(const TreeIter & lhs, const TreeIter & rhs)
    {
        return lhs.equal(rhs);
    }
    inline bool operator !=(const TreeIter & lhs, const TreeIter & rhs)
    {
        return !lhs.equal(rhs);
    }
    template<class ColumnType >
    class TreeValueProxy
    {
        public :
            inline TreeValueProxy(const TreeRow & row, const TreeModelColumn< ColumnType > & column);
            inline TreeValueProxy< ColumnType > & operator =(const ColumnType & data);
            inline operator ColumnType() const;
        private :
            const TreeRow & row_;
            const TreeModelColumn< ColumnType > & column_;
            TreeValueProxy< ColumnType > & operator =(const TreeValueProxy< ColumnType > &);
    };
    class TreeRow : public TreeIter
    {
        public :
            template<class ColumnType >
            inline TreeValueProxy< ColumnType > operator [](const TreeModelColumn< ColumnType > & column) const;
            template<class ColumnType >
            void set_value(const TreeModelColumn< ColumnType > & column, const ColumnType & data) const;
            template<class ColumnType >
            void set_value(int column, const ColumnType & data) const;
            template<class ColumnType >
            ColumnType get_value(const TreeModelColumn< ColumnType > & column) const;
            template<class ColumnType >
            void get_value(int column, ColumnType & data) const;
            const TreeNodeChildren & children() const;
            TreeIter parent() const;
            operator bool() const;
            GtkTreeIter * gobj()
            {
                return TreeIter::gobj();
            }
            const GtkTreeIter * gobj() const
            {
                return TreeIter::gobj();
            }
        private :
            void set_value_impl(int column, const Glib::ValueBase & value) const;
            void get_value_impl(int column, Glib::ValueBase & value) const;
    };
    class TreeNodeChildren : public TreeIter
    {
        public :
            typedef Gtk::TreeRow value_type;
            typedef unsigned int size_type;
            typedef int difference_type;
            typedef Gtk::TreeIter iterator;
            typedef std::reverse_iterator< iterator > reverse_iterator;
            typedef Gtk::TreeIter const_iterator;
            typedef std::reverse_iterator< const_iterator > const_reverse_iterator;
            iterator begin();
            const_iterator begin() const;
            iterator end();
            const_iterator end() const;
            reverse_iterator rbegin()
            {
                return reverse_iterator(end());
            }
            reverse_iterator rend()
            {
                return reverse_iterator(begin());
            }
            const_reverse_iterator rbegin() const
            {
                return const_reverse_iterator(end());
            }
            const_reverse_iterator rend() const
            {
                return const_reverse_iterator(begin());
            }
            value_type operator [](size_type index) const;
            size_type size() const;
            bool empty() const;
            operator bool() const
            {
                return !empty();
            }
            explicit TreeNodeChildren(TreeModel * model)
                : TreeIter(model) 
            {
            }
            const GtkTreeIter * get_parent_gobject() const
            {
                return (gobject_.stamp != 0) ? &gobject_ : 0;
            }
    };
    inline TreeIter::reference TreeIter::operator *() const
    {
        return static_cast<const TreeRow & >(*this);
    }
    inline TreeIter::pointer TreeIter::operator ->() const
    {
        return static_cast<const TreeRow * >(this);
    }
    template<class ColumnType >
    inline TreeValueProxy< ColumnType >::TreeValueProxy(const TreeRow & row, const TreeModelColumn< ColumnType > & column)
        : row_(row), column_(column) 
    {
    }
    template<class ColumnType >
    inline TreeValueProxy< ColumnType > & TreeValueProxy< ColumnType >::operator =(const ColumnType & data)
    {
        row_.set_value(column_, data);
        return *this;
    }
    template<class ColumnType >
    inline TreeValueProxy< ColumnType >::operator ColumnType() const
    {
        return row_.get_value(column_);
    }
    template<class ColumnType >
    inline TreeValueProxy< ColumnType > TreeRow::operator [](const TreeModelColumn< ColumnType > & column) const
    {
        return TreeValueProxy< ColumnType >(*this, column);
    }
    template<class ColumnType >
    void TreeRow::set_value(const TreeModelColumn< ColumnType > & column, const ColumnType & data) const
    {
        typedef typename Gtk::TreeModelColumn< ColumnType >::ValueType ValueType;
        ValueType value;
        value.init(column.type());
        value.set(data);
        this->set_value_impl(column.index(), value);
    }
    template<class ColumnType >
    void TreeRow::set_value(int column, const ColumnType & data) const
    {
        typedef typename Gtk::template TreeModelColumn< ColumnType > type_cppcolumn;
        typedef typename type_cppcolumn::ValueType ValueType;
        ValueType value;
        value.init(ValueType::value_type());
        value.set(data);
        this->set_value_impl(column, value);
    }
    template<class ColumnType >
    ColumnType TreeRow::get_value(const TreeModelColumn< ColumnType > & column) const
    {
        typedef typename Gtk::TreeModelColumn< ColumnType >::ValueType ValueType;
        ValueType value;
        this->get_value_impl(column.index(), value);
        return value.get();
    }
    template<class ColumnType >
    void TreeRow::get_value(int column, ColumnType & data) const
    {
        typedef typename Gtk::TreeModelColumn< ColumnType >::ValueType ValueType;
        ValueType value;
        this->get_value_impl(column, value);
        data = value.get();
    }
}
namespace Glib {
    template<>
    class Value< Gtk::TreeIterBase > : public Glib::Value_Boxed< Gtk::TreeIterBase >
    {
    };
}
typedef struct _GtkTreeModel GtkTreeModel;
typedef struct _GtkTreeModelClass GtkTreeModelClass;
namespace Gtk {
    class TreeModel_Class;
}
namespace Gtk {
    class TreeModelSort;
    class TreePath;
    class TreeRowReference;
    enum TreeModelFlags
    {
        TREE_MODEL_ITERS_PERSIST = 1 << 0, 
        TREE_MODEL_LIST_ONLY = 1 << 1
    };
    inline TreeModelFlags operator |(TreeModelFlags lhs, TreeModelFlags rhs)
    {
        return static_cast<TreeModelFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline TreeModelFlags operator &(TreeModelFlags lhs, TreeModelFlags rhs)
    {
        return static_cast<TreeModelFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline TreeModelFlags operator ^(TreeModelFlags lhs, TreeModelFlags rhs)
    {
        return static_cast<TreeModelFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline TreeModelFlags operator ~(TreeModelFlags flags)
    {
        return static_cast<TreeModelFlags >(~static_cast<unsigned >(flags));
    }
    inline TreeModelFlags & operator |=(TreeModelFlags & lhs, TreeModelFlags rhs)
    {
        return (lhs = static_cast<TreeModelFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline TreeModelFlags & operator &=(TreeModelFlags & lhs, TreeModelFlags rhs)
    {
        return (lhs = static_cast<TreeModelFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline TreeModelFlags & operator ^=(TreeModelFlags & lhs, TreeModelFlags rhs)
    {
        return (lhs = static_cast<TreeModelFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gtk::TreeModelFlags > : public Glib::Value_Flags< Gtk::TreeModelFlags >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class TreeModel : public Glib::Interface
    {
        public :
            typedef TreeModel CppObjectType;
            typedef TreeModel_Class CppClassType;
            typedef GtkTreeModel BaseObjectType;
            typedef GtkTreeModelIface BaseClassType;
        private :
            friend class TreeModel_Class;
            static CppClassType treemodel_class_;
            TreeModel(const TreeModel &);
            TreeModel & operator =(const TreeModel &);
        protected :
            TreeModel();
            explicit TreeModel(const Glib::Interface_Class & interface_class);
        public :
            explicit TreeModel(GtkTreeModel * castitem);
        protected :
        public :
            virtual ~TreeModel();
            static void add_interface(GType gtype_implementer);
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTreeModel * gobj()
            {
                return reinterpret_cast<GtkTreeModel * >(gobject_);
            }
            const GtkTreeModel * gobj() const
            {
                return reinterpret_cast<GtkTreeModel * >(gobject_);
            }
        private :
        public :
            typedef TreeModelColumnRecord ColumnRecord;
            typedef TreeNodeChildren Children;
            typedef Children::iterator iterator;
            typedef Children::reverse_iterator reverse_iterator;
            typedef Children::const_iterator const_iterator;
            typedef Children::const_reverse_iterator const_reverse_iterator;
            typedef TreeRow Row;
            typedef TreePath Path;
            typedef TreeRowReference RowReference;
            iterator get_iter(const Path & path);
            iterator get_iter(const Glib::ustring & path_string);
            Children children();
            Children children() const;
            typedef sigc::slot< bool, const TreeModel::iterator & > SlotForeachIter;
            void foreach_iter(const SlotForeachIter & slot);
            typedef sigc::slot< bool, const TreeModel::Path & > SlotForeachPath;
            void foreach_path(const SlotForeachPath & slot);
            typedef sigc::slot< bool, const TreeModel::Path &, const TreeModel::iterator & > SlotForeachPathAndIter;
            void foreach(const SlotForeachPathAndIter & slot);
            TreeModelFlags get_flags() const;
            int get_n_columns() const;
            GType get_column_type(int index) const;
            TreeModel::Path get_path(const iterator & iter) const;
            void row_changed(const Path & path, const iterator & iter);
            void row_inserted(const Path & path, const iterator & iter);
            void row_has_child_toggled(const Path & path, const iterator & iter);
            void row_deleted(const Path & path);
            void rows_reordered(const Path & path, const iterator & iter, const Glib::ArrayHandle< int > & new_order);
            void rows_reordered(const Path & path, const Glib::ArrayHandle< int > & new_order);
            void rows_reordered(const Path & path, const iterator & iter, int * new_order);
            Glib::ustring get_string(const iterator & iter) const;
            Glib::SignalProxy2< void, const TreeModel::Path &, const TreeModel::iterator & > signal_row_changed();
            Glib::SignalProxy2< void, const TreeModel::Path &, const TreeModel::iterator & > signal_row_inserted();
            Glib::SignalProxy2< void, const TreeModel::Path &, const TreeModel::iterator & > signal_row_has_child_toggled();
            Glib::SignalProxy1< void, const TreeModel::Path & > signal_row_deleted();
            Glib::SignalProxy3< void, const TreeModel::Path &, const TreeModel::iterator &, int * > signal_rows_reordered();
        protected :
            virtual TreeModelFlags get_flags_vfunc() const;
            virtual int get_n_columns_vfunc() const;
            virtual GType get_column_type_vfunc(int index) const;
            virtual bool iter_next_vfunc(const iterator & iter, iterator & iter_next) const;
            virtual bool get_iter_vfunc(const Path & path, iterator & iter) const;
            virtual bool iter_children_vfunc(const iterator & parent, iterator & iter) const;
            virtual bool iter_parent_vfunc(const iterator & child, iterator & iter) const;
            virtual bool iter_nth_child_vfunc(const iterator & parent, int n, iterator & iter) const;
            virtual bool iter_nth_root_child_vfunc(int n, iterator & iter) const;
            virtual bool iter_has_child_vfunc(const iterator & iter) const;
            virtual int iter_n_children_vfunc(const iterator & iter) const;
            virtual int iter_n_root_children_vfunc() const;
            virtual void ref_node_vfunc(const iterator & iter) const;
            virtual void unref_node_vfunc(const iterator & iter) const;
            virtual TreeModel::Path get_path_vfunc(const iterator & iter) const;
            virtual void get_value_vfunc(const iterator & iter, int column, Glib::ValueBase & value) const;
            virtual bool iter_is_valid(const iterator & iter) const;
            virtual void set_value_impl(const iterator & row, int column, const Glib::ValueBase & value);
            virtual void get_value_impl(const iterator & row, int column, Glib::ValueBase & value) const;
            friend class Gtk::TreeModelSort;
            friend class Gtk::TreeRow;
            friend class Gtk::TreeIter;
        public :
        public :
        protected :
            virtual void on_row_changed(const TreeModel::Path & path, const TreeModel::iterator & iter);
            virtual void on_row_inserted(const TreeModel::Path & path, const TreeModel::iterator & iter);
            virtual void on_row_has_child_toggled(const TreeModel::Path & path, const TreeModel::iterator & iter);
            virtual void on_row_deleted(const TreeModel::Path & path);
            virtual void on_rows_reordered(const TreeModel::Path & path, const TreeModel::iterator & iter, int * new_order);
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::TreeModel > wrap(GtkTreeModel * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkCellLayoutIface GtkCellLayoutIface;
}
typedef struct _GtkCellLayout GtkCellLayout;
typedef struct _GtkCellLayoutClass GtkCellLayoutClass;
namespace Gtk {
    class CellLayout_Class;
}
namespace Gtk {
    class CellLayout : public Glib::Interface
    {
        public :
            typedef CellLayout CppObjectType;
            typedef CellLayout_Class CppClassType;
            typedef GtkCellLayout BaseObjectType;
            typedef GtkCellLayoutIface BaseClassType;
        private :
            friend class CellLayout_Class;
            static CppClassType celllayout_class_;
            CellLayout(const CellLayout &);
            CellLayout & operator =(const CellLayout &);
        protected :
            CellLayout();
            explicit CellLayout(const Glib::Interface_Class & interface_class);
        public :
            explicit CellLayout(GtkCellLayout * castitem);
        protected :
        public :
            virtual ~CellLayout();
            static void add_interface(GType gtype_implementer);
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkCellLayout * gobj()
            {
                return reinterpret_cast<GtkCellLayout * >(gobject_);
            }
            const GtkCellLayout * gobj() const
            {
                return reinterpret_cast<GtkCellLayout * >(gobject_);
            }
        private :
        public :
            template<class ColumnType >
            inline void pack_start(const TreeModelColumn< ColumnType > & model_column, bool expand = true);
            void pack_start(CellRenderer & cell, bool expand = true);
            void pack_end(CellRenderer & cell, bool expand = true);
            Glib::ListHandle< CellRenderer * > get_cells();
            Glib::ListHandle< const CellRenderer * > get_cells() const;
            void clear();
            void add_attribute(CellRenderer & cell, const Glib::ustring & attribute, int column);
            void add_attribute(const Glib::PropertyProxy_Base & property, const TreeModelColumnBase & column);
            void add_attribute(CellRenderer & cell, const Glib::ustring & attribute, const TreeModelColumnBase & column);
            typedef sigc::slot< void, const TreeModel::const_iterator & > SlotCellData;
            void set_cell_data_func(CellRenderer & cell, const SlotCellData & slot);
            void clear_attributes(CellRenderer & cell);
            void reorder(CellRenderer & cell, int position);
        protected :
            virtual void pack_start_vfunc(CellRenderer * cell, bool expand);
            virtual void pack_end_vfunc(CellRenderer * cell, bool expand);
            virtual void clear_vfunc();
            virtual void add_attribute_vfunc(CellRenderer * cell, const Glib::ustring & attribute, int column);
            virtual void clear_attributes_vfunc(CellRenderer * cell);
            virtual void reorder_vfunc(CellRenderer * cell, int position);
        public :
        public :
        protected :
    };
    template<class T_ModelColumnType >
    void CellLayout::pack_start(const TreeModelColumn< T_ModelColumnType > & column, bool expand)
    {
        CellRenderer * pCellRenderer = manage(CellRenderer_Generation::generate_cellrenderer< T_ModelColumnType >());
        pack_start(*pCellRenderer, expand);
        add_attribute(pCellRenderer->_property_renderable(), column);
    }
}
namespace Glib {
    Glib::RefPtr< Gtk::CellLayout > wrap(GtkCellLayout * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkTreePath GtkTreePath;
}
namespace Gtk {
    class TreePath
    {
        public :
            typedef TreePath CppObjectType;
            typedef GtkTreePath BaseObjectType;
            static GType get_type() __attribute__((__const__));
            TreePath();
            explicit TreePath(GtkTreePath * gobject, bool make_a_copy = true);
            TreePath(const TreePath & other);
            TreePath & operator =(const TreePath & other);
            ~TreePath();
            void swap(TreePath & other);
            GtkTreePath * gobj()
            {
                return gobject_;
            }
            const GtkTreePath * gobj() const
            {
                return gobject_;
            }
            GtkTreePath * gobj_copy() const;
        protected :
            GtkTreePath * gobject_;
        private :
        public :
            typedef unsigned int size_type;
            typedef int difference_type;
            typedef int value_type;
            typedef int & reference;
            typedef const int & const_reference;
            typedef int * iterator;
            typedef const int * const_iterator;
            typedef std::reverse_iterator< iterator > reverse_iterator;
            typedef std::reverse_iterator< const_iterator > const_reverse_iterator;
            explicit TreePath(size_type n, value_type value = 0);
            explicit TreePath(const Glib::ustring & path);
            explicit TreePath(const TreeModel::iterator & iter);
            template<class In >
            inline TreePath(In pbegin, In pend);
            void clear();
            TreePath & operator =(const TreeModel::iterator & iter);
            template<class In >
            inline void assign(In pbegin, In pend);
            template<class In >
            void append(In pbegin, In pend);
            void push_back(int index);
            void push_front(int index);
            size_type size() const;
            bool empty() const;
            reference operator [](size_type i);
            const_reference operator [](size_type i) const;
            iterator begin();
            iterator end();
            const_iterator begin() const;
            const_iterator end() const;
            reverse_iterator rbegin()
            {
                return reverse_iterator(end());
            }
            reverse_iterator rend()
            {
                return reverse_iterator(begin());
            }
            const_reverse_iterator rbegin() const
            {
                return const_reverse_iterator(end());
            }
            const_reverse_iterator rend() const
            {
                return const_reverse_iterator(begin());
            }
            reference front()
            {
                return *begin();
            }
            const_reference front() const
            {
                return *begin();
            }
            reference back()
            {
                return *rbegin();
            }
            const_reference back() const
            {
                return *rbegin();
            }
            void next();
            bool prev();
            bool up();
            void down();
            bool is_ancestor(const TreePath & descendant) const;
            bool is_descendant(const TreePath & ancestor) const;
            Glib::ustring to_string() const;
            void append_index(int index);
            void prepend_index(int index);
            int get_depth() const;
            Glib::ArrayHandle< int > get_indices() const;
            static bool get_from_selection_data(const SelectionData & selection_data, Glib::RefPtr< TreeModel > & model, TreePath & path);
            static bool get_from_selection_data(const SelectionData & selection_data, TreePath & path);
            bool set_in_selection_data(SelectionData & selection_data, const Glib::RefPtr< const TreeModel > & model) const;
    };
    template<class In >
    void TreePath::append(In pbegin, In pend)
    {
        for (;
            pbegin != pend;
            ++pbegin)
        this->push_back(*pbegin);
    }
    template<class In >
    inline TreePath::TreePath(In pbegin, In pend)
        : gobject_(gtk_tree_path_new()) 
    {
        this->append(pbegin, pend);
    }
    template<class In >
    inline void TreePath::assign(In pbegin, In pend)
    {
        TreePath temp(pbegin, pend);
        this->swap(temp);
    }
    struct TreePath_Traits
    {
            typedef TreePath CppType;
            typedef const GtkTreePath * CType;
            typedef GtkTreePath * CTypeNonConst;
            static CType to_c_type(const CppType & item)
            {
                return item.gobj();
            }
            static CType to_c_type(CType item)
            {
                return item;
            }
            static CppType to_cpp_type(CType item)
            {
                return CppType(const_cast<CTypeNonConst >(item));
            }
            static void release_c_type(CType item)
            {
                gtk_tree_path_free(const_cast<CTypeNonConst >(item));
            }
    };
}
namespace Gtk {
    bool operator ==(const TreePath & lhs, const TreePath & rhs);
    bool operator !=(const TreePath & lhs, const TreePath & rhs);
    bool operator <(const TreePath & lhs, const TreePath & rhs);
    bool operator >(const TreePath & lhs, const TreePath & rhs);
    bool operator <=(const TreePath & lhs, const TreePath & rhs);
    bool operator >=(const TreePath & lhs, const TreePath & rhs);
}
namespace Gtk {
    inline void swap(TreePath & lhs, TreePath & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    Gtk::TreePath wrap(GtkTreePath * object, bool take_copy = false);
    template<>
    class Value< Gtk::TreePath > : public Glib::Value_Boxed< Gtk::TreePath >
    {
    };
}
typedef struct _GtkCellView GtkCellView;
typedef struct _GtkCellViewClass GtkCellViewClass;
namespace Gtk {
    class CellView_Class;
}
namespace Gtk {
    class CellView : public Widget, public CellLayout
    {
        public :
            typedef CellView CppObjectType;
            typedef CellView_Class CppClassType;
            typedef GtkCellView BaseObjectType;
            typedef GtkCellViewClass BaseClassType;
            virtual ~CellView();
        private :
            friend class CellView_Class;
            static CppClassType cellview_class_;
            CellView(const CellView &);
            CellView & operator =(const CellView &);
        protected :
            explicit CellView(const Glib::ConstructParams & construct_params);
            explicit CellView(GtkCellView * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkCellView * gobj()
            {
                return reinterpret_cast<GtkCellView * >(gobject_);
            }
            const GtkCellView * gobj() const
            {
                return reinterpret_cast<GtkCellView * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            CellView();
            explicit CellView(const Glib::ustring & text, bool use_markup = false);
            explicit CellView(const Glib::RefPtr< Gdk::Pixbuf > & pixbuf);
            void set_model(const Glib::RefPtr< TreeModel > & model);
            void set_displayed_row(const TreeModel::Path & path);
            TreeModel::Path get_displayed_row() const;
            bool get_size_of_row(const TreeModel::Path & path, Requisition & requisition) const;
            void set_background_color(const Gdk::Color & color);
            Glib::ListHandle< CellRenderer * > get_cell_renderers();
            Glib::ListHandle< const CellRenderer * > get_cell_renderers() const;
    };
}
namespace Glib {
    Gtk::CellView * wrap(GtkCellView * object, bool take_copy = false);
}
typedef struct _GtkToggleButton GtkToggleButton;
typedef struct _GtkToggleButtonClass GtkToggleButtonClass;
namespace Gtk {
    class ToggleButton_Class;
}
namespace Gtk {
    class ToggleButton : public Button
    {
        public :
            typedef ToggleButton CppObjectType;
            typedef ToggleButton_Class CppClassType;
            typedef GtkToggleButton BaseObjectType;
            typedef GtkToggleButtonClass BaseClassType;
            virtual ~ToggleButton();
        private :
            friend class ToggleButton_Class;
            static CppClassType togglebutton_class_;
            ToggleButton(const ToggleButton &);
            ToggleButton & operator =(const ToggleButton &);
        protected :
            explicit ToggleButton(const Glib::ConstructParams & construct_params);
            explicit ToggleButton(GtkToggleButton * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkToggleButton * gobj()
            {
                return reinterpret_cast<GtkToggleButton * >(gobject_);
            }
            const GtkToggleButton * gobj() const
            {
                return reinterpret_cast<GtkToggleButton * >(gobject_);
            }
        public :
        protected :
            virtual void on_toggled();
        private :
        public :
            ToggleButton();
            explicit ToggleButton(const Glib::ustring & label, bool mnemonic = false);
            explicit ToggleButton(const StockID & stock_id);
            void set_mode(bool draw_indicator = true);
            bool get_mode() const;
            void set_active(bool is_active = true);
            bool get_active() const;
            void set_inconsistent(bool setting = true);
            bool get_inconsistent() const;
            void toggled();
            Glib::SignalProxy0< void > signal_toggled();
            Glib::PropertyProxy< bool > property_active();
            Glib::PropertyProxy_ReadOnly< bool > property_active() const;
            Glib::PropertyProxy< bool > property_inconsistent();
            Glib::PropertyProxy_ReadOnly< bool > property_inconsistent() const;
            Glib::PropertyProxy< bool > property_draw_indicator();
            Glib::PropertyProxy_ReadOnly< bool > property_draw_indicator() const;
    };
}
namespace Glib {
    Gtk::ToggleButton * wrap(GtkToggleButton * object, bool take_copy = false);
}
typedef struct _GtkCheckButton GtkCheckButton;
typedef struct _GtkCheckButtonClass GtkCheckButtonClass;
namespace Gtk {
    class CheckButton_Class;
}
namespace Gtk {
    class CheckButton : public ToggleButton
    {
        public :
            typedef CheckButton CppObjectType;
            typedef CheckButton_Class CppClassType;
            typedef GtkCheckButton BaseObjectType;
            typedef GtkCheckButtonClass BaseClassType;
            virtual ~CheckButton();
        private :
            friend class CheckButton_Class;
            static CppClassType checkbutton_class_;
            CheckButton(const CheckButton &);
            CheckButton & operator =(const CheckButton &);
        protected :
            explicit CheckButton(const Glib::ConstructParams & construct_params);
            explicit CheckButton(GtkCheckButton * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkCheckButton * gobj()
            {
                return reinterpret_cast<GtkCheckButton * >(gobject_);
            }
            const GtkCheckButton * gobj() const
            {
                return reinterpret_cast<GtkCheckButton * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            CheckButton();
            explicit CheckButton(const Glib::ustring & label, bool mnemonic = false);
        protected :
            virtual void draw_indicator_vfunc(GdkRectangle * area);
    };
}
namespace Glib {
    Gtk::CheckButton * wrap(GtkCheckButton * object, bool take_copy = false);
}
typedef struct _GtkItem GtkItem;
typedef struct _GtkItemClass GtkItemClass;
namespace Gtk {
    class Item_Class;
}
namespace Gtk {
    class Item : public Bin
    {
        public :
            typedef Item CppObjectType;
            typedef Item_Class CppClassType;
            typedef GtkItem BaseObjectType;
            typedef GtkItemClass BaseClassType;
            virtual ~Item();
        private :
            friend class Item_Class;
            static CppClassType item_class_;
            Item(const Item &);
            Item & operator =(const Item &);
        protected :
            explicit Item(const Glib::ConstructParams & construct_params);
            explicit Item(GtkItem * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkItem * gobj()
            {
                return reinterpret_cast<GtkItem * >(gobject_);
            }
            const GtkItem * gobj() const
            {
                return reinterpret_cast<GtkItem * >(gobject_);
            }
        public :
        protected :
            virtual void on_select();
            virtual void on_deselect();
            virtual void on_toggle();
        private :
        public :
            void select();
            Glib::SignalProxy0< void > signal_select();
            void deselect();
            Glib::SignalProxy0< void > signal_deselect();
            void toggle();
            Glib::SignalProxy0< void > signal_toggle();
        protected :
            Item();
    };
}
namespace Glib {
    Gtk::Item * wrap(GtkItem * object, bool take_copy = false);
}
typedef struct _GtkLabel GtkLabel;
typedef struct _GtkLabelClass GtkLabelClass;
namespace Gtk {
    class Label_Class;
}
namespace Gtk {
    class Menu;
    class Label : public Misc
    {
        public :
            typedef Label CppObjectType;
            typedef Label_Class CppClassType;
            typedef GtkLabel BaseObjectType;
            typedef GtkLabelClass BaseClassType;
            virtual ~Label();
        private :
            friend class Label_Class;
            static CppClassType label_class_;
            Label(const Label &);
            Label & operator =(const Label &);
        protected :
            explicit Label(const Glib::ConstructParams & construct_params);
            explicit Label(GtkLabel * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkLabel * gobj()
            {
                return reinterpret_cast<GtkLabel * >(gobject_);
            }
            const GtkLabel * gobj() const
            {
                return reinterpret_cast<GtkLabel * >(gobject_);
            }
        public :
        protected :
            virtual void on_populate_popup(Menu * menu);
        private :
        public :
            Label();
            explicit Label(const Glib::ustring & label, bool mnemonic = false);
            Label(const Glib::ustring & label, float xalign, float yalign, bool mnemonic = false);
            Label(const Glib::ustring & label, AlignmentEnum xalign, AlignmentEnum yalign = ALIGN_CENTER, bool mnemonic = false);
            void set_text(const Glib::ustring & str);
            Glib::ustring get_text() const;
            void set_attributes(Pango::AttrList & attrs);
            Pango::AttrList get_attributes() const;
            void set_label(const Glib::ustring & str);
            Glib::ustring get_label() const;
            void set_markup(const Glib::ustring & str);
            void set_use_markup(bool setting = true);
            bool get_use_markup() const;
            void set_use_underline(bool setting = true);
            bool get_use_underline() const;
            void set_markup_with_mnemonic(const Glib::ustring & str);
            guint get_mnemonic_keyval() const;
            void set_mnemonic_widget(Widget & widget);
            Widget * get_mnemonic_widget();
            const Widget * get_mnemonic_widget() const;
            void set_text_with_mnemonic(const Glib::ustring & str);
            void set_justify(Justification jtype);
            Justification get_justify() const;
            void set_ellipsize(Pango::EllipsizeMode mode);
            Pango::EllipsizeMode get_ellipsize() const;
            void set_width_chars(int n_chars);
            int get_width_chars() const;
            void set_max_width_chars(int n_chars);
            int get_max_width_chars() const;
            void set_pattern(const Glib::ustring & pattern);
            void set_line_wrap(bool wrap = true);
            bool get_line_wrap() const;
            void set_line_wrap_mode(Pango::WrapMode wrap_mode);
            Pango::WrapMode get_line_wrap_mode() const;
            void set_selectable(bool setting = true);
            bool get_selectable() const;
            void set_angle(double angle);
            double get_angle() const;
            void select_region(int start_offset, int end_offset);
            void select_region(int start_offset);
            bool get_selection_bounds(int & start, int & end) const;
            Glib::RefPtr< Pango::Layout > get_layout();
            Glib::RefPtr< const Pango::Layout > get_layout() const;
            void get_layout_offsets(int & x, int & y) const;
            void set_single_line_mode(bool single_line_mode = true);
            bool get_single_line_mode() const;
            Glib::SignalProxy1< void, Menu * > signal_populate_popup();
            Glib::PropertyProxy< Glib::ustring > property_label();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_label() const;
            Glib::PropertyProxy< Pango::AttrList > property_attributes();
            Glib::PropertyProxy_ReadOnly< Pango::AttrList > property_attributes() const;
            Glib::PropertyProxy< bool > property_use_markup();
            Glib::PropertyProxy_ReadOnly< bool > property_use_markup() const;
            Glib::PropertyProxy< bool > property_use_underline();
            Glib::PropertyProxy_ReadOnly< bool > property_use_underline() const;
            Glib::PropertyProxy< Justification > property_justify();
            Glib::PropertyProxy_ReadOnly< Justification > property_justify() const;
            Glib::PropertyProxy_WriteOnly< Glib::ustring > property_pattern();
            Glib::PropertyProxy< bool > property_wrap();
            Glib::PropertyProxy_ReadOnly< bool > property_wrap() const;
            Glib::PropertyProxy< Pango::WrapMode > property_wrap_mode();
            Glib::PropertyProxy_ReadOnly< Pango::WrapMode > property_wrap_mode() const;
            Glib::PropertyProxy< bool > property_selectable();
            Glib::PropertyProxy_ReadOnly< bool > property_selectable() const;
            Glib::PropertyProxy_ReadOnly< guint > property_mnemonic_keyval() const;
            Glib::PropertyProxy< Widget * > property_mnemonic_widget();
            Glib::PropertyProxy_ReadOnly< Widget * > property_mnemonic_widget() const;
            Glib::PropertyProxy_ReadOnly< int > property_cursor_position() const;
            Glib::PropertyProxy_ReadOnly< int > property_selection_bound() const;
            Glib::PropertyProxy< Pango::EllipsizeMode > property_ellipsize();
            Glib::PropertyProxy_ReadOnly< Pango::EllipsizeMode > property_ellipsize() const;
            Glib::PropertyProxy< int > property_width_chars();
            Glib::PropertyProxy_ReadOnly< int > property_width_chars() const;
            Glib::PropertyProxy< bool > property_single_line_mode();
            Glib::PropertyProxy_ReadOnly< bool > property_single_line_mode() const;
            Glib::PropertyProxy< double > property_angle();
            Glib::PropertyProxy_ReadOnly< double > property_angle() const;
            Glib::PropertyProxy< int > property_max_width_chars();
            Glib::PropertyProxy_ReadOnly< int > property_max_width_chars() const;
    };
}
namespace Glib {
    Gtk::Label * wrap(GtkLabel * object, bool take_copy = false);
}
typedef struct _GtkAccelLabel GtkAccelLabel;
typedef struct _GtkAccelLabelClass GtkAccelLabelClass;
namespace Gtk {
    class AccelLabel_Class;
}
namespace Gtk {
    class AccelLabel : public Label
    {
        public :
            typedef AccelLabel CppObjectType;
            typedef AccelLabel_Class CppClassType;
            typedef GtkAccelLabel BaseObjectType;
            typedef GtkAccelLabelClass BaseClassType;
            virtual ~AccelLabel();
        private :
            friend class AccelLabel_Class;
            static CppClassType accellabel_class_;
            AccelLabel(const AccelLabel &);
            AccelLabel & operator =(const AccelLabel &);
        protected :
            explicit AccelLabel(const Glib::ConstructParams & construct_params);
            explicit AccelLabel(GtkAccelLabel * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkAccelLabel * gobj()
            {
                return reinterpret_cast<GtkAccelLabel * >(gobject_);
            }
            const GtkAccelLabel * gobj() const
            {
                return reinterpret_cast<GtkAccelLabel * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            AccelLabel();
            explicit AccelLabel(const Glib::ustring & label, bool mnemonic = false);
            void set_accel_widget(const Widget & accel_widget);
            void unset_accel_widget();
            Widget * get_accel_widget();
            const Widget * get_accel_widget() const;
            guint get_accel_width() const;
            bool refetch();
            Glib::PropertyProxy< Gtk::Widget * > property_accel_widget();
            Glib::PropertyProxy_ReadOnly< Gtk::Widget * > property_accel_widget() const;
    };
}
namespace Glib {
    Gtk::AccelLabel * wrap(GtkAccelLabel * object, bool take_copy = false);
}
typedef struct _GtkMenuItem GtkMenuItem;
typedef struct _GtkMenuItemClass GtkMenuItemClass;
namespace Gtk {
    class MenuItem_Class;
}
namespace Gtk {
    class Menu;
    namespace Menu_Helpers {
        class Element;
    }
    class MenuItem : public Item
    {
        public :
            typedef MenuItem CppObjectType;
            typedef MenuItem_Class CppClassType;
            typedef GtkMenuItem BaseObjectType;
            typedef GtkMenuItemClass BaseClassType;
            virtual ~MenuItem();
        private :
            friend class MenuItem_Class;
            static CppClassType menuitem_class_;
            MenuItem(const MenuItem &);
            MenuItem & operator =(const MenuItem &);
        protected :
            explicit MenuItem(const Glib::ConstructParams & construct_params);
            explicit MenuItem(GtkMenuItem * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkMenuItem * gobj()
            {
                return reinterpret_cast<GtkMenuItem * >(gobject_);
            }
            const GtkMenuItem * gobj() const
            {
                return reinterpret_cast<GtkMenuItem * >(gobject_);
            }
        public :
        protected :
            virtual void on_activate();
            virtual void on_activate_item();
            virtual void on_toggle_size_request(int * requisition);
            virtual void on_toggle_size_allocate(int allocation);
        private :
        public :
            MenuItem();
            explicit MenuItem(Widget & widget);
            explicit MenuItem(const Glib::ustring & label, bool mnemonic = false);
            void set_submenu(Menu & submenu);
            Menu * get_submenu();
            const Menu * get_submenu() const;
            bool has_submenu() const;
            void remove_submenu();
            void select();
            void deselect();
            void activate();
            void toggle_size_request(int & requisition);
            void toggle_size_allocate(int allocation);
            void set_right_justified(bool right_justified = true);
            bool get_right_justified() const;
            void set_accel_path(const Glib::ustring & accel_path);
            void unset_accel_path();
            Glib::SignalProxy0< void > signal_activate();
            Glib::SignalProxy0< void > signal_activate_item();
            Glib::SignalProxy1< void, int * > signal_toggle_size_request();
            Glib::SignalProxy1< void, int > signal_toggle_size_allocate();
            void accelerate(Window & window);
        protected :
            void add_accel_label(const Glib::ustring & label, bool mnemonic = true);
            void set_accel_key(const AccelKey & accel_key);
        private :
            friend class Menu_Helpers::Element;
            AccelKey accel_key_;
    };
}
namespace Glib {
    Gtk::MenuItem * wrap(GtkMenuItem * object, bool take_copy = false);
}
typedef struct _GtkCheckMenuItem GtkCheckMenuItem;
typedef struct _GtkCheckMenuItemClass GtkCheckMenuItemClass;
namespace Gtk {
    class CheckMenuItem_Class;
}
namespace Gtk {
    class CheckMenuItem : public MenuItem
    {
        public :
            typedef CheckMenuItem CppObjectType;
            typedef CheckMenuItem_Class CppClassType;
            typedef GtkCheckMenuItem BaseObjectType;
            typedef GtkCheckMenuItemClass BaseClassType;
            virtual ~CheckMenuItem();
        private :
            friend class CheckMenuItem_Class;
            static CppClassType checkmenuitem_class_;
            CheckMenuItem(const CheckMenuItem &);
            CheckMenuItem & operator =(const CheckMenuItem &);
        protected :
            explicit CheckMenuItem(const Glib::ConstructParams & construct_params);
            explicit CheckMenuItem(GtkCheckMenuItem * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkCheckMenuItem * gobj()
            {
                return reinterpret_cast<GtkCheckMenuItem * >(gobject_);
            }
            const GtkCheckMenuItem * gobj() const
            {
                return reinterpret_cast<GtkCheckMenuItem * >(gobject_);
            }
        public :
        protected :
            virtual void on_toggled();
        private :
        public :
            CheckMenuItem();
            explicit CheckMenuItem(const Glib::ustring & label, bool mnemonic = false);
            void set_active(bool state = true);
            bool get_active() const;
            void toggled();
            void set_inconsistent(bool setting = true);
            bool get_inconsistent() const;
            void set_draw_as_radio(bool draw_as_radio = true);
            bool get_draw_as_radio() const;
            Glib::SignalProxy0< void > signal_toggled();
            Glib::PropertyProxy< bool > property_active();
            Glib::PropertyProxy_ReadOnly< bool > property_active() const;
            Glib::PropertyProxy< bool > property_inconsistent();
            Glib::PropertyProxy_ReadOnly< bool > property_inconsistent() const;
            Glib::PropertyProxy< bool > property_draw_as_radio();
            Glib::PropertyProxy_ReadOnly< bool > property_draw_as_radio() const;
        protected :
            virtual void draw_indicator_vfunc(GdkRectangle * area);
    };
}
namespace Glib {
    Gtk::CheckMenuItem * wrap(GtkCheckMenuItem * object, bool take_copy = false);
}
typedef struct _GtkCellRendererCombo GtkCellRendererCombo;
typedef struct _GtkCellRendererComboClass GtkCellRendererComboClass;
namespace Gtk {
    class CellRendererCombo_Class;
}
namespace Gtk {
    class CellRendererCombo : public CellRendererText
    {
        public :
            typedef CellRendererCombo CppObjectType;
            typedef CellRendererCombo_Class CppClassType;
            typedef GtkCellRendererCombo BaseObjectType;
            typedef GtkCellRendererComboClass BaseClassType;
            virtual ~CellRendererCombo();
        private :
            friend class CellRendererCombo_Class;
            static CppClassType cellrenderercombo_class_;
            CellRendererCombo(const CellRendererCombo &);
            CellRendererCombo & operator =(const CellRendererCombo &);
        protected :
            explicit CellRendererCombo(const Glib::ConstructParams & construct_params);
            explicit CellRendererCombo(GtkCellRendererCombo * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkCellRendererCombo * gobj()
            {
                return reinterpret_cast<GtkCellRendererCombo * >(gobject_);
            }
            const GtkCellRendererCombo * gobj() const
            {
                return reinterpret_cast<GtkCellRendererCombo * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            CellRendererCombo();
            Glib::PropertyProxy< Glib::RefPtr< Gtk::TreeModel > > property_model();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Gtk::TreeModel > > property_model() const;
            Glib::PropertyProxy< int > property_text_column();
            Glib::PropertyProxy_ReadOnly< int > property_text_column() const;
            Glib::PropertyProxy< bool > property_has_entry();
            Glib::PropertyProxy_ReadOnly< bool > property_has_entry() const;
            virtual Glib::PropertyProxy_Base _property_renderable();
    };
}
namespace Glib {
    Gtk::CellRendererCombo * wrap(GtkCellRendererCombo * object, bool take_copy = false);
}
typedef struct _GtkCellRendererProgress GtkCellRendererProgress;
typedef struct _GtkCellRendererProgressClass GtkCellRendererProgressClass;
namespace Gtk {
    class CellRendererProgress_Class;
}
namespace Gtk {
    class CellRendererProgress : public CellRenderer
    {
        public :
            typedef CellRendererProgress CppObjectType;
            typedef CellRendererProgress_Class CppClassType;
            typedef GtkCellRendererProgress BaseObjectType;
            typedef GtkCellRendererProgressClass BaseClassType;
            virtual ~CellRendererProgress();
        private :
            friend class CellRendererProgress_Class;
            static CppClassType cellrendererprogress_class_;
            CellRendererProgress(const CellRendererProgress &);
            CellRendererProgress & operator =(const CellRendererProgress &);
        protected :
            explicit CellRendererProgress(const Glib::ConstructParams & construct_params);
            explicit CellRendererProgress(GtkCellRendererProgress * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkCellRendererProgress * gobj()
            {
                return reinterpret_cast<GtkCellRendererProgress * >(gobject_);
            }
            const GtkCellRendererProgress * gobj() const
            {
                return reinterpret_cast<GtkCellRendererProgress * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            CellRendererProgress();
            Glib::PropertyProxy< int > property_value();
            Glib::PropertyProxy_ReadOnly< int > property_value() const;
            Glib::PropertyProxy< Glib::ustring > property_text();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_text() const;
            Glib::PropertyProxy< int > property_pulse();
            Glib::PropertyProxy_ReadOnly< int > property_pulse() const;
            Glib::PropertyProxy< float > property_text_xalign();
            Glib::PropertyProxy_ReadOnly< float > property_text_xalign() const;
            Glib::PropertyProxy< float > property_text_yalign();
            Glib::PropertyProxy_ReadOnly< float > property_text_yalign() const;
            virtual Glib::PropertyProxy_Base _property_renderable();
    };
}
namespace Glib {
    Gtk::CellRendererProgress * wrap(GtkCellRendererProgress * object, bool take_copy = false);
}
typedef struct _GtkCellRendererSpin GtkCellRendererSpin;
typedef struct _GtkCellRendererSpinClass GtkCellRendererSpinClass;
namespace Gtk {
    class CellRendererSpin_Class;
}
namespace Gtk {
    class CellRendererSpin : public CellRendererText
    {
        public :
            typedef CellRendererSpin CppObjectType;
            typedef CellRendererSpin_Class CppClassType;
            typedef GtkCellRendererSpin BaseObjectType;
            typedef GtkCellRendererSpinClass BaseClassType;
            virtual ~CellRendererSpin();
        private :
            friend class CellRendererSpin_Class;
            static CppClassType cellrendererspin_class_;
            CellRendererSpin(const CellRendererSpin &);
            CellRendererSpin & operator =(const CellRendererSpin &);
        protected :
            explicit CellRendererSpin(const Glib::ConstructParams & construct_params);
            explicit CellRendererSpin(GtkCellRendererSpin * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkCellRendererSpin * gobj()
            {
                return reinterpret_cast<GtkCellRendererSpin * >(gobject_);
            }
            const GtkCellRendererSpin * gobj() const
            {
                return reinterpret_cast<GtkCellRendererSpin * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            CellRendererSpin();
            Glib::PropertyProxy< Gtk::Adjustment * > property_adjustment();
            Glib::PropertyProxy_ReadOnly< Gtk::Adjustment * > property_adjustment() const;
            Glib::PropertyProxy< double > property_climb_rate();
            Glib::PropertyProxy_ReadOnly< double > property_climb_rate() const;
            Glib::PropertyProxy< guint > property_digits();
            Glib::PropertyProxy_ReadOnly< guint > property_digits() const;
            virtual Glib::PropertyProxy_Base _property_renderable();
    };
}
namespace Glib {
    Gtk::CellRendererSpin * wrap(GtkCellRendererSpin * object, bool take_copy = false);
}
typedef struct _GtkColorButton GtkColorButton;
typedef struct _GtkColorButtonClass GtkColorButtonClass;
namespace Gtk {
    class ColorButton_Class;
}
namespace Gtk {
    class ColorButton : public Button
    {
        public :
            typedef ColorButton CppObjectType;
            typedef ColorButton_Class CppClassType;
            typedef GtkColorButton BaseObjectType;
            typedef GtkColorButtonClass BaseClassType;
            virtual ~ColorButton();
        private :
            friend class ColorButton_Class;
            static CppClassType colorbutton_class_;
            ColorButton(const ColorButton &);
            ColorButton & operator =(const ColorButton &);
        protected :
            explicit ColorButton(const Glib::ConstructParams & construct_params);
            explicit ColorButton(GtkColorButton * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkColorButton * gobj()
            {
                return reinterpret_cast<GtkColorButton * >(gobject_);
            }
            const GtkColorButton * gobj() const
            {
                return reinterpret_cast<GtkColorButton * >(gobject_);
            }
        public :
        protected :
            virtual void on_color_set();
        private :
        public :
            ColorButton();
            explicit ColorButton(const Gdk::Color & color);
            void set_color(const Gdk::Color & color);
            void set_alpha(guint16 alpha);
            Gdk::Color get_color() const;
            guint16 get_alpha() const;
            void set_use_alpha(bool use_alpha = true);
            bool get_use_alpha() const;
            void set_title(const Glib::ustring & title);
            Glib::ustring get_title() const;
            Glib::PropertyProxy< bool > property_use_alpha();
            Glib::PropertyProxy_ReadOnly< bool > property_use_alpha() const;
            Glib::PropertyProxy< Glib::ustring > property_title();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_title() const;
            Glib::PropertyProxy< Gdk::Color > property_color();
            Glib::PropertyProxy_ReadOnly< Gdk::Color > property_color() const;
            Glib::PropertyProxy< guint16 > property_alpha();
            Glib::PropertyProxy_ReadOnly< guint16 > property_alpha() const;
            Glib::SignalProxy0< void > signal_color_set();
    };
}
namespace Glib {
    Gtk::ColorButton * wrap(GtkColorButton * object, bool take_copy = false);
}
typedef struct _GtkColorSelection GtkColorSelection;
typedef struct _GtkColorSelectionClass GtkColorSelectionClass;
namespace Gtk {
    class ColorSelection_Class;
}
typedef struct _GtkColorSelectionDialog GtkColorSelectionDialog;
typedef struct _GtkColorSelectionDialogClass GtkColorSelectionDialogClass;
namespace Gtk {
    class ColorSelectionDialog_Class;
}
namespace Gtk {
    class ColorSelection : public VBox
    {
        public :
            typedef ColorSelection CppObjectType;
            typedef ColorSelection_Class CppClassType;
            typedef GtkColorSelection BaseObjectType;
            typedef GtkColorSelectionClass BaseClassType;
            virtual ~ColorSelection();
        private :
            friend class ColorSelection_Class;
            static CppClassType colorselection_class_;
            ColorSelection(const ColorSelection &);
            ColorSelection & operator =(const ColorSelection &);
        protected :
            explicit ColorSelection(const Glib::ConstructParams & construct_params);
            explicit ColorSelection(GtkColorSelection * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkColorSelection * gobj()
            {
                return reinterpret_cast<GtkColorSelection * >(gobject_);
            }
            const GtkColorSelection * gobj() const
            {
                return reinterpret_cast<GtkColorSelection * >(gobject_);
            }
        public :
        protected :
            virtual void on_color_changed();
        private :
        public :
            ColorSelection();
            bool get_has_opacity_control() const;
            void set_has_opacity_control(bool has_opacity = true);
            bool get_has_palette() const;
            void set_has_palette(bool has_palette = true);
            void set_current_color(const Gdk::Color & color);
            void set_current_alpha(guint16 alpha);
            Gdk::Color get_current_color() const;
            guint16 get_current_alpha() const;
            void set_previous_color(const Gdk::Color & color);
            void set_previous_alpha(guint16 alpha);
            Gdk::Color get_previous_color() const;
            guint16 get_previous_alpha() const;
            bool is_adjusting() const;
            static Gdk::ArrayHandle_Color palette_from_string(const Glib::ustring & str);
            static Glib::ustring palette_to_string(const Gdk::ArrayHandle_Color & colors);
            typedef sigc::slot< void, const Glib::RefPtr< Gdk::Screen > &, const Gdk::ArrayHandle_Color & > SlotChangePaletteHook;
            static SlotChangePaletteHook set_change_palette_hook(const SlotChangePaletteHook & slot);
            Glib::SignalProxy0< void > signal_color_changed();
            Glib::PropertyProxy< bool > property_has_palette();
            Glib::PropertyProxy_ReadOnly< bool > property_has_palette() const;
            Glib::PropertyProxy< bool > property_has_opacity_control();
            Glib::PropertyProxy_ReadOnly< bool > property_has_opacity_control() const;
            Glib::PropertyProxy< Gdk::Color > property_current_color();
            Glib::PropertyProxy_ReadOnly< Gdk::Color > property_current_color() const;
            Glib::PropertyProxy< guint > property_current_alpha();
            Glib::PropertyProxy_ReadOnly< guint > property_current_alpha() const;
    };
    class ColorSelectionDialog : public Dialog
    {
        public :
            typedef ColorSelectionDialog CppObjectType;
            typedef ColorSelectionDialog_Class CppClassType;
            typedef GtkColorSelectionDialog BaseObjectType;
            typedef GtkColorSelectionDialogClass BaseClassType;
            virtual ~ColorSelectionDialog();
        private :
            friend class ColorSelectionDialog_Class;
            static CppClassType colorselectiondialog_class_;
            ColorSelectionDialog(const ColorSelectionDialog &);
            ColorSelectionDialog & operator =(const ColorSelectionDialog &);
        protected :
            explicit ColorSelectionDialog(const Glib::ConstructParams & construct_params);
            explicit ColorSelectionDialog(GtkColorSelectionDialog * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkColorSelectionDialog * gobj()
            {
                return reinterpret_cast<GtkColorSelectionDialog * >(gobject_);
            }
            const GtkColorSelectionDialog * gobj() const
            {
                return reinterpret_cast<GtkColorSelectionDialog * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            ColorSelectionDialog();
            explicit ColorSelectionDialog(const Glib::ustring & title);
            ColorSelection * get_colorsel();
            const ColorSelection * get_colorsel() const;
            Button * get_ok_button();
            const Button * get_ok_button() const;
            Button * get_cancel_button();
            const Button * get_cancel_button() const;
            Button * get_help_button();
            const Button * get_help_button() const;
    };
}
namespace Glib {
    Gtk::ColorSelection * wrap(GtkColorSelection * object, bool take_copy = false);
}
namespace Glib {
    Gtk::ColorSelectionDialog * wrap(GtkColorSelectionDialog * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkEditable GtkEditable;
    typedef struct _GtkEditableClass GtkEditableClass;
    struct _GtkEditableClass
    {
            GTypeInterface base_iface;
            void (* insert_text)(GtkEditable * editable, const gchar * text, gint length, gint * position);
            void (* delete_text)(GtkEditable * editable, gint start_pos, gint end_pos);
            void (* changed)(GtkEditable * editable);
            void (* do_insert_text)(GtkEditable * editable, const gchar * text, gint length, gint * position);
            void (* do_delete_text)(GtkEditable * editable, gint start_pos, gint end_pos);
            gchar * (* get_chars)(GtkEditable * editable, gint start_pos, gint end_pos);
            void (* set_selection_bounds)(GtkEditable * editable, gint start_pos, gint end_pos);
            gboolean (* get_selection_bounds)(GtkEditable * editable, gint * start_pos, gint * end_pos);
            void (* set_position)(GtkEditable * editable, gint position);
            gint (* get_position)(GtkEditable * editable);
    };
    GType gtk_editable_get_type(void) __attribute__((__const__));
    void gtk_editable_select_region(GtkEditable * editable, gint start, gint end);
    gboolean gtk_editable_get_selection_bounds(GtkEditable * editable, gint * start, gint * end);
    void gtk_editable_insert_text(GtkEditable * editable, const gchar * new_text, gint new_text_length, gint * position);
    void gtk_editable_delete_text(GtkEditable * editable, gint start_pos, gint end_pos);
    gchar * gtk_editable_get_chars(GtkEditable * editable, gint start_pos, gint end_pos);
    void gtk_editable_cut_clipboard(GtkEditable * editable);
    void gtk_editable_copy_clipboard(GtkEditable * editable);
    void gtk_editable_paste_clipboard(GtkEditable * editable);
    void gtk_editable_delete_selection(GtkEditable * editable);
    void gtk_editable_set_position(GtkEditable * editable, gint position);
    gint gtk_editable_get_position(GtkEditable * editable);
    void gtk_editable_set_editable(GtkEditable * editable, gboolean is_editable);
    gboolean gtk_editable_get_editable(GtkEditable * editable);
}
typedef struct _GtkEditable GtkEditable;
typedef struct _GtkEditableClass GtkEditableClass;
namespace Gtk {
    class Editable_Class;
}
namespace Gtk {
    class Editable : public Glib::Interface
    {
        public :
            typedef Editable CppObjectType;
            typedef Editable_Class CppClassType;
            typedef GtkEditable BaseObjectType;
            typedef GtkEditableClass BaseClassType;
        private :
            friend class Editable_Class;
            static CppClassType editable_class_;
            Editable(const Editable &);
            Editable & operator =(const Editable &);
        protected :
            Editable();
            explicit Editable(const Glib::Interface_Class & interface_class);
        public :
            explicit Editable(GtkEditable * castitem);
        protected :
        public :
            virtual ~Editable();
            static void add_interface(GType gtype_implementer);
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkEditable * gobj()
            {
                return reinterpret_cast<GtkEditable * >(gobject_);
            }
            const GtkEditable * gobj() const
            {
                return reinterpret_cast<GtkEditable * >(gobject_);
            }
        private :
        public :
            void cut_clipboard();
            void copy_clipboard();
            void paste_clipboard();
            void delete_selection();
            void set_editable(bool is_editable = true);
            bool get_editable() const;
            void insert_text(const Glib::ustring & text, int length, int & position);
            void delete_text(int start_pos, int end_pos);
            Glib::ustring get_chars(int start_pos, int end_pos) const;
            void select_region(int start_pos, int end_pos);
            bool get_selection_bounds(int & start_pos, int & end_pos) const;
            void set_position(int position);
            int get_position() const;
            Glib::SignalProxy2< void, const Glib::ustring &, int * > signal_insert_text();
            Glib::SignalProxy2< void, int, int > signal_delete_text();
            Glib::SignalProxy0< void > signal_changed();
        protected :
            virtual void delete_text_vfunc(int start_pos, int end_pos);
            virtual Glib::ustring get_chars_vfunc(int start_pos, int end_pos) const;
            virtual void select_region_vfunc(int start_pos, int end_pos);
            virtual bool get_selection_bounds_vfunc(int & start_pos, int & end_pos) const;
            virtual void set_position_vfunc(int position);
            virtual int get_position_vfunc() const;
        public :
        public :
        protected :
            virtual void insert_text_vfunc(const Glib::ustring & text, int & position);
            virtual void on_insert_text(const Glib::ustring & text, int * position);
            virtual void on_delete_text(int start_pos, int end_pos);
            virtual void on_changed();
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::Editable > wrap(GtkEditable * object, bool take_copy = false);
}
typedef struct _GtkImageMenuItem GtkImageMenuItem;
typedef struct _GtkImageMenuItemClass GtkImageMenuItemClass;
namespace Gtk {
    class ImageMenuItem_Class;
}
namespace Gtk {
    class ImageMenuItem : public MenuItem
    {
        public :
            typedef ImageMenuItem CppObjectType;
            typedef ImageMenuItem_Class CppClassType;
            typedef GtkImageMenuItem BaseObjectType;
            typedef GtkImageMenuItemClass BaseClassType;
            virtual ~ImageMenuItem();
        private :
            friend class ImageMenuItem_Class;
            static CppClassType imagemenuitem_class_;
            ImageMenuItem(const ImageMenuItem &);
            ImageMenuItem & operator =(const ImageMenuItem &);
        protected :
            explicit ImageMenuItem(const Glib::ConstructParams & construct_params);
            explicit ImageMenuItem(GtkImageMenuItem * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkImageMenuItem * gobj()
            {
                return reinterpret_cast<GtkImageMenuItem * >(gobject_);
            }
            const GtkImageMenuItem * gobj() const
            {
                return reinterpret_cast<GtkImageMenuItem * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            ImageMenuItem();
            explicit ImageMenuItem(Widget & image, const Glib::ustring & label, bool mnemonic = false);
            explicit ImageMenuItem(const Glib::ustring & label, bool mnemonic = false);
            explicit ImageMenuItem(const StockID & id);
            void set_image(Widget & image);
            Widget * get_image();
            const Widget * get_image() const;
    };
}
namespace Glib {
    Gtk::ImageMenuItem * wrap(GtkImageMenuItem * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GSList GSList;
}
namespace Gtk {
    class RadioButton;
    class RadioMenuItem;
    class RadioAction;
    class RadioToolButton;
    class RadioButtonGroup
    {
        public :
            RadioButtonGroup();
            RadioButtonGroup(const RadioButtonGroup & src);
            RadioButtonGroup & operator =(const RadioButtonGroup & src);
        protected :
            explicit RadioButtonGroup(GSList * group);
            friend class Gtk::RadioButton;
            friend class Gtk::RadioMenuItem;
            friend class Gtk::RadioAction;
            friend class Gtk::RadioToolButton;
            void add(RadioButton & item);
            void add(RadioMenuItem & item);
            void add(const Glib::RefPtr< RadioAction > & item);
            void add(RadioToolButton & item);
            void * operator new(size_t);
            GSList * group_;
    };
}
typedef struct _GtkRadioButton GtkRadioButton;
typedef struct _GtkRadioButtonClass GtkRadioButtonClass;
namespace Gtk {
    class RadioButton_Class;
}
namespace Gtk {
    class RadioButton : public CheckButton
    {
        public :
            typedef RadioButton CppObjectType;
            typedef RadioButton_Class CppClassType;
            typedef GtkRadioButton BaseObjectType;
            typedef GtkRadioButtonClass BaseClassType;
            virtual ~RadioButton();
        private :
            friend class RadioButton_Class;
            static CppClassType radiobutton_class_;
            RadioButton(const RadioButton &);
            RadioButton & operator =(const RadioButton &);
        protected :
            explicit RadioButton(const Glib::ConstructParams & construct_params);
            explicit RadioButton(GtkRadioButton * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkRadioButton * gobj()
            {
                return reinterpret_cast<GtkRadioButton * >(gobject_);
            }
            const GtkRadioButton * gobj() const
            {
                return reinterpret_cast<GtkRadioButton * >(gobject_);
            }
        public :
        protected :
            virtual void on_group_changed();
        private :
        public :
            typedef RadioButtonGroup Group;
            RadioButton();
            explicit RadioButton(const Glib::ustring & label, bool mnemonic = false);
            explicit RadioButton(Group & group);
            RadioButton(Group & group, const Glib::ustring & label, bool mnemonic = false);
            Group get_group();
            void set_group(Group & group);
            void reset_group();
            Glib::SignalProxy0< void > signal_group_changed();
    };
}
namespace Glib {
    Gtk::RadioButton * wrap(GtkRadioButton * object, bool take_copy = false);
}
typedef struct _GtkRadioMenuItem GtkRadioMenuItem;
typedef struct _GtkRadioMenuItemClass GtkRadioMenuItemClass;
namespace Gtk {
    class RadioMenuItem_Class;
}
namespace Gtk {
    class RadioMenuItem;
    class RadioMenuItem : public CheckMenuItem
    {
        public :
            typedef RadioMenuItem CppObjectType;
            typedef RadioMenuItem_Class CppClassType;
            typedef GtkRadioMenuItem BaseObjectType;
            typedef GtkRadioMenuItemClass BaseClassType;
            virtual ~RadioMenuItem();
        private :
            friend class RadioMenuItem_Class;
            static CppClassType radiomenuitem_class_;
            RadioMenuItem(const RadioMenuItem &);
            RadioMenuItem & operator =(const RadioMenuItem &);
        protected :
            explicit RadioMenuItem(const Glib::ConstructParams & construct_params);
            explicit RadioMenuItem(GtkRadioMenuItem * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkRadioMenuItem * gobj()
            {
                return reinterpret_cast<GtkRadioMenuItem * >(gobject_);
            }
            const GtkRadioMenuItem * gobj() const
            {
                return reinterpret_cast<GtkRadioMenuItem * >(gobject_);
            }
        public :
        protected :
            virtual void on_group_changed();
        private :
        public :
            typedef RadioButtonGroup Group;
            RadioMenuItem(Group & groupx);
            RadioMenuItem(Group & groupx, const Glib::ustring & label, bool mnemonic = false);
            Group get_group();
            void set_group(Group & group);
            void reset_group();
            Glib::SignalProxy0< void > signal_group_changed();
        protected :
            void constructor(const Group & group);
    };
}
namespace Glib {
    Gtk::RadioMenuItem * wrap(GtkRadioMenuItem * object, bool take_copy = false);
}
typedef struct _GtkTearoffMenuItem GtkTearoffMenuItem;
typedef struct _GtkTearoffMenuItemClass GtkTearoffMenuItemClass;
namespace Gtk {
    class TearoffMenuItem_Class;
}
namespace Gtk {
    class TearoffMenuItem : public MenuItem
    {
        public :
            typedef TearoffMenuItem CppObjectType;
            typedef TearoffMenuItem_Class CppClassType;
            typedef GtkTearoffMenuItem BaseObjectType;
            typedef GtkTearoffMenuItemClass BaseClassType;
            virtual ~TearoffMenuItem();
        private :
            friend class TearoffMenuItem_Class;
            static CppClassType tearoffmenuitem_class_;
            TearoffMenuItem(const TearoffMenuItem &);
            TearoffMenuItem & operator =(const TearoffMenuItem &);
        protected :
            explicit TearoffMenuItem(const Glib::ConstructParams & construct_params);
            explicit TearoffMenuItem(GtkTearoffMenuItem * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTearoffMenuItem * gobj()
            {
                return reinterpret_cast<GtkTearoffMenuItem * >(gobject_);
            }
            const GtkTearoffMenuItem * gobj() const
            {
                return reinterpret_cast<GtkTearoffMenuItem * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            TearoffMenuItem();
            bool is_torn_off() const;
    };
}
namespace Glib {
    Gtk::TearoffMenuItem * wrap(GtkTearoffMenuItem * object, bool take_copy = false);
}
typedef struct _GtkSeparatorMenuItem GtkSeparatorMenuItem;
typedef struct _GtkSeparatorMenuItemClass GtkSeparatorMenuItemClass;
namespace Gtk {
    class SeparatorMenuItem_Class;
}
namespace Gtk {
    class SeparatorMenuItem : public MenuItem
    {
        public :
            typedef SeparatorMenuItem CppObjectType;
            typedef SeparatorMenuItem_Class CppClassType;
            typedef GtkSeparatorMenuItem BaseObjectType;
            typedef GtkSeparatorMenuItemClass BaseClassType;
            virtual ~SeparatorMenuItem();
        private :
            friend class SeparatorMenuItem_Class;
            static CppClassType separatormenuitem_class_;
            SeparatorMenuItem(const SeparatorMenuItem &);
            SeparatorMenuItem & operator =(const SeparatorMenuItem &);
        protected :
            explicit SeparatorMenuItem(const Glib::ConstructParams & construct_params);
            explicit SeparatorMenuItem(GtkSeparatorMenuItem * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkSeparatorMenuItem * gobj()
            {
                return reinterpret_cast<GtkSeparatorMenuItem * >(gobject_);
            }
            const GtkSeparatorMenuItem * gobj() const
            {
                return reinterpret_cast<GtkSeparatorMenuItem * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            SeparatorMenuItem();
    };
}
namespace Glib {
    Gtk::SeparatorMenuItem * wrap(GtkSeparatorMenuItem * object, bool take_copy = false);
}
namespace Gtk {
    class Menu;
    namespace Menu_Helpers {
        class Element
        {
            public :
                typedef sigc::slot< void > CallSlot;
                Element();
                Element(MenuItem & child);
                ~Element();
                const Glib::RefPtr< MenuItem > & get_child() const;
            protected :
                void set_child(MenuItem * pChild);
                void set_accel_key(const AccelKey & accel_key);
                Glib::RefPtr< MenuItem > child_;
        };
        class MenuElem : public Element
        {
            public :
                MenuElem(MenuItem & child);
                MenuElem(const Glib::ustring & label, const CallSlot & slot = CallSlot());
                MenuElem(const Glib::ustring & label, const AccelKey & key, const CallSlot & slot = CallSlot());
                MenuElem(const Glib::ustring & label, Gtk::Menu & submenu);
                MenuElem(const Glib::ustring & label, const AccelKey & key, Gtk::Menu & submenu);
        };
        class SeparatorElem : public Element
        {
            public :
                SeparatorElem();
        };
        class ImageMenuElem : public Element
        {
            public :
                ImageMenuElem(ImageMenuItem & child);
                ImageMenuElem(const Glib::ustring & label, Gtk::Widget & image_widget, const CallSlot & slot = CallSlot());
                ImageMenuElem(const Glib::ustring & label, const AccelKey & key, Gtk::Widget & image_widget, const CallSlot & slot = CallSlot());
                ImageMenuElem(const Glib::ustring & label, Gtk::Widget & image_widget, Gtk::Menu & submenu);
                ImageMenuElem(const Glib::ustring & label, const AccelKey & key, Gtk::Widget & image_widget, Gtk::Menu & submenu);
        };
        class StockMenuElem : public Element
        {
            public :
                StockMenuElem(const Gtk::StockID & stock_id, const CallSlot & slot = CallSlot());
                StockMenuElem(const Gtk::StockID & stock_id, const AccelKey & key, const CallSlot & slot = CallSlot());
                StockMenuElem(const Gtk::StockID & stock_id, Gtk::Menu & submenu);
                StockMenuElem(const Gtk::StockID & stock_id, const AccelKey & key, Gtk::Menu & submenu);
        };
        class CheckMenuElem : public Element
        {
            public :
                CheckMenuElem(CheckMenuItem & child);
                CheckMenuElem(const Glib::ustring & label, const CallSlot & slot = CallSlot());
                CheckMenuElem(const Glib::ustring & label, const AccelKey & key, const CallSlot & slot = CallSlot());
        };
        class RadioMenuElem : public Element
        {
            public :
                RadioMenuElem(RadioMenuItem & child);
                RadioMenuElem(RadioMenuItem::Group &, const Glib::ustring & label, const CallSlot & slot = CallSlot());
                RadioMenuElem(RadioMenuItem::Group & group, const Glib::ustring & label, const AccelKey & key, const CallSlot & slot = CallSlot());
            protected :
                RadioMenuItem::Group * gr_;
        };
        class TearoffMenuElem : public Element
        {
            public :
                TearoffMenuElem(TearoffMenuItem & child);
                TearoffMenuElem(const CallSlot & slot = CallSlot());
                TearoffMenuElem(const AccelKey & key, const CallSlot & slot = CallSlot());
        };
    }
}
typedef struct _GtkMenuShell GtkMenuShell;
typedef struct _GtkMenuShellClass GtkMenuShellClass;
namespace Gtk {
    class MenuShell_Class;
}
namespace Gtk {
    class Menu;
    class MenuShell;
    class Window;
    namespace Menu_Helpers {
        class MenuList : public Glib::HelperList< MenuItem, const Element, Glib::List_Cpp_Iterator< GtkMenuItem, MenuItem > >
        {
            public :
                MenuList();
                explicit MenuList(GtkMenuShell * gparent);
                MenuList(const MenuList & src);
                virtual ~MenuList()
                {
                }
                MenuList & operator =(const MenuList & src);
                typedef Glib::HelperList< MenuItem, const Element, Glib::List_Cpp_Iterator< GtkMenuItem, MenuItem > > type_base;
                GtkMenuShell * gparent();
                const GtkMenuShell * gparent() const;
                virtual GList * & glist() const;
                virtual void erase(iterator start, iterator stop);
                virtual iterator erase(iterator);
                virtual void remove(const_reference);
                reference operator [](size_type l) const;
            public :
                iterator insert(iterator position, element_type & e);
                template<class InputIterator >
                inline void insert(iterator position, InputIterator first, InputIterator last)
                {
                    for (;
                        first != last;
                        ++first)
                    position = insert(position, *first);
                }
                inline void push_front(element_type & e)
                {
                    insert(begin(), e);
                }
                inline void push_back(element_type & e)
                {
                    insert(end(), e);
                }
                virtual void remove(Widget & widget);
        };
    }
    class MenuShell : public Container
    {
        public :
            typedef MenuShell CppObjectType;
            typedef MenuShell_Class CppClassType;
            typedef GtkMenuShell BaseObjectType;
            typedef GtkMenuShellClass BaseClassType;
            virtual ~MenuShell();
        private :
            friend class MenuShell_Class;
            static CppClassType menushell_class_;
            MenuShell(const MenuShell &);
            MenuShell & operator =(const MenuShell &);
        protected :
            explicit MenuShell(const Glib::ConstructParams & construct_params);
            explicit MenuShell(GtkMenuShell * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkMenuShell * gobj()
            {
                return reinterpret_cast<GtkMenuShell * >(gobject_);
            }
            const GtkMenuShell * gobj() const
            {
                return reinterpret_cast<GtkMenuShell * >(gobject_);
            }
        public :
        protected :
            virtual void on_deactivate();
            virtual void on_selection_done();
        private :
        public :
            typedef Menu_Helpers::MenuList MenuList;
            friend class Menu_Helpers::MenuList;
            void append(MenuItem & menu_item);
            void prepend(MenuItem & menu_item);
            void insert(MenuItem & menu_item, int position);
            void select_item(MenuItem & menu_item);
            void deselect();
            void activate_item(MenuItem & menu_item, bool force_deactivate = false);
            void select_first(bool search_sensitive = true);
            void deactivate();
            void cancel();
            Glib::SignalProxy0< void > signal_deactivate();
            Glib::SignalProxy0< void > signal_selection_done();
            Glib::SignalProxy1< gboolean, int > signal_move_selected();
            MenuList & items();
            const MenuList & items() const;
            void accelerate(Window & window);
            void accelerate(Widget & parent);
            bool get_take_focus() const;
            void set_take_focus(bool take_focus = true);
            Glib::PropertyProxy< bool > property_take_focus();
            Glib::PropertyProxy_ReadOnly< bool > property_take_focus() const;
        protected :
            MenuShell();
        private :
            MenuList items_proxy_;
            Gtk::Window * accel_window_;
    };
}
namespace Glib {
    Gtk::MenuShell * wrap(GtkMenuShell * object, bool take_copy = false);
}
typedef struct _GtkMenu GtkMenu;
typedef struct _GtkMenuClass GtkMenuClass;
namespace Gtk {
    class Menu_Class;
}
namespace Gtk {
    class AccelGroup;
    class Menu : public MenuShell
    {
        public :
            typedef Menu CppObjectType;
            typedef Menu_Class CppClassType;
            typedef GtkMenu BaseObjectType;
            typedef GtkMenuClass BaseClassType;
            virtual ~Menu();
        private :
            friend class Menu_Class;
            static CppClassType menu_class_;
            Menu(const Menu &);
            Menu & operator =(const Menu &);
        protected :
            explicit Menu(const Glib::ConstructParams & construct_params);
            explicit Menu(GtkMenu * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkMenu * gobj()
            {
                return reinterpret_cast<GtkMenu * >(gobject_);
            }
            const GtkMenu * gobj() const
            {
                return reinterpret_cast<GtkMenu * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            Menu();
            typedef sigc::slot< void, int &, int &, bool & > SlotPositionCalc;
            void popup(MenuShell & parent_menu_shell, MenuItem & parent_menu_item, const SlotPositionCalc & slot, guint button, guint32 activate_time);
            void popup(const SlotPositionCalc & position_calc_slot, guint button, guint32 activate_time);
            void popup(guint button, guint32 activate_time);
            void reposition();
            void popdown();
            MenuItem * get_active();
            const MenuItem * get_active() const;
            void set_active(guint index);
            void set_accel_group(const Glib::RefPtr< AccelGroup > & accel_group);
            void unset_accel_group();
            Glib::RefPtr< AccelGroup > get_accel_group();
            Glib::RefPtr< const AccelGroup > get_accel_group() const;
            void set_accel_path(const Glib::ustring & accel_path);
            void detach();
            Widget * get_attach_widget();
            const Widget * get_attach_widget() const;
            void set_tearoff_state(bool torn_off = true);
            bool get_tearoff_state() const;
            void set_title(const Glib::ustring & title);
            void unset_title();
            Glib::ustring get_title() const;
            void set_screen(const Glib::RefPtr< Gdk::Screen > & screen);
            void attach(Gtk::Widget & child, guint left_attach, guint right_attach, guint top_attach, guint bottom_attach);
            void set_monitor(int monitor_num);
            void reorder_child(const MenuItem & child, int position);
            Glib::PropertyProxy< Glib::ustring > property_tearoff_title();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_tearoff_title() const;
        protected :
            typedef void (* GtkMenuDetachFunc)(GtkWidget * attach_widget, GtkMenu * menu);
            void attach_to_widget(Widget & attach_widget, GtkMenuDetachFunc detacher);
            void attach_to_widget(Widget & attach_widget);
    };
}
namespace Glib {
    Gtk::Menu * wrap(GtkMenu * object, bool take_copy = false);
}
typedef struct _GtkEntryCompletion GtkEntryCompletion;
typedef struct _GtkEntryCompletionClass GtkEntryCompletionClass;
namespace Gtk {
    class EntryCompletion_Class;
}
namespace Gtk {
    class Entry;
    class EntryCompletion : public Glib::Object
    {
        public :
            typedef EntryCompletion CppObjectType;
            typedef EntryCompletion_Class CppClassType;
            typedef GtkEntryCompletion BaseObjectType;
            typedef GtkEntryCompletionClass BaseClassType;
        private :
            friend class EntryCompletion_Class;
            static CppClassType entrycompletion_class_;
        private :
            EntryCompletion(const EntryCompletion &);
            EntryCompletion & operator =(const EntryCompletion &);
        protected :
            explicit EntryCompletion(const Glib::ConstructParams & construct_params);
            explicit EntryCompletion(GtkEntryCompletion * castitem);
        public :
            virtual ~EntryCompletion();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkEntryCompletion * gobj()
            {
                return reinterpret_cast<GtkEntryCompletion * >(gobject_);
            }
            const GtkEntryCompletion * gobj() const
            {
                return reinterpret_cast<GtkEntryCompletion * >(gobject_);
            }
            GtkEntryCompletion * gobj_copy();
        private :
        protected :
            EntryCompletion();
        public :
            static Glib::RefPtr< EntryCompletion > create();
            Entry * get_entry();
            const Entry * get_entry() const;
            void set_model(const Glib::RefPtr< TreeModel > & model);
            Glib::RefPtr< TreeModel > get_model();
            Glib::RefPtr< const TreeModel > get_model() const;
            typedef sigc::slot< bool, const Glib::ustring &, const TreeModel::const_iterator & > SlotMatch;
            void set_match_func(const SlotMatch & slot);
            void set_minimum_key_length(int length);
            int get_minimum_key_length() const;
            void complete();
            void insert_prefix();
            void insert_action_text(const Glib::ustring & text, int index);
            void prepend_action_text(const Glib::ustring & text);
            void insert_action_markup(const Glib::ustring & markup, int index);
            void prepend_action_markup(const Glib::ustring & markup);
            void delete_action(int index = 0);
            void set_inline_completion(bool inline_completion = true);
            bool get_inline_completion() const;
            void set_inline_selection(bool inline_selection = true);
            bool get_inline_selection() const;
            void set_popup_completion(bool popup_completion = true);
            bool get_popup_completion() const;
            void set_popup_set_width(bool popup_set_width = true);
            bool get_popup_set_width() const;
            void set_popup_single_width(bool popup_single_match = true);
            bool get_popup_single_match() const;
            Glib::ustring get_completion_prefix() const;
            void set_text_column(const TreeModelColumnBase & column);
            void set_text_column(int column);
            int get_text_column();
            Glib::SignalProxy1< void, int > signal_action_activated();
            Glib::SignalProxy1< bool, const TreeModel::iterator & > signal_match_selected();
            Glib::SignalProxy1< bool, const TreeModel::iterator & > signal_cursor_on_match();
            Glib::SignalProxy1< bool, const Glib::ustring & > signal_insert_prefix();
            Glib::PropertyProxy< Glib::RefPtr< Gtk::TreeModel > > property_model();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Gtk::TreeModel > > property_model() const;
            Glib::PropertyProxy< int > property_minimum_key_length();
            Glib::PropertyProxy_ReadOnly< int > property_minimum_key_length() const;
            Glib::PropertyProxy< int > property_text_column();
            Glib::PropertyProxy_ReadOnly< int > property_text_column() const;
            Glib::PropertyProxy< bool > property_inline_completion();
            Glib::PropertyProxy_ReadOnly< bool > property_inline_completion() const;
            Glib::PropertyProxy< bool > property_popup_completion();
            Glib::PropertyProxy_ReadOnly< bool > property_popup_completion() const;
            Glib::PropertyProxy< bool > property_popup_set_width();
            Glib::PropertyProxy_ReadOnly< bool > property_popup_set_width() const;
            Glib::PropertyProxy< bool > property_popup_single_match();
            Glib::PropertyProxy_ReadOnly< bool > property_popup_single_match() const;
            Glib::PropertyProxy< bool > property_inline_selection();
            Glib::PropertyProxy_ReadOnly< bool > property_inline_selection() const;
        protected :
            virtual bool on_match_selected(const TreeModel::iterator & iter);
        public :
        public :
        protected :
            virtual void on_action_activated(int index);
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::EntryCompletion > wrap(GtkEntryCompletion * object, bool take_copy = false);
}
typedef struct _GtkEntry GtkEntry;
typedef struct _GtkEntryClass GtkEntryClass;
namespace Gtk {
    class Entry_Class;
}
namespace Gtk {
    typedef GtkBorder Border;
    class Entry : public Widget, public Editable, public CellEditable
    {
        public :
            typedef Entry CppObjectType;
            typedef Entry_Class CppClassType;
            typedef GtkEntry BaseObjectType;
            typedef GtkEntryClass BaseClassType;
            virtual ~Entry();
        private :
            friend class Entry_Class;
            static CppClassType entry_class_;
            Entry(const Entry &);
            Entry & operator =(const Entry &);
        protected :
            explicit Entry(const Glib::ConstructParams & construct_params);
            explicit Entry(GtkEntry * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkEntry * gobj()
            {
                return reinterpret_cast<GtkEntry * >(gobject_);
            }
            const GtkEntry * gobj() const
            {
                return reinterpret_cast<GtkEntry * >(gobject_);
            }
        public :
        protected :
            virtual void on_populate_popup(Menu * menu);
            virtual void on_insert_at_cursor(const Glib::ustring & str);
            virtual void on_activate();
        private :
        public :
            Entry();
            void set_visibility(bool visible = true);
            bool get_visibility() const;
            void set_invisible_char(gunichar ch);
            gunichar get_invisible_char() const;
            void set_has_frame(bool setting = true);
            bool get_has_frame() const;
            void set_inner_border(const Border & border);
            Border get_inner_border() const;
            void set_max_length(int max);
            int get_max_length() const;
            void set_activates_default(bool setting = true);
            gboolean get_activates_default() const;
            void set_width_chars(int n_chars);
            int get_width_chars() const;
            void set_text(const Glib::ustring & text);
            Glib::ustring get_text() const;
            Glib::RefPtr< Pango::Layout > get_layout();
            Glib::RefPtr< const Pango::Layout > get_layout() const;
            void get_layout_offsets(int & x, int & y);
            int layout_index_to_text_index(int layout_index) const;
            int text_index_to_layout_index(int text_index) const;
            void set_cursor_hadjustment(Adjustment & adjustment);
            Adjustment * get_cursor_hadjustment();
            const Adjustment * get_cursor_hadjustment() const;
            void set_alignment(float xalign);
            void set_alignment(AlignmentEnum xalign);
            float get_alignment() const;
            void set_completion(const Glib::RefPtr< EntryCompletion > & completion);
            Glib::RefPtr< EntryCompletion > get_completion();
            Glib::RefPtr< const EntryCompletion > get_completion() const;
            guint16 get_text_length() const;
            Glib::SignalProxy1< void, Menu * > signal_populate_popup();
            Glib::SignalProxy1< void, const Glib::ustring & > signal_insert_at_cursor();
            Glib::SignalProxy0< void > signal_activate();
            Glib::PropertyProxy_ReadOnly< int > property_cursor_position() const;
            Glib::PropertyProxy_ReadOnly< int > property_selection_bound() const;
            Glib::PropertyProxy< bool > property_editable();
            Glib::PropertyProxy_ReadOnly< bool > property_editable() const;
            Glib::PropertyProxy< int > property_max_length();
            Glib::PropertyProxy_ReadOnly< int > property_max_length() const;
            Glib::PropertyProxy< bool > property_visibility();
            Glib::PropertyProxy_ReadOnly< bool > property_visibility() const;
            Glib::PropertyProxy< bool > property_has_frame();
            Glib::PropertyProxy_ReadOnly< bool > property_has_frame() const;
            Glib::PropertyProxy< gunichar > property_invisible_char();
            Glib::PropertyProxy_ReadOnly< gunichar > property_invisible_char() const;
            Glib::PropertyProxy< bool > property_activates_default();
            Glib::PropertyProxy_ReadOnly< bool > property_activates_default() const;
            Glib::PropertyProxy< int > property_width_chars();
            Glib::PropertyProxy_ReadOnly< int > property_width_chars() const;
            Glib::PropertyProxy_ReadOnly< int > property_scroll_offset() const;
            Glib::PropertyProxy< Glib::ustring > property_text();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_text() const;
            Glib::PropertyProxy< float > property_xalign();
            Glib::PropertyProxy_ReadOnly< float > property_xalign() const;
            Glib::PropertyProxy< bool > property_truncate_multiline();
            Glib::PropertyProxy_ReadOnly< bool > property_truncate_multiline() const;
    };
}
namespace Glib {
    Gtk::Entry * wrap(GtkEntry * object, bool take_copy = false);
}
typedef struct _GtkListItem GtkListItem;
typedef struct _GtkListItemClass GtkListItemClass;
namespace Gtk {
    class ComboDropDownItem_Class;
}
typedef struct _GtkList GtkList;
typedef struct _GtkListClass GtkListClass;
namespace Gtk {
    class ComboDropDown_Class;
}
typedef struct _GtkCombo GtkCombo;
typedef struct _GtkComboClass GtkComboClass;
namespace Gtk {
    class Combo_Class;
}
namespace Gtk {
    class ComboDropDownItem : public Gtk::Item
    {
        public :
            typedef ComboDropDownItem CppObjectType;
            typedef ComboDropDownItem_Class CppClassType;
            typedef GtkListItem BaseObjectType;
            typedef GtkListItemClass BaseClassType;
            virtual ~ComboDropDownItem();
        private :
            friend class ComboDropDownItem_Class;
            static CppClassType combodropdownitem_class_;
            ComboDropDownItem(const ComboDropDownItem &);
            ComboDropDownItem & operator =(const ComboDropDownItem &);
        protected :
            explicit ComboDropDownItem(const Glib::ConstructParams & construct_params);
            explicit ComboDropDownItem(GtkListItem * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkListItem * gobj()
            {
                return reinterpret_cast<GtkListItem * >(gobject_);
            }
            const GtkListItem * gobj() const
            {
                return reinterpret_cast<GtkListItem * >(gobject_);
            }
        public :
        protected :
            virtual void on_scroll_horizontal(ScrollType scroll_type, float position);
            virtual void on_scroll_vertical(ScrollType scroll_type, float position);
        private :
        public :
            ComboDropDownItem();
            Glib::SignalProxy2< void, ScrollType, float > signal_scroll_horizontal();
            Glib::SignalProxy2< void, ScrollType, float > signal_scroll_vertical();
    };
    namespace ComboDropDown_Helpers {
        typedef Gtk::ComboDropDownItem Element;
        class ComboDropDownList : public Glib::HelperList< ComboDropDownItem, const Element, Glib::List_Cpp_Iterator< GtkListItem, ComboDropDownItem > >
        {
            public :
                ComboDropDownList();
                explicit ComboDropDownList(GtkList * gparent);
                ComboDropDownList(const ComboDropDownList & src);
                virtual ~ComboDropDownList()
                {
                }
                ComboDropDownList & operator =(const ComboDropDownList & src);
                typedef Glib::HelperList< ComboDropDownItem, const Element, Glib::List_Cpp_Iterator< GtkListItem, ComboDropDownItem > > type_base;
                GtkList * gparent();
                const GtkList * gparent() const;
                virtual GList * & glist() const;
                virtual void erase(iterator start, iterator stop);
                virtual iterator erase(iterator);
                virtual void remove(const_reference);
                reference operator [](size_type l) const;
            public :
                iterator insert(iterator position, element_type & e);
                template<class InputIterator >
                inline void insert(iterator position, InputIterator first, InputIterator last)
                {
                    for (;
                        first != last;
                        ++first)
                    position = insert(position, *first);
                }
                inline void push_front(element_type & e)
                {
                    insert(begin(), e);
                }
                inline void push_back(element_type & e)
                {
                    insert(end(), e);
                }
                iterator find(const_reference c);
                iterator find(Widget &);
        };
    }
    class Combo;
    class ComboDropDown : public Gtk::Container
    {
        public :
            typedef ComboDropDown CppObjectType;
            typedef ComboDropDown_Class CppClassType;
            typedef GtkList BaseObjectType;
            typedef GtkListClass BaseClassType;
            virtual ~ComboDropDown();
        private :
            friend class ComboDropDown_Class;
            static CppClassType combodropdown_class_;
            ComboDropDown(const ComboDropDown &);
            ComboDropDown & operator =(const ComboDropDown &);
        protected :
            explicit ComboDropDown(const Glib::ConstructParams & construct_params);
            explicit ComboDropDown(GtkList * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkList * gobj()
            {
                return reinterpret_cast<GtkList * >(gobject_);
            }
            const GtkList * gobj() const
            {
                return reinterpret_cast<GtkList * >(gobject_);
            }
        public :
        protected :
            virtual void on_select_child(Widget & item);
            virtual void on_selection_changed();
            virtual void on_unselect_child(Widget & item);
        private :
        public :
            typedef ComboDropDown_Helpers::ComboDropDownList ComboDropDownList;
        protected :
            ComboDropDown();
            friend class Combo;
        public :
            void scroll_horizontal(ScrollType scroll_type, float position);
            void scroll_vertical(ScrollType scroll_type, float position);
            ComboDropDownList & children();
            const ComboDropDownList & children() const;
            Glib::SignalProxy1< void, Widget & > signal_select_child();
            Glib::SignalProxy0< void > signal_selection_changed();
            Glib::SignalProxy1< void, Widget & > signal_unselect_child();
        protected :
            mutable ComboDropDownList children_proxy_;
    };
    class ScrolledWindow;
    class Window;
    class Combo : public HBox
    {
        public :
            typedef Combo CppObjectType;
            typedef Combo_Class CppClassType;
            typedef GtkCombo BaseObjectType;
            typedef GtkComboClass BaseClassType;
            virtual ~Combo();
        private :
            friend class Combo_Class;
            static CppClassType combo_class_;
            Combo(const Combo &);
            Combo & operator =(const Combo &);
        protected :
            explicit Combo(const Glib::ConstructParams & construct_params);
            explicit Combo(GtkCombo * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkCombo * gobj()
            {
                return reinterpret_cast<GtkCombo * >(gobject_);
            }
            const GtkCombo * gobj() const
            {
                return reinterpret_cast<GtkCombo * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            Combo();
            void set_value_in_list(bool value = true, bool empty = false);
            void set_use_arrows(bool arrows_on = true);
            void set_use_arrows_always(bool arrows_always = true);
            void set_case_sensitive(bool val = true);
            void set_item_string(Gtk::Item & item, const Glib::ustring & item_value);
            void remove_item_string(Gtk::Item & item);
            void set_popdown_strings(const Glib::ListHandle< Glib::ustring > & strings);
            Glib::ListHandle< Glib::ustring > get_popdown_strings() const;
            void disable_activate();
            Entry * get_entry();
            const Entry * get_entry() const;
            ComboDropDown * get_list();
            const ComboDropDown * get_list() const;
            Glib::PropertyProxy< bool > property_enable_arrow_keys();
            Glib::PropertyProxy_ReadOnly< bool > property_enable_arrow_keys() const;
            Glib::PropertyProxy< bool > property_enable_arrows_always();
            Glib::PropertyProxy_ReadOnly< bool > property_enable_arrows_always() const;
            Glib::PropertyProxy< bool > property_case_sensitive();
            Glib::PropertyProxy_ReadOnly< bool > property_case_sensitive() const;
            Glib::PropertyProxy< bool > property_allow_empty();
            Glib::PropertyProxy_ReadOnly< bool > property_allow_empty() const;
            Glib::PropertyProxy< bool > property_value_in_list();
            Glib::PropertyProxy_ReadOnly< bool > property_value_in_list() const;
    };
}
namespace Glib {
    Gtk::ComboDropDownItem * wrap(GtkListItem * object, bool take_copy = false);
}
namespace Glib {
    Gtk::ComboDropDown * wrap(GtkList * object, bool take_copy = false);
}
namespace Glib {
    Gtk::Combo * wrap(GtkCombo * object, bool take_copy = false);
}
typedef struct _GtkTreeViewColumn GtkTreeViewColumn;
typedef struct _GtkTreeViewColumnClass GtkTreeViewColumnClass;
namespace Gtk {
    class TreeViewColumn_Class;
}
namespace Gtk {
    enum TreeViewColumnSizing
    {
        TREE_VIEW_COLUMN_GROW_ONLY, 
        TREE_VIEW_COLUMN_AUTOSIZE, 
        TREE_VIEW_COLUMN_FIXED
    };
}
namespace Glib {
    template<>
    class Value< Gtk::TreeViewColumnSizing > : public Glib::Value_Enum< Gtk::TreeViewColumnSizing >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class TreeViewColumn : public Gtk::Object
    {
        public :
            typedef TreeViewColumn CppObjectType;
            typedef TreeViewColumn_Class CppClassType;
            typedef GtkTreeViewColumn BaseObjectType;
            typedef GtkTreeViewColumnClass BaseClassType;
            virtual ~TreeViewColumn();
        private :
            friend class TreeViewColumn_Class;
            static CppClassType treeviewcolumn_class_;
            TreeViewColumn(const TreeViewColumn &);
            TreeViewColumn & operator =(const TreeViewColumn &);
        protected :
            explicit TreeViewColumn(const Glib::ConstructParams & construct_params);
            explicit TreeViewColumn(GtkTreeViewColumn * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTreeViewColumn * gobj()
            {
                return reinterpret_cast<GtkTreeViewColumn * >(gobject_);
            }
            const GtkTreeViewColumn * gobj() const
            {
                return reinterpret_cast<GtkTreeViewColumn * >(gobject_);
            }
        public :
        protected :
            virtual void on_clicked();
        private :
        public :
            typedef TreeViewColumn Column;
            TreeViewColumn();
            explicit TreeViewColumn(const Glib::ustring & title);
            TreeViewColumn(const Glib::ustring & title, CellRenderer & cell);
            template<class T_ModelColumnType >
            TreeViewColumn(const Glib::ustring & title, const TreeModelColumn< T_ModelColumnType > & column);
            void pack_start(CellRenderer & cell, bool expand = true);
            void pack_end(CellRenderer & cell, bool expand = true);
            template<class T_ModelColumnType >
            void pack_start(const TreeModelColumn< T_ModelColumnType > & column, bool expand = true);
            template<class T_ModelColumnType >
            void pack_end(const TreeModelColumn< T_ModelColumnType > & column, bool expand = true);
            void clear();
            CellRenderer * get_first_cell_renderer();
            const CellRenderer * get_first_cell_renderer() const;
            Glib::ListHandle< CellRenderer * > get_cell_renderers();
            Glib::ListHandle< const CellRenderer * > get_cell_renderers() const;
            void add_attribute(CellRenderer & cell_renderer, const Glib::ustring & attribute, int column);
            void add_attribute(const Glib::PropertyProxy_Base & property, const TreeModelColumnBase & column);
            void add_attribute(Gtk::CellRenderer & cell, const Glib::ustring & property_name, const TreeModelColumnBase & column);
            void set_renderer(Gtk::CellRenderer & renderer, const TreeModelColumnBase & column);
            typedef sigc::slot< void, CellRenderer *, const Gtk::TreeModel::iterator & > SlotCellData;
            void set_cell_data_func(CellRenderer & cell_renderer, const SlotCellData & slot);
            void unset_cell_data_func(CellRenderer & cell_renderer);
            void clear_attributes(CellRenderer & cell_renderer);
            void set_spacing(int spacing);
            int get_spacing() const;
            void set_visible(bool visible = true);
            bool get_visible() const;
            void set_resizable(bool resizable = true);
            bool get_resizable() const;
            void set_sizing(TreeViewColumnSizing type);
            TreeViewColumnSizing get_sizing();
            int get_width() const;
            int get_fixed_width() const;
            void set_fixed_width(int fixed_width);
            void set_min_width(int min_width);
            int get_min_width() const;
            void set_max_width(int max_width);
            int get_max_width() const;
            void clicked();
            void set_title(const Glib::ustring & title);
            Glib::ustring get_title() const;
            void set_expand(bool expand = true);
            bool get_expand() const;
            void set_clickable(bool clickable = true);
            bool get_clickable() const;
            void set_widget(Gtk::Widget & widget);
            Widget * get_widget();
            const Widget * get_widget() const;
            void set_alignment(float xalign);
            void set_alignment(AlignmentEnum xalign);
            float get_alignment() const;
            void set_reorderable(bool reorderable = true);
            bool get_reorderable() const;
            void set_sort_column(const TreeModelColumnBase & sort_column_id);
            void set_sort_column(int sort_column_id);
            void set_sort_column_id(const TreeModelColumnBase & sort_column_id);
            void set_sort_column_id(int sort_column_id);
            int get_sort_column_id() const;
            void set_sort_indicator(bool setting);
            bool get_sort_indicator() const;
            void set_sort_order(SortType order);
            SortType get_sort_order() const;
            void cell_set_cell_data(const Glib::RefPtr< TreeModel > & tree_model, const TreeModel::iterator & iter, bool is_expander, bool is_expanded);
            void cell_get_size(Gdk::Rectangle & cell_area, int & x_offset, int & y_offset, int & width, int & height) const;
            bool cell_is_visible() const;
            void focus_cell(CellRenderer & cell);
            bool get_cell_position(const CellRenderer & cell_renderer, int & start_pos, int & width) const;
            void queue_resize();
            Glib::SignalProxy0< void > signal_clicked();
            Glib::PropertyProxy< bool > property_visible();
            Glib::PropertyProxy_ReadOnly< bool > property_visible() const;
            Glib::PropertyProxy_ReadOnly< int > property_width() const;
            Glib::PropertyProxy< TreeViewColumnSizing > property_sizing();
            Glib::PropertyProxy_ReadOnly< TreeViewColumnSizing > property_sizing() const;
            Glib::PropertyProxy< int > property_fixed_width();
            Glib::PropertyProxy_ReadOnly< int > property_fixed_width() const;
            Glib::PropertyProxy< int > property_min_width();
            Glib::PropertyProxy_ReadOnly< int > property_min_width() const;
            Glib::PropertyProxy< int > property_max_width();
            Glib::PropertyProxy_ReadOnly< int > property_max_width() const;
            Glib::PropertyProxy< Glib::ustring > property_title();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_title() const;
            Glib::PropertyProxy< bool > property_expand();
            Glib::PropertyProxy_ReadOnly< bool > property_expand() const;
            Glib::PropertyProxy< bool > property_clickable();
            Glib::PropertyProxy_ReadOnly< bool > property_clickable() const;
            Glib::PropertyProxy< Widget * > property_widget();
            Glib::PropertyProxy_ReadOnly< Widget * > property_widget() const;
            Glib::PropertyProxy< float > property_alignment();
            Glib::PropertyProxy_ReadOnly< float > property_alignment() const;
            Glib::PropertyProxy< bool > property_reorderable();
            Glib::PropertyProxy_ReadOnly< bool > property_reorderable() const;
            Glib::PropertyProxy< bool > property_sort_indicator();
            Glib::PropertyProxy_ReadOnly< bool > property_sort_indicator() const;
            Glib::PropertyProxy< SortType > property_sort_order();
            Glib::PropertyProxy_ReadOnly< SortType > property_sort_order() const;
        private :
            static const Glib::Class & class_init_();
    };
    template<class T_ModelColumnType >
    inline void TreeViewColumn::pack_start(const TreeModelColumn< T_ModelColumnType > & column, bool expand)
    {
        CellRenderer * pCellRenderer = manage(CellRenderer_Generation::generate_cellrenderer< T_ModelColumnType >());
        pack_start(*pCellRenderer, expand);
        set_renderer(*pCellRenderer, column);
    }
    template<class T_ModelColumnType >
    inline void TreeViewColumn::pack_end(const TreeModelColumn< T_ModelColumnType > & column, bool expand)
    {
        CellRenderer * pCellRenderer = manage(CellRenderer_Generation::generate_cellrenderer< T_ModelColumnType >());
        pack_end(*pCellRenderer, expand);
        set_renderer(*pCellRenderer, column);
    }
    template<class T_ModelColumnType >
    inline TreeViewColumn::TreeViewColumn(const Glib::ustring & title, const TreeModelColumn< T_ModelColumnType > & column)
        : Glib::ObjectBase(0), Gtk::Object(Glib::ConstructParams(class_init_(), "title", title.c_str(), (char *) 0)) 
    {
        pack_start(column, true);
    }
}
namespace Glib {
    Gtk::TreeViewColumn * wrap(GtkTreeViewColumn * object, bool take_copy = false);
}
typedef struct _GtkTreeSelection GtkTreeSelection;
typedef struct _GtkTreeSelectionClass GtkTreeSelectionClass;
namespace Gtk {
    class TreeSelection_Class;
}
namespace Gtk {
    class TreeView;
    class TreeModel;
    class TreePath;
    class TreeSelection : public Glib::Object
    {
        public :
            typedef TreeSelection CppObjectType;
            typedef TreeSelection_Class CppClassType;
            typedef GtkTreeSelection BaseObjectType;
            typedef GtkTreeSelectionClass BaseClassType;
        private :
            friend class TreeSelection_Class;
            static CppClassType treeselection_class_;
        private :
            TreeSelection(const TreeSelection &);
            TreeSelection & operator =(const TreeSelection &);
        protected :
            explicit TreeSelection(const Glib::ConstructParams & construct_params);
            explicit TreeSelection(GtkTreeSelection * castitem);
        public :
            virtual ~TreeSelection();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTreeSelection * gobj()
            {
                return reinterpret_cast<GtkTreeSelection * >(gobject_);
            }
            const GtkTreeSelection * gobj() const
            {
                return reinterpret_cast<GtkTreeSelection * >(gobject_);
            }
            GtkTreeSelection * gobj_copy();
        private :
        protected :
        public :
            void set_mode(SelectionMode type);
            SelectionMode get_mode() const;
            typedef sigc::slot< bool, const Glib::RefPtr< TreeModel > &, const TreeModel::Path &, bool > SlotSelect;
            void set_select_function(const SlotSelect & slot);
            TreeView * get_tree_view();
            const TreeView * get_tree_view() const;
            Glib::RefPtr< TreeModel > get_model();
            Glib::RefPtr< const TreeModel > get_model() const;
            TreeModel::iterator get_selected();
            TreeModel::iterator get_selected(Glib::RefPtr< TreeModel > & model);
            typedef Glib::ListHandle< TreeModel::Path, TreePath_Traits > ListHandle_Path;
            ListHandle_Path get_selected_rows() const;
            ListHandle_Path get_selected_rows(Glib::RefPtr< TreeModel > & model);
            int count_selected_rows() const;
            typedef sigc::slot< void, const TreeModel::iterator & > SlotForeachIter;
            void selected_foreach_iter(const SlotForeachIter & slot) const;
            typedef sigc::slot< void, const TreeModel::Path & > SlotForeachPath;
            void selected_foreach_path(const SlotForeachPath & slot) const;
            typedef sigc::slot< void, const TreeModel::Path &, const TreeModel::iterator & > SlotForeachPathAndIter;
            void selected_foreach(const SlotForeachPathAndIter & slot) const;
            void select(const TreeModel::Path & path);
            void select(const TreeModel::iterator & iter);
            void select(const TreeModel::Row & row);
            void select(const TreeModel::Path & start_path, const TreeModel::Path & end_path);
            void unselect(const TreeModel::Path & path);
            void unselect(const TreeModel::Path & start_path, const TreeModel::Path & end_path);
            void unselect(const TreeModel::iterator & iter);
            bool is_selected(const TreeModel::Path & path) const;
            bool is_selected(const TreeModel::iterator & iter) const;
            void select_all();
            void unselect_all();
            Glib::SignalProxy0< void > signal_changed();
        public :
        public :
        protected :
            virtual void on_changed();
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::TreeSelection > wrap(GtkTreeSelection * object, bool take_copy = false);
}
typedef struct _GtkTooltip GtkTooltip;
typedef struct _GtkTooltipClass GtkTooltipClass;
namespace Gtk {
    class Tooltip_Class;
}
namespace Gtk {
    class Tooltip : public Glib::Object
    {
        protected :
        public :
            typedef Tooltip CppObjectType;
            typedef Tooltip_Class CppClassType;
            typedef GtkTooltip BaseObjectType;
            typedef GtkTooltipClass BaseClassType;
        private :
            friend class Tooltip_Class;
            static CppClassType tooltip_class_;
        private :
            Tooltip(const Tooltip &);
            Tooltip & operator =(const Tooltip &);
        protected :
            explicit Tooltip(const Glib::ConstructParams & construct_params);
            explicit Tooltip(GtkTooltip * castitem);
        public :
            virtual ~Tooltip();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTooltip * gobj()
            {
                return reinterpret_cast<GtkTooltip * >(gobject_);
            }
            const GtkTooltip * gobj() const
            {
                return reinterpret_cast<GtkTooltip * >(gobject_);
            }
            GtkTooltip * gobj_copy();
        private :
        public :
            void set_markup(const Glib::ustring & markup);
            void set_text(const Glib::ustring & markup);
            void set_icon(const Glib::RefPtr< Gdk::Pixbuf > & pixbuf);
            void set_icon_from_stock(const StockID & stock_id, IconSize size);
            void set_custom(Widget & custom_widget);
            void set_tip_area(const Gdk::Rectangle & rect);
            static void trigger_tooltip_query(const Glib::RefPtr< Gdk::Display > & display);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::Tooltip > wrap(GtkTooltip * object, bool take_copy = false);
}
using std::strtod;
typedef struct _GtkTreeView GtkTreeView;
typedef struct _GtkTreeViewClass GtkTreeViewClass;
namespace Gtk {
    class TreeView_Class;
}
namespace Gtk {
    enum TreeViewDropPosition
    {
        TREE_VIEW_DROP_BEFORE, 
        TREE_VIEW_DROP_AFTER, 
        TREE_VIEW_DROP_INTO_OR_BEFORE, 
        TREE_VIEW_DROP_INTO_OR_AFTER
    };
}
namespace Glib {
    template<>
    class Value< Gtk::TreeViewDropPosition > : public Glib::Value_Enum< Gtk::TreeViewDropPosition >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum TreeViewGridLines
    {
        TREE_VIEW_GRID_LINES_NONE, 
        TREE_VIEW_GRID_LINES_HORIZONTAL, 
        TREE_VIEW_GRID_LINES_VERTICAL, 
        TREE_VIEW_GRID_LINES_BOTH
    };
}
namespace Glib {
    template<>
    class Value< Gtk::TreeViewGridLines > : public Glib::Value_Enum< Gtk::TreeViewGridLines >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class TreeView;
    namespace TreeView_Private {
        template<class ColumnType >
        inline void _connect_auto_store_editable_signal_handler(Gtk::TreeView * this_p, Gtk::CellRenderer * pCellRenderer, const Gtk::TreeModelColumn< ColumnType > & model_column);
        template<class ColumnType >
        inline void _auto_store_on_cellrenderer_text_edited_string(const Glib::ustring & path_string, const Glib::ustring & new_text, int model_column, const Glib::RefPtr< Gtk::TreeModel > & model);
        template<class ColumnType >
        inline void _auto_store_on_cellrenderer_text_edited_numerical(const Glib::ustring & path_string, const Glib::ustring & new_text, int model_column, const Glib::RefPtr< Gtk::TreeModel > & model);
        template<class ColumnType >
        inline void _auto_cell_data_func(Gtk::CellRenderer * cell, const Gtk::TreeModel::iterator & iter, int model_column, const Glib::ustring & format);
    }
    class TreeModel;
    class TreeView : public Container
    {
        public :
            typedef TreeView CppObjectType;
            typedef TreeView_Class CppClassType;
            typedef GtkTreeView BaseObjectType;
            typedef GtkTreeViewClass BaseClassType;
            virtual ~TreeView();
        private :
            friend class TreeView_Class;
            static CppClassType treeview_class_;
            TreeView(const TreeView &);
            TreeView & operator =(const TreeView &);
        protected :
            explicit TreeView(const Glib::ConstructParams & construct_params);
            explicit TreeView(GtkTreeView * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTreeView * gobj()
            {
                return reinterpret_cast<GtkTreeView * >(gobject_);
            }
            const GtkTreeView * gobj() const
            {
                return reinterpret_cast<GtkTreeView * >(gobject_);
            }
        public :
        protected :
            virtual void on_set_scroll_adjustments(Adjustment * hadjustment, Adjustment * vadjustment);
            virtual void on_row_activated(const TreeModel::Path & path, TreeViewColumn * column);
            virtual bool on_test_expand_row(const TreeModel::iterator & iter, const TreeModel::Path & path);
            virtual bool on_test_collapse_row(const TreeModel::iterator & iter, const TreeModel::Path & path);
            virtual void on_row_expanded(const TreeModel::iterator & iter, const TreeModel::Path & path);
            virtual void on_row_collapsed(const TreeModel::iterator & iter, const TreeModel::Path & path);
            virtual void on_cursor_changed();
            virtual void on_columns_changed();
        private :
        public :
            typedef TreeViewColumn Column;
            typedef TreeSelection Selection;
            TreeView();
            explicit TreeView(const Glib::RefPtr< TreeModel > & model);
            Glib::RefPtr< TreeModel > get_model();
            Glib::RefPtr< const TreeModel > get_model() const;
            void set_model(const Glib::RefPtr< TreeModel > & model);
            void unset_model();
            Glib::RefPtr< TreeSelection > get_selection();
            Glib::RefPtr< const TreeSelection > get_selection() const;
            Adjustment * get_hadjustment();
            const Adjustment * get_hadjustment() const;
            void set_hadjustment(Adjustment & adjustment);
            void unset_hadjustment();
            Adjustment * get_vadjustment();
            const Adjustment * get_vadjustment() const;
            void set_vadjustment(Adjustment & adjustment);
            void unset_vadjustment();
            bool get_headers_visible() const;
            void set_headers_visible(bool headers_visible);
            void columns_autosize();
            bool get_headers_clickable() const;
            void set_headers_clickable(bool setting = true);
            void set_rules_hint(bool setting = true);
            bool get_rules_hint() const;
            int append_column(TreeViewColumn & column);
            template<class ColumnType >
            inline int append_column(const Glib::ustring & title, const TreeModelColumn< ColumnType > & model_column);
            template<class ColumnType >
            inline int append_column_numeric(const Glib::ustring & title, const TreeModelColumn< ColumnType > & model_column, const Glib::ustring & format);
            template<class ColumnType >
            inline int append_column_editable(const Glib::ustring & title, const TreeModelColumn< ColumnType > & model_column);
            template<class ColumnType >
            inline int append_column_numeric_editable(const Glib::ustring & title, const TreeModelColumn< ColumnType > & model_column, const Glib::ustring & format);
            int append_column(const Glib::ustring & title, CellRenderer & cell);
            int remove_column(TreeViewColumn & column);
            void remove_all_columns();
            int insert_column(TreeViewColumn & column, int position);
            int insert_column(const Glib::ustring & title, CellRenderer & cell, int position);
            template<class ColumnType >
            inline int insert_column(const Glib::ustring & title, const TreeModelColumn< ColumnType > & model_column, int position);
            template<class ColumnType >
            inline int insert_column_editable(const Glib::ustring & title, const TreeModelColumn< ColumnType > & model_column, int position);
            typedef TreeViewColumn::SlotCellData SlotCellData;
            int insert_column_with_data_func(int position, const Glib::ustring & title, CellRenderer & cell, const SlotCellData & slot);
            TreeViewColumn * get_column(int n);
            const TreeViewColumn * get_column(int n) const;
            CellRenderer * get_column_cell_renderer(int n);
            const CellRenderer * get_column_cell_renderer(int n) const;
            Glib::ListHandle< TreeViewColumn * > get_columns();
            Glib::ListHandle< const TreeViewColumn * > get_columns() const;
            void move_column_after(TreeViewColumn & column, TreeViewColumn & base_column);
            void move_column_to_start(TreeViewColumn & column);
            void set_expander_column(TreeViewColumn & column);
            void reset_expander_column();
            TreeViewColumn * get_expander_column();
            const TreeViewColumn * get_expander_column() const;
            typedef sigc::slot< bool, TreeView *, TreeViewColumn *, TreeViewColumn *, TreeViewColumn * > SlotColumnDrop;
            void set_column_drag_function(const SlotColumnDrop & slot);
            void unset_column_drag_function();
            void scroll_to_point(int tree_x, int tree_y);
            void scroll_to_cell(const TreeModel::Path & path, TreeViewColumn & column, float row_align, float col_align);
            void scroll_to_cell(const TreeModel::Path & path, TreeViewColumn & column);
            void scroll_to_row(const TreeModel::Path & path, float row_align);
            void scroll_to_row(const TreeModel::Path & path);
            void scroll_to_column(TreeViewColumn & column, float col_align);
            void scroll_to_column(TreeViewColumn & column);
            void row_activated(const TreeModel::Path & path, TreeViewColumn & column);
            void expand_all();
            void collapse_all();
            void expand_to_path(const TreeModel::Path & path);
            bool expand_row(const TreeModel::Path & path, bool open_all);
            bool collapse_row(const TreeModel::Path & path);
            typedef sigc::slot< void, TreeView *, const TreeModel::Path & > SlotMapping;
            void map_expanded_rows(const SlotMapping & slot);
            bool row_expanded(const TreeModel::Path & path);
            void set_reorderable(bool reorderable = true);
            bool get_reorderable() const;
            void set_cursor(const TreeModel::Path & path, TreeViewColumn & focus_column, bool start_editing = false);
            void set_cursor(const TreeModel::Path & path, TreeViewColumn & focus_column, CellRenderer & focus_cell, bool start_editing = false);
            void set_cursor(const TreeModel::Path & path);
            void get_cursor(TreeModel::Path & path, TreeViewColumn * & focus_column);
            Glib::RefPtr< Gdk::Window > get_bin_window();
            Glib::RefPtr< const Gdk::Window > get_bin_window() const;
            bool get_path_at_pos(int x, int y, TreeModel::Path & path, TreeViewColumn * & column, int & cell_x, int & cell_y);
            bool get_path_at_pos(int x, int y, TreeModel::Path & path, TreeViewColumn * & column, int & cell_x, int & cell_y) const;
            void get_cell_area(const TreeModel::Path & path, TreeViewColumn & column, Gdk::Rectangle & rect);
            void get_cell_area(const TreeModel::Path & path, TreeViewColumn & column, Gdk::Rectangle & rect) const;
            void get_background_area(const TreeModel::Path & path, TreeViewColumn & column, Gdk::Rectangle & rect);
            void get_background_area(const TreeModel::Path & path, TreeViewColumn & column, Gdk::Rectangle & rect) const;
            void get_visible_rect(Gdk::Rectangle & visible_rect);
            void get_visible_rect(Gdk::Rectangle & visible_rect) const;
            void widget_to_tree_coords(int wx, int wy, int & tx, int & ty);
            void widget_to_tree_coords(int wx, int wy, int & tx, int & ty) const;
            void tree_to_widget_coords(int tx, int ty, int & wx, int & wy);
            void tree_to_widget_coords(int tx, int ty, int & wx, int & wy) const;
            bool get_visible_range(TreeModel::Path & start_path, TreeModel::Path & end_path) const;
            void enable_model_drag_source(const ArrayHandle_TargetEntry & targets, Gdk::ModifierType start_button_mask = Gdk::MODIFIER_MASK, Gdk::DragAction actions = Gdk::ACTION_COPY | Gdk::ACTION_MOVE);
            void enable_model_drag_source(Gdk::ModifierType start_button_mask = Gdk::MODIFIER_MASK, Gdk::DragAction actions = Gdk::ACTION_COPY | Gdk::ACTION_MOVE);
            void enable_model_drag_dest(const ArrayHandle_TargetEntry & targets, Gdk::DragAction actions = Gdk::ACTION_COPY | Gdk::ACTION_MOVE);
            void enable_model_drag_dest(Gdk::DragAction actions = Gdk::ACTION_COPY | Gdk::ACTION_MOVE);
            void unset_rows_drag_source();
            void unset_rows_drag_dest();
            void set_drag_dest_row(const TreeModel::Path & path, TreeViewDropPosition pos);
            void get_drag_dest_row(TreeModel::Path & path, TreeViewDropPosition & pos) const;
            bool get_dest_row_at_pos(int drag_x, int drag_y, TreeModel::Path & path, TreeViewDropPosition & pos) const;
            Glib::RefPtr< Gdk::Pixmap > create_row_drag_icon(const TreeModel::Path & path);
            void set_enable_search(bool enable_search = true);
            bool get_enable_search() const;
            int get_search_column() const;
            void set_search_column(const TreeModelColumnBase & column);
            void set_search_column(int column);
            typedef sigc::slot< bool, const Glib::RefPtr< TreeModel > &, int, const Glib::ustring &, const TreeModel::iterator & > SlotSearchEqual;
            void set_search_equal_func(const SlotSearchEqual & slot);
            Entry * get_search_entry();
            const Entry * get_search_entry() const;
            void set_search_entry(Entry & entry);
            typedef sigc::slot< void, Gtk::Widget * > SlotSearchPosition;
            void set_search_position_func(const SlotSearchPosition & slot);
            void convert_widget_to_tree_coords(int wx, int wy, int & tx, int & ty) const;
            void convert_tree_to_widget_coords(int tx, int ty, int & wx, int & wy) const;
            void convert_widget_to_bin_window_coords(int wx, int wy, int & bx, int & by) const;
            void convert_bin_window_to_widget_coords(int bx, int by, int & wx, int & wy) const;
            void convert_tree_to_bin_window_coords(int tx, int ty, int & bx, int & by) const;
            void convert_bin_window_to_tree_coords(int bx, int by, int & tx, int & ty) const;
            void set_fixed_height_mode(bool enable = true);
            bool get_fixed_height_mode() const;
            void set_hover_selection(bool hover = true);
            bool get_hover_selection() const;
            void set_hover_expand(bool expand = true);
            bool get_hover_expand() const;
            void set_rubber_banding(bool enable = true);
            bool get_rubber_banding() const;
            bool is_rubber_banding_active() const;
            typedef sigc::slot< bool, const Glib::RefPtr< TreeModel > &, const TreeModel::iterator & > SlotRowSeparator;
            void set_row_separator_func(const SlotRowSeparator & slot);
            void set_grid_lines(TreeViewGridLines grid_lines);
            TreeViewGridLines get_grid_lines() const;
            void set_enable_tree_lines(bool enable = true);
            bool get_enable_tree_lines() const;
            void set_show_expanders(bool enabled = true);
            bool get_show_expanders() const;
            void set_level_indentation(int indentation);
            int get_level_indentation() const;
            void set_tooltip_row(const Glib::RefPtr< Tooltip > & tooltip, const TreePath & path);
            void set_tooltip_cell(const Glib::RefPtr< Tooltip > & tooltip, const TreeModel::Path * path, TreeViewColumn * column, CellRenderer * cell);
            bool get_tooltip_context_path(int & x, int & y, bool keyboard_tip, TreeModel::Path & path);
            bool get_tooltip_context_iter(int & x, int & y, bool keyboard_tip, Gtk::TreeModel::iterator & iter);
            void set_tooltip_column(int column);
            int get_tooltip_column() const;
            Glib::SignalProxy2< void, Adjustment *, Adjustment * > signal_set_scroll_adjustments();
            Glib::SignalProxy2< void, const TreeModel::Path &, TreeViewColumn * > signal_row_activated();
            Glib::SignalProxy2< bool, const TreeModel::iterator &, const TreeModel::Path & > signal_test_expand_row();
            Glib::SignalProxy2< bool, const TreeModel::iterator &, const TreeModel::Path & > signal_test_collapse_row();
            Glib::SignalProxy2< void, const TreeModel::iterator &, const TreeModel::Path & > signal_row_expanded();
            Glib::SignalProxy2< void, const TreeModel::iterator &, const TreeModel::Path & > signal_row_collapsed();
            Glib::SignalProxy0< void > signal_cursor_changed();
            Glib::SignalProxy0< void > signal_columns_changed();
            Glib::PropertyProxy< Glib::RefPtr< TreeModel > > property_model();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< TreeModel > > property_model() const;
            Glib::PropertyProxy< Adjustment * > property_hadjustment();
            Glib::PropertyProxy_ReadOnly< Adjustment * > property_hadjustment() const;
            Glib::PropertyProxy< Adjustment * > property_vadjustment();
            Glib::PropertyProxy_ReadOnly< Adjustment * > property_vadjustment() const;
            Glib::PropertyProxy< bool > property_headers_visible();
            Glib::PropertyProxy_ReadOnly< bool > property_headers_visible() const;
            Glib::PropertyProxy< bool > property_headers_clickable();
            Glib::PropertyProxy_ReadOnly< bool > property_headers_clickable() const;
            Glib::PropertyProxy< TreeViewColumn * > property_expander_column();
            Glib::PropertyProxy_ReadOnly< TreeViewColumn * > property_expander_column() const;
            Glib::PropertyProxy< bool > property_reorderable();
            Glib::PropertyProxy_ReadOnly< bool > property_reorderable() const;
            Glib::PropertyProxy< bool > property_rules_hint();
            Glib::PropertyProxy_ReadOnly< bool > property_rules_hint() const;
            Glib::PropertyProxy< bool > property_enable_search();
            Glib::PropertyProxy_ReadOnly< bool > property_enable_search() const;
            Glib::PropertyProxy< int > property_search_column();
            Glib::PropertyProxy_ReadOnly< int > property_search_column() const;
            Glib::PropertyProxy< bool > property_fixed_height_mode();
            Glib::PropertyProxy_ReadOnly< bool > property_fixed_height_mode() const;
            Glib::PropertyProxy< bool > property_hover_selection();
            Glib::PropertyProxy_ReadOnly< bool > property_hover_selection() const;
            Glib::PropertyProxy< bool > property_hover_expand();
            Glib::PropertyProxy_ReadOnly< bool > property_hover_expand() const;
            Glib::PropertyProxy< bool > property_show_expanders();
            Glib::PropertyProxy_ReadOnly< bool > property_show_expanders() const;
            Glib::PropertyProxy< bool > property_level_indentation();
            Glib::PropertyProxy_ReadOnly< bool > property_level_indentation() const;
            Glib::PropertyProxy< bool > property_rubber_banding();
            Glib::PropertyProxy_ReadOnly< bool > property_rubber_banding() const;
            Glib::PropertyProxy< bool > property_enable_grid_lines();
            Glib::PropertyProxy_ReadOnly< bool > property_enable_grid_lines() const;
            Glib::PropertyProxy< bool > property_enable_tree_lines();
            Glib::PropertyProxy_ReadOnly< bool > property_enable_tree_lines() const;
            Glib::RefPtr< Gtk::TreeModel > _get_base_model();
        protected :
            template<class ColumnType >
            friend void _auto_store_on_cellrenderer_text_edited_string(const Glib::ustring & path_string, const Glib::ustring & new_text, int model_column, const Glib::RefPtr< Gtk::TreeModel > & model);
            template<class ColumnType >
            friend void _auto_store_on_cellrenderer_text_edited_numerical(const Glib::ustring & path_string, const Glib::ustring & new_text, int model_column, const Glib::RefPtr< Gtk::TreeModel > & model);
            void _auto_store_on_cellrenderer_toggle_edited_with_model(const Glib::ustring & path_string, int model_column, const Glib::RefPtr< Gtk::TreeModel > & model);
            void _auto_store_on_cellrenderer_toggle_edited(const Glib::ustring & path_string, int model_column);
            template<class ColumnType >
            friend void TreeView_Private::_connect_auto_store_editable_signal_handler(TreeView *, CellRenderer *, const TreeModelColumn< ColumnType > &);
    };
    template<class ColumnType >
    inline int TreeView::append_column(const Glib::ustring & title, const TreeModelColumn< ColumnType > & model_column)
    {
        TreeViewColumn *const pViewColumn = Gtk::manage(new TreeViewColumn (title, model_column));
        return append_column(*pViewColumn);
    }
    template<class ColumnType >
    inline int TreeView::append_column_numeric(const Glib::ustring & title, const TreeModelColumn< ColumnType > & model_column, const Glib::ustring & format)
    {
        TreeViewColumn *const pViewColumn = Gtk::manage(new TreeViewColumn (title));
        CellRenderer * pCellRenderer = manage(new CellRendererText ());
        pViewColumn->pack_start(*pCellRenderer);
        typedef void (* type_fptr)(Gtk::CellRenderer * cell, const Gtk::TreeModel::iterator & iter, int model_column, const Glib::ustring & format);
        type_fptr fptr = TreeView_Private::_auto_cell_data_func< ColumnType >;
        Gtk::TreeViewColumn::SlotCellData slot = sigc::bind< -1 >(sigc::bind< -1 >(sigc::ptr_fun(fptr), format), model_column.index());
        pViewColumn->set_cell_data_func(*pCellRenderer, slot);
        return append_column(*pViewColumn);
    }
    template<class ColumnType >
    inline int TreeView::append_column_numeric_editable(const Glib::ustring & title, const TreeModelColumn< ColumnType > & model_column, const Glib::ustring & format)
    {
        int cols_count = append_column_numeric(title, model_column, format);
        CellRenderer *const cell = get_column_cell_renderer(cols_count - 1);
        if (cell)
        {
            TreeView_Private::_connect_auto_store_editable_signal_handler< ColumnType >(this, cell, model_column);
        }
        return cols_count;
    }
    template<class ColumnType >
    inline int TreeView::append_column_editable(const Glib::ustring & title, const TreeModelColumn< ColumnType > & model_column)
    {
        TreeViewColumn *const pViewColumn = Gtk::manage(new TreeViewColumn (title, model_column));
        CellRenderer * pCellRender = pViewColumn->get_first_cell_renderer();
        TreeView_Private::_connect_auto_store_editable_signal_handler< ColumnType >(this, pCellRender, model_column);
        return append_column(*pViewColumn);
    }
    template<class ColumnType >
    inline int TreeView::insert_column(const Glib::ustring & title, const TreeModelColumn< ColumnType > & model_column, int position)
    {
        TreeViewColumn *const pViewColumn = Gtk::manage(new TreeViewColumn (title, model_column));
        return insert_column(*pViewColumn, position);
    }
    template<class ColumnType >
    inline int TreeView::insert_column_editable(const Glib::ustring & title, const TreeModelColumn< ColumnType > & model_column, int position)
    {
        TreeViewColumn *const pViewColumn = Gtk::manage(new TreeViewColumn (title, model_column));
        CellRenderer * pCellRender = pViewColumn->get_first_cell_renderer();
        TreeView_Private::_connect_auto_store_editable_signal_handler(this, pCellRender, model_column);
        return insert_column(*pViewColumn, position);
    }
    namespace TreeView_Private {
        template<>
        inline void _connect_auto_store_editable_signal_handler(Gtk::TreeView * this_p, Gtk::CellRenderer * pCellRenderer, const Gtk::TreeModelColumn< bool > & model_column)
        {
            Gtk::CellRendererToggle * pCellToggle = dynamic_cast<Gtk::CellRendererToggle * >(pCellRenderer);
            if (pCellToggle)
            {
                pCellToggle->property_activatable() = true;
                sigc::slot< void, const Glib::ustring &, int > slot_temp = sigc::bind< -1 >(sigc::mem_fun(*this_p, &Gtk::TreeView::_auto_store_on_cellrenderer_toggle_edited_with_model), this_p->_get_base_model());
                pCellToggle->signal_toggled().connect(sigc::bind< -1 >(slot_temp, model_column.index()));
            }
        }
        template<>
        inline void _connect_auto_store_editable_signal_handler(Gtk::TreeView * this_p, Gtk::CellRenderer * pCellRenderer, const Gtk::TreeModelColumn< int > & model_column)
        {
            Gtk::CellRendererText * pCellText = dynamic_cast<Gtk::CellRendererText * >(pCellRenderer);
            if (pCellText)
            {
                pCellText->property_editable() = true;
                typedef void (* type_fptr)(const Glib::ustring & path_string, const Glib::ustring & new_text, int model_column, const Glib::RefPtr< Gtk::TreeModel > & model);
                type_fptr fptr = _auto_store_on_cellrenderer_text_edited_numerical< int >;
                pCellText->signal_edited().connect(sigc::bind< -1 >(sigc::bind< -1 >(sigc::ptr_fun(fptr), this_p->_get_base_model()), model_column.index()));
            }
        }
        template<>
        inline void _connect_auto_store_editable_signal_handler(Gtk::TreeView * this_p, Gtk::CellRenderer * pCellRenderer, const Gtk::TreeModelColumn< unsigned int > & model_column)
        {
            Gtk::CellRendererText * pCellText = dynamic_cast<Gtk::CellRendererText * >(pCellRenderer);
            if (pCellText)
            {
                pCellText->property_editable() = true;
                typedef void (* type_fptr)(const Glib::ustring & path_string, const Glib::ustring & new_text, int model_column, const Glib::RefPtr< Gtk::TreeModel > & model);
                type_fptr fptr = _auto_store_on_cellrenderer_text_edited_numerical< unsigned int >;
                pCellText->signal_edited().connect(sigc::bind< -1 >(sigc::bind< -1 >(sigc::ptr_fun(fptr), this_p->_get_base_model()), model_column.index()));
            }
        }
        template<>
        inline void _connect_auto_store_editable_signal_handler(Gtk::TreeView * this_p, Gtk::CellRenderer * pCellRenderer, const Gtk::TreeModelColumn< long > & model_column)
        {
            Gtk::CellRendererText * pCellText = dynamic_cast<Gtk::CellRendererText * >(pCellRenderer);
            if (pCellText)
            {
                pCellText->property_editable() = true;
                typedef void (* type_fptr)(const Glib::ustring & path_string, const Glib::ustring & new_text, int model_column, const Glib::RefPtr< Gtk::TreeModel > & model);
                type_fptr fptr = _auto_store_on_cellrenderer_text_edited_numerical< long >;
                pCellText->signal_edited().connect(sigc::bind< -1 >(sigc::bind< -1 >(sigc::ptr_fun(fptr), this_p->_get_base_model()), model_column.index()));
            }
        }
        template<>
        inline void _connect_auto_store_editable_signal_handler(Gtk::TreeView * this_p, Gtk::CellRenderer * pCellRenderer, const Gtk::TreeModelColumn< unsigned long > & model_column)
        {
            Gtk::CellRendererText * pCellText = dynamic_cast<Gtk::CellRendererText * >(pCellRenderer);
            if (pCellText)
            {
                pCellText->property_editable() = true;
                typedef void (* type_fptr)(const Glib::ustring & path_string, const Glib::ustring & new_text, int model_column, const Glib::RefPtr< Gtk::TreeModel > & model);
                type_fptr fptr = _auto_store_on_cellrenderer_text_edited_numerical< unsigned long >;
                pCellText->signal_edited().connect(sigc::bind< -1 >(sigc::bind< -1 >(sigc::ptr_fun(fptr), this_p->_get_base_model()), model_column.index()));
            }
        }
        template<>
        inline void _connect_auto_store_editable_signal_handler(Gtk::TreeView * this_p, Gtk::CellRenderer * pCellRenderer, const Gtk::TreeModelColumn< float > & model_column)
        {
            Gtk::CellRendererText * pCellText = dynamic_cast<Gtk::CellRendererText * >(pCellRenderer);
            if (pCellText)
            {
                pCellText->property_editable() = true;
                typedef void (* type_fptr)(const Glib::ustring & path_string, const Glib::ustring & new_text, int model_column, const Glib::RefPtr< Gtk::TreeModel > & model);
                type_fptr fptr = _auto_store_on_cellrenderer_text_edited_numerical< float >;
                pCellText->signal_edited().connect(sigc::bind< -1 >(sigc::bind< -1 >(sigc::ptr_fun(fptr), this_p->_get_base_model()), model_column.index()));
            }
        }
        template<>
        inline void _connect_auto_store_editable_signal_handler(Gtk::TreeView * this_p, Gtk::CellRenderer * pCellRenderer, const Gtk::TreeModelColumn< double > & model_column)
        {
            Gtk::CellRendererText * pCellText = dynamic_cast<Gtk::CellRendererText * >(pCellRenderer);
            if (pCellText)
            {
                pCellText->property_editable() = true;
                typedef void (* type_fptr)(const Glib::ustring & path_string, const Glib::ustring & new_text, int model_column, const Glib::RefPtr< Gtk::TreeModel > & model);
                type_fptr fptr = _auto_store_on_cellrenderer_text_edited_numerical< double >;
                pCellText->signal_edited().connect(sigc::bind< -1 >(sigc::bind< -1 >(sigc::ptr_fun(fptr), this_p->_get_base_model()), model_column.index()));
            }
        }
    }
    namespace TreeView_Private {
        template<class ColumnType >
        inline void _connect_auto_store_editable_signal_handler(Gtk::TreeView * this_p, Gtk::CellRenderer * pCellRenderer, const Gtk::TreeModelColumn< ColumnType > & model_column)
        {
            Gtk::CellRendererText * pCellText = dynamic_cast<Gtk::CellRendererText * >(pCellRenderer);
            if (pCellText)
            {
                pCellText->property_editable() = true;
                typedef void (* type_func)(const Glib::ustring &, const Glib::ustring &, int, const Glib::RefPtr< Gtk::TreeModel > &);
                type_func func = &(_auto_store_on_cellrenderer_text_edited_string< ColumnType >);
                sigc::slot< void, const Glib::ustring &, const Glib::ustring &, int, const Glib::RefPtr< Gtk::TreeModel > & > theslot = sigc::ptr_fun(func);
                pCellText->signal_edited().connect(sigc::bind< -1 >(sigc::bind< -1 >(theslot, this_p->_get_base_model()), model_column.index()));
            }
        }
        template<class ColumnType >
        inline void _auto_store_on_cellrenderer_text_edited_string(const Glib::ustring & path_string, const Glib::ustring & new_text, int model_column, const Glib::RefPtr< Gtk::TreeModel > & model)
        {
            Gtk::TreePath path(path_string);
            if (model)
            {
                Gtk::TreeModel::iterator iter = model->get_iter(path);
                if (iter)
                {
                    Gtk::TreeRow row = *iter;
                    row.set_value(model_column, (ColumnType) new_text);
                }
            }
        }
        template<class ColumnType >
        inline void _auto_store_on_cellrenderer_text_edited_numerical(const Glib::ustring & path_string, const Glib::ustring & new_text, int model_column, const Glib::RefPtr< Gtk::TreeModel > & model)
        {
            Gtk::TreePath path(path_string);
            if (model)
            {
                Gtk::TreeModel::iterator iter = model->get_iter(path);
                if (iter)
                {
                    char * pchEnd = 0;
                    ColumnType new_value = static_cast<ColumnType >(strtod(new_text.c_str(), &pchEnd));
                    Gtk::TreeRow row = *iter;
                    row.set_value(model_column, (ColumnType) new_value);
                }
            }
        }
        template<class ColumnType >
        inline void _auto_cell_data_func(Gtk::CellRenderer * cell, const Gtk::TreeModel::iterator & iter, int model_column, const Glib::ustring & format)
        {
            Gtk::CellRendererText * pTextRenderer = dynamic_cast<Gtk::CellRendererText * >(cell);
            if (!pTextRenderer)
            {
                g_log(((gchar *) 0), G_LOG_LEVEL_WARNING, "gtkmm: TextView: append_column_numeric() was used with a non-numeric type.");
            }
            else
            {
                if (iter)
                {
                    Gtk::TreeModel::Row row = *iter;
                    ColumnType value = ColumnType();
                    row.get_value(model_column, value);
                    char buff[20];
                    int used = g_snprintf(buff, sizeof (buff), format.c_str(), value);
                    if (used > 0)
                    {
                        pTextRenderer->property_text() = buff;
                    }
                }
            }
        }
    }
}
namespace Glib {
    Gtk::TreeView * wrap(GtkTreeView * object, bool take_copy = false);
}
typedef struct _GtkComboBox GtkComboBox;
typedef struct _GtkComboBoxClass GtkComboBoxClass;
namespace Gtk {
    class ComboBox_Class;
}
namespace Gtk {
    class ComboBox : public Bin, public CellLayout
    {
        public :
            typedef ComboBox CppObjectType;
            typedef ComboBox_Class CppClassType;
            typedef GtkComboBox BaseObjectType;
            typedef GtkComboBoxClass BaseClassType;
            virtual ~ComboBox();
        private :
            friend class ComboBox_Class;
            static CppClassType combobox_class_;
            ComboBox(const ComboBox &);
            ComboBox & operator =(const ComboBox &);
        protected :
            explicit ComboBox(const Glib::ConstructParams & construct_params);
            explicit ComboBox(GtkComboBox * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkComboBox * gobj()
            {
                return reinterpret_cast<GtkComboBox * >(gobject_);
            }
            const GtkComboBox * gobj() const
            {
                return reinterpret_cast<GtkComboBox * >(gobject_);
            }
        public :
        protected :
            virtual void on_changed();
        private :
        public :
            ComboBox();
            explicit ComboBox(const Glib::RefPtr< TreeModel > & model);
            void set_wrap_width(int width);
            int get_wrap_width() const;
            void set_row_span_column(int row_span);
            int get_row_span_column() const;
            void set_column_span_column(int column_span);
            int get_column_span_column() const;
            bool get_add_tearoffs() const;
            void set_add_tearoffs(bool add_tearoffs = true);
            Glib::ustring get_title() const;
            void set_title(const Glib::ustring & title);
            bool get_focus_on_click() const;
            void set_focus_on_click(bool focus_on_click = true);
            int get_active_row_number() const;
            TreeModel::iterator get_active();
            TreeModel::const_iterator get_active() const;
            void set_active(int index);
            void set_active(const TreeModel::iterator & iter);
            void unset_active();
            Glib::RefPtr< TreeModel > get_model();
            Glib::RefPtr< const TreeModel > get_model() const;
            void set_model(const Glib::RefPtr< TreeModel > & model);
            typedef TreeView::SlotRowSeparator SlotRowSeparator;
            void set_row_separator_func(const SlotRowSeparator & slot);
            void unset_row_separator_func();
            void popup();
            void popdown();
            Glib::RefPtr< Atk::Object > get_popup_accessible();
            Glib::RefPtr< const Atk::Object > get_popup_accessible() const;
            Glib::PropertyProxy< Glib::RefPtr< TreeModel > > property_model();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< TreeModel > > property_model() const;
            Glib::PropertyProxy< int > property_wrap_width();
            Glib::PropertyProxy_ReadOnly< int > property_wrap_width() const;
            Glib::PropertyProxy< int > property_row_span_column();
            Glib::PropertyProxy_ReadOnly< int > property_row_span_column() const;
            Glib::PropertyProxy< int > property_column_span_column();
            Glib::PropertyProxy_ReadOnly< int > property_column_span_column() const;
            Glib::PropertyProxy< int > property_active();
            Glib::PropertyProxy_ReadOnly< int > property_active() const;
            Glib::PropertyProxy< bool > property_add_tearoffs();
            Glib::PropertyProxy_ReadOnly< bool > property_add_tearoffs() const;
            Glib::PropertyProxy< bool > property_has_frame();
            Glib::PropertyProxy_ReadOnly< bool > property_has_frame() const;
            Glib::PropertyProxy< bool > property_focus_on_click();
            Glib::PropertyProxy_ReadOnly< bool > property_focus_on_click() const;
            Glib::PropertyProxy< Glib::ustring > property_tearoff_title();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_tearoff_title() const;
            Glib::SignalProxy0< void > signal_changed();
    };
}
namespace Glib {
    Gtk::ComboBox * wrap(GtkComboBox * object, bool take_copy = false);
}
typedef struct _GtkComboBoxEntry GtkComboBoxEntry;
typedef struct _GtkComboBoxEntryClass GtkComboBoxEntryClass;
namespace Gtk {
    class ComboBoxEntry_Class;
}
namespace Gtk {
    class ComboBoxEntry : public ComboBox
    {
        public :
            typedef ComboBoxEntry CppObjectType;
            typedef ComboBoxEntry_Class CppClassType;
            typedef GtkComboBoxEntry BaseObjectType;
            typedef GtkComboBoxEntryClass BaseClassType;
            virtual ~ComboBoxEntry();
        private :
            friend class ComboBoxEntry_Class;
            static CppClassType comboboxentry_class_;
            ComboBoxEntry(const ComboBoxEntry &);
            ComboBoxEntry & operator =(const ComboBoxEntry &);
        protected :
            explicit ComboBoxEntry(const Glib::ConstructParams & construct_params);
            explicit ComboBoxEntry(GtkComboBoxEntry * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkComboBoxEntry * gobj()
            {
                return reinterpret_cast<GtkComboBoxEntry * >(gobject_);
            }
            const GtkComboBoxEntry * gobj() const
            {
                return reinterpret_cast<GtkComboBoxEntry * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            ComboBoxEntry();
            explicit ComboBoxEntry(const Glib::RefPtr< TreeModel > & model, const TreeModelColumnBase & text_column);
            explicit ComboBoxEntry(const Glib::RefPtr< TreeModel > & model, int text_column = 0);
            void set_text_column(const TreeModelColumnBase & text_column) const;
            void set_text_column(int text_column) const;
            int get_text_column() const;
            Entry * get_entry();
            const Entry * get_entry() const;
    };
}
namespace Glib {
    Gtk::ComboBoxEntry * wrap(GtkComboBoxEntry * object, bool take_copy = false);
}
namespace Gtk {
    class ComboBoxEntryText : public ComboBoxEntry
    {
        private :
            ComboBoxEntryText(const ComboBoxEntryText &);
            ComboBoxEntryText & operator =(const ComboBoxEntryText &);
        protected :
            explicit ComboBoxEntryText(const Glib::ConstructParams & construct_params);
            explicit ComboBoxEntryText(GtkComboBoxEntry * castitem);
        public :
            ComboBoxEntryText();
            void append_text(const Glib::ustring & text);
            void insert_text(int position, const Glib::ustring & text);
            void prepend_text(const Glib::ustring & text);
            Glib::ustring get_active_text() const;
            void set_active_text(const Glib::ustring & text);
            void clear();
            void clear_items();
            void remove_text(const Glib::ustring & text);
        protected :
            class TextModelColumns : public Gtk::TreeModel::ColumnRecord
            {
                public :
                    TextModelColumns()
                    {
                        add(m_column);
                    }
                    Gtk::TreeModelColumn< Glib::ustring > m_column;
            };
            TextModelColumns m_text_columns;
    };
}
namespace Gtk {
    class ComboBoxText : public ComboBox
    {
        private :
            ComboBoxText(const ComboBoxText &);
            ComboBoxText & operator =(const ComboBoxText &);
        protected :
            explicit ComboBoxText(const Glib::ConstructParams & construct_params);
            explicit ComboBoxText(GtkComboBox * castitem);
        public :
            ComboBoxText();
            void append_text(const Glib::ustring & text);
            void insert_text(int position, const Glib::ustring & text);
            void prepend_text(const Glib::ustring & text);
            Glib::ustring get_active_text() const;
            void set_active_text(const Glib::ustring & text);
            void clear();
            void clear_items();
            void remove_text(const Glib::ustring & text);
        protected :
            class TextModelColumns : public Gtk::TreeModel::ColumnRecord
            {
                public :
                    TextModelColumns()
                    {
                        add(m_column);
                    }
                    Gtk::TreeModelColumn< Glib::ustring > m_column;
            };
            TextModelColumns m_text_columns;
    };
}
typedef struct _GtkDrawingArea GtkDrawingArea;
typedef struct _GtkDrawingAreaClass GtkDrawingAreaClass;
namespace Gtk {
    class DrawingArea_Class;
}
namespace Gtk {
    class DrawingArea : public Widget
    {
        public :
            typedef DrawingArea CppObjectType;
            typedef DrawingArea_Class CppClassType;
            typedef GtkDrawingArea BaseObjectType;
            typedef GtkDrawingAreaClass BaseClassType;
            virtual ~DrawingArea();
        private :
            friend class DrawingArea_Class;
            static CppClassType drawingarea_class_;
            DrawingArea(const DrawingArea &);
            DrawingArea & operator =(const DrawingArea &);
        protected :
            explicit DrawingArea(const Glib::ConstructParams & construct_params);
            explicit DrawingArea(GtkDrawingArea * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkDrawingArea * gobj()
            {
                return reinterpret_cast<GtkDrawingArea * >(gobject_);
            }
            const GtkDrawingArea * gobj() const
            {
                return reinterpret_cast<GtkDrawingArea * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            DrawingArea();
    };
}
namespace Glib {
    Gtk::DrawingArea * wrap(GtkDrawingArea * object, bool take_copy = false);
}
typedef struct _GtkCurve GtkCurve;
typedef struct _GtkCurveClass GtkCurveClass;
namespace Gtk {
    class Curve_Class;
}
typedef struct _GtkGammaCurve GtkGammaCurve;
typedef struct _GtkGammaCurveClass GtkGammaCurveClass;
namespace Gtk {
    class GammaCurve_Class;
}
namespace Gtk {
    class Curve : public DrawingArea
    {
        public :
            typedef Curve CppObjectType;
            typedef Curve_Class CppClassType;
            typedef GtkCurve BaseObjectType;
            typedef GtkCurveClass BaseClassType;
            virtual ~Curve();
        private :
            friend class Curve_Class;
            static CppClassType curve_class_;
            Curve(const Curve &);
            Curve & operator =(const Curve &);
        protected :
            explicit Curve(const Glib::ConstructParams & construct_params);
            explicit Curve(GtkCurve * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkCurve * gobj()
            {
                return reinterpret_cast<GtkCurve * >(gobject_);
            }
            const GtkCurve * gobj() const
            {
                return reinterpret_cast<GtkCurve * >(gobject_);
            }
        public :
        protected :
            virtual void on_curve_type_changed();
        private :
        public :
            Curve();
            void reset();
            void set_gamma(float gamma);
            void set_range(float min_x, float max_x, float min_y, float max_y);
            void get_vector(int veclen, float * data) const;
            Glib::ArrayHandle< float > get_vector(int veclen) const;
            void set_vector(const Glib::ArrayHandle< float > & array);
            void set_curve_type(CurveType type);
            Glib::SignalProxy0< void > signal_curve_type_changed();
            Glib::PropertyProxy< CurveType > property_curve_type();
            Glib::PropertyProxy_ReadOnly< CurveType > property_curve_type() const;
            Glib::PropertyProxy< float > property_min_x();
            Glib::PropertyProxy_ReadOnly< float > property_min_x() const;
            Glib::PropertyProxy< float > property_max_x();
            Glib::PropertyProxy_ReadOnly< float > property_max_x() const;
            Glib::PropertyProxy< float > property_min_y();
            Glib::PropertyProxy_ReadOnly< float > property_min_y() const;
            Glib::PropertyProxy< float > property_max_y();
            Glib::PropertyProxy_ReadOnly< float > property_max_y() const;
    };
    class GammaCurve : public VBox
    {
        public :
            typedef GammaCurve CppObjectType;
            typedef GammaCurve_Class CppClassType;
            typedef GtkGammaCurve BaseObjectType;
            typedef GtkGammaCurveClass BaseClassType;
            virtual ~GammaCurve();
        private :
            friend class GammaCurve_Class;
            static CppClassType gammacurve_class_;
            GammaCurve(const GammaCurve &);
            GammaCurve & operator =(const GammaCurve &);
        protected :
            explicit GammaCurve(const Glib::ConstructParams & construct_params);
            explicit GammaCurve(GtkGammaCurve * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkGammaCurve * gobj()
            {
                return reinterpret_cast<GtkGammaCurve * >(gobject_);
            }
            const GtkGammaCurve * gobj() const
            {
                return reinterpret_cast<GtkGammaCurve * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            GammaCurve();
    };
}
namespace Glib {
    Gtk::Curve * wrap(GtkCurve * object, bool take_copy = false);
}
namespace Glib {
    Gtk::GammaCurve * wrap(GtkGammaCurve * object, bool take_copy = false);
}
typedef struct _GtkExpander GtkExpander;
typedef struct _GtkExpanderClass GtkExpanderClass;
namespace Gtk {
    class Expander_Class;
}
namespace Gtk {
    class Expander : public Bin
    {
        public :
            typedef Expander CppObjectType;
            typedef Expander_Class CppClassType;
            typedef GtkExpander BaseObjectType;
            typedef GtkExpanderClass BaseClassType;
            virtual ~Expander();
        private :
            friend class Expander_Class;
            static CppClassType expander_class_;
            Expander(const Expander &);
            Expander & operator =(const Expander &);
        protected :
            explicit Expander(const Glib::ConstructParams & construct_params);
            explicit Expander(GtkExpander * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkExpander * gobj()
            {
                return reinterpret_cast<GtkExpander * >(gobject_);
            }
            const GtkExpander * gobj() const
            {
                return reinterpret_cast<GtkExpander * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            Expander();
            explicit Expander(const Glib::ustring & label, bool mnemonic = false);
            void set_expanded(bool expanded = true);
            bool get_expanded() const;
            void set_spacing(int spacing);
            int get_spacing() const;
            void set_label(const Glib::ustring & label);
            Glib::ustring get_label() const;
            void set_use_underline(bool use_underline = true);
            bool get_use_underline() const;
            void set_use_markup(bool use_markup = true);
            bool get_use_markup() const;
            void set_label_widget(Widget & label_widget);
            Widget * get_label_widget();
            const Widget * get_label_widget() const;
            Glib::PropertyProxy< bool > property_expanded();
            Glib::PropertyProxy_ReadOnly< bool > property_expanded() const;
            Glib::PropertyProxy< Glib::ustring > property_label();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_label() const;
            Glib::PropertyProxy< bool > property_use_underline();
            Glib::PropertyProxy_ReadOnly< bool > property_use_underline() const;
            Glib::PropertyProxy< bool > property_use_markup();
            Glib::PropertyProxy_ReadOnly< bool > property_use_markup() const;
            Glib::PropertyProxy< int > property_spacing();
            Glib::PropertyProxy_ReadOnly< int > property_spacing() const;
            Glib::PropertyProxy< Widget * > property_label_widget();
            Glib::PropertyProxy_ReadOnly< Widget * > property_label_widget() const;
    };
}
namespace Glib {
    Gtk::Expander * wrap(GtkExpander * object, bool take_copy = false);
}
typedef struct _GtkEventBox GtkEventBox;
typedef struct _GtkEventBoxClass GtkEventBoxClass;
namespace Gtk {
    class EventBox_Class;
}
namespace Gtk {
    class EventBox : public Bin
    {
        public :
            typedef EventBox CppObjectType;
            typedef EventBox_Class CppClassType;
            typedef GtkEventBox BaseObjectType;
            typedef GtkEventBoxClass BaseClassType;
            virtual ~EventBox();
        private :
            friend class EventBox_Class;
            static CppClassType eventbox_class_;
            EventBox(const EventBox &);
            EventBox & operator =(const EventBox &);
        protected :
            explicit EventBox(const Glib::ConstructParams & construct_params);
            explicit EventBox(GtkEventBox * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkEventBox * gobj()
            {
                return reinterpret_cast<GtkEventBox * >(gobject_);
            }
            const GtkEventBox * gobj() const
            {
                return reinterpret_cast<GtkEventBox * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            EventBox();
            bool get_visible_window() const;
            void set_visible_window(bool visible_window = true);
            bool get_above_child() const;
            void set_above_child(bool above_child = true);
            Glib::PropertyProxy< bool > property_visible_window();
            Glib::PropertyProxy_ReadOnly< bool > property_visible_window() const;
            Glib::PropertyProxy< bool > property_above_child();
            Glib::PropertyProxy_ReadOnly< bool > property_above_child() const;
    };
}
namespace Glib {
    Gtk::EventBox * wrap(GtkEventBox * object, bool take_copy = false);
}
typedef struct _GtkFileFilter GtkFileFilter;
typedef struct _GtkFileFilterClass GtkFileFilterClass;
namespace Gtk {
    class FileFilter_Class;
}
namespace Gtk {
    enum FileFilterFlags
    {
        FILE_FILTER_FILENAME = 1 << 0, 
        FILE_FILTER_URI = 1 << 1, 
        FILE_FILTER_DISPLAY_NAME = 1 << 2, 
        FILE_FILTER_MIME_TYPE = 1 << 3
    };
    inline FileFilterFlags operator |(FileFilterFlags lhs, FileFilterFlags rhs)
    {
        return static_cast<FileFilterFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline FileFilterFlags operator &(FileFilterFlags lhs, FileFilterFlags rhs)
    {
        return static_cast<FileFilterFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline FileFilterFlags operator ^(FileFilterFlags lhs, FileFilterFlags rhs)
    {
        return static_cast<FileFilterFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline FileFilterFlags operator ~(FileFilterFlags flags)
    {
        return static_cast<FileFilterFlags >(~static_cast<unsigned >(flags));
    }
    inline FileFilterFlags & operator |=(FileFilterFlags & lhs, FileFilterFlags rhs)
    {
        return (lhs = static_cast<FileFilterFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline FileFilterFlags & operator &=(FileFilterFlags & lhs, FileFilterFlags rhs)
    {
        return (lhs = static_cast<FileFilterFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline FileFilterFlags & operator ^=(FileFilterFlags & lhs, FileFilterFlags rhs)
    {
        return (lhs = static_cast<FileFilterFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gtk::FileFilterFlags > : public Glib::Value_Flags< Gtk::FileFilterFlags >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class FileFilter : public Gtk::Object
    {
        public :
            typedef FileFilter CppObjectType;
            typedef FileFilter_Class CppClassType;
            typedef GtkFileFilter BaseObjectType;
            typedef GtkFileFilterClass BaseClassType;
            virtual ~FileFilter();
        private :
            friend class FileFilter_Class;
            static CppClassType filefilter_class_;
            FileFilter(const FileFilter &);
            FileFilter & operator =(const FileFilter &);
        protected :
            explicit FileFilter(const Glib::ConstructParams & construct_params);
            explicit FileFilter(GtkFileFilter * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkFileFilter * gobj()
            {
                return reinterpret_cast<GtkFileFilter * >(gobject_);
            }
            const GtkFileFilter * gobj() const
            {
                return reinterpret_cast<GtkFileFilter * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            FileFilter();
            void set_name(const Glib::ustring & name);
            Glib::ustring get_name() const;
            void add_mime_type(const Glib::ustring & mime_type);
            void add_pattern(const Glib::ustring & pattern);
            void add_pixbuf_formats();
            class Info
            {
                public :
                    FileFilterFlags contains;
                    Glib::ustring filename;
                    Glib::ustring uri;
                    Glib::ustring display_name;
                    Glib::ustring mime_type;
            };
            typedef sigc::slot< bool, const Info & > SlotCustom;
            void add_custom(FileFilterFlags needed, const SlotCustom & slot);
            FileFilterFlags get_needed() const;
    };
}
namespace Glib {
    Gtk::FileFilter * wrap(GtkFileFilter * object, bool take_copy = false);
}
typedef struct _GtkFileChooser GtkFileChooser;
typedef struct _GtkFileChooserClass GtkFileChooserClass;
namespace Gtk {
    class FileChooser_Class;
}
namespace Gtk {
    enum FileChooserAction
    {
        FILE_CHOOSER_ACTION_OPEN, 
        FILE_CHOOSER_ACTION_SAVE, 
        FILE_CHOOSER_ACTION_SELECT_FOLDER, 
        FILE_CHOOSER_ACTION_CREATE_FOLDER
    };
}
namespace Glib {
    template<>
    class Value< Gtk::FileChooserAction > : public Glib::Value_Enum< Gtk::FileChooserAction >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum FileChooserConfirmation
    {
        FILE_CHOOSER_CONFIRMATION_CONFIRM, 
        FILE_CHOOSER_CONFIRMATION_ACCEPT_FILENAME, 
        FILE_CHOOSER_CONFIRMATION_SELECT_AGAIN
    };
}
namespace Glib {
    template<>
    class Value< Gtk::FileChooserConfirmation > : public Glib::Value_Enum< Gtk::FileChooserConfirmation >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class FileChooserError : public Glib::Error
    {
        public :
            enum Code
            {
                NONEXISTENT, 
                BAD_FILENAME, 
                ALREADY_EXISTS
            };
            FileChooserError(Code error_code, const Glib::ustring & error_message);
            explicit FileChooserError(GError * gobject);
            Code code() const;
        private :
            static void throw_func(GError * gobject);
            friend void wrap_init();
    };
}
namespace Glib {
    template<>
    class Value< Gtk::FileChooserError::Code > : public Glib::Value_Enum< Gtk::FileChooserError::Code >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class FileChooser : public Glib::Interface
    {
        public :
            typedef FileChooser CppObjectType;
            typedef FileChooser_Class CppClassType;
            typedef GtkFileChooser BaseObjectType;
            typedef GtkFileChooserClass BaseClassType;
        private :
            friend class FileChooser_Class;
            static CppClassType filechooser_class_;
            FileChooser(const FileChooser &);
            FileChooser & operator =(const FileChooser &);
        protected :
            FileChooser();
            explicit FileChooser(const Glib::Interface_Class & interface_class);
        public :
            explicit FileChooser(GtkFileChooser * castitem);
        protected :
        public :
            virtual ~FileChooser();
            static void add_interface(GType gtype_implementer);
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkFileChooser * gobj()
            {
                return reinterpret_cast<GtkFileChooser * >(gobject_);
            }
            const GtkFileChooser * gobj() const
            {
                return reinterpret_cast<GtkFileChooser * >(gobject_);
            }
        private :
        public :
            void set_action(FileChooserAction action);
            FileChooserAction get_action() const;
            void set_local_only(bool local_only = true);
            bool get_local_only() const;
            void set_select_multiple(bool select_multiple = true);
            bool get_select_multiple() const;
            void set_show_hidden(bool show_hidden = true);
            bool get_show_hidden() const;
            void set_do_overwrite_confirmation(bool do_overwrite_confirmation = true);
            bool get_do_overwrite_confirmation() const;
            void set_current_name(const Glib::ustring & name);
            Glib::ustring get_filename() const;
            bool set_filename(const Glib::ustring & filename);
            bool select_filename(const Glib::ustring & filename);
            void unselect_filename(const Glib::ustring & filename);
            void select_all();
            void unselect_all();
            Glib::SListHandle< Glib::ustring > get_filenames() const;
            bool set_current_folder(const Glib::ustring & filename);
            Glib::ustring get_current_folder() const;
            Glib::ustring get_uri() const;
            bool set_uri(const Glib::ustring & uri);
            bool select_uri(const Glib::ustring & uri);
            void unselect_uri(const Glib::ustring & uri);
            Glib::SListHandle< Glib::ustring > get_uris() const;
            bool set_current_folder_uri(const Glib::ustring & uri);
            Glib::ustring get_current_folder_uri() const;
            void set_preview_widget(Gtk::Widget & preview_widget);
            const Gtk::Widget * get_preview_widget() const;
            Gtk::Widget * get_preview_widget();
            void set_preview_widget_active(bool active = true);
            bool get_preview_widget_active() const;
            void set_use_preview_label(bool use_label = true);
            bool get_use_preview_label() const;
            Glib::ustring get_preview_filename() const;
            Glib::ustring get_preview_uri() const;
            void set_extra_widget(Gtk::Widget & extra_widget);
            Gtk::Widget * get_extra_widget();
            const Gtk::Widget * get_extra_widget() const;
            void add_filter(const FileFilter & filter);
            void remove_filter(const FileFilter & filter);
            Glib::SListHandle< FileFilter * > list_filters();
            Glib::SListHandle< const FileFilter * > list_filters() const;
            void set_filter(const FileFilter & filter);
            FileFilter * get_filter();
            const FileFilter * get_filter() const;
            bool add_shortcut_folder(const Glib::ustring & folder);
            bool remove_shortcut_folder(const Glib::ustring & folder);
            Glib::SListHandle< Glib::ustring > list_shortcut_folders() const;
            bool add_shortcut_folder_uri(const Glib::ustring & uri);
            bool remove_shortcut_folder_uri(const Glib::ustring & uri);
            Glib::SListHandle< Glib::ustring > list_shortcut_folder_uris() const;
            Glib::SignalProxy0< void > signal_current_folder_changed();
            Glib::SignalProxy0< void > signal_selection_changed();
            Glib::SignalProxy0< void > signal_update_preview();
            Glib::SignalProxy0< void > signal_file_activated();
            Glib::SignalProxy0< FileChooserConfirmation > signal_confirm_overwrite();
            Glib::PropertyProxy< FileChooserAction > property_action();
            Glib::PropertyProxy_ReadOnly< FileChooserAction > property_action() const;
            Glib::PropertyProxy< FileFilter * > property_filter();
            Glib::PropertyProxy_ReadOnly< FileFilter * > property_filter() const;
            Glib::PropertyProxy< bool > property_folder_mode();
            Glib::PropertyProxy_ReadOnly< bool > property_folder_mode() const;
            Glib::PropertyProxy< bool > property_local_only();
            Glib::PropertyProxy_ReadOnly< bool > property_local_only() const;
            Glib::PropertyProxy< Widget * > property_preview_widget();
            Glib::PropertyProxy_ReadOnly< Widget * > property_preview_widget() const;
            Glib::PropertyProxy< bool > property_preview_widget_active();
            Glib::PropertyProxy_ReadOnly< bool > property_preview_widget_active() const;
            Glib::PropertyProxy< bool > property_use_preview_label();
            Glib::PropertyProxy_ReadOnly< bool > property_use_preview_label() const;
            Glib::PropertyProxy< Widget * > property_extra_widget();
            Glib::PropertyProxy_ReadOnly< Widget * > property_extra_widget() const;
            Glib::PropertyProxy< bool > property_select_multiple();
            Glib::PropertyProxy_ReadOnly< bool > property_select_multiple() const;
            Glib::PropertyProxy< bool > property_show_hidden();
            Glib::PropertyProxy_ReadOnly< bool > property_show_hidden() const;
            Glib::PropertyProxy< bool > property_do_overwrite_confirmation();
            Glib::PropertyProxy_ReadOnly< bool > property_do_overwrite_confirmation() const;
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::FileChooser > wrap(GtkFileChooser * object, bool take_copy = false);
}
typedef struct _GtkFileChooserDialog GtkFileChooserDialog;
typedef struct _GtkFileChooserDialogClass GtkFileChooserDialogClass;
namespace Gtk {
    class FileChooserDialog_Class;
}
namespace Gtk {
    class FileChooserDialog : public Dialog, public FileChooser
    {
        public :
            typedef FileChooserDialog CppObjectType;
            typedef FileChooserDialog_Class CppClassType;
            typedef GtkFileChooserDialog BaseObjectType;
            typedef GtkFileChooserDialogClass BaseClassType;
            virtual ~FileChooserDialog();
        private :
            friend class FileChooserDialog_Class;
            static CppClassType filechooserdialog_class_;
            FileChooserDialog(const FileChooserDialog &);
            FileChooserDialog & operator =(const FileChooserDialog &);
        protected :
            explicit FileChooserDialog(const Glib::ConstructParams & construct_params);
            explicit FileChooserDialog(GtkFileChooserDialog * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkFileChooserDialog * gobj()
            {
                return reinterpret_cast<GtkFileChooserDialog * >(gobject_);
            }
            const GtkFileChooserDialog * gobj() const
            {
                return reinterpret_cast<GtkFileChooserDialog * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            explicit FileChooserDialog(Gtk::Window & parent, const Glib::ustring & title, FileChooserAction action = FILE_CHOOSER_ACTION_OPEN);
            explicit FileChooserDialog(const Glib::ustring & title, FileChooserAction action = FILE_CHOOSER_ACTION_OPEN);
            explicit FileChooserDialog(Gtk::Window & parent, const Glib::ustring & title, FileChooserAction action, const Glib::ustring & backend);
            explicit FileChooserDialog(const Glib::ustring & title, FileChooserAction action, const Glib::ustring & backend);
    };
}
namespace Glib {
    Gtk::FileChooserDialog * wrap(GtkFileChooserDialog * object, bool take_copy = false);
}
typedef struct _GtkFileChooserButton GtkFileChooserButton;
typedef struct _GtkFileChooserButtonClass GtkFileChooserButtonClass;
namespace Gtk {
    class FileChooserButton_Class;
}
namespace Gtk {
    class FileChooserButton : public HBox, public FileChooser
    {
        public :
            typedef FileChooserButton CppObjectType;
            typedef FileChooserButton_Class CppClassType;
            typedef GtkFileChooserButton BaseObjectType;
            typedef GtkFileChooserButtonClass BaseClassType;
            virtual ~FileChooserButton();
        private :
            friend class FileChooserButton_Class;
            static CppClassType filechooserbutton_class_;
            FileChooserButton(const FileChooserButton &);
            FileChooserButton & operator =(const FileChooserButton &);
        protected :
            explicit FileChooserButton(const Glib::ConstructParams & construct_params);
            explicit FileChooserButton(GtkFileChooserButton * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkFileChooserButton * gobj()
            {
                return reinterpret_cast<GtkFileChooserButton * >(gobject_);
            }
            const GtkFileChooserButton * gobj() const
            {
                return reinterpret_cast<GtkFileChooserButton * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            explicit FileChooserButton(FileChooserAction action = FILE_CHOOSER_ACTION_OPEN);
            explicit FileChooserButton(const Glib::ustring & title, FileChooserAction action = FILE_CHOOSER_ACTION_OPEN);
            explicit FileChooserButton(const Glib::ustring & title, FileChooserAction action, const Glib::ustring & backend);
            explicit FileChooserButton(FileChooserDialog & dialog);
            Glib::ustring get_title() const;
            void set_title(const Glib::ustring & title);
            int get_width_chars() const;
            void set_width_chars(int n_chars);
            bool get_focus_on_click() const;
            void set_focus_on_click(gboolean focus_on_click = true);
            Glib::PropertyProxy< bool > property_focus_on_click();
            Glib::PropertyProxy_ReadOnly< bool > property_focus_on_click() const;
            Glib::PropertyProxy< Glib::ustring > property_title();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_title() const;
            Glib::PropertyProxy< int > property_width_chars();
            Glib::PropertyProxy_ReadOnly< int > property_width_chars() const;
    };
}
namespace Glib {
    Gtk::FileChooserButton * wrap(GtkFileChooserButton * object, bool take_copy = false);
}
typedef struct _GtkFileChooserWidget GtkFileChooserWidget;
typedef struct _GtkFileChooserWidgetClass GtkFileChooserWidgetClass;
namespace Gtk {
    class FileChooserWidget_Class;
}
namespace Gtk {
    class FileChooserWidget : public VBox, public FileChooser
    {
        public :
            typedef FileChooserWidget CppObjectType;
            typedef FileChooserWidget_Class CppClassType;
            typedef GtkFileChooserWidget BaseObjectType;
            typedef GtkFileChooserWidgetClass BaseClassType;
            virtual ~FileChooserWidget();
        private :
            friend class FileChooserWidget_Class;
            static CppClassType filechooserwidget_class_;
            FileChooserWidget(const FileChooserWidget &);
            FileChooserWidget & operator =(const FileChooserWidget &);
        protected :
            explicit FileChooserWidget(const Glib::ConstructParams & construct_params);
            explicit FileChooserWidget(GtkFileChooserWidget * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkFileChooserWidget * gobj()
            {
                return reinterpret_cast<GtkFileChooserWidget * >(gobject_);
            }
            const GtkFileChooserWidget * gobj() const
            {
                return reinterpret_cast<GtkFileChooserWidget * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            FileChooserWidget();
            explicit FileChooserWidget(FileChooserAction action);
            explicit FileChooserWidget(FileChooserAction action, const Glib::ustring & backend);
    };
}
namespace Glib {
    Gtk::FileChooserWidget * wrap(GtkFileChooserWidget * object, bool take_copy = false);
}
typedef struct _GtkOptionMenu GtkOptionMenu;
typedef struct _GtkOptionMenuClass GtkOptionMenuClass;
namespace Gtk {
    class OptionMenu_Class;
}
namespace Gtk {
    class Menu;
    class OptionMenu : public Button
    {
        public :
            typedef OptionMenu CppObjectType;
            typedef OptionMenu_Class CppClassType;
            typedef GtkOptionMenu BaseObjectType;
            typedef GtkOptionMenuClass BaseClassType;
            virtual ~OptionMenu();
        private :
            friend class OptionMenu_Class;
            static CppClassType optionmenu_class_;
            OptionMenu(const OptionMenu &);
            OptionMenu & operator =(const OptionMenu &);
        protected :
            explicit OptionMenu(const Glib::ConstructParams & construct_params);
            explicit OptionMenu(GtkOptionMenu * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkOptionMenu * gobj()
            {
                return reinterpret_cast<GtkOptionMenu * >(gobject_);
            }
            const GtkOptionMenu * gobj() const
            {
                return reinterpret_cast<GtkOptionMenu * >(gobject_);
            }
        public :
        protected :
            virtual void on_changed();
        private :
        public :
            OptionMenu();
            void set_menu(Menu & menu);
            Menu * get_menu();
            const Menu * get_menu() const;
            void remove_menu();
            int get_history() const;
            void set_history(guint index);
            Glib::SignalProxy0< void > signal_changed();
        private :
            void init_accels_handler_();
    };
}
namespace Glib {
    Gtk::OptionMenu * wrap(GtkOptionMenu * object, bool take_copy = false);
}
typedef struct _GtkFileSelection GtkFileSelection;
typedef struct _GtkFileSelectionClass GtkFileSelectionClass;
namespace Gtk {
    class FileSelection_Class;
}
namespace Gtk {
    class FileSelection : public Dialog
    {
        public :
            typedef FileSelection CppObjectType;
            typedef FileSelection_Class CppClassType;
            typedef GtkFileSelection BaseObjectType;
            typedef GtkFileSelectionClass BaseClassType;
            virtual ~FileSelection();
        private :
            friend class FileSelection_Class;
            static CppClassType fileselection_class_;
            FileSelection(const FileSelection &);
            FileSelection & operator =(const FileSelection &);
        protected :
            explicit FileSelection(const Glib::ConstructParams & construct_params);
            explicit FileSelection(GtkFileSelection * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkFileSelection * gobj()
            {
                return reinterpret_cast<GtkFileSelection * >(gobject_);
            }
            const GtkFileSelection * gobj() const
            {
                return reinterpret_cast<GtkFileSelection * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            FileSelection();
            explicit FileSelection(const Glib::ustring & title);
            void set_filename(const std::string & filename);
            std::string get_filename() const;
            void complete(const Glib::ustring & pattern);
            void show_fileop_buttons();
            void hide_fileop_buttons();
            Glib::ArrayHandle< std::string > get_selections() const;
            void set_select_multiple(bool select_multiple = true);
            bool get_select_multiple() const;
            TreeView * get_dir_list();
            const TreeView * get_dir_list() const;
            TreeView * get_file_list();
            const TreeView * get_file_list() const;
            OptionMenu * get_history_pulldown();
            const OptionMenu * get_history_pulldown() const;
            Entry * get_selection_entry();
            const Entry * get_selection_entry() const;
            Label * get_selection_text();
            const Label * get_selection_text() const;
            VBox * get_main_vbox();
            const VBox * get_main_vbox() const;
            Button * get_ok_button();
            const Button * get_ok_button() const;
            Button * get_cancel_button();
            const Button * get_cancel_button() const;
            Button * get_help_button();
            const Button * get_help_button() const;
            HButtonBox * get_button_area();
            const HButtonBox * get_button_area() const;
            HBox * get_action_area();
            const HBox * get_action_area() const;
            Glib::PropertyProxy< bool > property_show_fileops();
            Glib::PropertyProxy_ReadOnly< bool > property_show_fileops() const;
            Glib::PropertyProxy< std::string > property_filename();
            Glib::PropertyProxy_ReadOnly< std::string > property_filename() const;
            Glib::PropertyProxy< bool > property_select_multiple();
            Glib::PropertyProxy_ReadOnly< bool > property_select_multiple() const;
    };
}
namespace Glib {
    Gtk::FileSelection * wrap(GtkFileSelection * object, bool take_copy = false);
}
typedef struct _GtkFixed GtkFixed;
typedef struct _GtkFixedClass GtkFixedClass;
namespace Gtk {
    class Fixed_Class;
}
namespace Gtk {
    class Fixed : public Container
    {
        public :
            typedef Fixed CppObjectType;
            typedef Fixed_Class CppClassType;
            typedef GtkFixed BaseObjectType;
            typedef GtkFixedClass BaseClassType;
            virtual ~Fixed();
        private :
            friend class Fixed_Class;
            static CppClassType fixed_class_;
            Fixed(const Fixed &);
            Fixed & operator =(const Fixed &);
        protected :
            explicit Fixed(const Glib::ConstructParams & construct_params);
            explicit Fixed(GtkFixed * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkFixed * gobj()
            {
                return reinterpret_cast<GtkFixed * >(gobject_);
            }
            const GtkFixed * gobj() const
            {
                return reinterpret_cast<GtkFixed * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            Fixed();
            void put(Widget & widget, int x, int y);
            void move(Widget & widget, int x, int y);
            void set_has_window(bool has_window = true);
            bool get_has_window() const;
    };
}
namespace Glib {
    Gtk::Fixed * wrap(GtkFixed * object, bool take_copy = false);
}
typedef struct _GtkFontButton GtkFontButton;
typedef struct _GtkFontButtonClass GtkFontButtonClass;
namespace Gtk {
    class FontButton_Class;
}
namespace Gtk {
    class FontButton : public Button
    {
        public :
            typedef FontButton CppObjectType;
            typedef FontButton_Class CppClassType;
            typedef GtkFontButton BaseObjectType;
            typedef GtkFontButtonClass BaseClassType;
            virtual ~FontButton();
        private :
            friend class FontButton_Class;
            static CppClassType fontbutton_class_;
            FontButton(const FontButton &);
            FontButton & operator =(const FontButton &);
        protected :
            explicit FontButton(const Glib::ConstructParams & construct_params);
            explicit FontButton(GtkFontButton * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkFontButton * gobj()
            {
                return reinterpret_cast<GtkFontButton * >(gobject_);
            }
            const GtkFontButton * gobj() const
            {
                return reinterpret_cast<GtkFontButton * >(gobject_);
            }
        public :
        protected :
            virtual void on_font_set();
        private :
        public :
            FontButton();
            explicit FontButton(const Glib::ustring & font_name);
            Glib::ustring get_title() const;
            void set_title(const Glib::ustring & title);
            bool get_use_font() const;
            void set_use_font(bool use_font = true);
            bool get_use_size() const;
            void set_use_size(bool use_size = true);
            Glib::ustring get_font_name() const;
            bool set_font_name(const Glib::ustring & fontname);
            bool get_show_style() const;
            void set_show_style(bool show_style = true);
            bool get_show_size() const;
            void set_show_size(bool show_size = true);
            Glib::PropertyProxy< Glib::ustring > property_title();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_title() const;
            Glib::PropertyProxy< Glib::ustring > property_font_name();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_font_name() const;
            Glib::PropertyProxy< bool > property_use_font();
            Glib::PropertyProxy_ReadOnly< bool > property_use_font() const;
            Glib::PropertyProxy< bool > property_use_size();
            Glib::PropertyProxy_ReadOnly< bool > property_use_size() const;
            Glib::PropertyProxy< bool > property_show_style();
            Glib::PropertyProxy_ReadOnly< bool > property_show_style() const;
            Glib::PropertyProxy< bool > property_show_size();
            Glib::PropertyProxy_ReadOnly< bool > property_show_size() const;
            Glib::SignalProxy0< void > signal_font_set();
    };
}
namespace Glib {
    Gtk::FontButton * wrap(GtkFontButton * object, bool take_copy = false);
}
typedef struct _GtkFontSelection GtkFontSelection;
typedef struct _GtkFontSelectionClass GtkFontSelectionClass;
namespace Gtk {
    class FontSelection_Class;
}
typedef struct _GtkFontSelectionDialog GtkFontSelectionDialog;
typedef struct _GtkFontSelectionDialogClass GtkFontSelectionDialogClass;
namespace Gtk {
    class FontSelectionDialog_Class;
}
namespace Gtk {
    class Button;
    class Entry;
    class RadioButton;
    class FontSelection : public VBox
    {
        public :
            typedef FontSelection CppObjectType;
            typedef FontSelection_Class CppClassType;
            typedef GtkFontSelection BaseObjectType;
            typedef GtkFontSelectionClass BaseClassType;
            virtual ~FontSelection();
        private :
            friend class FontSelection_Class;
            static CppClassType fontselection_class_;
            FontSelection(const FontSelection &);
            FontSelection & operator =(const FontSelection &);
        protected :
            explicit FontSelection(const Glib::ConstructParams & construct_params);
            explicit FontSelection(GtkFontSelection * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkFontSelection * gobj()
            {
                return reinterpret_cast<GtkFontSelection * >(gobject_);
            }
            const GtkFontSelection * gobj() const
            {
                return reinterpret_cast<GtkFontSelection * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            FontSelection();
            Glib::ustring get_font_name() const;
            bool set_font_name(const Glib::ustring & fontname);
            Glib::ustring get_preview_text() const;
            void set_preview_text(const Glib::ustring & fontname);
            Entry * get_font_entry();
            const Entry * get_font_entry() const;
            Entry * get_font_style_entry();
            const Entry * get_font_style_entry() const;
            Entry * get_size_entry();
            const Entry * get_size_entry() const;
            RadioButton * get_pixels_button();
            const RadioButton * get_pixels_button() const;
            RadioButton * get_points_button();
            const RadioButton * get_points_button() const;
            Button * get_filter_button();
            const Button * get_filter_button() const;
            Entry * get_preview_entry();
            const Entry * get_preview_entry() const;
            Glib::PropertyProxy< Glib::ustring > property_font_name();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_font_name() const;
            Glib::PropertyProxy< Glib::ustring > property_preview_text();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_preview_text() const;
    };
    class FontSelectionDialog : public Dialog
    {
        public :
            typedef FontSelectionDialog CppObjectType;
            typedef FontSelectionDialog_Class CppClassType;
            typedef GtkFontSelectionDialog BaseObjectType;
            typedef GtkFontSelectionDialogClass BaseClassType;
            virtual ~FontSelectionDialog();
        private :
            friend class FontSelectionDialog_Class;
            static CppClassType fontselectiondialog_class_;
            FontSelectionDialog(const FontSelectionDialog &);
            FontSelectionDialog & operator =(const FontSelectionDialog &);
        protected :
            explicit FontSelectionDialog(const Glib::ConstructParams & construct_params);
            explicit FontSelectionDialog(GtkFontSelectionDialog * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkFontSelectionDialog * gobj()
            {
                return reinterpret_cast<GtkFontSelectionDialog * >(gobject_);
            }
            const GtkFontSelectionDialog * gobj() const
            {
                return reinterpret_cast<GtkFontSelectionDialog * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            FontSelectionDialog();
            explicit FontSelectionDialog(const Glib::ustring & title);
            bool set_font_name(const Glib::ustring & fontname);
            Glib::ustring get_font_name() const;
            Glib::ustring get_preview_text() const;
            void set_preview_text(const Glib::ustring & fontname);
            FontSelection * get_font_selection();
            const FontSelection * get_font_selection() const;
            Button * get_ok_button();
            const Button * get_ok_button() const;
            Button * get_apply_button();
            const Button * get_apply_button() const;
            Button * get_cancel_button();
            const Button * get_cancel_button() const;
    };
}
namespace Glib {
    Gtk::FontSelection * wrap(GtkFontSelection * object, bool take_copy = false);
}
namespace Glib {
    Gtk::FontSelectionDialog * wrap(GtkFontSelectionDialog * object, bool take_copy = false);
}
typedef struct _GtkHandleBox GtkHandleBox;
typedef struct _GtkHandleBoxClass GtkHandleBoxClass;
namespace Gtk {
    class HandleBox_Class;
}
namespace Gtk {
    class HandleBox : public Bin
    {
        public :
            typedef HandleBox CppObjectType;
            typedef HandleBox_Class CppClassType;
            typedef GtkHandleBox BaseObjectType;
            typedef GtkHandleBoxClass BaseClassType;
            virtual ~HandleBox();
        private :
            friend class HandleBox_Class;
            static CppClassType handlebox_class_;
            HandleBox(const HandleBox &);
            HandleBox & operator =(const HandleBox &);
        protected :
            explicit HandleBox(const Glib::ConstructParams & construct_params);
            explicit HandleBox(GtkHandleBox * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkHandleBox * gobj()
            {
                return reinterpret_cast<GtkHandleBox * >(gobject_);
            }
            const GtkHandleBox * gobj() const
            {
                return reinterpret_cast<GtkHandleBox * >(gobject_);
            }
        public :
        protected :
            virtual void on_child_attached(Widget * child);
            virtual void on_child_detached(Widget * child);
        private :
        public :
            HandleBox();
            void set_shadow_type(ShadowType type);
            ShadowType get_shadow_type() const;
            void set_handle_position(PositionType position);
            PositionType get_handle_position() const;
            void set_snap_edge(PositionType edge);
            PositionType get_snap_edge() const;
            Glib::SignalProxy1< void, Widget * > signal_child_attached();
            Glib::SignalProxy1< void, Widget * > signal_child_detached();
            Glib::RefPtr< Gdk::Window > get_bin_window();
            Glib::RefPtr< const Gdk::Window > get_bin_window() const;
            Glib::RefPtr< Gdk::Window > get_float_window();
            Glib::RefPtr< const Gdk::Window > get_float_window() const;
            bool is_child_detached() const;
            bool is_float_window_mapped() const;
            bool is_in_drag() const;
            bool shrinks_on_detach() const;
            Glib::PropertyProxy< ShadowType > property_shadow_type();
            Glib::PropertyProxy_ReadOnly< ShadowType > property_shadow_type() const;
            Glib::PropertyProxy< PositionType > property_handle_position();
            Glib::PropertyProxy_ReadOnly< PositionType > property_handle_position() const;
            Glib::PropertyProxy< PositionType > property_snap_edge();
            Glib::PropertyProxy_ReadOnly< PositionType > property_snap_edge() const;
    };
}
namespace Glib {
    Gtk::HandleBox * wrap(GtkHandleBox * object, bool take_copy = false);
}
typedef struct _GtkIconFactory GtkIconFactory;
typedef struct _GtkIconFactoryClass GtkIconFactoryClass;
namespace Gtk {
    class IconFactory_Class;
}
namespace Gtk {
    class IconFactory : public Glib::Object
    {
        public :
            typedef IconFactory CppObjectType;
            typedef IconFactory_Class CppClassType;
            typedef GtkIconFactory BaseObjectType;
            typedef GtkIconFactoryClass BaseClassType;
        private :
            friend class IconFactory_Class;
            static CppClassType iconfactory_class_;
        private :
            IconFactory(const IconFactory &);
            IconFactory & operator =(const IconFactory &);
        protected :
            explicit IconFactory(const Glib::ConstructParams & construct_params);
            explicit IconFactory(GtkIconFactory * castitem);
        public :
            virtual ~IconFactory();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkIconFactory * gobj()
            {
                return reinterpret_cast<GtkIconFactory * >(gobject_);
            }
            const GtkIconFactory * gobj() const
            {
                return reinterpret_cast<GtkIconFactory * >(gobject_);
            }
            GtkIconFactory * gobj_copy();
        private :
        protected :
            IconFactory();
        public :
            static Glib::RefPtr< IconFactory > create();
            void add(const Gtk::StockID & stock_id, const IconSet & icon_set);
            void add_default();
            void remove_default();
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::IconFactory > wrap(GtkIconFactory * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkIconInfo GtkIconInfo;
}
namespace Gtk {
    class IconInfo
    {
        public :
            typedef IconInfo CppObjectType;
            typedef GtkIconInfo BaseObjectType;
            static GType get_type() __attribute__((__const__));
            IconInfo();
            explicit IconInfo(GtkIconInfo * gobject, bool make_a_copy = true);
            IconInfo(const IconInfo & other);
            IconInfo & operator =(const IconInfo & other);
            ~IconInfo();
            void swap(IconInfo & other);
            GtkIconInfo * gobj()
            {
                return gobject_;
            }
            const GtkIconInfo * gobj() const
            {
                return gobject_;
            }
            GtkIconInfo * gobj_copy() const;
        protected :
            GtkIconInfo * gobject_;
        private :
        public :
            operator bool();
            int get_base_size() const;
            Glib::ustring get_filename() const;
            Glib::RefPtr< Gdk::Pixbuf > get_builtin_pixbuf();
            Glib::RefPtr< const Gdk::Pixbuf > get_builtin_pixbuf() const;
            Glib::RefPtr< Gdk::Pixbuf > load_icon() const;
            void set_raw_coordinates(bool raw_coordinates = true);
            bool get_embedded_rect(Gdk::Rectangle & rectangle) const;
            bool get_attach_points(Glib::ArrayHandle< Gdk::Point > & points) const;
            Glib::ustring get_display_name() const;
    };
}
namespace Gtk {
    inline void swap(IconInfo & lhs, IconInfo & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    Gtk::IconInfo wrap(GtkIconInfo * object, bool take_copy = false);
    template<>
    class Value< Gtk::IconInfo > : public Glib::Value_Boxed< Gtk::IconInfo >
    {
    };
}
typedef struct _GtkIconTheme GtkIconTheme;
typedef struct _GtkIconThemeClass GtkIconThemeClass;
namespace Gtk {
    class IconTheme_Class;
}
namespace Gtk {
    enum IconLookupFlags
    {
        ICON_LOOKUP_NO_SVG = 1 << 0, 
        ICON_LOOKUP_FORCE_SVG = 1 << 1, 
        ICON_LOOKUP_USE_BUILTIN = 1 << 2, 
        ICON_LOOKUP_GENERIC_FALLBACK = 1 << 3
    };
    inline IconLookupFlags operator |(IconLookupFlags lhs, IconLookupFlags rhs)
    {
        return static_cast<IconLookupFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline IconLookupFlags operator &(IconLookupFlags lhs, IconLookupFlags rhs)
    {
        return static_cast<IconLookupFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline IconLookupFlags operator ^(IconLookupFlags lhs, IconLookupFlags rhs)
    {
        return static_cast<IconLookupFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline IconLookupFlags operator ~(IconLookupFlags flags)
    {
        return static_cast<IconLookupFlags >(~static_cast<unsigned >(flags));
    }
    inline IconLookupFlags & operator |=(IconLookupFlags & lhs, IconLookupFlags rhs)
    {
        return (lhs = static_cast<IconLookupFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline IconLookupFlags & operator &=(IconLookupFlags & lhs, IconLookupFlags rhs)
    {
        return (lhs = static_cast<IconLookupFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline IconLookupFlags & operator ^=(IconLookupFlags & lhs, IconLookupFlags rhs)
    {
        return (lhs = static_cast<IconLookupFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
    class IconThemeError : public Glib::Error
    {
        public :
            enum Code
            {
                ICON_THEME_NOT_FOUND, 
                ICON_THEME_FAILED
            };
            IconThemeError(Code error_code, const Glib::ustring & error_message);
            explicit IconThemeError(GError * gobject);
            Code code() const;
        private :
            static void throw_func(GError * gobject);
            friend void wrap_init();
    };
}
namespace Glib {
    template<>
    class Value< Gtk::IconThemeError::Code > : public Glib::Value_Enum< Gtk::IconThemeError::Code >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class IconTheme : public Glib::Object
    {
        public :
            typedef IconTheme CppObjectType;
            typedef IconTheme_Class CppClassType;
            typedef GtkIconTheme BaseObjectType;
            typedef GtkIconThemeClass BaseClassType;
        private :
            friend class IconTheme_Class;
            static CppClassType icontheme_class_;
        private :
            IconTheme(const IconTheme &);
            IconTheme & operator =(const IconTheme &);
        protected :
            explicit IconTheme(const Glib::ConstructParams & construct_params);
            explicit IconTheme(GtkIconTheme * castitem);
        public :
            virtual ~IconTheme();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkIconTheme * gobj()
            {
                return reinterpret_cast<GtkIconTheme * >(gobject_);
            }
            const GtkIconTheme * gobj() const
            {
                return reinterpret_cast<GtkIconTheme * >(gobject_);
            }
            GtkIconTheme * gobj_copy();
        private :
        protected :
            IconTheme();
        public :
            static Glib::RefPtr< IconTheme > create();
            static Glib::RefPtr< IconTheme > get_default();
            static Glib::RefPtr< IconTheme > get_for_screen(const Glib::RefPtr< Gdk::Screen > & screen);
            void set_screen(const Glib::RefPtr< Gdk::Screen > & screen);
            void set_search_path(const Glib::ArrayHandle< Glib::ustring > & path);
            Glib::ArrayHandle< Glib::ustring > get_search_path() const;
            void append_search_path(const Glib::ustring & path);
            void prepend_search_path(const Glib::ustring & path);
            void set_custom_theme(const Glib::ustring & theme_name);
            bool has_icon(const Glib::ustring & icon_name) const;
            Glib::ArrayHandle< int > get_icon_sizes(const Glib::ustring & icon_name) const;
            IconInfo lookup_icon(const Glib::ustring & icon_name, int size, IconLookupFlags flags) const;
            IconInfo choose_icon(const Glib::StringArrayHandle & icon_names, int size, IconLookupFlags flags);
            Glib::RefPtr< Gdk::Pixbuf > load_icon(const Glib::ustring & icon_name, int size, IconLookupFlags flags) const;
            Glib::ListHandle< Glib::ustring > list_icons(const Glib::ustring & context) const;
            Glib::ListHandle< Glib::ustring > list_icons() const;
            Glib::ListHandle< Glib::ustring > list_contexts() const;
            Glib::ustring get_example_icon_name() const;
            bool rescan_if_needed();
            static void add_builtin_icon(const Glib::ustring & icon_name, int size, const Glib::RefPtr< Gdk::Pixbuf > & pixbuf);
            Glib::SignalProxy0< void > signal_changed();
        public :
        public :
        protected :
            virtual void on_changed();
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::IconTheme > wrap(GtkIconTheme * object, bool take_copy = false);
}
typedef struct _GtkIconView GtkIconView;
typedef struct _GtkIconViewClass GtkIconViewClass;
namespace Gtk {
    class IconView_Class;
}
namespace Gtk {
    enum IconViewDropPosition
    {
        ICON_VIEW_NO_DROP, 
        ICON_VIEW_DROP_INTO, 
        ICON_VIEW_DROP_LEFT, 
        ICON_VIEW_DROP_RIGHT, 
        ICON_VIEW_DROP_ABOVE, 
        ICON_VIEW_DROP_BELOW
    };
}
namespace Glib {
    template<>
    class Value< Gtk::IconViewDropPosition > : public Glib::Value_Enum< Gtk::IconViewDropPosition >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class IconView : public Container
    {
        public :
            typedef IconView CppObjectType;
            typedef IconView_Class CppClassType;
            typedef GtkIconView BaseObjectType;
            typedef GtkIconViewClass BaseClassType;
            virtual ~IconView();
        private :
            friend class IconView_Class;
            static CppClassType iconview_class_;
            IconView(const IconView &);
            IconView & operator =(const IconView &);
        protected :
            explicit IconView(const Glib::ConstructParams & construct_params);
            explicit IconView(GtkIconView * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkIconView * gobj()
            {
                return reinterpret_cast<GtkIconView * >(gobject_);
            }
            const GtkIconView * gobj() const
            {
                return reinterpret_cast<GtkIconView * >(gobject_);
            }
        public :
        protected :
            virtual void on_set_scroll_adjustments(Adjustment * hadjustment, Adjustment * vadjustment);
            virtual void on_item_activated(const TreeModel::Path & path);
            virtual void on_selection_changed();
        private :
        public :
            IconView();
            explicit IconView(const Glib::RefPtr< TreeModel > & model);
            void set_model(const Glib::RefPtr< TreeModel > & model);
            Glib::RefPtr< TreeModel > get_model();
            Glib::RefPtr< const TreeModel > get_model() const;
            void set_text_column(int column);
            void set_text_column(const TreeModelColumnBase & model_column);
            int get_text_column() const;
            void set_markup_column(int column);
            void set_markup_column(const TreeModelColumnBase & column);
            int get_markup_column() const;
            void set_pixbuf_column(int column);
            void set_pixbuf_column(const TreeModelColumnBase & column);
            int get_pixbuf_column() const;
            void set_orientation(Orientation orientation);
            Orientation get_orientation() const;
            void set_columns(int columns);
            int get_columns() const;
            void set_item_width(int item_width);
            int get_icon_width() const;
            void set_spacing(int spacing);
            int get_spacing() const;
            void set_row_spacing(int row_spacing);
            gint get_row_spacing() const;
            void set_column_spacing(int column_spacing);
            int get_column_spacing() const;
            void set_margin(int margin);
            int get_margin() const;
            TreeModel::Path get_path_at_pos(int x, int y) const;
            bool get_item_at_pos(int x, int y, TreeModel::Path & path, CellRenderer * & cell) const;
            bool get_item_at_pos(int x, int y, TreeModel::Path & path) const;
            bool get_item_at_pos(int x, int y, CellRenderer * & cell) const;
            bool get_visible_range(TreeModel::Path & start_path, TreeModel::Path & end_path) const;
            typedef sigc::slot< void, const TreeModel::Path & > SlotForeach;
            void selected_foreach(const SlotForeach & slot);
            void set_selection_mode(SelectionMode mode);
            SelectionMode get_selection_mode() const;
            void select_path(const TreeModel::Path & path);
            void unselect_path(const TreeModel::Path & path);
            bool path_is_selected(const TreeModel::Path & path) const;
            struct TreePathTraits
            {
                    typedef TreePath CppType;
                    typedef const GtkTreePath * CType;
                    typedef GtkTreePath * CTypeNonConst;
                    static CType to_c_type(const CppType & obj)
                    {
                        return obj.gobj();
                    }
                    static CType to_c_type(const CType & obj)
                    {
                        return obj;
                    }
                    static CppType to_cpp_type(const CType & obj)
                    {
                        return CppType(const_cast<CTypeNonConst >(obj), true);
                    }
                    static void release_c_type(const CType &)
                    {
                    }
            };
            typedef Glib::ListHandle< TreePath, TreePathTraits > ArrayHandle_TreePaths;
            ArrayHandle_TreePaths get_selected_items() const;
            void select_all();
            void unselect_all();
            void item_activated(const TreeModel::Path & path);
            void set_cursor(const TreeModel::Path & path, CellRenderer & cell, bool start_editing);
            bool get_cursor(TreeModel::Path & path, CellRenderer * & cell) const;
            bool get_cursor(TreeModel::Path & path) const;
            bool get_cursor(CellRenderer * & cell) const;
            void scroll_to_path(const TreeModel::Path & path, bool use_align, gfloat row_align, gfloat col_align);
            void enable_model_drag_source(const ArrayHandle_TargetEntry & targets, Gdk::ModifierType start_button_mask = Gdk::MODIFIER_MASK, Gdk::DragAction actions = Gdk::ACTION_COPY | Gdk::ACTION_MOVE);
            void enable_model_drag_dest(const ArrayHandle_TargetEntry & targets, Gdk::DragAction actions = Gdk::ACTION_COPY | Gdk::ACTION_MOVE);
            void unset_model_drag_source();
            void unset_model_drag_dest();
            void set_reorderable(bool reorderable = true);
            bool get_reorderable() const;
            void set_drag_dest_item(const TreeModel::Path & path, IconViewDropPosition pos);
            void get_drag_dest_item(TreeModel::Path & path, IconViewDropPosition & pos) const;
            void get_drag_dest_item(TreeModel::Path & path) const;
            void get_drag_dest_item(IconViewDropPosition & pos) const;
            bool get_dest_item_at_pos(int drag_x, int drag_y, TreeModel::Path & path, IconViewDropPosition & pos) const;
            bool get_dest_item_at_pos(int drag_x, int drag_y, TreeModel::Path & path) const;
            bool get_dest_item_at_pos(int drag_x, int drag_y, IconViewDropPosition & pos) const;
            Glib::RefPtr< Gdk::Pixmap > create_drag_icon(const TreeModel::Path & path);
            void convert_widget_to_bin_window_coords(int wx, int wy, int & bx, int & by) const;
            void set_tooltip_item(const Glib::RefPtr< Tooltip > & tooltip, const TreeModel::Path & path);
            void set_tooltip_cell(const Glib::RefPtr< Tooltip > & tooltip, const TreeModel::Path & path, CellRenderer & cell);
            void set_tooltip_cell(const Glib::RefPtr< Tooltip > & tooltip, const TreeModel::Path & path);
            bool get_tooltip_context_path(int & x, int & y, bool keyboard_tip, TreeModel::Path & path);
            bool get_tooltip_context_iter(int & x, int & y, bool keyboard_tip, Gtk::TreeModel::iterator & iter);
            void set_tooltip_column(int column);
            int get_tooltip_column() const;
            Glib::SignalProxy2< void, Adjustment *, Adjustment * > signal_set_scroll_adjustments();
            Glib::SignalProxy1< void, const TreeModel::Path & > signal_item_activated();
            Glib::SignalProxy0< void > signal_selection_changed();
            Glib::PropertyProxy< int > property_pixbuf_column();
            Glib::PropertyProxy_ReadOnly< int > property_pixbuf_column() const;
            Glib::PropertyProxy< int > property_text_column();
            Glib::PropertyProxy_ReadOnly< int > property_text_column() const;
            Glib::PropertyProxy< int > property_markup_column();
            Glib::PropertyProxy_ReadOnly< int > property_markup_column() const;
            Glib::PropertyProxy< SelectionMode > property_selection_mode();
            Glib::PropertyProxy_ReadOnly< SelectionMode > property_selection_mode() const;
            Glib::PropertyProxy< Orientation > property_orientation();
            Glib::PropertyProxy_ReadOnly< Orientation > property_orientation() const;
            Glib::PropertyProxy< Glib::RefPtr< TreeModel > > property_model();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< TreeModel > > property_model() const;
            Glib::PropertyProxy< int > property_columns();
            Glib::PropertyProxy_ReadOnly< int > property_columns() const;
            Glib::PropertyProxy< int > property_item_width();
            Glib::PropertyProxy_ReadOnly< int > property_item_width() const;
            Glib::PropertyProxy< int > property_spacing();
            Glib::PropertyProxy_ReadOnly< int > property_spacing() const;
            Glib::PropertyProxy< int > property_row_spacing();
            Glib::PropertyProxy_ReadOnly< int > property_row_spacing() const;
            Glib::PropertyProxy< int > property_column_spacing();
            Glib::PropertyProxy_ReadOnly< int > property_column_spacing() const;
            Glib::PropertyProxy< int > property_margin();
            Glib::PropertyProxy_ReadOnly< int > property_margin() const;
    };
}
namespace Glib {
    Gtk::IconView * wrap(GtkIconView * object, bool take_copy = false);
}
typedef struct _GtkImage GtkImage;
typedef struct _GtkImageClass GtkImageClass;
namespace Gtk {
    class Image_Class;
}
namespace Gtk {
    enum ImageType
    {
        IMAGE_EMPTY, 
        IMAGE_PIXMAP, 
        IMAGE_IMAGE, 
        IMAGE_PIXBUF, 
        IMAGE_STOCK, 
        IMAGE_ICON_SET, 
        IMAGE_ANIMATION, 
        IMAGE_ICON_NAME
    };
}
namespace Glib {
    template<>
    class Value< Gtk::ImageType > : public Glib::Value_Enum< Gtk::ImageType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class Image : public Misc
    {
        public :
            typedef Image CppObjectType;
            typedef Image_Class CppClassType;
            typedef GtkImage BaseObjectType;
            typedef GtkImageClass BaseClassType;
            virtual ~Image();
        private :
            friend class Image_Class;
            static CppClassType image_class_;
            Image(const Image &);
            Image & operator =(const Image &);
        protected :
            explicit Image(const Glib::ConstructParams & construct_params);
            explicit Image(GtkImage * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkImage * gobj()
            {
                return reinterpret_cast<GtkImage * >(gobject_);
            }
            const GtkImage * gobj() const
            {
                return reinterpret_cast<GtkImage * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            Image();
            explicit Image(const Glib::RefPtr< Gdk::Pixmap > & pixmap, const Glib::RefPtr< Gdk::Bitmap > & mask);
            explicit Image(const Glib::RefPtr< Gdk::Image > & image, const Glib::RefPtr< Gdk::Bitmap > & mask);
            explicit Image(const std::string & file);
            explicit Image(const Glib::RefPtr< Gdk::Pixbuf > & pixbuf);
            Image(const Gtk::StockID & stock_id, IconSize size);
            Image(IconSet & icon_set, IconSize size);
            Image(const Glib::RefPtr< Gdk::PixbufAnimation > & animation);
            void set(const Glib::RefPtr< Gdk::Pixmap > & pixmap, const Glib::RefPtr< Gdk::Bitmap > & mask);
            void set(const Glib::RefPtr< Gdk::Image > & gdk_image, const Glib::RefPtr< Gdk::Bitmap > & mask);
            void set(const std::string & filename);
            void set(const Glib::RefPtr< Gdk::Pixbuf > & pixbuf);
            void set(const Gtk::StockID & stock_id, IconSize size);
            void set(IconSet & icon_set, IconSize size);
            void set(const Glib::RefPtr< Gdk::PixbufAnimation > & animation);
            void set_from_icon_name(const Glib::ustring & icon_name, IconSize size);
            void clear();
            ImageType get_storage_type() const;
            void get_pixmap(Glib::RefPtr< Gdk::Pixmap > & pixmap, Glib::RefPtr< Gdk::Bitmap > & mask) const;
            void get_image(Glib::RefPtr< Gdk::Image > & gdk_image, Glib::RefPtr< Gdk::Bitmap > & mask) const;
            Glib::RefPtr< Gdk::Pixbuf > get_pixbuf();
            Glib::RefPtr< const Gdk::Pixbuf > get_pixbuf() const;
            void get_stock(Gtk::StockID & stock_id, IconSize & size) const;
            void get_icon_set(IconSet & icon_set, IconSize & size) const;
            Glib::RefPtr< Gdk::PixbufAnimation > get_animation();
            Glib::RefPtr< const Gdk::PixbufAnimation > get_animation() const;
            Glib::ustring get_icon_name() const;
            Glib::ustring get_icon_name(IconSize & size);
            int get_pixel_size() const;
            void set_pixel_size(int pixel_size);
            Glib::PropertyProxy< Glib::RefPtr< Gdk::Pixbuf > > property_pixbuf();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Gdk::Pixbuf > > property_pixbuf() const;
            Glib::PropertyProxy< Glib::RefPtr< Gdk::Pixmap > > property_pixmap();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Gdk::Pixmap > > property_pixmap() const;
            Glib::PropertyProxy< Glib::RefPtr< Gdk::Image > > property_image();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Gdk::Image > > property_image() const;
            Glib::PropertyProxy< Glib::RefPtr< Gdk::Pixmap > > property_mask();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Gdk::Pixmap > > property_mask() const;
            Glib::PropertyProxy< Glib::ustring > property_file();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_file() const;
            Glib::PropertyProxy< Glib::ustring > property_stock();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_stock() const;
            Glib::PropertyProxy< Gtk::IconSet > property_icon_set();
            Glib::PropertyProxy_ReadOnly< Gtk::IconSet > property_icon_set() const;
            Glib::PropertyProxy< int > property_icon_size();
            Glib::PropertyProxy_ReadOnly< int > property_icon_size() const;
            Glib::PropertyProxy< Glib::RefPtr< Gdk::PixbufAnimation > > property_pixbuf_animation();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Gdk::PixbufAnimation > > property_pixbuf_animation() const;
            Glib::PropertyProxy_ReadOnly< ImageType > property_storage_type() const;
    };
}
namespace Glib {
    Gtk::Image * wrap(GtkImage * object, bool take_copy = false);
}
typedef struct _GtkInputDialog GtkInputDialog;
typedef struct _GtkInputDialogClass GtkInputDialogClass;
namespace Gtk {
    class InputDialog_Class;
}
namespace Gtk {
    class Button;
    class Table;
    class OptionMenu;
    class ScrolledWindow;
    class InputDialog : public Dialog
    {
        public :
            typedef InputDialog CppObjectType;
            typedef InputDialog_Class CppClassType;
            typedef GtkInputDialog BaseObjectType;
            typedef GtkInputDialogClass BaseClassType;
            virtual ~InputDialog();
        private :
            friend class InputDialog_Class;
            static CppClassType inputdialog_class_;
            InputDialog(const InputDialog &);
            InputDialog & operator =(const InputDialog &);
        protected :
            explicit InputDialog(const Glib::ConstructParams & construct_params);
            explicit InputDialog(GtkInputDialog * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkInputDialog * gobj()
            {
                return reinterpret_cast<GtkInputDialog * >(gobject_);
            }
            const GtkInputDialog * gobj() const
            {
                return reinterpret_cast<GtkInputDialog * >(gobject_);
            }
        public :
        protected :
            virtual void on_enable_device(const Glib::RefPtr< Gdk::Device > & device);
            virtual void on_disable_device(const Glib::RefPtr< Gdk::Device > & device);
        private :
        public :
            InputDialog();
            Table * get_axis_list();
            const Table * get_axis_list() const;
            ScrolledWindow * get_axis_box();
            const ScrolledWindow * get_axis_box() const;
            OptionMenu * get_mode_optionmenu();
            const OptionMenu * get_mode_optionmenu() const;
            Button * get_close_button();
            const Button * get_close_button() const;
            Button * get_save_button();
            const Button * get_save_button() const;
            Glib::RefPtr< Gdk::Device > get_current_device();
            Glib::RefPtr< const Gdk::Device > get_current_device() const;
            Table * get_keys_list();
            const Table * get_keys_list() const;
            ScrolledWindow * get_keys_box();
            const ScrolledWindow * get_keys_box() const;
            Glib::SignalProxy1< void, const Glib::RefPtr< Gdk::Device > & > signal_enable_device();
            Glib::SignalProxy1< void, const Glib::RefPtr< Gdk::Device > & > signal_disable_device();
    };
}
namespace Glib {
    Gtk::InputDialog * wrap(GtkInputDialog * object, bool take_copy = false);
}
typedef struct _GtkCalendar GtkCalendar;
typedef struct _GtkCalendarClass GtkCalendarClass;
namespace Gtk {
    class Calendar_Class;
}
namespace Gtk {
    enum CalendarDisplayOptions
    {
        CALENDAR_SHOW_HEADING = 1 << 0, 
        CALENDAR_SHOW_DAY_NAMES = 1 << 1, 
        CALENDAR_NO_MONTH_CHANGE = 1 << 2, 
        CALENDAR_SHOW_WEEK_NUMBERS = 1 << 3, 
        CALENDAR_WEEK_START_MONDAY = 1 << 4
    };
    inline CalendarDisplayOptions operator |(CalendarDisplayOptions lhs, CalendarDisplayOptions rhs)
    {
        return static_cast<CalendarDisplayOptions >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline CalendarDisplayOptions operator &(CalendarDisplayOptions lhs, CalendarDisplayOptions rhs)
    {
        return static_cast<CalendarDisplayOptions >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline CalendarDisplayOptions operator ^(CalendarDisplayOptions lhs, CalendarDisplayOptions rhs)
    {
        return static_cast<CalendarDisplayOptions >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline CalendarDisplayOptions operator ~(CalendarDisplayOptions flags)
    {
        return static_cast<CalendarDisplayOptions >(~static_cast<unsigned >(flags));
    }
    inline CalendarDisplayOptions & operator |=(CalendarDisplayOptions & lhs, CalendarDisplayOptions rhs)
    {
        return (lhs = static_cast<CalendarDisplayOptions >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline CalendarDisplayOptions & operator &=(CalendarDisplayOptions & lhs, CalendarDisplayOptions rhs)
    {
        return (lhs = static_cast<CalendarDisplayOptions >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline CalendarDisplayOptions & operator ^=(CalendarDisplayOptions & lhs, CalendarDisplayOptions rhs)
    {
        return (lhs = static_cast<CalendarDisplayOptions >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gtk::CalendarDisplayOptions > : public Glib::Value_Flags< Gtk::CalendarDisplayOptions >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class Calendar : public Widget
    {
        public :
            typedef Calendar CppObjectType;
            typedef Calendar_Class CppClassType;
            typedef GtkCalendar BaseObjectType;
            typedef GtkCalendarClass BaseClassType;
            virtual ~Calendar();
        private :
            friend class Calendar_Class;
            static CppClassType calendar_class_;
            Calendar(const Calendar &);
            Calendar & operator =(const Calendar &);
        protected :
            explicit Calendar(const Glib::ConstructParams & construct_params);
            explicit Calendar(GtkCalendar * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkCalendar * gobj()
            {
                return reinterpret_cast<GtkCalendar * >(gobject_);
            }
            const GtkCalendar * gobj() const
            {
                return reinterpret_cast<GtkCalendar * >(gobject_);
            }
        public :
        protected :
            virtual void on_month_changed();
            virtual void on_day_selected();
            virtual void on_day_selected_double_click();
            virtual void on_prev_month();
            virtual void on_next_month();
            virtual void on_prev_year();
            virtual void on_next_year();
        private :
        public :
            Calendar();
            int select_month(guint month, guint year);
            void select_day(guint day);
            int mark_day(guint day);
            int unmark_day(guint day);
            void clear_marks();
            void display_options(CalendarDisplayOptions flags);
            void set_display_options(CalendarDisplayOptions flags);
            CalendarDisplayOptions get_display_options() const;
            void get_date(guint & year, guint & month, guint & day) const;
            void get_date(Glib::Date & date) const;
            void freeze();
            void thaw();
            Glib::SignalProxy0< void > signal_month_changed();
            Glib::SignalProxy0< void > signal_day_selected();
            Glib::SignalProxy0< void > signal_day_selected_double_click();
            Glib::SignalProxy0< void > signal_prev_month();
            Glib::SignalProxy0< void > signal_next_month();
            Glib::SignalProxy0< void > signal_prev_year();
            Glib::SignalProxy0< void > signal_next_year();
    };
}
namespace Glib {
    Gtk::Calendar * wrap(GtkCalendar * object, bool take_copy = false);
}
typedef struct _GtkInvisible GtkInvisible;
typedef struct _GtkInvisibleClass GtkInvisibleClass;
namespace Gtk {
    class Invisible_Class;
}
namespace Gtk {
    class Invisible : public Widget
    {
        public :
            typedef Invisible CppObjectType;
            typedef Invisible_Class CppClassType;
            typedef GtkInvisible BaseObjectType;
            typedef GtkInvisibleClass BaseClassType;
            virtual ~Invisible();
        private :
            friend class Invisible_Class;
            static CppClassType invisible_class_;
            Invisible(const Invisible &);
            Invisible & operator =(const Invisible &);
        protected :
            explicit Invisible(const Glib::ConstructParams & construct_params);
            explicit Invisible(GtkInvisible * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkInvisible * gobj()
            {
                return reinterpret_cast<GtkInvisible * >(gobject_);
            }
            const GtkInvisible * gobj() const
            {
                return reinterpret_cast<GtkInvisible * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            Invisible();
            explicit Invisible(const Glib::RefPtr< Gdk::Screen > & screen);
            Glib::RefPtr< Gdk::Screen > get_screen();
            Glib::RefPtr< const Gdk::Screen > get_screen() const;
            void set_screen(const Glib::RefPtr< Gdk::Screen > & screen);
    };
}
namespace Glib {
    Gtk::Invisible * wrap(GtkInvisible * object, bool take_copy = false);
}
typedef struct _GtkLayout GtkLayout;
typedef struct _GtkLayoutClass GtkLayoutClass;
namespace Gtk {
    class Layout_Class;
}
namespace Gtk {
    class Layout : public Container
    {
        public :
            typedef Layout CppObjectType;
            typedef Layout_Class CppClassType;
            typedef GtkLayout BaseObjectType;
            typedef GtkLayoutClass BaseClassType;
            virtual ~Layout();
        private :
            friend class Layout_Class;
            static CppClassType layout_class_;
            Layout(const Layout &);
            Layout & operator =(const Layout &);
        protected :
            explicit Layout(const Glib::ConstructParams & construct_params);
            explicit Layout(GtkLayout * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkLayout * gobj()
            {
                return reinterpret_cast<GtkLayout * >(gobject_);
            }
            const GtkLayout * gobj() const
            {
                return reinterpret_cast<GtkLayout * >(gobject_);
            }
        public :
        protected :
            virtual void on_set_scroll_adjustments(Adjustment * hadj, Adjustment * vadj);
        private :
        public :
            Layout();
            Layout(Adjustment & hadjustment, Adjustment & vadjustment);
            void put(Widget & child_widget, int x, int y);
            void move(Widget & child_widget, int x, int y);
            void set_size(guint width, guint height);
            void get_size(guint & width, guint & height) const;
            void set_hadjustment(Adjustment & adjustment);
            void set_hadjustment();
            Adjustment * get_hadjustment();
            const Adjustment * get_hadjustment() const;
            void set_vadjustment(Adjustment & adjustment);
            void set_vadjustment();
            Adjustment * get_vadjustment();
            const Adjustment * get_vadjustment() const;
            Glib::RefPtr< Gdk::Window > get_bin_window();
            Glib::RefPtr< const Gdk::Window > get_bin_window() const;
            Glib::SignalProxy2< void, Adjustment *, Adjustment * > signal_set_scroll_adjustments();
            Glib::PropertyProxy< Adjustment * > property_hadjustment();
            Glib::PropertyProxy_ReadOnly< Adjustment * > property_hadjustment() const;
            Glib::PropertyProxy< Adjustment * > property_vadjustment();
            Glib::PropertyProxy_ReadOnly< Adjustment * > property_vadjustment() const;
            Glib::PropertyProxy< guint > property_width();
            Glib::PropertyProxy_ReadOnly< guint > property_width() const;
            Glib::PropertyProxy< guint > property_height();
            Glib::PropertyProxy_ReadOnly< guint > property_height() const;
    };
}
namespace Glib {
    Gtk::Layout * wrap(GtkLayout * object, bool take_copy = false);
}
extern "C"
{
    enum 
    {
        GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID = -1, 
        GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID = -2
    };
    typedef struct _GtkTreeSortable GtkTreeSortable;
    typedef struct _GtkTreeSortableIface GtkTreeSortableIface;
    typedef gint (* GtkTreeIterCompareFunc)(GtkTreeModel * model, GtkTreeIter * a, GtkTreeIter * b, gpointer user_data);
    struct _GtkTreeSortableIface
    {
            GTypeInterface g_iface;
            void (* sort_column_changed)(GtkTreeSortable * sortable);
            gboolean (* get_sort_column_id)(GtkTreeSortable * sortable, gint * sort_column_id, GtkSortType * order);
            void (* set_sort_column_id)(GtkTreeSortable * sortable, gint sort_column_id, GtkSortType order);
            void (* set_sort_func)(GtkTreeSortable * sortable, gint sort_column_id, GtkTreeIterCompareFunc func, gpointer data, GtkDestroyNotify destroy);
            void (* set_default_sort_func)(GtkTreeSortable * sortable, GtkTreeIterCompareFunc func, gpointer data, GtkDestroyNotify destroy);
            gboolean (* has_default_sort_func)(GtkTreeSortable * sortable);
    };
    GType gtk_tree_sortable_get_type(void) __attribute__((__const__));
    void gtk_tree_sortable_sort_column_changed(GtkTreeSortable * sortable);
    gboolean gtk_tree_sortable_get_sort_column_id(GtkTreeSortable * sortable, gint * sort_column_id, GtkSortType * order);
    void gtk_tree_sortable_set_sort_column_id(GtkTreeSortable * sortable, gint sort_column_id, GtkSortType order);
    void gtk_tree_sortable_set_sort_func(GtkTreeSortable * sortable, gint sort_column_id, GtkTreeIterCompareFunc sort_func, gpointer user_data, GtkDestroyNotify destroy);
    void gtk_tree_sortable_set_default_sort_func(GtkTreeSortable * sortable, GtkTreeIterCompareFunc sort_func, gpointer user_data, GtkDestroyNotify destroy);
    gboolean gtk_tree_sortable_has_default_sort_func(GtkTreeSortable * sortable);
}
typedef struct _GtkTreeSortable GtkTreeSortable;
typedef struct _GtkTreeSortableClass GtkTreeSortableClass;
namespace Gtk {
    class TreeSortable_Class;
}
namespace Gtk {
    class TreeSortable : public Glib::Interface
    {
        public :
            typedef TreeSortable CppObjectType;
            typedef TreeSortable_Class CppClassType;
            typedef GtkTreeSortable BaseObjectType;
            typedef GtkTreeSortableIface BaseClassType;
        private :
            friend class TreeSortable_Class;
            static CppClassType treesortable_class_;
            TreeSortable(const TreeSortable &);
            TreeSortable & operator =(const TreeSortable &);
        protected :
            TreeSortable();
            explicit TreeSortable(const Glib::Interface_Class & interface_class);
        public :
            explicit TreeSortable(GtkTreeSortable * castitem);
        protected :
        public :
            virtual ~TreeSortable();
            static void add_interface(GType gtype_implementer);
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTreeSortable * gobj()
            {
                return reinterpret_cast<GtkTreeSortable * >(gobject_);
            }
            const GtkTreeSortable * gobj() const
            {
                return reinterpret_cast<GtkTreeSortable * >(gobject_);
            }
        private :
        public :
            enum 
            {
                DEFAULT_SORT_COLUMN_ID = -1, 
                DEFAULT_UNSORTED_COLUMN_ID = -2
            };
            bool get_sort_column_id(int & sort_column_id, SortType & order) const;
            void set_sort_column(const TreeModelColumnBase & sort_column_id, SortType order);
            void set_sort_column(int sort_column_id, SortType order);
            void set_sort_column_id(const TreeModelColumnBase & sort_column_id, SortType order);
            void set_sort_column_id(int sort_column_id, SortType order);
            typedef sigc::slot< int, const Gtk::TreeModel::iterator &, const Gtk::TreeModel::iterator & > SlotCompare;
            void set_sort_func(const TreeModelColumnBase & sort_column, const SlotCompare & slot);
            void set_sort_func(int sort_column_id, const SlotCompare & slot);
            void set_default_sort_func(const SlotCompare & slot);
            void unset_default_sort_func();
            bool has_default_sort_func() const;
            void sort_column_changed();
            Glib::SignalProxy0< void > signal_sort_column_changed();
        protected :
            virtual bool get_sort_column_id_vfunc(int * sort_column_id, SortType * order) const;
            virtual void set_sort_column_id_vfunc(int sort_column_id, SortType order);
            virtual void set_sort_func_vfunc(int sort_column_id, GtkTreeIterCompareFunc func, void * data, GtkDestroyNotify destroy);
            virtual void set_default_sort_func_vfunc(GtkTreeIterCompareFunc func, void * data, GtkDestroyNotify destroy);
            virtual bool has_default_sort_func_vfunc() const;
            virtual void sort_column_changed_vfunc() const;
        public :
        public :
        protected :
            virtual void on_sort_column_changed();
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::TreeSortable > wrap(GtkTreeSortable * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkTreeDragDestIface GtkTreeDragDestIface;
    typedef struct _GtkSelectionData GtkSelectionData;
}
typedef struct _GtkTreeDragDest GtkTreeDragDest;
typedef struct _GtkTreeDragDestClass GtkTreeDragDestClass;
namespace Gtk {
    class TreeDragDest_Class;
}
namespace Gtk {
    class TreeDragDest : public Glib::Interface
    {
        public :
            typedef TreeDragDest CppObjectType;
            typedef TreeDragDest_Class CppClassType;
            typedef GtkTreeDragDest BaseObjectType;
            typedef GtkTreeDragDestIface BaseClassType;
        private :
            friend class TreeDragDest_Class;
            static CppClassType treedragdest_class_;
            TreeDragDest(const TreeDragDest &);
            TreeDragDest & operator =(const TreeDragDest &);
        protected :
            TreeDragDest();
            explicit TreeDragDest(const Glib::Interface_Class & interface_class);
        public :
            explicit TreeDragDest(GtkTreeDragDest * castitem);
        protected :
        public :
            virtual ~TreeDragDest();
            static void add_interface(GType gtype_implementer);
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTreeDragDest * gobj()
            {
                return reinterpret_cast<GtkTreeDragDest * >(gobject_);
            }
            const GtkTreeDragDest * gobj() const
            {
                return reinterpret_cast<GtkTreeDragDest * >(gobject_);
            }
        private :
        public :
            bool drag_data_received(const TreeModel::Path & dest, const SelectionData & selection_data);
            bool row_drop_possible(const TreeModel::Path & dest_path, const SelectionData & selection_data) const;
        protected :
            virtual bool drag_data_received_vfunc(const TreeModel::Path & dest, const SelectionData & selection_data);
            virtual bool row_drop_possible_vfunc(const TreeModel::Path & dest, const SelectionData & selection_data) const;
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::TreeDragDest > wrap(GtkTreeDragDest * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkTreeDragSourceIface GtkTreeDragSourceIface;
    typedef struct _GtkSelectionData GtkSelectionData;
}
typedef struct _GtkTreeDragSource GtkTreeDragSource;
typedef struct _GtkTreeDragSourceClass GtkTreeDragSourceClass;
namespace Gtk {
    class TreeDragSource_Class;
}
namespace Gtk {
    class TreeDragSource : public Glib::Interface
    {
        public :
            typedef TreeDragSource CppObjectType;
            typedef TreeDragSource_Class CppClassType;
            typedef GtkTreeDragSource BaseObjectType;
            typedef GtkTreeDragSourceIface BaseClassType;
        private :
            friend class TreeDragSource_Class;
            static CppClassType treedragsource_class_;
            TreeDragSource(const TreeDragSource &);
            TreeDragSource & operator =(const TreeDragSource &);
        protected :
            TreeDragSource();
            explicit TreeDragSource(const Glib::Interface_Class & interface_class);
        public :
            explicit TreeDragSource(GtkTreeDragSource * castitem);
        protected :
        public :
            virtual ~TreeDragSource();
            static void add_interface(GType gtype_implementer);
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTreeDragSource * gobj()
            {
                return reinterpret_cast<GtkTreeDragSource * >(gobject_);
            }
            const GtkTreeDragSource * gobj() const
            {
                return reinterpret_cast<GtkTreeDragSource * >(gobject_);
            }
        private :
        public :
            bool row_draggable(const TreeModel::Path & path) const;
            bool drag_data_get(const TreeModel::Path & path, SelectionData & selection_data);
            bool drag_data_delete(const TreeModel::Path & path);
        protected :
            virtual bool row_draggable_vfunc(const TreeModel::Path & path) const;
            virtual bool drag_data_get_vfunc(const TreeModel::Path & path, SelectionData & selection_data) const;
            virtual bool drag_data_delete_vfunc(const TreeModel::Path & path);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::TreeDragSource > wrap(GtkTreeDragSource * object, bool take_copy = false);
}
typedef struct _GtkListStore GtkListStore;
typedef struct _GtkListStoreClass GtkListStoreClass;
namespace Gtk {
    class ListStore_Class;
}
namespace Gtk {
    class ListStore : public Glib::Object, public TreeModel, public TreeSortable, public TreeDragSource, public TreeDragDest
    {
        public :
            typedef ListStore CppObjectType;
            typedef ListStore_Class CppClassType;
            typedef GtkListStore BaseObjectType;
            typedef GtkListStoreClass BaseClassType;
        private :
            friend class ListStore_Class;
            static CppClassType liststore_class_;
        private :
            ListStore(const ListStore &);
            ListStore & operator =(const ListStore &);
        protected :
            explicit ListStore(const Glib::ConstructParams & construct_params);
            explicit ListStore(GtkListStore * castitem);
        public :
            virtual ~ListStore();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkListStore * gobj()
            {
                return reinterpret_cast<GtkListStore * >(gobject_);
            }
            const GtkListStore * gobj() const
            {
                return reinterpret_cast<GtkListStore * >(gobject_);
            }
            GtkListStore * gobj_copy();
        private :
        protected :
            ListStore();
            explicit ListStore(const TreeModelColumnRecord & columns);
        public :
            static Glib::RefPtr< ListStore > create(const TreeModelColumnRecord & columns);
            void set_column_types(const TreeModelColumnRecord & columns);
            iterator erase(const iterator & iter);
            iterator insert(const iterator & iter);
            iterator insert_after(const iterator & iter);
            iterator prepend();
            iterator append();
            void iter_swap(const iterator & a, const iterator & b);
            void move(const iterator & source, const iterator & destination);
            void reorder(const Glib::ArrayHandle< int > & new_order);
            void clear();
            bool iter_is_valid(const iterator & iter) const;
        protected :
            virtual void set_value_impl(const iterator & row, int column, const Glib::ValueBase & value);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::ListStore > wrap(GtkListStore * object, bool take_copy = false);
}
namespace Gtk {
    class ListViewText : public Gtk::TreeView
    {
        public :
            ListViewText(guint columns_count, bool editable = false, Gtk::SelectionMode mode = Gtk::SELECTION_SINGLE);
            virtual ~ListViewText();
            void set_column_title(guint column, const Glib::ustring & title);
            Glib::ustring get_column_title(guint column) const;
            guint append_text(const Glib::ustring & column_one_value = Glib::ustring());
            void prepend_text(const Glib::ustring & column_one_value = Glib::ustring());
            void insert_text(guint row, const Glib::ustring & column_one_value = Glib::ustring());
            void clear_items();
            Glib::ustring get_text(guint row, guint column = 0) const;
            void set_text(guint row, guint column, const Glib::ustring & value);
            void set_text(guint row, const Glib::ustring & value);
            guint size() const;
            guint get_num_columns() const;
            typedef std::vector< int > SelectionList;
            SelectionList get_selected();
        protected :
            class TextModelColumns : public Gtk::TreeModel::ColumnRecord
            {
                public :
                    TextModelColumns(guint columns_count);
                    ~TextModelColumns();
                    guint get_num_columns() const;
                    Gtk::TreeModelColumn< Glib::ustring > * m_columns;
                protected :
                    guint m_columns_count;
            };
            Glib::RefPtr< Gtk::ListStore > m_model;
            TextModelColumns m_model_columns;
    };
}
typedef struct _GtkLinkButton GtkLinkButton;
typedef struct _GtkLinkButtonClass GtkLinkButtonClass;
namespace Gtk {
    class LinkButton_Class;
}
namespace Gtk {
    class LinkButton : public Button
    {
        public :
            typedef LinkButton CppObjectType;
            typedef LinkButton_Class CppClassType;
            typedef GtkLinkButton BaseObjectType;
            typedef GtkLinkButtonClass BaseClassType;
            virtual ~LinkButton();
        private :
            friend class LinkButton_Class;
            static CppClassType linkbutton_class_;
            LinkButton(const LinkButton &);
            LinkButton & operator =(const LinkButton &);
        protected :
            explicit LinkButton(const Glib::ConstructParams & construct_params);
            explicit LinkButton(GtkLinkButton * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkLinkButton * gobj()
            {
                return reinterpret_cast<GtkLinkButton * >(gobject_);
            }
            const GtkLinkButton * gobj() const
            {
                return reinterpret_cast<GtkLinkButton * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            LinkButton();
            explicit LinkButton(const Glib::ustring & uri);
            explicit LinkButton(const Glib::ustring & uri, const Glib::ustring & label);
            Glib::ustring get_uri() const;
            void set_uri(const Glib::ustring & uri);
            typedef sigc::slot< void, Gtk::LinkButton *, const Glib::ustring & > SlotUri;
            static void set_uri_hook(const SlotUri & slot);
            static void unset_uri_hook();
            Glib::PropertyProxy< Glib::ustring > property_uri();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_uri() const;
    };
}
namespace Glib {
    Gtk::LinkButton * wrap(GtkLinkButton * object, bool take_copy = false);
}
extern "C"
{
    typedef gint (* GtkKeySnoopFunc)(GtkWidget * grab_widget, GdkEventKey * event, gpointer func_data);
    extern const guint gtk_major_version;
    extern const guint gtk_minor_version;
    extern const guint gtk_micro_version;
    extern const guint gtk_binary_age;
    extern const guint gtk_interface_age;
    const gchar * gtk_check_version(guint required_major, guint required_minor, guint required_micro);
    gboolean gtk_parse_args(int * argc, char * * * argv);
    void gtk_init(int * argc, char * * * argv);
    gboolean gtk_init_check(int * argc, char * * * argv);
    gboolean gtk_init_with_args(int * argc, char * * * argv, char * parameter_string, GOptionEntry * entries, char * translation_domain, GError * * error);
    GOptionGroup * gtk_get_option_group(gboolean open_default_display);
    void gtk_exit(gint error_code);
    void gtk_disable_setlocale(void);
    gchar * gtk_set_locale(void);
    PangoLanguage * gtk_get_default_language(void);
    gboolean gtk_events_pending(void);
    void gtk_main_do_event(GdkEvent * event);
    void gtk_main(void);
    guint gtk_main_level(void);
    void gtk_main_quit(void);
    gboolean gtk_main_iteration(void);
    gboolean gtk_main_iteration_do(gboolean blocking);
    gboolean gtk_true(void) __attribute__((__const__));
    gboolean gtk_false(void) __attribute__((__const__));
    void gtk_grab_add(GtkWidget * widget);
    GtkWidget * gtk_grab_get_current(void);
    void gtk_grab_remove(GtkWidget * widget);
    void gtk_init_add(GtkFunction function, gpointer data);
    void gtk_quit_add_destroy(guint main_level, GtkObject * object);
    guint gtk_quit_add(guint main_level, GtkFunction function, gpointer data);
    guint gtk_quit_add_full(guint main_level, GtkFunction function, GtkCallbackMarshal marshal, gpointer data, GtkDestroyNotify destroy);
    void gtk_quit_remove(guint quit_handler_id);
    void gtk_quit_remove_by_data(gpointer data);
    guint gtk_timeout_add(guint32 interval, GtkFunction function, gpointer data);
    guint gtk_timeout_add_full(guint32 interval, GtkFunction function, GtkCallbackMarshal marshal, gpointer data, GtkDestroyNotify destroy);
    void gtk_timeout_remove(guint timeout_handler_id);
    guint gtk_idle_add(GtkFunction function, gpointer data);
    guint gtk_idle_add_priority(gint priority, GtkFunction function, gpointer data);
    guint gtk_idle_add_full(gint priority, GtkFunction function, GtkCallbackMarshal marshal, gpointer data, GtkDestroyNotify destroy);
    void gtk_idle_remove(guint idle_handler_id);
    void gtk_idle_remove_by_data(gpointer data);
    guint gtk_input_add_full(gint source, GdkInputCondition condition, GdkInputFunction function, GtkCallbackMarshal marshal, gpointer data, GtkDestroyNotify destroy);
    void gtk_input_remove(guint input_handler_id);
    guint gtk_key_snooper_install(GtkKeySnoopFunc snooper, gpointer func_data);
    void gtk_key_snooper_remove(guint snooper_handler_id);
    GdkEvent * gtk_get_current_event(void);
    guint32 gtk_get_current_event_time(void);
    gboolean gtk_get_current_event_state(GdkModifierType * state);
    GtkWidget * gtk_get_event_widget(GdkEvent * event);
    void gtk_propagate_event(GtkWidget * widget, GdkEvent * event);
    gboolean _gtk_boolean_handled_accumulator(GSignalInvocationHint * ihint, GValue * return_accu, const GValue * handler_return, gpointer dummy);
    gchar * _gtk_get_lc_ctype(void);
}
namespace Gtk {
    class Widget;
    class Window;
    class RunSig
    {
        public :
            typedef sigc::slot< void > SlotType;
            sigc::connection connect(const SlotType & slot);
        protected :
            static gboolean gtk_callback(gpointer data);
    };
    class QuitSig
    {
        public :
            typedef sigc::slot< bool > SlotType;
            sigc::connection connect(const SlotType & slot, guint main_level = 0);
        protected :
            static gboolean gtk_callback(gpointer data);
    };
    class KeySnooperSig
    {
        public :
            typedef sigc::slot< int, Widget *, GdkEventKey * > SlotType;
            sigc::connection connect(const SlotType & slot);
        protected :
            static int gtk_callback(GtkWidget * widget, GdkEventKey * event, gpointer data);
    };
    class Main : public sigc::trackable
    {
        public :
            Main(int & argc, char * * & argv, Glib::OptionContext & option_context);
            Main(int * argc, char * * * argv, bool set_locale = true);
            Main(int & argc, char * * & argv, bool set_locale = true);
            virtual ~Main();
            static Gtk::Main * instance();
            static void run();
            static void run(Window & window);
            static void quit();
            static guint level();
            static void add_gtk_option_group(Glib::OptionContext & option_context, bool open_default_display = true);
            static bool iteration(bool blocking = true);
            static bool events_pending();
            static RunSig & signal_run();
            static QuitSig & signal_quit();
            static KeySnooperSig & signal_key_snooper();
            static void init_gtkmm_internals();
        protected :
            Main();
            void init(int * argc, char * * * argv, bool set_locale);
            virtual void run_impl();
            virtual void quit_impl();
            virtual guint level_impl();
            virtual bool iteration_impl(bool blocking);
            virtual bool events_pending_impl();
            virtual void on_window_hide();
            static RunSig signal_run_;
            static QuitSig signal_quit_;
            static KeySnooperSig signal_key_snooper_;
        private :
            static Main * instance_;
    };
}
typedef struct _GtkMenuBar GtkMenuBar;
typedef struct _GtkMenuBarClass GtkMenuBarClass;
namespace Gtk {
    class MenuBar_Class;
}
namespace Gtk {
    class MenuBar : public MenuShell
    {
        public :
            typedef MenuBar CppObjectType;
            typedef MenuBar_Class CppClassType;
            typedef GtkMenuBar BaseObjectType;
            typedef GtkMenuBarClass BaseClassType;
            virtual ~MenuBar();
        private :
            friend class MenuBar_Class;
            static CppClassType menubar_class_;
            MenuBar(const MenuBar &);
            MenuBar & operator =(const MenuBar &);
        protected :
            explicit MenuBar(const Glib::ConstructParams & construct_params);
            explicit MenuBar(GtkMenuBar * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkMenuBar * gobj()
            {
                return reinterpret_cast<GtkMenuBar * >(gobject_);
            }
            const GtkMenuBar * gobj() const
            {
                return reinterpret_cast<GtkMenuBar * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            MenuBar();
        private :
            void init_accels_handler_(void);
    };
}
namespace Glib {
    Gtk::MenuBar * wrap(GtkMenuBar * object, bool take_copy = false);
}
typedef struct _GtkMessageDialog GtkMessageDialog;
typedef struct _GtkMessageDialogClass GtkMessageDialogClass;
namespace Gtk {
    class MessageDialog_Class;
}
namespace Gtk {
    enum MessageType
    {
        MESSAGE_INFO, 
        MESSAGE_WARNING, 
        MESSAGE_QUESTION, 
        MESSAGE_ERROR, 
        MESSAGE_OTHER
    };
}
namespace Glib {
    template<>
    class Value< Gtk::MessageType > : public Glib::Value_Enum< Gtk::MessageType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum ButtonsType
    {
        BUTTONS_NONE, 
        BUTTONS_OK, 
        BUTTONS_CLOSE, 
        BUTTONS_CANCEL, 
        BUTTONS_YES_NO, 
        BUTTONS_OK_CANCEL
    };
}
namespace Glib {
    template<>
    class Value< Gtk::ButtonsType > : public Glib::Value_Enum< Gtk::ButtonsType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class MessageDialog : public Dialog
    {
        public :
            typedef MessageDialog CppObjectType;
            typedef MessageDialog_Class CppClassType;
            typedef GtkMessageDialog BaseObjectType;
            typedef GtkMessageDialogClass BaseClassType;
            virtual ~MessageDialog();
        private :
            friend class MessageDialog_Class;
            static CppClassType messagedialog_class_;
            MessageDialog(const MessageDialog &);
            MessageDialog & operator =(const MessageDialog &);
        protected :
            explicit MessageDialog(const Glib::ConstructParams & construct_params);
            explicit MessageDialog(GtkMessageDialog * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkMessageDialog * gobj()
            {
                return reinterpret_cast<GtkMessageDialog * >(gobject_);
            }
            const GtkMessageDialog * gobj() const
            {
                return reinterpret_cast<GtkMessageDialog * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            explicit MessageDialog(const Glib::ustring & message, bool use_markup = false, MessageType type = MESSAGE_INFO, ButtonsType buttons = BUTTONS_OK, bool modal = false);
            MessageDialog(Gtk::Window & parent, const Glib::ustring & message, bool use_markup = false, MessageType type = MESSAGE_INFO, ButtonsType buttons = BUTTONS_OK, bool modal = false);
            void set_image(Widget & image);
            void set_markup(const Glib::ustring & str);
            void set_message(const Glib::ustring & message, bool use_markup = false);
            void set_secondary_text(const Glib::ustring & text, bool use_markup = false);
            Glib::PropertyProxy< MessageType > property_message_type();
            Glib::PropertyProxy_ReadOnly< MessageType > property_message_type() const;
            Glib::PropertyProxy< Glib::ustring > property_text();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_text() const;
            Glib::PropertyProxy< bool > property_use_markup();
            Glib::PropertyProxy_ReadOnly< bool > property_use_markup() const;
            Glib::PropertyProxy< Glib::ustring > property_secondary_text();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_secondary_text() const;
            Glib::PropertyProxy< bool > property_secondary_use_markup();
            Glib::PropertyProxy_ReadOnly< bool > property_secondary_use_markup() const;
            Glib::PropertyProxy< Widget * > property_image();
            Glib::PropertyProxy_ReadOnly< Widget * > property_image() const;
    };
}
namespace Glib {
    Gtk::MessageDialog * wrap(GtkMessageDialog * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkNotebookPage GtkNotebookPage;
}
typedef struct _GtkNotebook GtkNotebook;
typedef struct _GtkNotebookClass GtkNotebookClass;
namespace Gtk {
    class Notebook_Class;
}
namespace Gtk {
    enum NotebookTab
    {
        NOTEBOOK_TAB_FIRST, 
        NOTEBOOK_TAB_LAST
    };
}
namespace Glib {
    template<>
    class Value< Gtk::NotebookTab > : public Glib::Value_Enum< Gtk::NotebookTab >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class Notebook;
    namespace Notebook_Helpers {
        class Page;
        class PageIterator
        {
            public :
                typedef std::bidirectional_iterator_tag iterator_category;
                typedef size_t size_type;
                typedef ptrdiff_t difference_type;
                typedef Page value_type;
                typedef const Page * pointer;
                typedef const Page & reference;
                PageIterator(Gtk::Notebook * parent, GList * node)
                    : node_(node), parent_(parent) 
                {
                }
                PageIterator()
                    : node_(0), parent_(0) 
                {
                }
                bool equal(const PageIterator & other) const;
                operator bool() const;
                PageIterator & operator ++();
                const PageIterator operator ++(int);
                PageIterator & operator --();
                const PageIterator operator --(int);
                inline reference operator *() const;
                inline pointer operator ->() const;
            protected :
                GList * node_;
                Gtk::Notebook * parent_;
                friend class Gtk::Notebook_Helpers::Page;
        };
        inline bool operator ==(const PageIterator & lhs, const PageIterator & rhs)
        {
            return lhs.equal(rhs);
        }
        inline bool operator !=(const PageIterator & lhs, const PageIterator & rhs)
        {
            return !lhs.equal(rhs);
        }
        class Page : public PageIterator
        {
            protected :
                Page();
            private :
                Page & operator =(const Page &);
            public :
                int get_page_num() const;
                Widget * get_child() const;
                Widget * get_tab_label() const;
                void set_tab_label(Widget & tab_label);
                void set_tab_label_text(const Glib::ustring & tab_text);
                Glib::ustring get_tab_label_text() const;
                Widget * get_menu_label() const;
                void set_menu_label(Widget & menu_label);
                void set_menu_label_text(const Glib::ustring & menu_text);
                Glib::ustring get_menu_label_text() const;
                void query_tab_label_packing(bool & expand, bool & fill, PackType & pack_type);
                void set_tab_label_packing(bool expand, bool fill, PackType pack_type);
        };
        class PageList;
        class Element
        {
            public :
                Element(Widget * child, Widget * tab, Widget * menu);
                Element(Widget & child, Widget & tab, Widget & menu);
                explicit Element(Widget & child);
            protected :
                friend class PageList;
                Widget * child_;
                Widget * tab_;
                Widget * menu_;
        };
        typedef Element WidgetElem;
        struct TabElem : public Element
        {
                TabElem(Widget & child, Widget & tab);
                TabElem(Widget & child, const Glib::ustring & label, bool mnemonic = false);
        };
        struct MenuElem : public Element
        {
                MenuElem(Widget & child, Widget & menu);
        };
        class PageList
        {
            public :
                PageList();
                explicit PageList(GtkNotebook * gparent);
                PageList(const PageList & src);
                PageList & operator =(const PageList & src);
                typedef Page value_type;
                typedef Page & reference;
                typedef const Page & const_reference;
                typedef PageIterator iterator;
                typedef Glib::List_ConstIterator< iterator > const_iterator;
                typedef Glib::List_ReverseIterator< iterator > reverse_iterator;
                typedef Glib::List_ConstIterator< reverse_iterator > const_reverse_iterator;
                typedef const Element element_type;
                typedef size_t difference_type;
                typedef size_t size_type;
                inline GtkNotebook * gparent()
                {
                    return gparent_;
                }
                inline const GtkNotebook * gparent() const
                {
                    return gparent_;
                }
                size_type size() const;
                size_type max_size() const;
                bool empty() const;
                inline iterator begin()
                {
                    return begin_();
                }
                inline iterator end()
                {
                    return end_();
                }
                inline const_iterator begin() const
                {
                    return const_iterator(begin_());
                }
                inline const_iterator end() const
                {
                    return const_iterator(end_());
                }
                inline reverse_iterator rbegin()
                {
                    return reverse_iterator(end_());
                }
                inline reverse_iterator rend()
                {
                    return reverse_iterator(begin_());
                }
                inline const_reverse_iterator rbegin() const
                {
                    return const_reverse_iterator(reverse_iterator(end_()));
                }
                inline const_reverse_iterator rend() const
                {
                    return const_reverse_iterator(reverse_iterator(begin_()));
                }
                value_type front() const;
                value_type back() const;
                value_type operator [](size_type l) const;
                iterator insert(iterator position, element_type & e);
                template<class InputIterator >
                inline void insert(iterator position, InputIterator first, InputIterator last)
                {
                    for (;
                        first != last;
                        ++first)
                    position = insert(position, *first);
                }
                inline void push_front(element_type & e)
                {
                    insert(begin(), e);
                }
                inline void push_back(element_type & e)
                {
                    insert(end(), e);
                }
                void erase(iterator start, iterator stop);
                iterator erase(iterator);
                void remove(const_reference child);
                void remove(Widget & w);
                void reorder(iterator loc, iterator page);
                iterator find(int num);
                iterator find(const_reference c);
                iterator find(Widget & w);
                iterator find(GtkNotebookPage * t);
                inline void pop_front()
                {
                    erase(begin());
                }
                inline void pop_back()
                {
                    erase(--end());
                }
                void clear();
            protected :
                iterator begin_() const;
                iterator end_() const;
                GtkNotebook * gparent_;
        };
    }
    class Notebook : public Container
    {
        public :
            typedef Notebook CppObjectType;
            typedef Notebook_Class CppClassType;
            typedef GtkNotebook BaseObjectType;
            typedef GtkNotebookClass BaseClassType;
            virtual ~Notebook();
        private :
            friend class Notebook_Class;
            static CppClassType notebook_class_;
            Notebook(const Notebook &);
            Notebook & operator =(const Notebook &);
        protected :
            explicit Notebook(const Glib::ConstructParams & construct_params);
            explicit Notebook(GtkNotebook * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkNotebook * gobj()
            {
                return reinterpret_cast<GtkNotebook * >(gobject_);
            }
            const GtkNotebook * gobj() const
            {
                return reinterpret_cast<GtkNotebook * >(gobject_);
            }
        public :
        protected :
            virtual void on_switch_page(GtkNotebookPage * page, guint page_num);
        private :
        public :
            typedef Notebook_Helpers::PageList PageList;
            Notebook();
            int prepend_page(Widget & child, Widget & tab_label);
            int prepend_page(Widget & child);
            int prepend_page(Widget & child, const Glib::ustring & tab_label, bool use_mnemonic = false);
            int prepend_page(Widget & child, Widget & tab_label, Widget & menu_label);
            int prepend_page(Widget & child, const Glib::ustring & tab_label, const Glib::ustring & menu_label, bool use_mnemonic);
            int append_page(Widget & child, Widget & tab_label);
            int append_page(Widget & child);
            int append_page(Widget & child, const Glib::ustring & tab_label, bool use_mnemonic = false);
            int append_page(Widget & child, Widget & tab_label, Widget & menu_label);
            int append_page(Widget & child, const Glib::ustring & tab_label, const Glib::ustring & menu_label, bool use_mnemonic = false);
            int insert_page(Widget & child, Widget & tab_label, int position);
            int insert_page(Widget & child, int position);
            int insert_page(Widget & child, const Glib::ustring & tab_label, int position, bool use_mnemonic = false);
            int insert_page(Widget & child, Widget & tab_label, Widget & menu_label, int position);
            int insert_page(Widget & child, const Glib::ustring & tab_label, const Glib::ustring & menu_label, int position, bool use_mnemonic = false);
            void remove_page(int page_num = 0);
            void remove_page(Widget & child);
            typedef sigc::slot< Notebook *, Widget *, int, int > SlotWindowCreation;
            static void set_window_creation_hook(const SlotWindowCreation & slot);
            void set_group_id(int group_id);
            int get_group_id() const;
            void set_group(void * group);
            void * get_group();
            const void * get_group() const;
            int get_current_page() const;
            Widget * get_nth_page(int page_num);
            const Widget * get_nth_page(int page_num) const;
            int get_n_pages();
            int get_n_pages() const;
            int page_num(const Widget & child);
            int page_num(const Widget & child) const;
            void set_current_page(int page_num);
            void next_page();
            void prev_page();
            void set_show_border(bool show_border = true);
            bool get_show_border() const;
            void set_show_tabs(bool show_tabs = true);
            bool get_show_tabs() const;
            void set_tab_pos(PositionType pos);
            PositionType get_tab_pos() const;
            void set_scrollable(bool scrollable = true);
            bool get_scrollable() const;
            void popup_enable();
            void popup_disable();
            Widget * get_tab_label(Widget & child);
            const Widget * get_tab_label(Widget & child) const;
            void set_tab_label(Widget & child, Widget & tab_label);
            void set_tab_label_text(Widget & child, const Glib::ustring & tab_text);
            Glib::ustring get_tab_label_text(Widget & child) const;
            Widget * get_menu_label(Widget & child);
            const Widget * get_menu_label(Widget & child) const;
            void set_menu_label(Widget & child, Widget & menu_label);
            void set_menu_label_text(Widget & child, const Glib::ustring & menu_text);
            Glib::ustring get_menu_label_text(Widget & child) const;
            void query_tab_label_packing(Widget & child, bool & expand, bool & fill, PackType & pack_type);
            void set_tab_label_packing(Widget & child, bool expand, bool fill, PackType pack_type);
            void reorder_child(Widget & child, int position);
            bool get_tab_reorderable(Widget & child) const;
            void set_tab_reorderable(Widget & child, bool reorderable = true);
            bool get_tab_detachable(Widget & child) const;
            void set_tab_detachable(Widget & child, bool detachable = true);
            PageList::iterator get_current();
            PageList & pages();
            const PageList & pages() const;
            Glib::SignalProxy2< void, GtkNotebookPage *, guint > signal_switch_page();
            Glib::SignalProxy2< void, Widget *, guint > signal_page_reordered();
            Glib::SignalProxy2< void, Widget *, guint > signal_page_removed();
            Glib::SignalProxy2< void, Widget *, guint > signal_page_added();
            Glib::PropertyProxy< PositionType > property_tab_pos();
            Glib::PropertyProxy_ReadOnly< PositionType > property_tab_pos() const;
            Glib::PropertyProxy< bool > property_show_tabs();
            Glib::PropertyProxy_ReadOnly< bool > property_show_tabs() const;
            Glib::PropertyProxy< bool > property_show_border();
            Glib::PropertyProxy_ReadOnly< bool > property_show_border() const;
            Glib::PropertyProxy< bool > property_scrollable();
            Glib::PropertyProxy_ReadOnly< bool > property_scrollable() const;
            Glib::PropertyProxy_WriteOnly< guint > property_tab_border();
            Glib::PropertyProxy< guint > property_tab_hborder();
            Glib::PropertyProxy_ReadOnly< guint > property_tab_hborder() const;
            Glib::PropertyProxy< guint > property_tab_vborder();
            Glib::PropertyProxy_ReadOnly< guint > property_tab_vborder() const;
            Glib::PropertyProxy< int > property_page();
            Glib::PropertyProxy_ReadOnly< int > property_page() const;
            Glib::PropertyProxy< bool > property_enable_popup();
            Glib::PropertyProxy_ReadOnly< bool > property_enable_popup() const;
            Glib::PropertyProxy< bool > property_homogeneous();
            Glib::PropertyProxy_ReadOnly< bool > property_homogeneous() const;
        protected :
            mutable PageList pages_proxy_;
    };
    namespace Notebook_Helpers {
        inline PageIterator::reference PageIterator::operator *() const
        {
            return static_cast<const Page & >(*this);
        }
        inline PageIterator::pointer PageIterator::operator ->() const
        {
            return static_cast<const Page * >(this);
        }
    }
}
namespace Glib {
    Gtk::Notebook * wrap(GtkNotebook * object, bool take_copy = false);
}
typedef struct _GtkPaned GtkPaned;
typedef struct _GtkPanedClass GtkPanedClass;
namespace Gtk {
    class Paned_Class;
}
typedef struct _GtkHPaned GtkHPaned;
typedef struct _GtkHPanedClass GtkHPanedClass;
namespace Gtk {
    class HPaned_Class;
}
typedef struct _GtkVPaned GtkVPaned;
typedef struct _GtkVPanedClass GtkVPanedClass;
namespace Gtk {
    class VPaned_Class;
}
namespace Gtk {
    class Paned : public Container
    {
        public :
            typedef Paned CppObjectType;
            typedef Paned_Class CppClassType;
            typedef GtkPaned BaseObjectType;
            typedef GtkPanedClass BaseClassType;
            virtual ~Paned();
        private :
            friend class Paned_Class;
            static CppClassType paned_class_;
            Paned(const Paned &);
            Paned & operator =(const Paned &);
        protected :
            explicit Paned(const Glib::ConstructParams & construct_params);
            explicit Paned(GtkPaned * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkPaned * gobj()
            {
                return reinterpret_cast<GtkPaned * >(gobject_);
            }
            const GtkPaned * gobj() const
            {
                return reinterpret_cast<GtkPaned * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            Paned();
            void add1(Widget & child);
            void add2(Widget & child);
            void pack1(Widget & child, bool resize, bool shrink);
            void pack1(Widget & child, AttachOptions options = Gtk::EXPAND);
            void pack2(Widget & child, bool resize, bool shrink);
            void pack2(Widget & child, AttachOptions options = Gtk::EXPAND);
            int get_position() const;
            void set_position(int position);
            Widget * get_child1();
            const Widget * get_child1() const;
            Widget * get_child2();
            const Widget * get_child2() const;
            Glib::PropertyProxy< int > property_position();
            Glib::PropertyProxy_ReadOnly< int > property_position() const;
            Glib::PropertyProxy< bool > property_position_set();
            Glib::PropertyProxy_ReadOnly< bool > property_position_set() const;
            Glib::PropertyProxy_ReadOnly< int > property_min_position() const;
            Glib::PropertyProxy_ReadOnly< int > property_max_position() const;
    };
    class HPaned : public Paned
    {
        public :
            typedef HPaned CppObjectType;
            typedef HPaned_Class CppClassType;
            typedef GtkHPaned BaseObjectType;
            typedef GtkHPanedClass BaseClassType;
            virtual ~HPaned();
        private :
            friend class HPaned_Class;
            static CppClassType hpaned_class_;
            HPaned(const HPaned &);
            HPaned & operator =(const HPaned &);
        protected :
            explicit HPaned(const Glib::ConstructParams & construct_params);
            explicit HPaned(GtkHPaned * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkHPaned * gobj()
            {
                return reinterpret_cast<GtkHPaned * >(gobject_);
            }
            const GtkHPaned * gobj() const
            {
                return reinterpret_cast<GtkHPaned * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            HPaned();
    };
    class VPaned : public Paned
    {
        public :
            typedef VPaned CppObjectType;
            typedef VPaned_Class CppClassType;
            typedef GtkVPaned BaseObjectType;
            typedef GtkVPanedClass BaseClassType;
            virtual ~VPaned();
        private :
            friend class VPaned_Class;
            static CppClassType vpaned_class_;
            VPaned(const VPaned &);
            VPaned & operator =(const VPaned &);
        protected :
            explicit VPaned(const Glib::ConstructParams & construct_params);
            explicit VPaned(GtkVPaned * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkVPaned * gobj()
            {
                return reinterpret_cast<GtkVPaned * >(gobject_);
            }
            const GtkVPaned * gobj() const
            {
                return reinterpret_cast<GtkVPaned * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            VPaned();
    };
}
namespace Glib {
    Gtk::Paned * wrap(GtkPaned * object, bool take_copy = false);
}
namespace Glib {
    Gtk::HPaned * wrap(GtkHPaned * object, bool take_copy = false);
}
namespace Glib {
    Gtk::VPaned * wrap(GtkVPaned * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkPaperSize GtkPaperSize;
}
namespace Gtk {
    const Glib::ustring PAPER_NAME_A3 = "iso_a3";
    const Glib::ustring PAPER_NAME_A4 = "iso_a4";
    const Glib::ustring PAPER_NAME_A5 = "iso_a5";
    const Glib::ustring PAPER_NAME_B5 = "iso_b5";
    const Glib::ustring PAPER_NAME_LETTER = "na_letter";
    const Glib::ustring PAPER_NAME_EXECUTIVE = "na_executive";
    const Glib::ustring PAPER_NAME_LEGAL = "na_legal";
    enum Unit
    {
        UNIT_PIXEL, 
        UNIT_POINTS, 
        UNIT_INCH, 
        UNIT_MM
    };
}
namespace Glib {
    template<>
    class Value< Gtk::Unit > : public Glib::Value_Enum< Gtk::Unit >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class PaperSize
    {
        public :
            typedef PaperSize CppObjectType;
            typedef GtkPaperSize BaseObjectType;
            static GType get_type() __attribute__((__const__));
            PaperSize();
            explicit PaperSize(GtkPaperSize * gobject, bool make_a_copy = true);
            PaperSize(const PaperSize & other);
            PaperSize & operator =(const PaperSize & other);
            ~PaperSize();
            void swap(PaperSize & other);
            GtkPaperSize * gobj()
            {
                return gobject_;
            }
            const GtkPaperSize * gobj() const
            {
                return gobject_;
            }
            GtkPaperSize * gobj_copy() const;
        protected :
            GtkPaperSize * gobject_;
        private :
        public :
            explicit PaperSize(const Glib::ustring & name = "");
            explicit PaperSize(const Glib::ustring & ppd_name, const Glib::ustring & ppd_display_name, double width, double height);
            explicit PaperSize(const Glib::ustring & name, const Glib::ustring & display_name, double width, double height, Unit unit);
            explicit PaperSize(const Glib::KeyFile & key_file, const Glib::ustring & group_name = Glib::ustring());
            bool equal(const PaperSize & other) const;
            operator bool() const;
            Glib::ustring get_name() const;
            Glib::ustring get_display_name() const;
            Glib::ustring get_ppd_name() const;
            double get_width(Unit unit) const;
            double get_height(Unit unit) const;
            bool is_custom() const;
            void set_size(double width, double height, Unit unit);
            double get_default_top_margin(Unit unit) const;
            double get_default_bottom_margin(Unit unit) const;
            double get_default_left_margin(Unit unit) const;
            double get_default_right_margin(Unit unit) const;
            static Glib::ustring get_default();
            void save_to_key_file(Glib::KeyFile & key_file, const Glib::ustring & group_name);
            void save_to_key_file(Glib::KeyFile & key_file);
    };
    inline bool operator ==(const PaperSize & lhs, const PaperSize & rhs)
    {
        return lhs.equal(rhs);
    }
    inline bool operator !=(const PaperSize & lhs, const PaperSize & rhs)
    {
        return !lhs.equal(rhs);
    }
}
namespace Gtk {
    inline void swap(PaperSize & lhs, PaperSize & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    Gtk::PaperSize wrap(GtkPaperSize * object, bool take_copy = false);
    template<>
    class Value< Gtk::PaperSize > : public Glib::Value_Boxed< Gtk::PaperSize >
    {
    };
}
typedef struct _GtkPageSetup GtkPageSetup;
typedef struct _GtkPageSetupClass GtkPageSetupClass;
namespace Gtk {
    class PageSetup_Class;
}
namespace Gtk {
    class PageSetup : public Glib::Object
    {
        public :
            typedef PageSetup CppObjectType;
            typedef PageSetup_Class CppClassType;
            typedef GtkPageSetup BaseObjectType;
            typedef GtkPageSetupClass BaseClassType;
        private :
            friend class PageSetup_Class;
            static CppClassType pagesetup_class_;
        private :
            PageSetup(const PageSetup &);
            PageSetup & operator =(const PageSetup &);
        protected :
            explicit PageSetup(const Glib::ConstructParams & construct_params);
            explicit PageSetup(GtkPageSetup * castitem);
        public :
            virtual ~PageSetup();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkPageSetup * gobj()
            {
                return reinterpret_cast<GtkPageSetup * >(gobject_);
            }
            const GtkPageSetup * gobj() const
            {
                return reinterpret_cast<GtkPageSetup * >(gobject_);
            }
            GtkPageSetup * gobj_copy();
        private :
        protected :
            PageSetup();
        public :
            static Glib::RefPtr< PageSetup > create();
            PageOrientation get_orientation() const;
            void set_orientation(PageOrientation orientation);
            PaperSize get_paper_size();
            const PaperSize get_paper_size() const;
            void set_paper_size(const PaperSize & paper_size);
            double get_top_margin(Unit unit) const;
            void set_top_margin(double margin, Unit unit);
            double get_bottom_margin(Unit unit) const;
            void set_bottom_margin(double margin, Unit unit);
            double get_left_margin(Unit unit) const;
            void set_left_margin(double margin, Unit unit);
            double get_right_margin(Unit unit) const;
            void set_right_margin(double margin, Unit unit);
            void set_paper_size_and_default_margins(const PaperSize & paper_size);
            double get_paper_width(Unit unit) const;
            double get_paper_height(Unit unit) const;
            double get_page_width(Unit unit) const;
            double get_page_height(Unit unit) const;
            bool save_to_file(const std::string & file_name) const;
            void save_to_key_file(Glib::KeyFile & key_file, const Glib::ustring & group_name);
            void save_to_key_file(Glib::KeyFile & key_file);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::PageSetup > wrap(GtkPageSetup * object, bool take_copy = false);
}
typedef struct _GtkPrintSettings GtkPrintSettings;
typedef struct _GtkPrintSettingsClass GtkPrintSettingsClass;
namespace Gtk {
    class PrintSettings_Class;
}
namespace Gtk {
    enum PrintDuplex
    {
        PRINT_DUPLEX_SIMPLEX, 
        PRINT_DUPLEX_HORIZONTAL, 
        PRINT_DUPLEX_VERTICAL
    };
}
namespace Glib {
    template<>
    class Value< Gtk::PrintDuplex > : public Glib::Value_Enum< Gtk::PrintDuplex >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum PrintQuality
    {
        PRINT_QUALITY_LOW, 
        PRINT_QUALITY_NORMAL, 
        PRINT_QUALITY_HIGH, 
        PRINT_QUALITY_DRAFT
    };
}
namespace Glib {
    template<>
    class Value< Gtk::PrintQuality > : public Glib::Value_Enum< Gtk::PrintQuality >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum PrintPages
    {
        PRINT_PAGES_ALL, 
        PRINT_PAGES_CURRENT, 
        PRINT_PAGES_RANGES
    };
}
namespace Glib {
    template<>
    class Value< Gtk::PrintPages > : public Glib::Value_Enum< Gtk::PrintPages >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum PageSet
    {
        PAGE_SET_ALL, 
        PAGE_SET_EVEN, 
        PAGE_SET_ODD
    };
}
namespace Glib {
    template<>
    class Value< Gtk::PageSet > : public Glib::Value_Enum< Gtk::PageSet >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class PrintSettings : public Glib::Object
    {
        public :
            typedef PrintSettings CppObjectType;
            typedef PrintSettings_Class CppClassType;
            typedef GtkPrintSettings BaseObjectType;
            typedef GtkPrintSettingsClass BaseClassType;
        private :
            friend class PrintSettings_Class;
            static CppClassType printsettings_class_;
        private :
            PrintSettings(const PrintSettings &);
            PrintSettings & operator =(const PrintSettings &);
        protected :
            explicit PrintSettings(const Glib::ConstructParams & construct_params);
            explicit PrintSettings(GtkPrintSettings * castitem);
        public :
            virtual ~PrintSettings();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkPrintSettings * gobj()
            {
                return reinterpret_cast<GtkPrintSettings * >(gobject_);
            }
            const GtkPrintSettings * gobj() const
            {
                return reinterpret_cast<GtkPrintSettings * >(gobject_);
            }
            GtkPrintSettings * gobj_copy();
        private :
        protected :
            PrintSettings();
        public :
            static Glib::RefPtr< PrintSettings > create();
            class Keys
            {
                public :
                    static const Glib::ustring PRINTER;
                    static const Glib::ustring ORIENTATION;
                    static const Glib::ustring PAPER_FORMAT;
                    static const Glib::ustring PAPER_WIDTH;
                    static const Glib::ustring PAPER_HEIGHT;
                    static const Glib::ustring NUM_COPIES;
                    static const Glib::ustring DEFAULT_SOURCE;
                    static const Glib::ustring QUALITY;
                    static const Glib::ustring RESOLUTION;
                    static const Glib::ustring USE_COLOR;
                    static const Glib::ustring DUPLEX;
                    static const Glib::ustring COLLATE;
                    static const Glib::ustring REVERSE;
                    static const Glib::ustring MEDIA_TYPE;
                    static const Glib::ustring DITHER;
                    static const Glib::ustring SCALE;
                    static const Glib::ustring PRINT_PAGES;
                    static const Glib::ustring PAGE_RANGES;
                    static const Glib::ustring PAGE_SET;
                    static const Glib::ustring FINISHINGS;
                    static const Glib::ustring NUMBER_UP;
                    static const Glib::ustring OUTPUT_BIN;
                    static const Glib::ustring OUTPUT_FILE_FORMAT;
                    static const Glib::ustring OUTPUT_URI;
                    static const Glib::ustring WIN32_DRIVER_VERSION;
                    static const Glib::ustring WIN32_DRIVER_EXTRA;
            };
            bool save_to_file(const std::string & file_name) const;
            void save_to_key_file(Glib::KeyFile & key_file, const Glib::ustring & group_name) const;
            void save_to_key_file(Glib::KeyFile & key_file);
            bool has_key(const Glib::ustring & key) const;
            Glib::ustring get(const Glib::ustring & key) const;
            void set(const Glib::ustring & key, const Glib::ustring & value);
            void unset(const Glib::ustring & key);
            typedef sigc::slot< void, const Glib::ustring &, const Glib::ustring & > SlotForeach;
            void setting_foreach(const SlotForeach & slot);
            bool get_bool(const Glib::ustring & key) const;
            void set_bool(const Glib::ustring & key, bool value = true);
            double get_double(const Glib::ustring & key) const;
            double get_double_with_default(const Glib::ustring & key, double def) const;
            void set_double(const Glib::ustring & key, double value);
            double get_length(const Glib::ustring & key, Unit unit) const;
            void set_length(const Glib::ustring & key, double value, Unit unit);
            int get_int(const Glib::ustring & key) const;
            int get_int_with_default(const Glib::ustring & key, int def) const;
            void set_int(const Glib::ustring & key, int value);
            Glib::ustring get_printer() const;
            void set_printer(const Glib::ustring & name);
            PageOrientation get_orientation() const;
            void set_orientation(PageOrientation orientation);
            PaperSize get_paper_size();
            const PaperSize get_paper_size() const;
            void set_paper_size(const PaperSize & paper_size);
            double get_paper_width(Unit unit) const;
            void set_paper_width(double width, Unit unit);
            double get_paper_height(Unit unit) const;
            void set_paper_height(double height, Unit unit);
            bool get_use_color() const;
            void set_use_color(bool use_color = true);
            bool get_collate() const;
            void set_collate(bool collate = true);
            bool get_reverse() const;
            void set_reverse(bool reverse = true);
            PrintDuplex get_duplex() const;
            void set_duplex(PrintDuplex duplex);
            PrintQuality get_quality() const;
            void set_quality(PrintQuality quality);
            int get_n_copies() const;
            void set_n_copies(int num_copies);
            int get_number_up() const;
            void set_number_up(int number_up);
            int get_resolution() const;
            void set_resolution(int resolution);
            double get_scale() const;
            void set_scale(double scale);
            PrintPages get_print_pages() const;
            void set_print_pages(PrintPages print_pages);
            class PageRange
            {
                public :
                    PageRange();
                    PageRange(int start, int end);
                    int start;
                    int end;
            };
            Glib::ArrayHandle< PageRange > get_page_ranges() const;
            void set_page_ranges(const Glib::ArrayHandle< PageRange > & page_ranges);
            PageSet get_page_set() const;
            void set_page_set(PageSet page_set);
            Glib::ustring get_default_source() const;
            void set_default_source(const Glib::ustring & default_source);
            Glib::ustring get_media_type() const;
            void set_media_type(const Glib::ustring & media_type);
            Glib::ustring get_dither() const;
            void set_dither(const Glib::ustring & dither);
            Glib::ustring get_finishings() const;
            void set_finishings(const Glib::ustring & finishings);
            Glib::ustring get_output_bin() const;
            void set_output_bin(const Glib::ustring & output_bin);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::PrintSettings > wrap(GtkPrintSettings * object, bool take_copy = false);
}
typedef struct _GtkPageSetupUnixDialog GtkPageSetupUnixDialog;
typedef struct _GtkPageSetupUnixDialogClass GtkPageSetupUnixDialogClass;
namespace Gtk {
    class PageSetupUnixDialog_Class;
}
namespace Gtk {
    class PageSetupUnixDialog : public Dialog
    {
        public :
            typedef PageSetupUnixDialog CppObjectType;
            typedef PageSetupUnixDialog_Class CppClassType;
            typedef GtkPageSetupUnixDialog BaseObjectType;
            typedef GtkPageSetupUnixDialogClass BaseClassType;
            virtual ~PageSetupUnixDialog();
        private :
            friend class PageSetupUnixDialog_Class;
            static CppClassType pagesetupunixdialog_class_;
            PageSetupUnixDialog(const PageSetupUnixDialog &);
            PageSetupUnixDialog & operator =(const PageSetupUnixDialog &);
        protected :
            explicit PageSetupUnixDialog(const Glib::ConstructParams & construct_params);
            explicit PageSetupUnixDialog(GtkPageSetupUnixDialog * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkPageSetupUnixDialog * gobj()
            {
                return reinterpret_cast<GtkPageSetupUnixDialog * >(gobject_);
            }
            const GtkPageSetupUnixDialog * gobj() const
            {
                return reinterpret_cast<GtkPageSetupUnixDialog * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            explicit PageSetupUnixDialog(Gtk::Window & parent, const Glib::ustring & title);
            explicit PageSetupUnixDialog(const Glib::ustring & title);
            void set_page_setup(const Glib::RefPtr< PageSetup > & page_setup);
            Glib::RefPtr< PageSetup > get_page_setup();
            Glib::RefPtr< const PageSetup > get_page_setup() const;
            void set_print_settings(const Glib::RefPtr< PrintSettings > & print_settings);
            Glib::RefPtr< PrintSettings > get_print_settings();
            Glib::RefPtr< const PrintSettings > get_print_settings() const;
    };
}
namespace Glib {
    Gtk::PageSetupUnixDialog * wrap(GtkPageSetupUnixDialog * object, bool take_copy = false);
}
typedef struct _GtkPrintContext GtkPrintContext;
typedef struct _GtkPrintContextClass GtkPrintContextClass;
namespace Gtk {
    class PrintContext_Class;
}
namespace Gtk {
    class PrintContext : public Glib::Object
    {
        public :
            typedef PrintContext CppObjectType;
            typedef PrintContext_Class CppClassType;
            typedef GtkPrintContext BaseObjectType;
            typedef GtkPrintContextClass BaseClassType;
        private :
            friend class PrintContext_Class;
            static CppClassType printcontext_class_;
        private :
            PrintContext(const PrintContext &);
            PrintContext & operator =(const PrintContext &);
        protected :
            explicit PrintContext(const Glib::ConstructParams & construct_params);
            explicit PrintContext(GtkPrintContext * castitem);
        public :
            virtual ~PrintContext();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkPrintContext * gobj()
            {
                return reinterpret_cast<GtkPrintContext * >(gobject_);
            }
            const GtkPrintContext * gobj() const
            {
                return reinterpret_cast<GtkPrintContext * >(gobject_);
            }
            GtkPrintContext * gobj_copy();
        private :
        public :
            Cairo::RefPtr< Cairo::Context > get_cairo_context();
            Cairo::RefPtr< const Cairo::Context > get_cairo_context() const;
            Glib::RefPtr< PageSetup > get_page_setup();
            Glib::RefPtr< const PageSetup > get_page_setup() const;
            double get_width() const;
            double get_height() const;
            double get_dpi_x() const;
            double get_dpi_y() const;
            Glib::RefPtr< Pango::FontMap > get_pango_fontmap();
            Glib::RefPtr< const Pango::FontMap > get_pango_fontmap() const;
            Glib::RefPtr< Pango::Context > create_pango_context();
            Glib::RefPtr< Pango::Layout > create_pango_layout();
            void set_cairo_context(const Cairo::RefPtr< Cairo::Context > & cr, double dpi_x, double dpi_y);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::PrintContext > wrap(GtkPrintContext * object, bool take_copy = false);
}
typedef struct _GtkPrinter GtkPrinter;
typedef struct _GtkPrinterClass GtkPrinterClass;
namespace Gtk {
    class Printer_Class;
}
namespace Gtk {
    enum PrintCapabilities
    {
        PRINT_CAPABILITY_PAGE_SET = 1 << 0, 
        PRINT_CAPABILITY_COPIES = 1 << 1, 
        PRINT_CAPABILITY_COLLATE = 1 << 2, 
        PRINT_CAPABILITY_REVERSE = 1 << 3, 
        PRINT_CAPABILITY_SCALE = 1 << 4, 
        PRINT_CAPABILITY_GENERATE_PDF = 1 << 5, 
        PRINT_CAPABILITY_GENERATE_PS = 1 << 6, 
        PRINT_CAPABILITY_PREVIEW = 1 << 7, 
        PRINT_CAPABILITY_NUMBER_UP = 1 << 8
    };
    inline PrintCapabilities operator |(PrintCapabilities lhs, PrintCapabilities rhs)
    {
        return static_cast<PrintCapabilities >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline PrintCapabilities operator &(PrintCapabilities lhs, PrintCapabilities rhs)
    {
        return static_cast<PrintCapabilities >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline PrintCapabilities operator ^(PrintCapabilities lhs, PrintCapabilities rhs)
    {
        return static_cast<PrintCapabilities >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline PrintCapabilities operator ~(PrintCapabilities flags)
    {
        return static_cast<PrintCapabilities >(~static_cast<unsigned >(flags));
    }
    inline PrintCapabilities & operator |=(PrintCapabilities & lhs, PrintCapabilities rhs)
    {
        return (lhs = static_cast<PrintCapabilities >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline PrintCapabilities & operator &=(PrintCapabilities & lhs, PrintCapabilities rhs)
    {
        return (lhs = static_cast<PrintCapabilities >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline PrintCapabilities & operator ^=(PrintCapabilities & lhs, PrintCapabilities rhs)
    {
        return (lhs = static_cast<PrintCapabilities >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gtk::PrintCapabilities > : public Glib::Value_Flags< Gtk::PrintCapabilities >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class Printer : public Glib::Object
    {
        public :
            typedef Printer CppObjectType;
            typedef Printer_Class CppClassType;
            typedef GtkPrinter BaseObjectType;
            typedef GtkPrinterClass BaseClassType;
        private :
            friend class Printer_Class;
            static CppClassType printer_class_;
        private :
            Printer(const Printer &);
            Printer & operator =(const Printer &);
        protected :
            explicit Printer(const Glib::ConstructParams & construct_params);
            explicit Printer(GtkPrinter * castitem);
        public :
            virtual ~Printer();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkPrinter * gobj()
            {
                return reinterpret_cast<GtkPrinter * >(gobject_);
            }
            const GtkPrinter * gobj() const
            {
                return reinterpret_cast<GtkPrinter * >(gobject_);
            }
            GtkPrinter * gobj_copy();
        private :
        public :
            bool equal(const Glib::RefPtr< Printer > & other) const;
            Glib::ustring get_name() const;
            Glib::ustring get_state_message() const;
            Glib::ustring get_description() const;
            Glib::ustring get_location() const;
            Glib::ustring get_icon_name() const;
            int get_job_count() const;
            bool is_active() const;
            bool is_virtual() const;
            bool is_default() const;
            bool accepts_pdf() const;
            bool accepts_ps() const;
            Glib::ListHandle< Glib::RefPtr< PageSetup > > list_papers();
            Glib::ListHandle< Glib::RefPtr< const PageSetup > > list_papers() const;
            bool has_details() const;
            void request_details();
            PrintCapabilities get_capabilities() const;
            Glib::SignalProxy1< void, bool > signal_details_acquired();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_name() const;
            Glib::PropertyProxy_ReadOnly< bool > property_is_virtual() const;
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_state_message() const;
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_location() const;
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_icon_name() const;
            Glib::PropertyProxy_ReadOnly< int > property_job_count() const;
            Glib::PropertyProxy_ReadOnly< bool > property_accepts_pdf() const;
            Glib::PropertyProxy_ReadOnly< bool > property_accepts_ps() const;
        public :
        public :
        protected :
            virtual void on_details_acquired(bool success);
    };
    inline bool operator ==(const Glib::RefPtr< Printer > & lhs, const Glib::RefPtr< Printer > & rhs)
    {
        return lhs->equal(rhs);
    }
    inline bool operator !=(const Glib::RefPtr< Printer > & lhs, const Glib::RefPtr< Printer > & rhs)
    {
        return !lhs->equal(rhs);
    }
    typedef sigc::slot< bool, const Glib::RefPtr< Printer > & > SlotPrinterEnumerator;
    void enumerate_printers(const SlotPrinterEnumerator & slot, bool wait = true);
}
namespace Glib {
    Glib::RefPtr< Gtk::Printer > wrap(GtkPrinter * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkPaperSize GtkPaperSize;
    GType gtk_paper_size_get_type(void) __attribute__((__const__));
    GtkPaperSize * gtk_paper_size_new(const gchar * name);
    GtkPaperSize * gtk_paper_size_new_from_ppd(const gchar * ppd_name, const gchar * ppd_display_name, gdouble width, gdouble height);
    GtkPaperSize * gtk_paper_size_new_custom(const gchar * name, const gchar * display_name, gdouble width, gdouble height, GtkUnit unit);
    GtkPaperSize * gtk_paper_size_copy(GtkPaperSize * other);
    void gtk_paper_size_free(GtkPaperSize * size);
    gboolean gtk_paper_size_is_equal(GtkPaperSize * size1, GtkPaperSize * size2);
    GList * gtk_paper_size_get_paper_sizes(gboolean include_custom);
    const gchar * gtk_paper_size_get_name(GtkPaperSize * size);
    const gchar * gtk_paper_size_get_display_name(GtkPaperSize * size);
    const gchar * gtk_paper_size_get_ppd_name(GtkPaperSize * size);
    gdouble gtk_paper_size_get_width(GtkPaperSize * size, GtkUnit unit);
    gdouble gtk_paper_size_get_height(GtkPaperSize * size, GtkUnit unit);
    gboolean gtk_paper_size_is_custom(GtkPaperSize * size);
    void gtk_paper_size_set_size(GtkPaperSize * size, gdouble width, gdouble height, GtkUnit unit);
    gdouble gtk_paper_size_get_default_top_margin(GtkPaperSize * size, GtkUnit unit);
    gdouble gtk_paper_size_get_default_bottom_margin(GtkPaperSize * size, GtkUnit unit);
    gdouble gtk_paper_size_get_default_left_margin(GtkPaperSize * size, GtkUnit unit);
    gdouble gtk_paper_size_get_default_right_margin(GtkPaperSize * size, GtkUnit unit);
    const gchar * gtk_paper_size_get_default(void);
    GtkPaperSize * gtk_paper_size_new_from_key_file(GKeyFile * key_file, const gchar * group_name, GError * * error);
    void gtk_paper_size_to_key_file(GtkPaperSize * size, GKeyFile * key_file, const gchar * group_name);
}
extern "C"
{
    typedef struct _GtkPageSetup GtkPageSetup;
    GType gtk_page_setup_get_type(void) __attribute__((__const__));
    GtkPageSetup * gtk_page_setup_new(void);
    GtkPageSetup * gtk_page_setup_copy(GtkPageSetup * other);
    GtkPageOrientation gtk_page_setup_get_orientation(GtkPageSetup * setup);
    void gtk_page_setup_set_orientation(GtkPageSetup * setup, GtkPageOrientation orientation);
    GtkPaperSize * gtk_page_setup_get_paper_size(GtkPageSetup * setup);
    void gtk_page_setup_set_paper_size(GtkPageSetup * setup, GtkPaperSize * size);
    gdouble gtk_page_setup_get_top_margin(GtkPageSetup * setup, GtkUnit unit);
    void gtk_page_setup_set_top_margin(GtkPageSetup * setup, gdouble margin, GtkUnit unit);
    gdouble gtk_page_setup_get_bottom_margin(GtkPageSetup * setup, GtkUnit unit);
    void gtk_page_setup_set_bottom_margin(GtkPageSetup * setup, gdouble margin, GtkUnit unit);
    gdouble gtk_page_setup_get_left_margin(GtkPageSetup * setup, GtkUnit unit);
    void gtk_page_setup_set_left_margin(GtkPageSetup * setup, gdouble margin, GtkUnit unit);
    gdouble gtk_page_setup_get_right_margin(GtkPageSetup * setup, GtkUnit unit);
    void gtk_page_setup_set_right_margin(GtkPageSetup * setup, gdouble margin, GtkUnit unit);
    void gtk_page_setup_set_paper_size_and_default_margins(GtkPageSetup * setup, GtkPaperSize * size);
    gdouble gtk_page_setup_get_paper_width(GtkPageSetup * setup, GtkUnit unit);
    gdouble gtk_page_setup_get_paper_height(GtkPageSetup * setup, GtkUnit unit);
    gdouble gtk_page_setup_get_page_width(GtkPageSetup * setup, GtkUnit unit);
    gdouble gtk_page_setup_get_page_height(GtkPageSetup * setup, GtkUnit unit);
    GtkPageSetup * gtk_page_setup_new_from_file(const gchar * file_name, GError * * error);
    gboolean gtk_page_setup_to_file(GtkPageSetup * setup, const char * file_name, GError * * error);
    GtkPageSetup * gtk_page_setup_new_from_key_file(GKeyFile * key_file, const gchar * group_name, GError * * error);
    void gtk_page_setup_to_key_file(GtkPageSetup * setup, GKeyFile * key_file, const gchar * group_name);
}
extern "C"
{
    typedef struct _GtkPrintContext GtkPrintContext;
    GType gtk_print_context_get_type(void) __attribute__((__const__));
    cairo_t * gtk_print_context_get_cairo_context(GtkPrintContext * context);
    GtkPageSetup * gtk_print_context_get_page_setup(GtkPrintContext * context);
    gdouble gtk_print_context_get_width(GtkPrintContext * context);
    gdouble gtk_print_context_get_height(GtkPrintContext * context);
    gdouble gtk_print_context_get_dpi_x(GtkPrintContext * context);
    gdouble gtk_print_context_get_dpi_y(GtkPrintContext * context);
    PangoFontMap * gtk_print_context_get_pango_fontmap(GtkPrintContext * context);
    PangoContext * gtk_print_context_create_pango_context(GtkPrintContext * context);
    PangoLayout * gtk_print_context_create_pango_layout(GtkPrintContext * context);
    void gtk_print_context_set_cairo_context(GtkPrintContext * context, cairo_t * cr, double dpi_x, double dpi_y);
}
extern "C"
{
    typedef struct _GtkPrintOperationPreview GtkPrintOperationPreview;
    typedef struct _GtkPrintOperationPreviewIface GtkPrintOperationPreviewIface;
    struct _GtkPrintOperationPreviewIface
    {
            GTypeInterface g_iface;
            void (* ready)(GtkPrintOperationPreview * preview, GtkPrintContext * context);
            void (* got_page_size)(GtkPrintOperationPreview * preview, GtkPrintContext * context, GtkPageSetup * page_setup);
            void (* render_page)(GtkPrintOperationPreview * preview, gint page_nr);
            gboolean (* is_selected)(GtkPrintOperationPreview * preview, gint page_nr);
            void (* end_preview)(GtkPrintOperationPreview * preview);
            void (* _gtk_reserved1)(void);
            void (* _gtk_reserved2)(void);
            void (* _gtk_reserved3)(void);
            void (* _gtk_reserved4)(void);
            void (* _gtk_reserved5)(void);
            void (* _gtk_reserved6)(void);
            void (* _gtk_reserved7)(void);
    };
    GType gtk_print_operation_preview_get_type(void) __attribute__((__const__));
    void gtk_print_operation_preview_render_page(GtkPrintOperationPreview * preview, gint page_nr);
    void gtk_print_operation_preview_end_preview(GtkPrintOperationPreview * preview);
    gboolean gtk_print_operation_preview_is_selected(GtkPrintOperationPreview * preview, gint page_nr);
}
typedef struct _GtkPrintOperationPreview GtkPrintOperationPreview;
typedef struct _GtkPrintOperationPreviewClass GtkPrintOperationPreviewClass;
namespace Gtk {
    class PrintOperationPreview_Class;
}
namespace Gtk {
    class PrintOperationPreview : public Glib::Interface
    {
        public :
            typedef PrintOperationPreview CppObjectType;
            typedef PrintOperationPreview_Class CppClassType;
            typedef GtkPrintOperationPreview BaseObjectType;
            typedef GtkPrintOperationPreviewIface BaseClassType;
        private :
            friend class PrintOperationPreview_Class;
            static CppClassType printoperationpreview_class_;
            PrintOperationPreview(const PrintOperationPreview &);
            PrintOperationPreview & operator =(const PrintOperationPreview &);
        protected :
            PrintOperationPreview();
            explicit PrintOperationPreview(const Glib::Interface_Class & interface_class);
        public :
            explicit PrintOperationPreview(GtkPrintOperationPreview * castitem);
        protected :
        public :
            virtual ~PrintOperationPreview();
            static void add_interface(GType gtype_implementer);
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkPrintOperationPreview * gobj()
            {
                return reinterpret_cast<GtkPrintOperationPreview * >(gobject_);
            }
            const GtkPrintOperationPreview * gobj() const
            {
                return reinterpret_cast<GtkPrintOperationPreview * >(gobject_);
            }
        private :
        public :
            void render_page(int page_nr);
            void end_preview();
            bool is_selected(int page_nr) const;
            virtual void render_page_vfunc(int page_nr);
            virtual void end_preview_vfunc();
            virtual bool is_selected_vfunc(int page_nr) const;
            Glib::SignalProxy1< void, const Glib::RefPtr< PrintContext > & > signal_ready();
            Glib::SignalProxy2< void, const Glib::RefPtr< PrintContext > &, const Glib::RefPtr< PageSetup > & > signal_got_page_size();
        public :
        public :
        protected :
            virtual void on_ready(const Glib::RefPtr< PrintContext > & context);
            virtual void on_got_page_size(const Glib::RefPtr< PrintContext > & context, const Glib::RefPtr< PageSetup > & page_setup);
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::PrintOperationPreview > wrap(GtkPrintOperationPreview * object, bool take_copy = false);
}
typedef struct _GtkPrintOperation GtkPrintOperation;
typedef struct _GtkPrintOperationClass GtkPrintOperationClass;
namespace Gtk {
    class PrintOperation_Class;
}
namespace Gtk {
    enum PrintStatus
    {
        PRINT_STATUS_INITIAL, 
        PRINT_STATUS_PREPARING, 
        PRINT_STATUS_GENERATING_DATA, 
        PRINT_STATUS_SENDING_DATA, 
        PRINT_STATUS_PENDING, 
        PRINT_STATUS_PENDING_ISSUE, 
        PRINT_STATUS_PRINTING, 
        PRINT_STATUS_FINISHED, 
        PRINT_STATUS_FINISHED_ABORTED
    };
}
namespace Glib {
    template<>
    class Value< Gtk::PrintStatus > : public Glib::Value_Enum< Gtk::PrintStatus >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum PrintOperationResult
    {
        PRINT_OPERATION_RESULT_ERROR, 
        PRINT_OPERATION_RESULT_APPLY, 
        PRINT_OPERATION_RESULT_CANCEL, 
        PRINT_OPERATION_RESULT_IN_PROGRESS
    };
}
namespace Glib {
    template<>
    class Value< Gtk::PrintOperationResult > : public Glib::Value_Enum< Gtk::PrintOperationResult >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum PrintOperationAction
    {
        PRINT_OPERATION_ACTION_PRINT_DIALOG, 
        PRINT_OPERATION_ACTION_PRINT, 
        PRINT_OPERATION_ACTION_PREVIEW, 
        PRINT_OPERATION_ACTION_EXPORT
    };
}
namespace Glib {
    template<>
    class Value< Gtk::PrintOperationAction > : public Glib::Value_Enum< Gtk::PrintOperationAction >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class PrintError : public Glib::Error
    {
        public :
            enum Code
            {
                GENERAL, 
                INTERNAL_ERROR, 
                NOMEM, 
                INVALID_FILE
            };
            PrintError(Code error_code, const Glib::ustring & error_message);
            explicit PrintError(GError * gobject);
            Code code() const;
        private :
            static void throw_func(GError * gobject);
            friend void wrap_init();
    };
}
namespace Glib {
    template<>
    class Value< Gtk::PrintError::Code > : public Glib::Value_Enum< Gtk::PrintError::Code >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class PrintOperation : public Glib::Object, public PrintOperationPreview
    {
        public :
            typedef PrintOperation CppObjectType;
            typedef PrintOperation_Class CppClassType;
            typedef GtkPrintOperation BaseObjectType;
            typedef GtkPrintOperationClass BaseClassType;
        private :
            friend class PrintOperation_Class;
            static CppClassType printoperation_class_;
        private :
            PrintOperation(const PrintOperation &);
            PrintOperation & operator =(const PrintOperation &);
        protected :
            explicit PrintOperation(const Glib::ConstructParams & construct_params);
            explicit PrintOperation(GtkPrintOperation * castitem);
        public :
            virtual ~PrintOperation();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkPrintOperation * gobj()
            {
                return reinterpret_cast<GtkPrintOperation * >(gobject_);
            }
            const GtkPrintOperation * gobj() const
            {
                return reinterpret_cast<GtkPrintOperation * >(gobject_);
            }
            GtkPrintOperation * gobj_copy();
        private :
        protected :
            PrintOperation();
        public :
            static Glib::RefPtr< PrintOperation > create();
            void set_default_page_setup(const Glib::RefPtr< PageSetup > & default_page_setup);
            Glib::RefPtr< PageSetup > get_default_page_setup() const;
            void set_print_settings(const Glib::RefPtr< PrintSettings > & print_settings);
            Glib::RefPtr< PrintSettings > get_print_settings() const;
            void set_job_name(const Glib::ustring & job_name);
            void set_n_pages(int n_pages);
            void set_current_page(int current_page);
            void set_use_full_page(bool use_full_page = true);
            void set_unit(Unit unit);
            void set_export_filename(const std::string & filename);
            void set_track_print_status(bool track_status = true);
            void set_show_progress(bool show_progress = true);
            void set_allow_async(bool allow_async = true);
            void set_custom_tab_label(const Glib::ustring & label);
            PrintOperationResult run(PrintOperationAction action = PRINT_OPERATION_ACTION_PRINT_DIALOG);
            PrintOperationResult run(PrintOperationAction action, Window & parent);
            PrintStatus get_status() const;
            Glib::ustring get_status_string() const;
            void cancel();
            bool is_finished() const;
            Glib::SignalProxy1< void, PrintOperationResult > signal_done();
            Glib::SignalProxy1< void, const Glib::RefPtr< PrintContext > & > signal_begin_print();
            Glib::SignalProxy1< bool, const Glib::RefPtr< PrintContext > & > signal_paginate();
            Glib::SignalProxy3< void, const Glib::RefPtr< PrintContext > &, int, const Glib::RefPtr< PageSetup > & > signal_request_page_setup();
            Glib::SignalProxy2< void, const Glib::RefPtr< PrintContext > &, int > signal_draw_page();
            Glib::SignalProxy1< void, const Glib::RefPtr< PrintContext > & > signal_end_print();
            Glib::SignalProxy0< void > signal_status_changed();
            Glib::SignalProxy0< Widget * > signal_create_custom_widget();
            Glib::SignalProxy1< void, Widget * > signal_custom_widget_apply();
            Glib::SignalProxy3< bool, const Glib::RefPtr< PrintOperationPreview > &, const Glib::RefPtr< PrintContext > &, Window * > signal_preview();
            Glib::PropertyProxy< Glib::RefPtr< PageSetup > > property_default_page_setup();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< PageSetup > > property_default_page_setup() const;
            Glib::PropertyProxy< Glib::RefPtr< PrintSettings > > property_print_settings();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< PrintSettings > > property_print_settings() const;
            Glib::PropertyProxy< Glib::ustring > property_job_name();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_job_name() const;
            Glib::PropertyProxy< int > property_n_pages();
            Glib::PropertyProxy_ReadOnly< int > property_n_pages() const;
            Glib::PropertyProxy< int > property_current_page();
            Glib::PropertyProxy_ReadOnly< int > property_current_page() const;
            Glib::PropertyProxy< bool > property_use_full_page();
            Glib::PropertyProxy_ReadOnly< bool > property_use_full_page() const;
            Glib::PropertyProxy< Unit > property_unit();
            Glib::PropertyProxy_ReadOnly< Unit > property_unit() const;
            Glib::PropertyProxy< bool > property_show_progress();
            Glib::PropertyProxy_ReadOnly< bool > property_show_progress() const;
            Glib::PropertyProxy< bool > property_allow_async();
            Glib::PropertyProxy_ReadOnly< bool > property_allow_async() const;
            Glib::PropertyProxy< std::string > property_export_filename();
            Glib::PropertyProxy_ReadOnly< std::string > property_export_filename() const;
            Glib::PropertyProxy_ReadOnly< PrintStatus > property_status() const;
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_status_string() const;
            Glib::PropertyProxy< Glib::ustring > property_custom_tab_label();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_custom_tab_label() const;
        public :
        public :
        protected :
            virtual void on_done(PrintOperationResult result);
            virtual void on_begin_print(const Glib::RefPtr< PrintContext > & context);
            virtual bool on_paginate(const Glib::RefPtr< PrintContext > & context);
            virtual void on_request_page_setup(const Glib::RefPtr< PrintContext > & context, int page_no, const Glib::RefPtr< PageSetup > & setup);
            virtual void on_draw_page(const Glib::RefPtr< PrintContext > & context, int page_nr);
            virtual void on_end_print(const Glib::RefPtr< PrintContext > & context);
            virtual void on_status_changed();
            virtual Widget * on_create_custom_widget();
            virtual void on_custom_widget_apply(Widget * widget);
            virtual bool on_preview(const Glib::RefPtr< PrintOperationPreview > & preview, const Glib::RefPtr< PrintContext > & context, Window * parent);
    };
    Glib::RefPtr< PageSetup > run_page_setup_dialog(Window & parent, const Glib::RefPtr< const PageSetup > & page_setup, const Glib::RefPtr< const PrintSettings > & print_settings);
    typedef sigc::slot< void, const Glib::RefPtr< PageSetup > & > SlotPrintSetupDone;
    void run_page_setup_dialog_async(Window & parent, const Glib::RefPtr< const PageSetup > & page_setup, const Glib::RefPtr< const PrintSettings > & print_settings, const SlotPrintSetupDone & slot);
}
namespace Glib {
    Glib::RefPtr< Gtk::PrintOperation > wrap(GtkPrintOperation * object, bool take_copy = false);
}
typedef struct _GtkPrintJob GtkPrintJob;
typedef struct _GtkPrintJobClass GtkPrintJobClass;
namespace Gtk {
    class PrintJob_Class;
}
namespace Gtk {
    class PrintJob : public Glib::Object
    {
        public :
            typedef PrintJob CppObjectType;
            typedef PrintJob_Class CppClassType;
            typedef GtkPrintJob BaseObjectType;
            typedef GtkPrintJobClass BaseClassType;
        private :
            friend class PrintJob_Class;
            static CppClassType printjob_class_;
        private :
            PrintJob(const PrintJob &);
            PrintJob & operator =(const PrintJob &);
        protected :
            explicit PrintJob(const Glib::ConstructParams & construct_params);
            explicit PrintJob(GtkPrintJob * castitem);
        public :
            virtual ~PrintJob();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkPrintJob * gobj()
            {
                return reinterpret_cast<GtkPrintJob * >(gobject_);
            }
            const GtkPrintJob * gobj() const
            {
                return reinterpret_cast<GtkPrintJob * >(gobject_);
            }
            GtkPrintJob * gobj_copy();
        private :
        protected :
            explicit PrintJob(const Glib::ustring & title, const Glib::RefPtr< Printer > & printer, const Glib::RefPtr< PrintSettings > & settings, const Glib::RefPtr< PageSetup > & page_setup);
        public :
            static Glib::RefPtr< PrintJob > create(const Glib::ustring & title, const Glib::RefPtr< Printer > & printer, const Glib::RefPtr< PrintSettings > & settings, const Glib::RefPtr< PageSetup > & page_setup);
            Glib::RefPtr< PrintSettings > get_settings();
            Glib::RefPtr< const PrintSettings > get_settings() const;
            Glib::RefPtr< Printer > get_printer();
            Glib::RefPtr< const Printer > get_printer() const;
            Glib::ustring get_title() const;
            PrintStatus get_status() const;
            void set_source_file(const std::string & filename);
            Cairo::RefPtr< Cairo::Surface > get_surface();
            Cairo::RefPtr< const Cairo::Surface > get_surface() const;
            void set_track_print_status(bool track_status = true);
            bool get_track_print_status() const;
            typedef sigc::slot< void, const Glib::RefPtr< PrintJob > & > SlotPrintJobComplete;
            void send(const SlotPrintJobComplete & slot);
            Glib::SignalProxy0< void > signal_status_changed();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_title() const;
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Printer > > property_printer() const;
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< PrintSettings > > property_settings() const;
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< PageSetup > > property_page_setup() const;
        public :
        public :
        protected :
            virtual void on_status_changed();
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::PrintJob > wrap(GtkPrintJob * object, bool take_copy = false);
}
typedef struct _GtkPrintUnixDialog GtkPrintUnixDialog;
typedef struct _GtkPrintUnixDialogClass GtkPrintUnixDialogClass;
namespace Gtk {
    class PrintUnixDialog_Class;
}
namespace Gtk {
    class PrintUnixDialog : public Dialog
    {
        public :
            typedef PrintUnixDialog CppObjectType;
            typedef PrintUnixDialog_Class CppClassType;
            typedef GtkPrintUnixDialog BaseObjectType;
            typedef GtkPrintUnixDialogClass BaseClassType;
            virtual ~PrintUnixDialog();
        private :
            friend class PrintUnixDialog_Class;
            static CppClassType printunixdialog_class_;
            PrintUnixDialog(const PrintUnixDialog &);
            PrintUnixDialog & operator =(const PrintUnixDialog &);
        protected :
            explicit PrintUnixDialog(const Glib::ConstructParams & construct_params);
            explicit PrintUnixDialog(GtkPrintUnixDialog * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkPrintUnixDialog * gobj()
            {
                return reinterpret_cast<GtkPrintUnixDialog * >(gobject_);
            }
            const GtkPrintUnixDialog * gobj() const
            {
                return reinterpret_cast<GtkPrintUnixDialog * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            explicit PrintUnixDialog(Gtk::Window & parent, const Glib::ustring & title);
            explicit PrintUnixDialog(const Glib::ustring & title);
            void set_page_setup(const Glib::RefPtr< PageSetup > & page_setup);
            Glib::RefPtr< PageSetup > get_page_setup();
            Glib::RefPtr< const PageSetup > get_page_setup() const;
            void set_current_page(int current_page);
            int get_current_page() const;
            void set_settings(const Glib::RefPtr< PrintSettings > & print_settings);
            Glib::RefPtr< PrintSettings > get_settings();
            Glib::RefPtr< const PrintSettings > get_settings() const;
            Glib::RefPtr< Printer > get_selected_printer();
            Glib::RefPtr< const Printer > get_selected_printer() const;
            void add_custom_tab(const Widget & child, const Glib::ustring & tab_label);
            void add_custom_tab(const Widget & child, const Widget & tab_label);
            void set_manual_capabilities(PrintCapabilities capabilities);
            Glib::PropertyProxy< Glib::RefPtr< PageSetup > > property_page_setup();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< PageSetup > > property_page_setup() const;
            Glib::PropertyProxy< int > property_current_page();
            Glib::PropertyProxy_ReadOnly< int > property_current_page() const;
            Glib::PropertyProxy< Glib::RefPtr< PrintSettings > > property_print_settings();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< PrintSettings > > property_print_settings() const;
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Printer > > property_selected_printer() const;
    };
}
namespace Glib {
    Gtk::PrintUnixDialog * wrap(GtkPrintUnixDialog * object, bool take_copy = false);
}
typedef struct _GtkProgressBar GtkProgressBar;
typedef struct _GtkProgressBarClass GtkProgressBarClass;
namespace Gtk {
    class ProgressBar_Class;
}
namespace Gtk {
    enum ProgressBarStyle
    {
        PROGRESS_CONTINUOUS, 
        PROGRESS_DISCRETE
    };
}
namespace Glib {
    template<>
    class Value< Gtk::ProgressBarStyle > : public Glib::Value_Enum< Gtk::ProgressBarStyle >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum ProgressBarOrientation
    {
        PROGRESS_LEFT_TO_RIGHT, 
        PROGRESS_RIGHT_TO_LEFT, 
        PROGRESS_BOTTOM_TO_TOP, 
        PROGRESS_TOP_TO_BOTTOM
    };
}
namespace Glib {
    template<>
    class Value< Gtk::ProgressBarOrientation > : public Glib::Value_Enum< Gtk::ProgressBarOrientation >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class ProgressBar : public Widget
    {
        public :
            typedef ProgressBar CppObjectType;
            typedef ProgressBar_Class CppClassType;
            typedef GtkProgressBar BaseObjectType;
            typedef GtkProgressBarClass BaseClassType;
            virtual ~ProgressBar();
        private :
            friend class ProgressBar_Class;
            static CppClassType progressbar_class_;
            ProgressBar(const ProgressBar &);
            ProgressBar & operator =(const ProgressBar &);
        protected :
            explicit ProgressBar(const Glib::ConstructParams & construct_params);
            explicit ProgressBar(GtkProgressBar * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkProgressBar * gobj()
            {
                return reinterpret_cast<GtkProgressBar * >(gobject_);
            }
            const GtkProgressBar * gobj() const
            {
                return reinterpret_cast<GtkProgressBar * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            ProgressBar();
            void pulse();
            Glib::ustring get_text() const;
            void set_text(const Glib::ustring & text);
            double get_fraction() const;
            void set_fraction(double fraction);
            double get_pulse_step() const;
            void set_pulse_step(double fraction);
            void set_orientation(ProgressBarOrientation orientation = PROGRESS_LEFT_TO_RIGHT);
            ProgressBarOrientation get_orientation() const;
            void set_ellipsize(Pango::EllipsizeMode mode);
            Pango::EllipsizeMode get_ellipsize() const;
            Glib::PropertyProxy< double > property_fraction();
            Glib::PropertyProxy_ReadOnly< double > property_fraction() const;
            Glib::PropertyProxy< double > property_pulse_step();
            Glib::PropertyProxy_ReadOnly< double > property_pulse_step() const;
            Glib::PropertyProxy< ProgressBarOrientation > property_orientation();
            Glib::PropertyProxy_ReadOnly< ProgressBarOrientation > property_orientation() const;
            Glib::PropertyProxy< Glib::ustring > property_text();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_text() const;
            Glib::PropertyProxy< bool > property_ellipsize();
            Glib::PropertyProxy_ReadOnly< bool > property_ellipsize() const;
    };
}
namespace Glib {
    Gtk::ProgressBar * wrap(GtkProgressBar * object, bool take_copy = false);
}
typedef struct _GtkAction GtkAction;
typedef struct _GtkActionClass GtkActionClass;
namespace Gtk {
    class Action_Class;
}
namespace Gtk {
    class Menu;
    class MenuItem;
    class ToolItem;
    class Image;
    class Action : public Glib::Object
    {
        public :
            typedef Action CppObjectType;
            typedef Action_Class CppClassType;
            typedef GtkAction BaseObjectType;
            typedef GtkActionClass BaseClassType;
        private :
            friend class Action_Class;
            static CppClassType action_class_;
        private :
            Action(const Action &);
            Action & operator =(const Action &);
        protected :
            explicit Action(const Glib::ConstructParams & construct_params);
            explicit Action(GtkAction * castitem);
        public :
            virtual ~Action();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkAction * gobj()
            {
                return reinterpret_cast<GtkAction * >(gobject_);
            }
            const GtkAction * gobj() const
            {
                return reinterpret_cast<GtkAction * >(gobject_);
            }
            GtkAction * gobj_copy();
        private :
        protected :
            Action();
            explicit Action(const Glib::ustring & name, const StockID & stock_id = StockID(), const Glib::ustring & label = Glib::ustring(), const Glib::ustring & tooltip = Glib::ustring());
        public :
            static Glib::RefPtr< Action > create();
            static Glib::RefPtr< Action > create(const Glib::ustring & name, const Glib::ustring & label = Glib::ustring(), const Glib::ustring & tooltip = Glib::ustring());
            static Glib::RefPtr< Action > create(const Glib::ustring & name, const Gtk::StockID & stock_id, const Glib::ustring & label = Glib::ustring(), const Glib::ustring & tooltip = Glib::ustring());
            Glib::ustring get_name() const;
            bool is_sensitive() const;
            bool get_sensitive() const;
            void set_tooltip(const Glib::ustring & tooltip);
            void set_sensitive(bool sensitive = true);
            bool is_visible() const;
            bool get_visible() const;
            void set_visible(bool visible = true);
            void activate();
            Image * create_icon(IconSize icon_size);
            MenuItem * create_menu_item();
            ToolItem * create_tool_item();
            Menu * create_menu();
            void connect_proxy(Widget & proxy);
            void disconnect_proxy(Widget & proxy);
            Glib::SListHandle< Widget * > get_proxies();
            Glib::SListHandle< const Widget * > get_proxies() const;
            void connect_accelerator();
            void disconnect_accelerator();
            Glib::ustring get_accel_path() const;
            typedef sigc::slot< void > SlotActivate;
            Glib::SignalProxy0< void > signal_activate();
            void set_accel_path(const Glib::ustring & accel_path);
            void set_accel_group(const Glib::RefPtr< AccelGroup > & accel_group);
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_name() const;
            Glib::PropertyProxy< Glib::ustring > property_label();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_label() const;
            Glib::PropertyProxy< Glib::ustring > property_short_label();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_short_label() const;
            Glib::PropertyProxy< Glib::ustring > property_tooltip();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_tooltip() const;
            Glib::PropertyProxy< StockID > property_stock_id();
            Glib::PropertyProxy_ReadOnly< StockID > property_stock_id() const;
            Glib::PropertyProxy< bool > property_visible_horizontal();
            Glib::PropertyProxy_ReadOnly< bool > property_visible_horizontal() const;
            Glib::PropertyProxy< bool > property_visible_vertical();
            Glib::PropertyProxy_ReadOnly< bool > property_visible_vertical() const;
            Glib::PropertyProxy< bool > property_is_important();
            Glib::PropertyProxy_ReadOnly< bool > property_is_important() const;
            Glib::PropertyProxy< bool > property_hide_if_empty();
            Glib::PropertyProxy_ReadOnly< bool > property_hide_if_empty() const;
            Glib::PropertyProxy< bool > property_sensitive();
            Glib::PropertyProxy_ReadOnly< bool > property_sensitive() const;
            Glib::PropertyProxy< bool > property_visible();
            Glib::PropertyProxy_ReadOnly< bool > property_visible() const;
        protected :
            void block_activate_from(Widget & proxy);
            void unblock_activate_from(Widget & proxy);
        protected :
            virtual Widget * create_menu_item_vfunc();
            virtual Widget * create_tool_item_vfunc();
            virtual void connect_proxy_vfunc(Widget * proxy);
            virtual void disconnect_proxy_vfunc(Widget * proxy);
        public :
        public :
        protected :
            virtual void on_activate();
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::Action > wrap(GtkAction * object, bool take_copy = false);
}
typedef struct _GtkToggleAction GtkToggleAction;
typedef struct _GtkToggleActionClass GtkToggleActionClass;
namespace Gtk {
    class ToggleAction_Class;
}
namespace Gtk {
    class ToggleAction : public Gtk::Action
    {
        public :
            typedef ToggleAction CppObjectType;
            typedef ToggleAction_Class CppClassType;
            typedef GtkToggleAction BaseObjectType;
            typedef GtkToggleActionClass BaseClassType;
        private :
            friend class ToggleAction_Class;
            static CppClassType toggleaction_class_;
        private :
            ToggleAction(const ToggleAction &);
            ToggleAction & operator =(const ToggleAction &);
        protected :
            explicit ToggleAction(const Glib::ConstructParams & construct_params);
            explicit ToggleAction(GtkToggleAction * castitem);
        public :
            virtual ~ToggleAction();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkToggleAction * gobj()
            {
                return reinterpret_cast<GtkToggleAction * >(gobject_);
            }
            const GtkToggleAction * gobj() const
            {
                return reinterpret_cast<GtkToggleAction * >(gobject_);
            }
            GtkToggleAction * gobj_copy();
        private :
        protected :
            ToggleAction();
            explicit ToggleAction(const Glib::ustring & name, const StockID & stock_id = StockID(), const Glib::ustring & label = Glib::ustring(), const Glib::ustring & tooltip = Glib::ustring(), bool is_active = false);
        public :
            static Glib::RefPtr< ToggleAction > create();
            static Glib::RefPtr< ToggleAction > create(const Glib::ustring & name, const Glib::ustring & label = Glib::ustring(), const Glib::ustring & tooltip = Glib::ustring(), bool is_active = false);
            static Glib::RefPtr< ToggleAction > create(const Glib::ustring & name, const Gtk::StockID & stock_id, const Glib::ustring & label = Glib::ustring(), const Glib::ustring & tooltip = Glib::ustring(), bool is_active = false);
            void toggled();
            void set_active(bool is_active = true);
            bool get_active() const;
            void set_draw_as_radio(bool draw_as_radio = true);
            bool get_draw_as_radio() const;
            Glib::SignalProxy0< void > signal_toggled();
            Glib::PropertyProxy< bool > property_draw_as_radio();
            Glib::PropertyProxy_ReadOnly< bool > property_draw_as_radio() const;
        public :
        public :
        protected :
            virtual void on_toggled();
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::ToggleAction > wrap(GtkToggleAction * object, bool take_copy = false);
}
typedef struct _GtkRadioAction GtkRadioAction;
typedef struct _GtkRadioActionClass GtkRadioActionClass;
namespace Gtk {
    class RadioAction_Class;
}
namespace Gtk {
    class RadioAction : public Gtk::ToggleAction
    {
        public :
            typedef RadioAction CppObjectType;
            typedef RadioAction_Class CppClassType;
            typedef GtkRadioAction BaseObjectType;
            typedef GtkRadioActionClass BaseClassType;
        private :
            friend class RadioAction_Class;
            static CppClassType radioaction_class_;
        private :
            RadioAction(const RadioAction &);
            RadioAction & operator =(const RadioAction &);
        protected :
            explicit RadioAction(const Glib::ConstructParams & construct_params);
            explicit RadioAction(GtkRadioAction * castitem);
        public :
            virtual ~RadioAction();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkRadioAction * gobj()
            {
                return reinterpret_cast<GtkRadioAction * >(gobject_);
            }
            const GtkRadioAction * gobj() const
            {
                return reinterpret_cast<GtkRadioAction * >(gobject_);
            }
            GtkRadioAction * gobj_copy();
        private :
        public :
            typedef RadioButtonGroup Group;
        protected :
            RadioAction();
            explicit RadioAction(Group & group, const Glib::ustring & name, const StockID & stock_id = StockID(), const Glib::ustring & label = Glib::ustring(), const Glib::ustring & tooltip = Glib::ustring());
        public :
            static Glib::RefPtr< RadioAction > create();
            static Glib::RefPtr< RadioAction > create(Group & group, const Glib::ustring & name, const Glib::ustring & label = Glib::ustring(), const Glib::ustring & tooltip = Glib::ustring());
            static Glib::RefPtr< RadioAction > create(Group & group, const Glib::ustring & name, const Gtk::StockID & stock_id, const Glib::ustring & label = Glib::ustring(), const Glib::ustring & tooltip = Glib::ustring());
            Group get_group();
            void set_group(Group & group);
            int get_current_value() const;
            void set_current_value(int current_value);
            Glib::SignalProxy1< void, const Glib::RefPtr< RadioAction > & > signal_changed();
            Glib::PropertyProxy< int > property_value();
            Glib::PropertyProxy_ReadOnly< int > property_value() const;
            Glib::PropertyProxy< int > property_current_value();
            Glib::PropertyProxy_ReadOnly< int > property_current_value() const;
        public :
        public :
        protected :
            virtual void on_changed(const Glib::RefPtr< RadioAction > & current);
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::RadioAction > wrap(GtkRadioAction * object, bool take_copy = false);
}
typedef struct _GtkTooltipsData GtkTooltipsData;
typedef struct _GtkTooltips GtkTooltips;
typedef struct _GtkTooltipsClass GtkTooltipsClass;
namespace Gtk {
    class Tooltips_Class;
}
namespace Gtk {
    class Widget;
    class Tooltips : public Object
    {
        public :
            typedef Tooltips CppObjectType;
            typedef Tooltips_Class CppClassType;
            typedef GtkTooltips BaseObjectType;
            typedef GtkTooltipsClass BaseClassType;
            virtual ~Tooltips();
        private :
            friend class Tooltips_Class;
            static CppClassType tooltips_class_;
            Tooltips(const Tooltips &);
            Tooltips & operator =(const Tooltips &);
        protected :
            explicit Tooltips(const Glib::ConstructParams & construct_params);
            explicit Tooltips(GtkTooltips * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTooltips * gobj()
            {
                return reinterpret_cast<GtkTooltips * >(gobject_);
            }
            const GtkTooltips * gobj() const
            {
                return reinterpret_cast<GtkTooltips * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            Tooltips();
            void enable();
            void disable();
            void set_tip(Widget & widget, const Glib::ustring & tip_text, const Glib::ustring & tip_private);
            void set_tip(Widget & widget, const Glib::ustring & tip_text);
            void unset_tip(Widget & widget);
        protected :
            static GtkTooltipsData * data_get(Widget & widget);
        public :
            void force_window();
    };
}
namespace Glib {
    Gtk::Tooltips * wrap(GtkTooltips * object, bool take_copy = false);
}
typedef struct _GtkToolItem GtkToolItem;
typedef struct _GtkToolItemClass GtkToolItemClass;
namespace Gtk {
    class ToolItem_Class;
}
namespace Gtk {
    class ToolItem : public Bin
    {
        public :
            typedef ToolItem CppObjectType;
            typedef ToolItem_Class CppClassType;
            typedef GtkToolItem BaseObjectType;
            typedef GtkToolItemClass BaseClassType;
            virtual ~ToolItem();
        private :
            friend class ToolItem_Class;
            static CppClassType toolitem_class_;
            ToolItem(const ToolItem &);
            ToolItem & operator =(const ToolItem &);
        protected :
            explicit ToolItem(const Glib::ConstructParams & construct_params);
            explicit ToolItem(GtkToolItem * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkToolItem * gobj()
            {
                return reinterpret_cast<GtkToolItem * >(gobject_);
            }
            const GtkToolItem * gobj() const
            {
                return reinterpret_cast<GtkToolItem * >(gobject_);
            }
        public :
        protected :
            virtual bool on_create_menu_proxy();
            virtual void on_toolbar_reconfigured();
        private :
        public :
            ToolItem();
            void set_homogeneous(bool homogeneous = true);
            bool get_homogeneous() const;
            void set_expand(bool expand = true);
            bool get_expand() const;
            void set_tooltip(Tooltips & tooltips, const Glib::ustring & tip_text, const Glib::ustring & tip_private = Glib::ustring());
            void set_tooltip_text(const Glib::ustring & text);
            void set_tooltip_markup(const Glib::ustring & markup);
            void set_use_drag_window(bool use_drag_window = true);
            bool get_use_drag_window() const;
            void set_visible_horizontal(bool visible_horizontal = true);
            bool get_visible_horizontal() const;
            void set_visible_vertical(bool visible_vertical = true);
            bool get_visible_vertical() const;
            bool get_is_important() const;
            void set_is_important(bool is_important = true);
            IconSize get_icon_size() const;
            Orientation get_orientation() const;
            ToolbarStyle get_toolbar_style() const;
            ReliefStyle get_relief_style() const;
            Widget * retrieve_proxy_menu_item();
            const Widget * retrieve_proxy_menu_item() const;
            Widget * get_proxy_menu_item(const Glib::ustring & menu_item_id);
            const Widget * get_proxy_menu_item(const Glib::ustring & menu_item_id) const;
            void set_proxy_menu_item(const Glib::ustring & menu_item_id, Widget & menu_item);
            void rebuild_menu();
            Glib::SignalProxy0< bool > signal_create_menu_proxy();
            Glib::SignalProxy0< void > signal_toolbar_reconfigured();
            Glib::SignalProxy3< bool, Tooltips *, const Glib::ustring &, const Glib::ustring & > signal_set_tooltip();
            Glib::PropertyProxy< bool > property_visible_horizontal();
            Glib::PropertyProxy_ReadOnly< bool > property_visible_horizontal() const;
            Glib::PropertyProxy< bool > property_visible_vertical();
            Glib::PropertyProxy_ReadOnly< bool > property_visible_vertical() const;
            Glib::PropertyProxy< bool > property_is_important();
            Glib::PropertyProxy_ReadOnly< bool > property_is_important() const;
    };
}
namespace Glib {
    Gtk::ToolItem * wrap(GtkToolItem * object, bool take_copy = false);
}
typedef struct _GtkToolButton GtkToolButton;
typedef struct _GtkToolButtonClass GtkToolButtonClass;
namespace Gtk {
    class ToolButton_Class;
}
namespace Gtk {
    class ToolButton : public ToolItem
    {
        public :
            typedef ToolButton CppObjectType;
            typedef ToolButton_Class CppClassType;
            typedef GtkToolButton BaseObjectType;
            typedef GtkToolButtonClass BaseClassType;
            virtual ~ToolButton();
        private :
            friend class ToolButton_Class;
            static CppClassType toolbutton_class_;
            ToolButton(const ToolButton &);
            ToolButton & operator =(const ToolButton &);
        protected :
            explicit ToolButton(const Glib::ConstructParams & construct_params);
            explicit ToolButton(GtkToolButton * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkToolButton * gobj()
            {
                return reinterpret_cast<GtkToolButton * >(gobject_);
            }
            const GtkToolButton * gobj() const
            {
                return reinterpret_cast<GtkToolButton * >(gobject_);
            }
        public :
        protected :
            virtual void on_clicked();
        private :
        public :
            ToolButton();
            explicit ToolButton(const Gtk::StockID & stock_id);
            explicit ToolButton(const Glib::ustring & label);
            explicit ToolButton(Widget & icon_widget, const Glib::ustring & label = Glib::ustring());
            void set_label(const Glib::ustring & label);
            Glib::ustring get_label() const;
            void set_use_underline(bool use_underline = true);
            bool get_use_underline() const;
            void set_stock_id(const Gtk::StockID & stock_id);
            Glib::ustring get_stock_id() const;
            void set_icon_name(const Glib::ustring & icon_name);
            Glib::ustring get_icon_name() const;
            void set_icon_widget(Widget & icon_widget);
            Widget * get_icon_widget();
            const Widget * get_icon_widget() const;
            void set_label_widget(Widget & label_widget);
            Widget * get_label_widget();
            const Widget * get_label_widget() const;
            Glib::SignalProxy0< void > signal_clicked();
            Glib::PropertyProxy< Glib::ustring > property_label();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_label() const;
            Glib::PropertyProxy< bool > property_use_underline();
            Glib::PropertyProxy_ReadOnly< bool > property_use_underline() const;
            Glib::PropertyProxy< Gtk::Widget * > property_label_widget();
            Glib::PropertyProxy_ReadOnly< Gtk::Widget * > property_label_widget() const;
            Glib::PropertyProxy< Glib::ustring > property_stock_id();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_stock_id() const;
            Glib::PropertyProxy< Gtk::Widget > property_icon_widget();
            Glib::PropertyProxy_ReadOnly< Gtk::Widget > property_icon_widget() const;
    };
}
namespace Glib {
    Gtk::ToolButton * wrap(GtkToolButton * object, bool take_copy = false);
}
typedef struct _GtkToggleToolButton GtkToggleToolButton;
typedef struct _GtkToggleToolButtonClass GtkToggleToolButtonClass;
namespace Gtk {
    class ToggleToolButton_Class;
}
namespace Gtk {
    class ToggleToolButton : public ToolButton
    {
        public :
            typedef ToggleToolButton CppObjectType;
            typedef ToggleToolButton_Class CppClassType;
            typedef GtkToggleToolButton BaseObjectType;
            typedef GtkToggleToolButtonClass BaseClassType;
            virtual ~ToggleToolButton();
        private :
            friend class ToggleToolButton_Class;
            static CppClassType toggletoolbutton_class_;
            ToggleToolButton(const ToggleToolButton &);
            ToggleToolButton & operator =(const ToggleToolButton &);
        protected :
            explicit ToggleToolButton(const Glib::ConstructParams & construct_params);
            explicit ToggleToolButton(GtkToggleToolButton * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkToggleToolButton * gobj()
            {
                return reinterpret_cast<GtkToggleToolButton * >(gobject_);
            }
            const GtkToggleToolButton * gobj() const
            {
                return reinterpret_cast<GtkToggleToolButton * >(gobject_);
            }
        public :
        protected :
            virtual void on_toggled();
        private :
        public :
            ToggleToolButton();
            explicit ToggleToolButton(const Gtk::StockID & stock_id);
            explicit ToggleToolButton(const Glib::ustring & label);
            explicit ToggleToolButton(Widget & icon_widget, const Glib::ustring & label = Glib::ustring());
            void set_active(bool is_active = true);
            bool get_active() const;
            Glib::SignalProxy0< void > signal_toggled();
    };
}
namespace Glib {
    Gtk::ToggleToolButton * wrap(GtkToggleToolButton * object, bool take_copy = false);
}
typedef struct _GtkRadioToolButton GtkRadioToolButton;
typedef struct _GtkRadioToolButtonClass GtkRadioToolButtonClass;
namespace Gtk {
    class RadioToolButton_Class;
}
namespace Gtk {
    class RadioToolButton : public ToggleToolButton
    {
        public :
            typedef RadioToolButton CppObjectType;
            typedef RadioToolButton_Class CppClassType;
            typedef GtkRadioToolButton BaseObjectType;
            typedef GtkRadioToolButtonClass BaseClassType;
            virtual ~RadioToolButton();
        private :
            friend class RadioToolButton_Class;
            static CppClassType radiotoolbutton_class_;
            RadioToolButton(const RadioToolButton &);
            RadioToolButton & operator =(const RadioToolButton &);
        protected :
            explicit RadioToolButton(const Glib::ConstructParams & construct_params);
            explicit RadioToolButton(GtkRadioToolButton * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkRadioToolButton * gobj()
            {
                return reinterpret_cast<GtkRadioToolButton * >(gobject_);
            }
            const GtkRadioToolButton * gobj() const
            {
                return reinterpret_cast<GtkRadioToolButton * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            typedef RadioButtonGroup Group;
            RadioToolButton();
            explicit RadioToolButton(Group & group, const Glib::ustring & label = Glib::ustring());
            RadioToolButton(Group & group, const Gtk::StockID & stock_id);
            explicit RadioToolButton(Widget & icon_widget, const Glib::ustring & label = Glib::ustring());
            Group get_group();
            void set_group(Group & group);
    };
}
namespace Glib {
    Gtk::RadioToolButton * wrap(GtkRadioToolButton * object, bool take_copy = false);
}
typedef struct _GtkRange GtkRange;
typedef struct _GtkRangeClass GtkRangeClass;
namespace Gtk {
    class Range_Class;
}
namespace Gtk {
    enum SensitivityType
    {
        SENSITIVITY_AUTO, 
        SENSITIVITY_ON, 
        SENSITIVITY_OFF
    };
}
namespace Glib {
    template<>
    class Value< Gtk::SensitivityType > : public Glib::Value_Enum< Gtk::SensitivityType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class Adjustment;
    class Range : public Widget
    {
        public :
            typedef Range CppObjectType;
            typedef Range_Class CppClassType;
            typedef GtkRange BaseObjectType;
            typedef GtkRangeClass BaseClassType;
            virtual ~Range();
        private :
            friend class Range_Class;
            static CppClassType range_class_;
            Range(const Range &);
            Range & operator =(const Range &);
        protected :
            explicit Range(const Glib::ConstructParams & construct_params);
            explicit Range(GtkRange * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkRange * gobj()
            {
                return reinterpret_cast<GtkRange * >(gobject_);
            }
            const GtkRange * gobj() const
            {
                return reinterpret_cast<GtkRange * >(gobject_);
            }
        public :
        protected :
            virtual void on_value_changed();
            virtual void on_adjust_bounds(double new_value);
            virtual void on_move_slider(ScrollType scroll);
        private :
        protected :
            Range();
        public :
            void set_update_policy(UpdateType policy);
            UpdateType get_update_policy() const;
            void set_adjustment(Gtk::Adjustment & adjustment);
            void unset_adjustment();
            Gtk::Adjustment * get_adjustment();
            const Gtk::Adjustment * get_adjustment() const;
            void set_inverted(bool setting = true);
            bool get_inverted() const;
            void set_lower_stepper_sensitivity(SensitivityType sensitivity);
            SensitivityType get_lower_stepper_sensitivity() const;
            void set_upper_stepper_sensitivity(SensitivityType sensitivity);
            SensitivityType get_upper_stepper_sensitivity() const;
            void set_increments(double step, double page);
            void set_range(double min, double max);
            void set_value(double value);
            double get_value() const;
            void set_show_fill_level(bool show_fill_level = true);
            bool get_show_fill_level() const;
            void set_restrict_to_fill_level(bool restrict_to_fill_level = true);
            bool get_restrict_to_fill_level() const;
            void set_fill_level(double fill_level);
            double get_fill_level() const;
            Glib::SignalProxy0< void > signal_value_changed();
            Glib::SignalProxy1< void, double > signal_adjust_bounds();
            Glib::SignalProxy1< void, ScrollType > signal_move_slider();
            Glib::SignalProxy2< bool, ScrollType, double > signal_change_value();
            Glib::PropertyProxy< UpdateType > property_update_policy();
            Glib::PropertyProxy_ReadOnly< UpdateType > property_update_policy() const;
            Glib::PropertyProxy< Adjustment * > property_adjustment();
            Glib::PropertyProxy_ReadOnly< Adjustment * > property_adjustment() const;
            Glib::PropertyProxy< bool > property_inverted();
            Glib::PropertyProxy_ReadOnly< bool > property_inverted() const;
            Glib::PropertyProxy< SensitivityType > property_lower_stepper_sensitivity();
            Glib::PropertyProxy_ReadOnly< SensitivityType > property_lower_stepper_sensitivity() const;
            Glib::PropertyProxy< SensitivityType > property_upper_stepper_sensitivity();
            Glib::PropertyProxy_ReadOnly< SensitivityType > property_upper_stepper_sensitivity() const;
            Glib::PropertyProxy< bool > property_show_fill_level();
            Glib::PropertyProxy_ReadOnly< bool > property_show_fill_level() const;
            Glib::PropertyProxy< bool > property_restrict_to_fill_level();
            Glib::PropertyProxy_ReadOnly< bool > property_restrict_to_fill_level() const;
            Glib::PropertyProxy< double > property_fill_level();
            Glib::PropertyProxy_ReadOnly< double > property_fill_level() const;
        protected :
            virtual void get_range_border_vfunc(GtkBorder * border) const;
    };
}
namespace Glib {
    Gtk::Range * wrap(GtkRange * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkRecentInfo GtkRecentInfo;
    typedef struct _GtkRecentData GtkRecentData;
    typedef struct _GtkRecentManager GtkRecentManager;
    typedef struct _GtkRecentManagerClass GtkRecentManagerClass;
    typedef struct _GtkRecentManagerPrivate GtkRecentManagerPrivate;
    struct _GtkRecentData
    {
            gchar * display_name;
            gchar * description;
            gchar * mime_type;
            gchar * app_name;
            gchar * app_exec;
            gchar * * groups;
            gboolean is_private;
    };
    struct _GtkRecentManager
    {
            GObject parent_instance;
            GtkRecentManagerPrivate * priv;
    };
    struct _GtkRecentManagerClass
    {
            GObjectClass parent_class;
            void (* changed)(GtkRecentManager * manager);
            void (* _gtk_recent1)(void);
            void (* _gtk_recent2)(void);
            void (* _gtk_recent3)(void);
            void (* _gtk_recent4)(void);
    };
    typedef enum 
    {
        GTK_RECENT_MANAGER_ERROR_NOT_FOUND, 
        GTK_RECENT_MANAGER_ERROR_INVALID_URI, 
        GTK_RECENT_MANAGER_ERROR_INVALID_ENCODING, 
        GTK_RECENT_MANAGER_ERROR_NOT_REGISTERED, 
        GTK_RECENT_MANAGER_ERROR_READ, 
        GTK_RECENT_MANAGER_ERROR_WRITE, 
        GTK_RECENT_MANAGER_ERROR_UNKNOWN
    } GtkRecentManagerError;
    GQuark gtk_recent_manager_error_quark(void);
    GType gtk_recent_manager_get_type(void) __attribute__((__const__));
    GtkRecentManager * gtk_recent_manager_new(void);
    GtkRecentManager * gtk_recent_manager_get_default(void);
    GtkRecentManager * gtk_recent_manager_get_for_screen(GdkScreen * screen);
    void gtk_recent_manager_set_screen(GtkRecentManager * manager, GdkScreen * screen);
    gboolean gtk_recent_manager_add_item(GtkRecentManager * manager, const gchar * uri);
    gboolean gtk_recent_manager_add_full(GtkRecentManager * manager, const gchar * uri, const GtkRecentData * recent_data);
    gboolean gtk_recent_manager_remove_item(GtkRecentManager * manager, const gchar * uri, GError * * error);
    GtkRecentInfo * gtk_recent_manager_lookup_item(GtkRecentManager * manager, const gchar * uri, GError * * error);
    gboolean gtk_recent_manager_has_item(GtkRecentManager * manager, const gchar * uri);
    gboolean gtk_recent_manager_move_item(GtkRecentManager * manager, const gchar * uri, const gchar * new_uri, GError * * error);
    void gtk_recent_manager_set_limit(GtkRecentManager * manager, gint limit);
    gint gtk_recent_manager_get_limit(GtkRecentManager * manager);
    GList * gtk_recent_manager_get_items(GtkRecentManager * manager);
    gint gtk_recent_manager_purge_items(GtkRecentManager * manager, GError * * error);
    GType gtk_recent_info_get_type(void) __attribute__((__const__));
    GtkRecentInfo * gtk_recent_info_ref(GtkRecentInfo * info);
    void gtk_recent_info_unref(GtkRecentInfo * info);
    const gchar * gtk_recent_info_get_uri(GtkRecentInfo * info);
    const gchar * gtk_recent_info_get_display_name(GtkRecentInfo * info);
    const gchar * gtk_recent_info_get_description(GtkRecentInfo * info);
    const gchar * gtk_recent_info_get_mime_type(GtkRecentInfo * info);
    time_t gtk_recent_info_get_added(GtkRecentInfo * info);
    time_t gtk_recent_info_get_modified(GtkRecentInfo * info);
    time_t gtk_recent_info_get_visited(GtkRecentInfo * info);
    gboolean gtk_recent_info_get_private_hint(GtkRecentInfo * info);
    gboolean gtk_recent_info_get_application_info(GtkRecentInfo * info, const gchar * app_name, gchar * * app_exec, guint * count, time_t * time_);
    gchar * * gtk_recent_info_get_applications(GtkRecentInfo * info, gsize * length) __attribute__((__malloc__));
    gchar * gtk_recent_info_last_application(GtkRecentInfo * info) __attribute__((__malloc__));
    gboolean gtk_recent_info_has_application(GtkRecentInfo * info, const gchar * app_name);
    gchar * * gtk_recent_info_get_groups(GtkRecentInfo * info, gsize * length) __attribute__((__malloc__));
    gboolean gtk_recent_info_has_group(GtkRecentInfo * info, const gchar * group_name);
    GdkPixbuf * gtk_recent_info_get_icon(GtkRecentInfo * info, gint size);
    gchar * gtk_recent_info_get_short_name(GtkRecentInfo * info) __attribute__((__malloc__));
    gchar * gtk_recent_info_get_uri_display(GtkRecentInfo * info) __attribute__((__malloc__));
    gint gtk_recent_info_get_age(GtkRecentInfo * info);
    gboolean gtk_recent_info_is_local(GtkRecentInfo * info);
    gboolean gtk_recent_info_exists(GtkRecentInfo * info);
    gboolean gtk_recent_info_match(GtkRecentInfo * info_a, GtkRecentInfo * info_b);
    void _gtk_recent_manager_sync(void);
}
extern "C"
{
    typedef struct _GtkRecentFilter GtkRecentFilter;
    typedef struct _GtkRecentFilterInfo GtkRecentFilterInfo;
    typedef enum 
    {
        GTK_RECENT_FILTER_URI = 1 << 0, 
        GTK_RECENT_FILTER_DISPLAY_NAME = 1 << 1, 
        GTK_RECENT_FILTER_MIME_TYPE = 1 << 2, 
        GTK_RECENT_FILTER_APPLICATION = 1 << 3, 
        GTK_RECENT_FILTER_GROUP = 1 << 4, 
        GTK_RECENT_FILTER_AGE = 1 << 5
    } GtkRecentFilterFlags;
    typedef gboolean (* GtkRecentFilterFunc)(const GtkRecentFilterInfo * filter_info, gpointer user_data);
    struct _GtkRecentFilterInfo
    {
            GtkRecentFilterFlags contains;
            const gchar * uri;
            const gchar * display_name;
            const gchar * mime_type;
            const gchar * * applications;
            const gchar * * groups;
            gint age;
    };
    GType gtk_recent_filter_get_type(void) __attribute__((__const__));
    GtkRecentFilter * gtk_recent_filter_new(void);
    void gtk_recent_filter_set_name(GtkRecentFilter * filter, const gchar * name);
    const gchar * gtk_recent_filter_get_name(GtkRecentFilter * filter);
    void gtk_recent_filter_add_mime_type(GtkRecentFilter * filter, const gchar * mime_type);
    void gtk_recent_filter_add_pattern(GtkRecentFilter * filter, const gchar * pattern);
    void gtk_recent_filter_add_pixbuf_formats(GtkRecentFilter * filter);
    void gtk_recent_filter_add_application(GtkRecentFilter * filter, const gchar * application);
    void gtk_recent_filter_add_group(GtkRecentFilter * filter, const gchar * group);
    void gtk_recent_filter_add_age(GtkRecentFilter * filter, gint days);
    void gtk_recent_filter_add_custom(GtkRecentFilter * filter, GtkRecentFilterFlags needed, GtkRecentFilterFunc func, gpointer data, GDestroyNotify data_destroy);
    GtkRecentFilterFlags gtk_recent_filter_get_needed(GtkRecentFilter * filter);
    gboolean gtk_recent_filter_filter(GtkRecentFilter * filter, const GtkRecentFilterInfo * filter_info);
}
extern "C"
{
    typedef enum 
    {
        GTK_RECENT_SORT_NONE = 0, 
        GTK_RECENT_SORT_MRU, 
        GTK_RECENT_SORT_LRU, 
        GTK_RECENT_SORT_CUSTOM
    } GtkRecentSortType;
    typedef gint (* GtkRecentSortFunc)(GtkRecentInfo * a, GtkRecentInfo * b, gpointer user_data);
    typedef struct _GtkRecentChooser GtkRecentChooser;
    typedef struct _GtkRecentChooserIface GtkRecentChooserIface;
    typedef enum 
    {
        GTK_RECENT_CHOOSER_ERROR_NOT_FOUND, 
        GTK_RECENT_CHOOSER_ERROR_INVALID_URI
    } GtkRecentChooserError;
    GQuark gtk_recent_chooser_error_quark(void);
    struct _GtkRecentChooserIface
    {
            GTypeInterface base_iface;
            gboolean (* set_current_uri)(GtkRecentChooser * chooser, const gchar * uri, GError * * error);
            gchar * (* get_current_uri)(GtkRecentChooser * chooser);
            gboolean (* select_uri)(GtkRecentChooser * chooser, const gchar * uri, GError * * error);
            void (* unselect_uri)(GtkRecentChooser * chooser, const gchar * uri);
            void (* select_all)(GtkRecentChooser * chooser);
            void (* unselect_all)(GtkRecentChooser * chooser);
            GList * (* get_items)(GtkRecentChooser * chooser);
            GtkRecentManager * (* get_recent_manager)(GtkRecentChooser * chooser);
            void (* add_filter)(GtkRecentChooser * chooser, GtkRecentFilter * filter);
            void (* remove_filter)(GtkRecentChooser * chooser, GtkRecentFilter * filter);
            GSList * (* list_filters)(GtkRecentChooser * chooser);
            void (* set_sort_func)(GtkRecentChooser * chooser, GtkRecentSortFunc sort_func, gpointer data, GDestroyNotify destroy);
            void (* item_activated)(GtkRecentChooser * chooser);
            void (* selection_changed)(GtkRecentChooser * chooser);
    };
    GType gtk_recent_chooser_get_type(void) __attribute__((__const__));
    void gtk_recent_chooser_set_show_private(GtkRecentChooser * chooser, gboolean show_private);
    gboolean gtk_recent_chooser_get_show_private(GtkRecentChooser * chooser);
    void gtk_recent_chooser_set_show_not_found(GtkRecentChooser * chooser, gboolean show_not_found);
    gboolean gtk_recent_chooser_get_show_not_found(GtkRecentChooser * chooser);
    void gtk_recent_chooser_set_select_multiple(GtkRecentChooser * chooser, gboolean select_multiple);
    gboolean gtk_recent_chooser_get_select_multiple(GtkRecentChooser * chooser);
    void gtk_recent_chooser_set_limit(GtkRecentChooser * chooser, gint limit);
    gint gtk_recent_chooser_get_limit(GtkRecentChooser * chooser);
    void gtk_recent_chooser_set_local_only(GtkRecentChooser * chooser, gboolean local_only);
    gboolean gtk_recent_chooser_get_local_only(GtkRecentChooser * chooser);
    void gtk_recent_chooser_set_show_tips(GtkRecentChooser * chooser, gboolean show_tips);
    gboolean gtk_recent_chooser_get_show_tips(GtkRecentChooser * chooser);
    void gtk_recent_chooser_set_show_numbers(GtkRecentChooser * chooser, gboolean show_numbers);
    gboolean gtk_recent_chooser_get_show_numbers(GtkRecentChooser * chooser);
    void gtk_recent_chooser_set_show_icons(GtkRecentChooser * chooser, gboolean show_icons);
    gboolean gtk_recent_chooser_get_show_icons(GtkRecentChooser * chooser);
    void gtk_recent_chooser_set_sort_type(GtkRecentChooser * chooser, GtkRecentSortType sort_type);
    GtkRecentSortType gtk_recent_chooser_get_sort_type(GtkRecentChooser * chooser);
    void gtk_recent_chooser_set_sort_func(GtkRecentChooser * chooser, GtkRecentSortFunc sort_func, gpointer sort_data, GDestroyNotify data_destroy);
    gboolean gtk_recent_chooser_set_current_uri(GtkRecentChooser * chooser, const gchar * uri, GError * * error);
    gchar * gtk_recent_chooser_get_current_uri(GtkRecentChooser * chooser);
    GtkRecentInfo * gtk_recent_chooser_get_current_item(GtkRecentChooser * chooser);
    gboolean gtk_recent_chooser_select_uri(GtkRecentChooser * chooser, const gchar * uri, GError * * error);
    void gtk_recent_chooser_unselect_uri(GtkRecentChooser * chooser, const gchar * uri);
    void gtk_recent_chooser_select_all(GtkRecentChooser * chooser);
    void gtk_recent_chooser_unselect_all(GtkRecentChooser * chooser);
    GList * gtk_recent_chooser_get_items(GtkRecentChooser * chooser);
    gchar * * gtk_recent_chooser_get_uris(GtkRecentChooser * chooser, gsize * length);
    void gtk_recent_chooser_add_filter(GtkRecentChooser * chooser, GtkRecentFilter * filter);
    void gtk_recent_chooser_remove_filter(GtkRecentChooser * chooser, GtkRecentFilter * filter);
    GSList * gtk_recent_chooser_list_filters(GtkRecentChooser * chooser);
    void gtk_recent_chooser_set_filter(GtkRecentChooser * chooser, GtkRecentFilter * filter);
    GtkRecentFilter * gtk_recent_chooser_get_filter(GtkRecentChooser * chooser);
}
typedef struct _GtkRecentInfo GtkRecentInfo;
namespace Gtk {
    class RecentInfo
    {
        public :
            typedef RecentInfo CppObjectType;
            typedef GtkRecentInfo BaseObjectType;
            void reference() const;
            void unreference() const;
            GtkRecentInfo * gobj();
            const GtkRecentInfo * gobj() const;
            GtkRecentInfo * gobj_copy() const;
        protected :
            RecentInfo();
            void operator delete(void *, size_t);
        private :
            RecentInfo(const RecentInfo &);
            RecentInfo & operator =(const RecentInfo &);
        public :
            bool equal(const RecentInfo & other) const;
            operator bool() const;
            Glib::ustring get_uri() const;
            Glib::ustring get_display_name() const;
            Glib::ustring get_description() const;
            Glib::ustring get_mime_type() const;
            time_t get_added() const;
            time_t get_modified() const;
            time_t get_visited() const;
            bool get_private_hint() const;
            bool get_application_info(const Glib::ustring & app_name, Glib::StringArrayHandle & app_exec, guint & count, time_t & time) const;
            Glib::StringArrayHandle get_applications() const;
            Glib::ustring last_application() const;
            bool has_application(const Glib::ustring & app_name) const;
            Glib::StringArrayHandle get_groups() const;
            bool has_group(const Glib::ustring & group) const;
            Glib::RefPtr< Gdk::Pixbuf > get_icon(int size);
            Glib::RefPtr< const Gdk::Pixbuf > get_icon(int size) const;
            Glib::ustring get_short_name() const;
            Glib::ustring get_uri_display() const;
            int get_age() const;
            bool is_local() const;
            bool exists() const;
    };
    struct RecentInfoTraits
    {
            typedef Glib::RefPtr< RecentInfo > CppType;
            typedef const GtkRecentInfo * CType;
            typedef GtkRecentInfo * CTypeNonConst;
            static CType to_c_type(const CppType & obj)
            {
                return Glib::unwrap(obj);
            }
            static CType to_c_type(const CType & obj)
            {
                return obj;
            }
            static CppType to_cpp_type(const CType & obj);
            static void release_c_type(const CType &)
            {
            }
    };
    inline bool operator ==(const RecentInfo & lhs, const RecentInfo & rhs)
    {
        return lhs.equal(rhs);
    }
    inline bool operator !=(const RecentInfo & lhs, const RecentInfo & rhs)
    {
        return !lhs.equal(rhs);
    }
}
namespace Glib {
    Glib::RefPtr< Gtk::RecentInfo > wrap(GtkRecentInfo * object, bool take_copy = false);
}
typedef struct _GtkRecentFilter GtkRecentFilter;
typedef struct _GtkRecentFilterClass GtkRecentFilterClass;
namespace Gtk {
    class RecentFilter_Class;
}
namespace Gtk {
    enum RecentFilterFlags
    {
        RECENT_FILTER_URI = 1 << 0, 
        RECENT_FILTER_DISPLAY_NAME = 1 << 1, 
        RECENT_FILTER_MIME_TYPE = 1 << 2, 
        RECENT_FILTER_APPLICATION = 1 << 3, 
        RECENT_FILTER_GROUP = 1 << 4, 
        RECENT_FILTER_AGE = 1 << 5
    };
    inline RecentFilterFlags operator |(RecentFilterFlags lhs, RecentFilterFlags rhs)
    {
        return static_cast<RecentFilterFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline RecentFilterFlags operator &(RecentFilterFlags lhs, RecentFilterFlags rhs)
    {
        return static_cast<RecentFilterFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline RecentFilterFlags operator ^(RecentFilterFlags lhs, RecentFilterFlags rhs)
    {
        return static_cast<RecentFilterFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline RecentFilterFlags operator ~(RecentFilterFlags flags)
    {
        return static_cast<RecentFilterFlags >(~static_cast<unsigned >(flags));
    }
    inline RecentFilterFlags & operator |=(RecentFilterFlags & lhs, RecentFilterFlags rhs)
    {
        return (lhs = static_cast<RecentFilterFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline RecentFilterFlags & operator &=(RecentFilterFlags & lhs, RecentFilterFlags rhs)
    {
        return (lhs = static_cast<RecentFilterFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline RecentFilterFlags & operator ^=(RecentFilterFlags & lhs, RecentFilterFlags rhs)
    {
        return (lhs = static_cast<RecentFilterFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gtk::RecentFilterFlags > : public Glib::Value_Flags< Gtk::RecentFilterFlags >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class RecentFilter : public Gtk::Object
    {
        public :
            typedef RecentFilter CppObjectType;
            typedef RecentFilter_Class CppClassType;
            typedef GtkRecentFilter BaseObjectType;
            typedef GtkRecentFilterClass BaseClassType;
            virtual ~RecentFilter();
        private :
            friend class RecentFilter_Class;
            static CppClassType recentfilter_class_;
            RecentFilter(const RecentFilter &);
            RecentFilter & operator =(const RecentFilter &);
        protected :
            explicit RecentFilter(const Glib::ConstructParams & construct_params);
            explicit RecentFilter(GtkRecentFilter * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkRecentFilter * gobj()
            {
                return reinterpret_cast<GtkRecentFilter * >(gobject_);
            }
            const GtkRecentFilter * gobj() const
            {
                return reinterpret_cast<GtkRecentFilter * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            RecentFilter();
            void set_name(const Glib::ustring & name);
            Glib::ustring get_name() const;
            void add_mime_type(const Glib::ustring & mime_type);
            void add_pattern(const Glib::ustring & pattern);
            void add_pixbuf_formats();
            void add_application(const Glib::ustring & application);
            void add_group(const Glib::ustring & group);
            void add_age(int days);
            class Info
            {
                public :
                    Info();
                    RecentFilterFlags contains;
                    Glib::ustring uri;
                    Glib::ustring display_name;
                    Glib::ustring mime_type;
                    std::list< Glib::ustring > applications;
                    std::list< Glib::ustring > groups;
                    int age;
            };
            typedef sigc::slot< bool, const Info & > SlotCustom;
            void add_custom(RecentFilterFlags needed, const SlotCustom & slot);
            RecentFilterFlags get_needed() const;
    };
}
namespace Glib {
    Gtk::RecentFilter * wrap(GtkRecentFilter * object, bool take_copy = false);
}
typedef struct _GtkRecentManager GtkRecentManager;
typedef struct _GtkRecentManagerClass GtkRecentManagerClass;
namespace Gtk {
    class RecentManager_Class;
}
namespace Gtk {
    class RecentManagerError : public Glib::Error
    {
        public :
            enum Code
            {
                NOT_FOUND, 
                INVALID_URI, 
                INVALID_ENCODING, 
                NOT_REGISTERED, 
                READ, 
                WRITE, 
                UNKNOWN
            };
            RecentManagerError(Code error_code, const Glib::ustring & error_message);
            explicit RecentManagerError(GError * gobject);
            Code code() const;
        private :
            static void throw_func(GError * gobject);
            friend void wrap_init();
    };
}
namespace Glib {
    template<>
    class Value< Gtk::RecentManagerError::Code > : public Glib::Value_Enum< Gtk::RecentManagerError::Code >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class RecentManager : public Glib::Object
    {
        public :
            typedef RecentManager CppObjectType;
            typedef RecentManager_Class CppClassType;
            typedef GtkRecentManager BaseObjectType;
            typedef GtkRecentManagerClass BaseClassType;
        private :
            friend class RecentManager_Class;
            static CppClassType recentmanager_class_;
        private :
            RecentManager(const RecentManager &);
            RecentManager & operator =(const RecentManager &);
        protected :
            explicit RecentManager(const Glib::ConstructParams & construct_params);
            explicit RecentManager(GtkRecentManager * castitem);
        public :
            virtual ~RecentManager();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkRecentManager * gobj()
            {
                return reinterpret_cast<GtkRecentManager * >(gobject_);
            }
            const GtkRecentManager * gobj() const
            {
                return reinterpret_cast<GtkRecentManager * >(gobject_);
            }
            GtkRecentManager * gobj_copy();
        private :
        protected :
            RecentManager();
        public :
            static Glib::RefPtr< RecentManager > create();
            static Glib::RefPtr< RecentManager > get_default();
            static Glib::RefPtr< RecentManager > get_for_screen(const Glib::RefPtr< Gdk::Screen > & screen);
            class Data
            {
                public :
                    Glib::ustring display_name;
                    Glib::ustring description;
                    Glib::ustring mime_type;
                    Glib::ustring app_name;
                    Glib::ustring app_exec;
                    std::vector< Glib::ustring > groups;
                    bool is_private;
            };
            void set_screen(const Glib::RefPtr< Gdk::Screen > & screen);
            bool add_item(const Glib::ustring & uri);
            bool add_item(const Glib::ustring & uri, const Data & recent_data);
            bool remove_item(const Glib::ustring & uri);
            Glib::RefPtr< RecentInfo > lookup_item(const Glib::ustring & uri);
            Glib::RefPtr< const RecentInfo > lookup_item(const Glib::ustring & uri) const;
            bool has_item(const Glib::ustring & uri) const;
            bool move_item(const Glib::ustring & uri, const Glib::ustring & new_uri);
            void set_limit(int limit);
            int get_limit() const;
            typedef Glib::ListHandle< RecentInfo, RecentInfoTraits > ListHandle_RecentInfos;
            ListHandle_RecentInfos get_items() const;
            int purge_items();
            typedef sigc::slot< void > SlotChanged;
            Glib::SignalProxy0< void > signal_changed();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_filename() const;
            Glib::PropertyProxy< int > property_limit();
            Glib::PropertyProxy_ReadOnly< int > property_limit() const;
            Glib::PropertyProxy_ReadOnly< int > property_size() const;
        public :
        public :
        protected :
            virtual void on_changed();
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::RecentManager > wrap(GtkRecentManager * object, bool take_copy = false);
}
typedef struct _GtkRecentChooser GtkRecentChooser;
typedef struct _GtkRecentChooserClass GtkRecentChooserClass;
namespace Gtk {
    class RecentChooser_Class;
}
namespace Gtk {
    enum RecentSortType
    {
        RECENT_SORT_NONE, 
        RECENT_SORT_MRU, 
        RECENT_SORT_LRU, 
        RECENT_SORT_CUSTOM
    };
}
namespace Glib {
    template<>
    class Value< Gtk::RecentSortType > : public Glib::Value_Enum< Gtk::RecentSortType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class RecentChooserError : public Glib::Error
    {
        public :
            enum Code
            {
                NOT_FOUND, 
                INVALID_URI
            };
            RecentChooserError(Code error_code, const Glib::ustring & error_message);
            explicit RecentChooserError(GError * gobject);
            Code code() const;
        private :
            static void throw_func(GError * gobject);
            friend void wrap_init();
    };
}
namespace Glib {
    template<>
    class Value< Gtk::RecentChooserError::Code > : public Glib::Value_Enum< Gtk::RecentChooserError::Code >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class RecentChooser : public Glib::Interface
    {
        public :
            typedef RecentChooser CppObjectType;
            typedef RecentChooser_Class CppClassType;
            typedef GtkRecentChooser BaseObjectType;
            typedef GtkRecentChooserIface BaseClassType;
        private :
            friend class RecentChooser_Class;
            static CppClassType recentchooser_class_;
            RecentChooser(const RecentChooser &);
            RecentChooser & operator =(const RecentChooser &);
        protected :
            RecentChooser();
            explicit RecentChooser(const Glib::Interface_Class & interface_class);
        public :
            explicit RecentChooser(GtkRecentChooser * castitem);
        protected :
        public :
            virtual ~RecentChooser();
            static void add_interface(GType gtype_implementer);
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkRecentChooser * gobj()
            {
                return reinterpret_cast<GtkRecentChooser * >(gobject_);
            }
            const GtkRecentChooser * gobj() const
            {
                return reinterpret_cast<GtkRecentChooser * >(gobject_);
            }
        private :
        public :
            void set_show_private(bool show_private = true);
            bool get_show_private() const;
            void set_show_not_found(bool show_not_found = true);
            bool get_show_not_found() const;
            void set_select_multiple(bool select_multiple = true);
            bool get_select_multiple() const;
            void set_limit(int limit);
            void unset_limit();
            int get_limit() const;
            void set_local_only(bool local_only = true);
            bool get_local_only() const;
            void set_show_tips(bool show_tips = true);
            bool get_show_tips() const;
            void set_show_icons(bool show_icons = true);
            bool get_show_icons() const;
            void set_sort_type(RecentSortType sort_type);
            RecentSortType get_sort_type() const;
            typedef sigc::slot< int, const Glib::RefPtr< RecentInfo > &, const Glib::RefPtr< RecentInfo > & > SlotCompare;
            void set_sort_func(const SlotCompare & slot);
            bool set_current_uri(const Glib::ustring & uri);
            Glib::ustring get_current_uri() const;
            Glib::RefPtr< RecentInfo > get_current_item();
            Glib::RefPtr< const RecentInfo > get_current_item() const;
            bool select_uri(const Glib::ustring & uri);
            void unselect_uri(const Glib::ustring & uri);
            void select_all();
            void unselect_all();
            typedef Glib::ListHandle< RecentInfo, RecentInfoTraits > ListHandle_RecentInfos;
            ListHandle_RecentInfos get_items() const;
            Glib::StringArrayHandle get_uris() const;
            void add_filter(const RecentFilter & filter);
            void remove_filter(const RecentFilter & filter);
            Glib::SListHandle< RecentFilter * > list_filters();
            Glib::SListHandle< const RecentFilter * > list_filters() const;
            void set_filter(const RecentFilter & filter);
            RecentFilter * get_filter();
            const RecentFilter * get_filter() const;
            Glib::SignalProxy0< void > signal_selection_changed();
            Glib::SignalProxy0< void > signal_item_activated();
            Glib::PropertyProxy< bool > property_show_private();
            Glib::PropertyProxy_ReadOnly< bool > property_show_private() const;
            Glib::PropertyProxy< bool > property_show_tips();
            Glib::PropertyProxy_ReadOnly< bool > property_show_tips() const;
            Glib::PropertyProxy< bool > property_show_icons();
            Glib::PropertyProxy_ReadOnly< bool > property_show_icons() const;
            Glib::PropertyProxy< bool > property_show_not_found();
            Glib::PropertyProxy_ReadOnly< bool > property_show_not_found() const;
            Glib::PropertyProxy< bool > property_select_multiple();
            Glib::PropertyProxy_ReadOnly< bool > property_select_multiple() const;
            Glib::PropertyProxy< bool > property_local_only();
            Glib::PropertyProxy_ReadOnly< bool > property_local_only() const;
            Glib::PropertyProxy< int > property_limit();
            Glib::PropertyProxy_ReadOnly< int > property_limit() const;
            Glib::PropertyProxy< RecentSortType > property_sort_type();
            Glib::PropertyProxy_ReadOnly< RecentSortType > property_sort_type() const;
            Glib::PropertyProxy< RecentFilter * > property_filter();
            Glib::PropertyProxy_ReadOnly< RecentFilter * > property_filter() const;
        protected :
            virtual Glib::ustring get_current_uri_vfunc() const;
            virtual void unselect_uri_vfunc(const Glib::ustring & uri);
            virtual void select_all_vfunc();
            virtual void unselect_all_vfunc();
            virtual Glib::RefPtr< RecentManager > get_recent_manager_vfunc();
            virtual void add_filter_vfunc(const RecentFilter & filter);
            virtual void remove_filter_vfunc(const RecentFilter & filter);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::RecentChooser > wrap(GtkRecentChooser * object, bool take_copy = false);
}
typedef struct _GtkRecentAction GtkRecentAction;
typedef struct _GtkRecentActionClass GtkRecentActionClass;
namespace Gtk {
    class RecentAction_Class;
}
namespace Gtk {
    class RecentAction : public Gtk::Action, public Gtk::RecentChooser
    {
        public :
            typedef RecentAction CppObjectType;
            typedef RecentAction_Class CppClassType;
            typedef GtkRecentAction BaseObjectType;
            typedef GtkRecentActionClass BaseClassType;
        private :
            friend class RecentAction_Class;
            static CppClassType recentaction_class_;
        private :
            RecentAction(const RecentAction &);
            RecentAction & operator =(const RecentAction &);
        protected :
            explicit RecentAction(const Glib::ConstructParams & construct_params);
            explicit RecentAction(GtkRecentAction * castitem);
        public :
            virtual ~RecentAction();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkRecentAction * gobj()
            {
                return reinterpret_cast<GtkRecentAction * >(gobject_);
            }
            const GtkRecentAction * gobj() const
            {
                return reinterpret_cast<GtkRecentAction * >(gobject_);
            }
            GtkRecentAction * gobj_copy();
        private :
        protected :
            RecentAction();
            explicit RecentAction(const Glib::ustring & name, const StockID & stock_id = StockID(), const Glib::ustring & label = Glib::ustring(), const Glib::ustring & tooltip = Glib::ustring());
            explicit RecentAction(const Glib::ustring & name, const StockID & stock_id, const Glib::ustring & label, const Glib::ustring & tooltip, const Glib::RefPtr< RecentManager > & manager);
        public :
            static Glib::RefPtr< RecentAction > create();
            static Glib::RefPtr< RecentAction > create(const Glib::ustring & name, const Glib::ustring & label = Glib::ustring(), const Glib::ustring & tooltip = Glib::ustring());
            static Glib::RefPtr< RecentAction > create(const Glib::ustring & name, const Gtk::StockID & stock_id, const Glib::ustring & label = Glib::ustring(), const Glib::ustring & tooltip = Glib::ustring());
            static Glib::RefPtr< RecentAction > create(const Glib::ustring & name, const Gtk::StockID & stock_id, const Glib::ustring & label, const Glib::ustring & tooltip, const Glib::RefPtr< RecentManager > & manager);
            bool get_show_numbers();
            void set_show_numbers(bool show_numbers = true);
            Glib::PropertyProxy< bool > property_show_numbers();
            Glib::PropertyProxy_ReadOnly< bool > property_show_numbers() const;
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::RecentAction > wrap(GtkRecentAction * object, bool take_copy = false);
}
typedef struct _GtkRecentChooserDialog GtkRecentChooserDialog;
typedef struct _GtkRecentChooserDialogClass GtkRecentChooserDialogClass;
namespace Gtk {
    class RecentChooserDialog_Class;
}
namespace Gtk {
    class RecentChooserDialog : public Dialog, public RecentChooser
    {
        public :
            typedef RecentChooserDialog CppObjectType;
            typedef RecentChooserDialog_Class CppClassType;
            typedef GtkRecentChooserDialog BaseObjectType;
            typedef GtkRecentChooserDialogClass BaseClassType;
            virtual ~RecentChooserDialog();
        private :
            friend class RecentChooserDialog_Class;
            static CppClassType recentchooserdialog_class_;
            RecentChooserDialog(const RecentChooserDialog &);
            RecentChooserDialog & operator =(const RecentChooserDialog &);
        protected :
            explicit RecentChooserDialog(const Glib::ConstructParams & construct_params);
            explicit RecentChooserDialog(GtkRecentChooserDialog * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkRecentChooserDialog * gobj()
            {
                return reinterpret_cast<GtkRecentChooserDialog * >(gobject_);
            }
            const GtkRecentChooserDialog * gobj() const
            {
                return reinterpret_cast<GtkRecentChooserDialog * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            explicit RecentChooserDialog(Gtk::Window & parent, const Glib::ustring & title);
            explicit RecentChooserDialog(const Glib::ustring & title);
            explicit RecentChooserDialog(Gtk::Window & parent, const Glib::ustring & title, const Glib::RefPtr< RecentManager > & recent_manager);
            explicit RecentChooserDialog(const Glib::ustring & title, const Glib::RefPtr< RecentManager > & recent_manager);
    };
}
namespace Glib {
    Gtk::RecentChooserDialog * wrap(GtkRecentChooserDialog * object, bool take_copy = false);
}
typedef struct _GtkRecentChooserMenu GtkRecentChooserMenu;
typedef struct _GtkRecentChooserMenuClass GtkRecentChooserMenuClass;
namespace Gtk {
    class RecentChooserMenu_Class;
}
namespace Gtk {
    class RecentChooserMenu : public Menu, public RecentChooser
    {
        public :
            typedef RecentChooserMenu CppObjectType;
            typedef RecentChooserMenu_Class CppClassType;
            typedef GtkRecentChooserMenu BaseObjectType;
            typedef GtkRecentChooserMenuClass BaseClassType;
            virtual ~RecentChooserMenu();
        private :
            friend class RecentChooserMenu_Class;
            static CppClassType recentchoosermenu_class_;
            RecentChooserMenu(const RecentChooserMenu &);
            RecentChooserMenu & operator =(const RecentChooserMenu &);
        protected :
            explicit RecentChooserMenu(const Glib::ConstructParams & construct_params);
            explicit RecentChooserMenu(GtkRecentChooserMenu * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkRecentChooserMenu * gobj()
            {
                return reinterpret_cast<GtkRecentChooserMenu * >(gobject_);
            }
            const GtkRecentChooserMenu * gobj() const
            {
                return reinterpret_cast<GtkRecentChooserMenu * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            RecentChooserMenu();
            explicit RecentChooserMenu(const Glib::RefPtr< RecentManager > & recent_manager);
            void set_show_numbers(bool show_numbers = true);
            bool get_show_numbers() const;
    };
}
namespace Glib {
    Gtk::RecentChooserMenu * wrap(GtkRecentChooserMenu * object, bool take_copy = false);
}
typedef struct _GtkRecentChooserWidget GtkRecentChooserWidget;
typedef struct _GtkRecentChooserWidgetClass GtkRecentChooserWidgetClass;
namespace Gtk {
    class RecentChooserWidget_Class;
}
namespace Gtk {
    class RecentChooserWidget : public VBox, public RecentChooser
    {
        public :
            typedef RecentChooserWidget CppObjectType;
            typedef RecentChooserWidget_Class CppClassType;
            typedef GtkRecentChooserWidget BaseObjectType;
            typedef GtkRecentChooserWidgetClass BaseClassType;
            virtual ~RecentChooserWidget();
        private :
            friend class RecentChooserWidget_Class;
            static CppClassType recentchooserwidget_class_;
            RecentChooserWidget(const RecentChooserWidget &);
            RecentChooserWidget & operator =(const RecentChooserWidget &);
        protected :
            explicit RecentChooserWidget(const Glib::ConstructParams & construct_params);
            explicit RecentChooserWidget(GtkRecentChooserWidget * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkRecentChooserWidget * gobj()
            {
                return reinterpret_cast<GtkRecentChooserWidget * >(gobject_);
            }
            const GtkRecentChooserWidget * gobj() const
            {
                return reinterpret_cast<GtkRecentChooserWidget * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            RecentChooserWidget();
            explicit RecentChooserWidget(const Glib::RefPtr< RecentManager > & recent_manager);
    };
}
namespace Glib {
    Gtk::RecentChooserWidget * wrap(GtkRecentChooserWidget * object, bool take_copy = false);
}
typedef struct _GtkRuler GtkRuler;
typedef struct _GtkRulerClass GtkRulerClass;
namespace Gtk {
    class Ruler_Class;
}
typedef struct _GtkVRuler GtkVRuler;
typedef struct _GtkVRulerClass GtkVRulerClass;
namespace Gtk {
    class VRuler_Class;
}
typedef struct _GtkHRuler GtkHRuler;
typedef struct _GtkHRulerClass GtkHRulerClass;
namespace Gtk {
    class HRuler_Class;
}
namespace Gtk {
    class Ruler : public Widget
    {
        public :
            typedef Ruler CppObjectType;
            typedef Ruler_Class CppClassType;
            typedef GtkRuler BaseObjectType;
            typedef GtkRulerClass BaseClassType;
            virtual ~Ruler();
        private :
            friend class Ruler_Class;
            static CppClassType ruler_class_;
            Ruler(const Ruler &);
            Ruler & operator =(const Ruler &);
        protected :
            explicit Ruler(const Glib::ConstructParams & construct_params);
            explicit Ruler(GtkRuler * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkRuler * gobj()
            {
                return reinterpret_cast<GtkRuler * >(gobject_);
            }
            const GtkRuler * gobj() const
            {
                return reinterpret_cast<GtkRuler * >(gobject_);
            }
        public :
        protected :
        private :
        protected :
            Ruler();
        public :
            MetricType get_metric() const;
            void set_metric(MetricType metric = PIXELS);
            MetricType get_metric();
            double get_range_lower() const;
            double get_range_upper() const;
            void set_range(double lower, double upper, double position, double max_size);
            void get_range(double & lower, double & upper, double & position, double & max_size);
            void draw_ticks();
            void draw_pos();
            virtual void draw_ticks_vfunc();
            virtual void draw_pos_vfunc();
            Glib::PropertyProxy< double > property_lower();
            Glib::PropertyProxy_ReadOnly< double > property_lower() const;
            Glib::PropertyProxy< double > property_upper();
            Glib::PropertyProxy_ReadOnly< double > property_upper() const;
            Glib::PropertyProxy< double > property_position();
            Glib::PropertyProxy_ReadOnly< double > property_position() const;
            Glib::PropertyProxy< double > property_max_size();
            Glib::PropertyProxy_ReadOnly< double > property_max_size() const;
    };
    class VRuler : public Ruler
    {
        public :
            typedef VRuler CppObjectType;
            typedef VRuler_Class CppClassType;
            typedef GtkVRuler BaseObjectType;
            typedef GtkVRulerClass BaseClassType;
            virtual ~VRuler();
        private :
            friend class VRuler_Class;
            static CppClassType vruler_class_;
            VRuler(const VRuler &);
            VRuler & operator =(const VRuler &);
        protected :
            explicit VRuler(const Glib::ConstructParams & construct_params);
            explicit VRuler(GtkVRuler * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkVRuler * gobj()
            {
                return reinterpret_cast<GtkVRuler * >(gobject_);
            }
            const GtkVRuler * gobj() const
            {
                return reinterpret_cast<GtkVRuler * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            VRuler();
    };
    class HRuler : public Ruler
    {
        public :
            typedef HRuler CppObjectType;
            typedef HRuler_Class CppClassType;
            typedef GtkHRuler BaseObjectType;
            typedef GtkHRulerClass BaseClassType;
            virtual ~HRuler();
        private :
            friend class HRuler_Class;
            static CppClassType hruler_class_;
            HRuler(const HRuler &);
            HRuler & operator =(const HRuler &);
        protected :
            explicit HRuler(const Glib::ConstructParams & construct_params);
            explicit HRuler(GtkHRuler * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkHRuler * gobj()
            {
                return reinterpret_cast<GtkHRuler * >(gobject_);
            }
            const GtkHRuler * gobj() const
            {
                return reinterpret_cast<GtkHRuler * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            HRuler();
    };
}
namespace Glib {
    Gtk::Ruler * wrap(GtkRuler * object, bool take_copy = false);
}
namespace Glib {
    Gtk::VRuler * wrap(GtkVRuler * object, bool take_copy = false);
}
namespace Glib {
    Gtk::HRuler * wrap(GtkHRuler * object, bool take_copy = false);
}
typedef struct _GtkScale GtkScale;
typedef struct _GtkScaleClass GtkScaleClass;
namespace Gtk {
    class Scale_Class;
}
typedef struct _GtkVScale GtkVScale;
typedef struct _GtkVScaleClass GtkVScaleClass;
namespace Gtk {
    class VScale_Class;
}
typedef struct _GtkHScale GtkHScale;
typedef struct _GtkHScaleClass GtkHScaleClass;
namespace Gtk {
    class HScale_Class;
}
namespace Gtk {
    class Scale : public Range
    {
        public :
            typedef Scale CppObjectType;
            typedef Scale_Class CppClassType;
            typedef GtkScale BaseObjectType;
            typedef GtkScaleClass BaseClassType;
            virtual ~Scale();
        private :
            friend class Scale_Class;
            static CppClassType scale_class_;
            Scale(const Scale &);
            Scale & operator =(const Scale &);
        protected :
            explicit Scale(const Glib::ConstructParams & construct_params);
            explicit Scale(GtkScale * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkScale * gobj()
            {
                return reinterpret_cast<GtkScale * >(gobject_);
            }
            const GtkScale * gobj() const
            {
                return reinterpret_cast<GtkScale * >(gobject_);
            }
        public :
        protected :
            virtual Glib::ustring on_format_value(double value);
        private :
        protected :
            Scale();
        public :
            void set_digits(int digits);
            int get_digits() const;
            void set_draw_value(bool draw_value = true);
            bool get_draw_value() const;
            void set_value_pos(PositionType pos);
            PositionType get_value_pos() const;
            Glib::RefPtr< Pango::Layout > get_layout();
            Glib::RefPtr< const Pango::Layout > get_layout() const;
            void get_layout_offsets(int & x, int & y) const;
            Glib::SignalProxy1< Glib::ustring, double > signal_format_value();
            Glib::PropertyProxy< int > property_digits();
            Glib::PropertyProxy_ReadOnly< int > property_digits() const;
            Glib::PropertyProxy< bool > property_draw_value();
            Glib::PropertyProxy_ReadOnly< bool > property_draw_value() const;
            Glib::PropertyProxy< PositionType > property_value_pos();
            Glib::PropertyProxy_ReadOnly< PositionType > property_value_pos() const;
        protected :
            virtual void draw_value_vfunc();
            virtual int calc_digits_(double step) const;
    };
    class VScale : public Scale
    {
        public :
            typedef VScale CppObjectType;
            typedef VScale_Class CppClassType;
            typedef GtkVScale BaseObjectType;
            typedef GtkVScaleClass BaseClassType;
            virtual ~VScale();
        private :
            friend class VScale_Class;
            static CppClassType vscale_class_;
            VScale(const VScale &);
            VScale & operator =(const VScale &);
        protected :
            explicit VScale(const Glib::ConstructParams & construct_params);
            explicit VScale(GtkVScale * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkVScale * gobj()
            {
                return reinterpret_cast<GtkVScale * >(gobject_);
            }
            const GtkVScale * gobj() const
            {
                return reinterpret_cast<GtkVScale * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            VScale();
            VScale(double min, double max, double step);
            explicit VScale(Adjustment & adjustment);
    };
    class HScale : public Scale
    {
        public :
            typedef HScale CppObjectType;
            typedef HScale_Class CppClassType;
            typedef GtkHScale BaseObjectType;
            typedef GtkHScaleClass BaseClassType;
            virtual ~HScale();
        private :
            friend class HScale_Class;
            static CppClassType hscale_class_;
            HScale(const HScale &);
            HScale & operator =(const HScale &);
        protected :
            explicit HScale(const Glib::ConstructParams & construct_params);
            explicit HScale(GtkHScale * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkHScale * gobj()
            {
                return reinterpret_cast<GtkHScale * >(gobject_);
            }
            const GtkHScale * gobj() const
            {
                return reinterpret_cast<GtkHScale * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            HScale();
            HScale(double min, double max, double step);
            explicit HScale(Adjustment & adjustment);
    };
}
namespace Glib {
    Gtk::Scale * wrap(GtkScale * object, bool take_copy = false);
}
namespace Glib {
    Gtk::VScale * wrap(GtkVScale * object, bool take_copy = false);
}
namespace Glib {
    Gtk::HScale * wrap(GtkHScale * object, bool take_copy = false);
}
typedef struct _GtkScrollbar GtkScrollbar;
typedef struct _GtkScrollbarClass GtkScrollbarClass;
namespace Gtk {
    class Scrollbar_Class;
}
typedef struct _GtkVScrollbar GtkVScrollbar;
typedef struct _GtkVScrollbarClass GtkVScrollbarClass;
namespace Gtk {
    class VScrollbar_Class;
}
typedef struct _GtkHScrollbar GtkHScrollbar;
typedef struct _GtkHScrollbarClass GtkHScrollbarClass;
namespace Gtk {
    class HScrollbar_Class;
}
namespace Gtk {
    class Scrollbar : public Range
    {
        public :
            typedef Scrollbar CppObjectType;
            typedef Scrollbar_Class CppClassType;
            typedef GtkScrollbar BaseObjectType;
            typedef GtkScrollbarClass BaseClassType;
            virtual ~Scrollbar();
        private :
            friend class Scrollbar_Class;
            static CppClassType scrollbar_class_;
            Scrollbar(const Scrollbar &);
            Scrollbar & operator =(const Scrollbar &);
        protected :
            explicit Scrollbar(const Glib::ConstructParams & construct_params);
            explicit Scrollbar(GtkScrollbar * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkScrollbar * gobj()
            {
                return reinterpret_cast<GtkScrollbar * >(gobject_);
            }
            const GtkScrollbar * gobj() const
            {
                return reinterpret_cast<GtkScrollbar * >(gobject_);
            }
        public :
        protected :
        private :
        protected :
    };
    class VScrollbar : public Scrollbar
    {
        public :
            typedef VScrollbar CppObjectType;
            typedef VScrollbar_Class CppClassType;
            typedef GtkVScrollbar BaseObjectType;
            typedef GtkVScrollbarClass BaseClassType;
            virtual ~VScrollbar();
        private :
            friend class VScrollbar_Class;
            static CppClassType vscrollbar_class_;
            VScrollbar(const VScrollbar &);
            VScrollbar & operator =(const VScrollbar &);
        protected :
            explicit VScrollbar(const Glib::ConstructParams & construct_params);
            explicit VScrollbar(GtkVScrollbar * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkVScrollbar * gobj()
            {
                return reinterpret_cast<GtkVScrollbar * >(gobject_);
            }
            const GtkVScrollbar * gobj() const
            {
                return reinterpret_cast<GtkVScrollbar * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            VScrollbar();
            explicit VScrollbar(Adjustment & gtkadjustment);
    };
    class HScrollbar : public Scrollbar
    {
        public :
            typedef HScrollbar CppObjectType;
            typedef HScrollbar_Class CppClassType;
            typedef GtkHScrollbar BaseObjectType;
            typedef GtkHScrollbarClass BaseClassType;
            virtual ~HScrollbar();
        private :
            friend class HScrollbar_Class;
            static CppClassType hscrollbar_class_;
            HScrollbar(const HScrollbar &);
            HScrollbar & operator =(const HScrollbar &);
        protected :
            explicit HScrollbar(const Glib::ConstructParams & construct_params);
            explicit HScrollbar(GtkHScrollbar * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkHScrollbar * gobj()
            {
                return reinterpret_cast<GtkHScrollbar * >(gobject_);
            }
            const GtkHScrollbar * gobj() const
            {
                return reinterpret_cast<GtkHScrollbar * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            HScrollbar();
            explicit HScrollbar(Adjustment & gtkadjustment);
    };
}
namespace Glib {
    Gtk::Scrollbar * wrap(GtkScrollbar * object, bool take_copy = false);
}
namespace Glib {
    Gtk::VScrollbar * wrap(GtkVScrollbar * object, bool take_copy = false);
}
namespace Glib {
    Gtk::HScrollbar * wrap(GtkHScrollbar * object, bool take_copy = false);
}
typedef struct _GtkScrolledWindow GtkScrolledWindow;
typedef struct _GtkScrolledWindowClass GtkScrolledWindowClass;
namespace Gtk {
    class ScrolledWindow_Class;
}
namespace Gtk {
    class Adjustment;
    class HScrollbar;
    class VScrollbar;
    class ScrolledWindow : public Bin
    {
        public :
            typedef ScrolledWindow CppObjectType;
            typedef ScrolledWindow_Class CppClassType;
            typedef GtkScrolledWindow BaseObjectType;
            typedef GtkScrolledWindowClass BaseClassType;
            virtual ~ScrolledWindow();
        private :
            friend class ScrolledWindow_Class;
            static CppClassType scrolledwindow_class_;
            ScrolledWindow(const ScrolledWindow &);
            ScrolledWindow & operator =(const ScrolledWindow &);
        protected :
            explicit ScrolledWindow(const Glib::ConstructParams & construct_params);
            explicit ScrolledWindow(GtkScrolledWindow * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkScrolledWindow * gobj()
            {
                return reinterpret_cast<GtkScrolledWindow * >(gobject_);
            }
            const GtkScrolledWindow * gobj() const
            {
                return reinterpret_cast<GtkScrolledWindow * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            ScrolledWindow();
            explicit ScrolledWindow(Adjustment & hadjustment, Adjustment & vadjustment);
            void set_hadjustment(Gtk::Adjustment * hadjustment = 0);
            void set_vadjustment(Gtk::Adjustment * vadjustment = 0);
            void set_hadjustment(Gtk::Adjustment & hadjustment);
            void set_vadjustment(Gtk::Adjustment & vadjustment);
            Gtk::Adjustment * get_hadjustment();
            const Gtk::Adjustment * get_hadjustment() const;
            Gtk::Adjustment * get_vadjustment();
            const Gtk::Adjustment * get_vadjustment() const;
            void set_policy(PolicyType hscrollbar_policy, PolicyType vscrollbar_policy);
            void get_policy(PolicyType & hscrollbar_policy, PolicyType & vscrollbar_policy) const;
            void set_placement(CornerType window_placement);
            void unset_placement();
            CornerType get_placement() const;
            void set_shadow_type(ShadowType type);
            ShadowType get_shadow_type() const;
            virtual void add(Gtk::Widget & widget);
            VScrollbar * get_vscrollbar();
            const VScrollbar * get_vscrollbar() const;
            HScrollbar * get_hscrollbar();
            const HScrollbar * get_hscrollbar() const;
            bool get_vscrollbar_visible() const;
            bool get_hscrollbar_visible() const;
            Glib::PropertyProxy< Gtk::Adjustment * > property_hadjustment();
            Glib::PropertyProxy_ReadOnly< Gtk::Adjustment * > property_hadjustment() const;
            Glib::PropertyProxy< Gtk::Adjustment * > property_vadjustment();
            Glib::PropertyProxy_ReadOnly< Gtk::Adjustment * > property_vadjustment() const;
            Glib::PropertyProxy< PolicyType > property_hscrollbar_policy();
            Glib::PropertyProxy_ReadOnly< PolicyType > property_hscrollbar_policy() const;
            Glib::PropertyProxy< PolicyType > property_vscrollbar_policy();
            Glib::PropertyProxy_ReadOnly< PolicyType > property_vscrollbar_policy() const;
            Glib::PropertyProxy< CornerType > property_window_placement();
            Glib::PropertyProxy_ReadOnly< CornerType > property_window_placement() const;
            Glib::PropertyProxy< ShadowType > property_shadow_type();
            Glib::PropertyProxy_ReadOnly< ShadowType > property_shadow_type() const;
    };
}
namespace Glib {
    Gtk::ScrolledWindow * wrap(GtkScrolledWindow * object, bool take_copy = false);
}
typedef struct _GtkSeparator GtkSeparator;
typedef struct _GtkSeparatorClass GtkSeparatorClass;
namespace Gtk {
    class Separator_Class;
}
typedef struct _GtkVSeparator GtkVSeparator;
typedef struct _GtkVSeparatorClass GtkVSeparatorClass;
namespace Gtk {
    class VSeparator_Class;
}
typedef struct _GtkHSeparator GtkHSeparator;
typedef struct _GtkHSeparatorClass GtkHSeparatorClass;
namespace Gtk {
    class HSeparator_Class;
}
namespace Gtk {
    class Separator : public Widget
    {
        public :
            typedef Separator CppObjectType;
            typedef Separator_Class CppClassType;
            typedef GtkSeparator BaseObjectType;
            typedef GtkSeparatorClass BaseClassType;
            virtual ~Separator();
        private :
            friend class Separator_Class;
            static CppClassType separator_class_;
            Separator(const Separator &);
            Separator & operator =(const Separator &);
        protected :
            explicit Separator(const Glib::ConstructParams & construct_params);
            explicit Separator(GtkSeparator * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkSeparator * gobj()
            {
                return reinterpret_cast<GtkSeparator * >(gobject_);
            }
            const GtkSeparator * gobj() const
            {
                return reinterpret_cast<GtkSeparator * >(gobject_);
            }
        public :
        protected :
        private :
        public :
        protected :
            Separator();
    };
    class VSeparator : public Separator
    {
        public :
            typedef VSeparator CppObjectType;
            typedef VSeparator_Class CppClassType;
            typedef GtkVSeparator BaseObjectType;
            typedef GtkVSeparatorClass BaseClassType;
            virtual ~VSeparator();
        private :
            friend class VSeparator_Class;
            static CppClassType vseparator_class_;
            VSeparator(const VSeparator &);
            VSeparator & operator =(const VSeparator &);
        protected :
            explicit VSeparator(const Glib::ConstructParams & construct_params);
            explicit VSeparator(GtkVSeparator * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkVSeparator * gobj()
            {
                return reinterpret_cast<GtkVSeparator * >(gobject_);
            }
            const GtkVSeparator * gobj() const
            {
                return reinterpret_cast<GtkVSeparator * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            VSeparator();
    };
    class HSeparator : public Separator
    {
        public :
            typedef HSeparator CppObjectType;
            typedef HSeparator_Class CppClassType;
            typedef GtkHSeparator BaseObjectType;
            typedef GtkHSeparatorClass BaseClassType;
            virtual ~HSeparator();
        private :
            friend class HSeparator_Class;
            static CppClassType hseparator_class_;
            HSeparator(const HSeparator &);
            HSeparator & operator =(const HSeparator &);
        protected :
            explicit HSeparator(const Glib::ConstructParams & construct_params);
            explicit HSeparator(GtkHSeparator * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkHSeparator * gobj()
            {
                return reinterpret_cast<GtkHSeparator * >(gobject_);
            }
            const GtkHSeparator * gobj() const
            {
                return reinterpret_cast<GtkHSeparator * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            HSeparator();
    };
}
namespace Glib {
    Gtk::Separator * wrap(GtkSeparator * object, bool take_copy = false);
}
namespace Glib {
    Gtk::VSeparator * wrap(GtkVSeparator * object, bool take_copy = false);
}
namespace Glib {
    Gtk::HSeparator * wrap(GtkHSeparator * object, bool take_copy = false);
}
typedef struct _GtkSeparatorToolItem GtkSeparatorToolItem;
typedef struct _GtkSeparatorToolItemClass GtkSeparatorToolItemClass;
namespace Gtk {
    class SeparatorToolItem_Class;
}
namespace Gtk {
    class SeparatorToolItem : public ToolItem
    {
        public :
            typedef SeparatorToolItem CppObjectType;
            typedef SeparatorToolItem_Class CppClassType;
            typedef GtkSeparatorToolItem BaseObjectType;
            typedef GtkSeparatorToolItemClass BaseClassType;
            virtual ~SeparatorToolItem();
        private :
            friend class SeparatorToolItem_Class;
            static CppClassType separatortoolitem_class_;
            SeparatorToolItem(const SeparatorToolItem &);
            SeparatorToolItem & operator =(const SeparatorToolItem &);
        protected :
            explicit SeparatorToolItem(const Glib::ConstructParams & construct_params);
            explicit SeparatorToolItem(GtkSeparatorToolItem * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkSeparatorToolItem * gobj()
            {
                return reinterpret_cast<GtkSeparatorToolItem * >(gobject_);
            }
            const GtkSeparatorToolItem * gobj() const
            {
                return reinterpret_cast<GtkSeparatorToolItem * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            SeparatorToolItem();
    };
}
namespace Glib {
    Gtk::SeparatorToolItem * wrap(GtkSeparatorToolItem * object, bool take_copy = false);
}
typedef struct _GtkToolbar GtkToolbar;
typedef struct _GtkToolbarClass GtkToolbarClass;
namespace Gtk {
    class Toolbar_Class;
}
namespace Gtk {
    class Toolbar : public Container
    {
        public :
            typedef Toolbar CppObjectType;
            typedef Toolbar_Class CppClassType;
            typedef GtkToolbar BaseObjectType;
            typedef GtkToolbarClass BaseClassType;
            virtual ~Toolbar();
        private :
            friend class Toolbar_Class;
            static CppClassType toolbar_class_;
            Toolbar(const Toolbar &);
            Toolbar & operator =(const Toolbar &);
        protected :
            explicit Toolbar(const Glib::ConstructParams & construct_params);
            explicit Toolbar(GtkToolbar * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkToolbar * gobj()
            {
                return reinterpret_cast<GtkToolbar * >(gobject_);
            }
            const GtkToolbar * gobj() const
            {
                return reinterpret_cast<GtkToolbar * >(gobject_);
            }
        public :
        protected :
            virtual void on_orientation_changed(Orientation orientation);
            virtual void on_toolbar_style_changed(ToolbarStyle style);
            virtual bool on_popup_context_menu(int x, int y, int button_number);
        private :
        public :
            Toolbar();
            void insert(ToolItem & item, int pos);
            void insert(ToolButton & item, int pos, const sigc::slot< void > & clicked_slot);
            void insert(ToggleToolButton & item, int pos, const sigc::slot< void > & toggled_slot);
            void append(ToolItem & item);
            void append(ToolButton & item, const sigc::slot< void > & clicked_slot);
            void append(ToggleToolButton & item, const sigc::slot< void > & toggled_slot);
            void prepend(ToolItem & item);
            void prepend(ToolButton & item, const sigc::slot< void > & clicked_slot);
            void prepend(ToggleToolButton & item, const sigc::slot< void > & toggled_slot);
            int get_item_index(const ToolItem & item) const;
            int get_n_items() const;
            ToolItem * get_nth_item(int n);
            const ToolItem * get_nth_item(int n) const;
            bool get_show_arrow() const;
            void set_show_arrow(bool show_arrow = true);
            void set_orientation(Orientation orientation);
            Orientation get_orientation() const;
            void set_toolbar_style(ToolbarStyle style);
            ToolbarStyle get_toolbar_style() const;
            void set_tooltips(bool enable = true);
            bool get_tooltips() const;
            void unset_toolbar_style();
            void set_icon_size(IconSize icon_size);
            void unset_icon_size();
            IconSize get_icon_size() const;
            ReliefStyle get_relief_style() const;
            int get_drop_index(int x, int y) const;
            void set_drop_highlight_item(ToolItem & tool_item, int index);
            void unset_drop_highlight_item();
            Glib::SignalProxy1< void, Orientation > signal_orientation_changed();
            Glib::SignalProxy1< void, ToolbarStyle > signal_toolbar_style_changed();
            Glib::SignalProxy3< bool, int, int, int > signal_popup_context_menu();
            Tooltips * get_tooltips_object() const;
            Glib::PropertyProxy< Orientation > property_orientation();
            Glib::PropertyProxy_ReadOnly< Orientation > property_orientation() const;
            Glib::PropertyProxy< ToolbarStyle > property_toolbar_style();
            Glib::PropertyProxy_ReadOnly< ToolbarStyle > property_toolbar_style() const;
            Glib::PropertyProxy< bool > property_show_arrow();
            Glib::PropertyProxy_ReadOnly< bool > property_show_arrow() const;
    };
}
namespace Glib {
    Gtk::Toolbar * wrap(GtkToolbar * object, bool take_copy = false);
}
typedef struct _GtkSettings GtkSettings;
typedef struct _GtkSettingsClass GtkSettingsClass;
namespace Gtk {
    class Settings_Class;
}
namespace Gtk {
    class Settings : public Glib::Object
    {
        public :
            typedef Settings CppObjectType;
            typedef Settings_Class CppClassType;
            typedef GtkSettings BaseObjectType;
            typedef GtkSettingsClass BaseClassType;
        private :
            friend class Settings_Class;
            static CppClassType settings_class_;
        private :
            Settings(const Settings &);
            Settings & operator =(const Settings &);
        protected :
            explicit Settings(const Glib::ConstructParams & construct_params);
            explicit Settings(GtkSettings * castitem);
        public :
            virtual ~Settings();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkSettings * gobj()
            {
                return reinterpret_cast<GtkSettings * >(gobject_);
            }
            const GtkSettings * gobj() const
            {
                return reinterpret_cast<GtkSettings * >(gobject_);
            }
            GtkSettings * gobj_copy();
        private :
        protected :
        public :
            static Glib::RefPtr< Settings > get_default();
            static Glib::RefPtr< Settings > get_for_screen(const Glib::RefPtr< Gdk::Screen > & screen);
            Glib::PropertyProxy< int > property_gtk_double_click_time();
            Glib::PropertyProxy_ReadOnly< int > property_gtk_double_click_time() const;
            Glib::PropertyProxy< int > property_gtk_double_click_distance();
            Glib::PropertyProxy_ReadOnly< int > property_gtk_double_click_distance() const;
            Glib::PropertyProxy< bool > property_gtk_cursor_blink();
            Glib::PropertyProxy_ReadOnly< bool > property_gtk_cursor_blink() const;
            Glib::PropertyProxy< int > property_gtk_cursor_blink_time();
            Glib::PropertyProxy_ReadOnly< int > property_gtk_cursor_blink_time() const;
            Glib::PropertyProxy< bool > property_gtk_split_cursor();
            Glib::PropertyProxy_ReadOnly< bool > property_gtk_split_cursor() const;
            Glib::PropertyProxy< Glib::ustring > property_gtk_theme_name();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_gtk_theme_name() const;
            Glib::PropertyProxy< Glib::ustring > property_gtk_key_theme_name();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_gtk_key_theme_name() const;
            Glib::PropertyProxy< Glib::ustring > property_gtk_menu_bar_accel();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_gtk_menu_bar_accel() const;
            Glib::PropertyProxy< int > property_gtk_dnd_drag_threshold();
            Glib::PropertyProxy_ReadOnly< int > property_gtk_dnd_drag_threshold() const;
            Glib::PropertyProxy< Glib::ustring > property_gtk_font_name();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_gtk_font_name() const;
            Glib::PropertyProxy< Glib::ustring > property_gtk_modules();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_gtk_modules() const;
            Glib::PropertyProxy< int > property_gtk_xft_antialias();
            Glib::PropertyProxy_ReadOnly< int > property_gtk_xft_antialias() const;
            Glib::PropertyProxy< int > property_gtk_xft_hinting();
            Glib::PropertyProxy_ReadOnly< int > property_gtk_xft_hinting() const;
            Glib::PropertyProxy< Glib::ustring > property_gtk_xft_hintstyle();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_gtk_xft_hintstyle() const;
            Glib::PropertyProxy< Glib::ustring > property_gtk_xft_rgba();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_gtk_xft_rgba() const;
            Glib::PropertyProxy< int > property_gtk_xft_dpi();
            Glib::PropertyProxy_ReadOnly< int > property_gtk_xft_dpi() const;
            Glib::PropertyProxy< Glib::ustring > property_gtk_cursor_theme_name();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_gtk_cursor_theme_name() const;
            Glib::PropertyProxy< int > property_gtk_cursor_theme_size();
            Glib::PropertyProxy_ReadOnly< int > property_gtk_cursor_theme_size() const;
            Glib::PropertyProxy< bool > property_gtk_alternative_button_order();
            Glib::PropertyProxy_ReadOnly< bool > property_gtk_alternative_button_order() const;
            Glib::PropertyProxy< bool > property_gtk_alternative_sort_arrows();
            Glib::PropertyProxy_ReadOnly< bool > property_gtk_alternative_sort_arrows() const;
            Glib::PropertyProxy< bool > property_gtk_show_input_method_menu();
            Glib::PropertyProxy_ReadOnly< bool > property_gtk_show_input_method_menu() const;
            Glib::PropertyProxy< bool > property_gtk_show_unicode_menu();
            Glib::PropertyProxy_ReadOnly< bool > property_gtk_show_unicode_menu() const;
            Glib::PropertyProxy< int > property_gtk_timeout_initial();
            Glib::PropertyProxy_ReadOnly< int > property_gtk_timeout_initial() const;
            Glib::PropertyProxy< int > property_gtk_timeout_repeat();
            Glib::PropertyProxy_ReadOnly< int > property_gtk_timeout_repeat() const;
            Glib::PropertyProxy< int > property_gtk_timeout_expand();
            Glib::PropertyProxy_ReadOnly< int > property_gtk_timeout_expand() const;
            Glib::PropertyProxy< Glib::ustring > property_gtk_color_scheme();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_gtk_color_scheme() const;
            Glib::PropertyProxy< bool > property_gtk_enable_animations();
            Glib::PropertyProxy_ReadOnly< bool > property_gtk_enable_animations() const;
            Glib::PropertyProxy< bool > property_gtk_touchscreen_mode();
            Glib::PropertyProxy_ReadOnly< bool > property_gtk_touchscreen_mode() const;
            Glib::PropertyProxy< int > property_gtk_tooltip_timeout();
            Glib::PropertyProxy_ReadOnly< int > property_gtk_tooltip_timeout() const;
            Glib::PropertyProxy< int > property_gtk_tooltip_browse_timeout();
            Glib::PropertyProxy_ReadOnly< int > property_gtk_tooltip_browse_timeout() const;
            Glib::PropertyProxy< int > property_gtk_tooltip_browse_mode_timeout();
            Glib::PropertyProxy_ReadOnly< int > property_gtk_tooltip_browse_mode_timeout() const;
            Glib::PropertyProxy< bool > property_gtk_keynav_cursor_only();
            Glib::PropertyProxy_ReadOnly< bool > property_gtk_keynav_cursor_only() const;
            Glib::PropertyProxy< bool > property_gtk_keynav_wrap_around();
            Glib::PropertyProxy_ReadOnly< bool > property_gtk_keynav_wrap_around() const;
            Glib::PropertyProxy< bool > property_gtk_error_bell();
            Glib::PropertyProxy_ReadOnly< bool > property_gtk_error_bell() const;
            Glib::PropertyProxy< Glib::ustring > property_gtk_file_chooser_backend();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_gtk_file_chooser_backend() const;
            Glib::PropertyProxy< Glib::ustring > property_gtk_print_backends();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_gtk_print_backends() const;
            Glib::PropertyProxy< Glib::ustring > property_gtk_print_preview_command();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_gtk_print_preview_command() const;
            Glib::PropertyProxy< bool > property_gtk_enable_mnemonics();
            Glib::PropertyProxy_ReadOnly< bool > property_gtk_enable_mnemonics() const;
            Glib::PropertyProxy< bool > property_gtk_enable_accels();
            Glib::PropertyProxy_ReadOnly< bool > property_gtk_enable_accels() const;
            Glib::PropertyProxy< ToolbarStyle > property_gtk_toolbar_style();
            Glib::PropertyProxy_ReadOnly< ToolbarStyle > property_gtk_toolbar_style() const;
            Glib::PropertyProxy< IconSize > property_gtk_toolbar_icon_size();
            Glib::PropertyProxy_ReadOnly< IconSize > property_gtk_toolbar_icon_size() const;
            Glib::PropertyProxy< bool > property_gtk_can_change_accels();
            Glib::PropertyProxy_ReadOnly< bool > property_gtk_can_change_accels() const;
            Glib::PropertyProxy< bool > property_gtk_entry_select_on_focus();
            Glib::PropertyProxy_ReadOnly< bool > property_gtk_entry_select_on_focus() const;
            Glib::PropertyProxy< Glib::ustring > property_gtk_color_palette();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_gtk_color_palette() const;
            Glib::PropertyProxy< bool > property_gtk_button_images();
            Glib::PropertyProxy_ReadOnly< bool > property_gtk_button_images() const;
            Glib::PropertyProxy< Glib::ustring > property_gtk_icon_theme_name();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_gtk_icon_theme_name() const;
            Glib::PropertyProxy< Glib::ustring > property_gtk_icon_sizes();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_gtk_icon_sizes() const;
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::Settings > wrap(GtkSettings * object, bool take_copy = false);
}
typedef struct _GtkSizeGroup GtkSizeGroup;
typedef struct _GtkSizeGroupClass GtkSizeGroupClass;
namespace Gtk {
    class SizeGroup_Class;
}
namespace Gtk {
    enum SizeGroupMode
    {
        SIZE_GROUP_NONE, 
        SIZE_GROUP_HORIZONTAL, 
        SIZE_GROUP_VERTICAL, 
        SIZE_GROUP_BOTH
    };
}
namespace Glib {
    template<>
    class Value< Gtk::SizeGroupMode > : public Glib::Value_Enum< Gtk::SizeGroupMode >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class SizeGroup : public Glib::Object
    {
        public :
            typedef SizeGroup CppObjectType;
            typedef SizeGroup_Class CppClassType;
            typedef GtkSizeGroup BaseObjectType;
            typedef GtkSizeGroupClass BaseClassType;
        private :
            friend class SizeGroup_Class;
            static CppClassType sizegroup_class_;
        private :
            SizeGroup(const SizeGroup &);
            SizeGroup & operator =(const SizeGroup &);
        protected :
            explicit SizeGroup(const Glib::ConstructParams & construct_params);
            explicit SizeGroup(GtkSizeGroup * castitem);
        public :
            virtual ~SizeGroup();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkSizeGroup * gobj()
            {
                return reinterpret_cast<GtkSizeGroup * >(gobject_);
            }
            const GtkSizeGroup * gobj() const
            {
                return reinterpret_cast<GtkSizeGroup * >(gobject_);
            }
            GtkSizeGroup * gobj_copy();
        private :
        protected :
            explicit SizeGroup(SizeGroupMode mode);
        public :
            static Glib::RefPtr< SizeGroup > create(SizeGroupMode mode);
            void set_mode(SizeGroupMode mode);
            SizeGroupMode get_mode() const;
            void set_ignore_hidden(bool ignore_hidden = true);
            bool get_ignore_hidden() const;
            void add_widget(Widget & widget);
            void remove_widget(Widget & widget);
            Glib::SListHandle< Widget * > get_widgets();
            Glib::SListHandle< const Widget * > get_widgets() const;
            Glib::PropertyProxy< SizeGroupMode > property_mode();
            Glib::PropertyProxy_ReadOnly< SizeGroupMode > property_mode() const;
            Glib::PropertyProxy< bool > property_ignore_hidden();
            Glib::PropertyProxy_ReadOnly< bool > property_ignore_hidden() const;
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::SizeGroup > wrap(GtkSizeGroup * object, bool take_copy = false);
}
typedef struct _GtkSpinButton GtkSpinButton;
typedef struct _GtkSpinButtonClass GtkSpinButtonClass;
namespace Gtk {
    class SpinButton_Class;
}
namespace Gtk {
    enum SpinButtonUpdatePolicy
    {
        UPDATE_ALWAYS, 
        UPDATE_IF_VALID
    };
}
namespace Glib {
    template<>
    class Value< Gtk::SpinButtonUpdatePolicy > : public Glib::Value_Enum< Gtk::SpinButtonUpdatePolicy >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum SpinType
    {
        SPIN_STEP_FORWARD, 
        SPIN_STEP_BACKWARD, 
        SPIN_PAGE_FORWARD, 
        SPIN_PAGE_BACKWARD, 
        SPIN_HOME, 
        SPIN_END, 
        SPIN_USER_DEFINED
    };
}
namespace Glib {
    template<>
    class Value< Gtk::SpinType > : public Glib::Value_Enum< Gtk::SpinType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    enum 
    {
        INPUT_ERROR = -1
    };
    class Adjustment;
    class SpinButton : public Entry
    {
        public :
            typedef SpinButton CppObjectType;
            typedef SpinButton_Class CppClassType;
            typedef GtkSpinButton BaseObjectType;
            typedef GtkSpinButtonClass BaseClassType;
            virtual ~SpinButton();
        private :
            friend class SpinButton_Class;
            static CppClassType spinbutton_class_;
            SpinButton(const SpinButton &);
            SpinButton & operator =(const SpinButton &);
        protected :
            explicit SpinButton(const Glib::ConstructParams & construct_params);
            explicit SpinButton(GtkSpinButton * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkSpinButton * gobj()
            {
                return reinterpret_cast<GtkSpinButton * >(gobject_);
            }
            const GtkSpinButton * gobj() const
            {
                return reinterpret_cast<GtkSpinButton * >(gobject_);
            }
        public :
        protected :
            virtual int on_input(double * new_value);
            virtual bool on_output();
            virtual void on_value_changed();
        private :
        public :
            SpinButton(double climb_rate = 0.0, guint digits = 0);
            explicit SpinButton(Adjustment & adjustment, double climb_rate = 0.0, guint digits = 0);
            void configure(Adjustment & adjustment, double climb_rate, guint digits);
            void set_adjustment(Adjustment & adjustment);
            void unset_adjustment();
            Gtk::Adjustment * get_adjustment();
            const Gtk::Adjustment * get_adjustment() const;
            void set_digits(guint digits);
            guint get_digits() const;
            void set_increments(double step, double page);
            void get_increments(double & step, double & page) const;
            void set_range(double min, double max);
            void get_range(double & min, double & max) const;
            double get_value() const;
            int get_value_as_int() const;
            void set_value(double value);
            void set_update_policy(SpinButtonUpdatePolicy policy);
            SpinButtonUpdatePolicy get_update_policy() const;
            void set_numeric(bool numeric = true);
            bool get_numeric() const;
            void spin(SpinType direction, double increment);
            void set_wrap(bool wrap = true);
            bool get_wrap() const;
            void set_snap_to_ticks(bool snap_to_ticks = true);
            bool get_snap_to_ticks() const;
            void update();
            Glib::SignalProxy1< int, double * > signal_input();
            Glib::SignalProxy0< bool > signal_output();
            Glib::SignalProxy0< bool > signal_wrapped();
            Glib::SignalProxy0< void > signal_value_changed();
            Glib::PropertyProxy< Gtk::Adjustment * > property_adjustment();
            Glib::PropertyProxy_ReadOnly< Gtk::Adjustment * > property_adjustment() const;
            Glib::PropertyProxy< double > property_climb_rate();
            Glib::PropertyProxy_ReadOnly< double > property_climb_rate() const;
            Glib::PropertyProxy< guint > property_digits();
            Glib::PropertyProxy_ReadOnly< guint > property_digits() const;
            Glib::PropertyProxy< bool > property_snap_to_ticks();
            Glib::PropertyProxy_ReadOnly< bool > property_snap_to_ticks() const;
            Glib::PropertyProxy< bool > property_numeric();
            Glib::PropertyProxy_ReadOnly< bool > property_numeric() const;
            Glib::PropertyProxy< bool > property_wrap();
            Glib::PropertyProxy_ReadOnly< bool > property_wrap() const;
            Glib::PropertyProxy< SpinButtonUpdatePolicy > property_update_policy();
            Glib::PropertyProxy_ReadOnly< SpinButtonUpdatePolicy > property_update_policy() const;
            Glib::PropertyProxy< double > property_value();
            Glib::PropertyProxy_ReadOnly< double > property_value() const;
    };
}
namespace Glib {
    Gtk::SpinButton * wrap(GtkSpinButton * object, bool take_copy = false);
}
typedef struct _GtkStatusbar GtkStatusbar;
typedef struct _GtkStatusbarClass GtkStatusbarClass;
namespace Gtk {
    class Statusbar_Class;
}
namespace Gtk {
    class Statusbar : public HBox
    {
        public :
            typedef Statusbar CppObjectType;
            typedef Statusbar_Class CppClassType;
            typedef GtkStatusbar BaseObjectType;
            typedef GtkStatusbarClass BaseClassType;
            virtual ~Statusbar();
        private :
            friend class Statusbar_Class;
            static CppClassType statusbar_class_;
            Statusbar(const Statusbar &);
            Statusbar & operator =(const Statusbar &);
        protected :
            explicit Statusbar(const Glib::ConstructParams & construct_params);
            explicit Statusbar(GtkStatusbar * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkStatusbar * gobj()
            {
                return reinterpret_cast<GtkStatusbar * >(gobject_);
            }
            const GtkStatusbar * gobj() const
            {
                return reinterpret_cast<GtkStatusbar * >(gobject_);
            }
        public :
        protected :
            virtual void on_text_pushed(guint context_id, const Glib::ustring & text);
            virtual void on_text_popped(guint context_id, const Glib::ustring & text);
        private :
        public :
            Statusbar();
            guint get_context_id(const Glib::ustring & context_description);
            guint push(const Glib::ustring & text, guint context_id = 0);
            void pop(guint context_id = 0);
            void remove_message(guint message_id, guint context_id = 0);
            void set_has_resize_grip(bool setting = true);
            bool get_has_resize_grip() const;
            Glib::SignalProxy2< void, guint, const Glib::ustring & > signal_text_pushed();
            Glib::SignalProxy2< void, guint, const Glib::ustring & > signal_text_popped();
            Glib::PropertyProxy< bool > property_has_resize_grip();
            Glib::PropertyProxy_ReadOnly< bool > property_has_resize_grip() const;
    };
}
namespace Glib {
    Gtk::Statusbar * wrap(GtkStatusbar * object, bool take_copy = false);
}
typedef struct _GtkStatusIcon GtkStatusIcon;
typedef struct _GtkStatusIconClass GtkStatusIconClass;
namespace Gtk {
    class StatusIcon_Class;
}
namespace Gtk {
    class StatusIcon : public Glib::Object
    {
        public :
            typedef StatusIcon CppObjectType;
            typedef StatusIcon_Class CppClassType;
            typedef GtkStatusIcon BaseObjectType;
            typedef GtkStatusIconClass BaseClassType;
        private :
            friend class StatusIcon_Class;
            static CppClassType statusicon_class_;
        private :
            StatusIcon(const StatusIcon &);
            StatusIcon & operator =(const StatusIcon &);
        protected :
            explicit StatusIcon(const Glib::ConstructParams & construct_params);
            explicit StatusIcon(GtkStatusIcon * castitem);
        public :
            virtual ~StatusIcon();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkStatusIcon * gobj()
            {
                return reinterpret_cast<GtkStatusIcon * >(gobject_);
            }
            const GtkStatusIcon * gobj() const
            {
                return reinterpret_cast<GtkStatusIcon * >(gobject_);
            }
            GtkStatusIcon * gobj_copy();
        private :
        protected :
            StatusIcon();
            explicit StatusIcon(const Glib::RefPtr< Gdk::Pixbuf > & pixbuf);
            explicit StatusIcon(const StockID & stock);
            explicit StatusIcon(const Glib::ustring & icon_name);
        public :
            static Glib::RefPtr< StatusIcon > create(const Glib::RefPtr< Gdk::Pixbuf > & pixbuf);
            static Glib::RefPtr< StatusIcon > create(const StockID & stock_id);
            static Glib::RefPtr< StatusIcon > create(const Glib::ustring & icon_name);
            static Glib::RefPtr< StatusIcon > create_from_file(const std::string & filename);
            void set(const Glib::RefPtr< Gdk::Pixbuf > & pixbuf);
            void set_from_file(const Glib::ustring & filename);
            void set(const StockID & stock_id);
            void set(const Glib::ustring & icon_name);
            ImageType get_storage_type() const;
            Glib::RefPtr< Gdk::Pixbuf > get_pixbuf();
            Glib::RefPtr< const Gdk::Pixbuf > get_pixbuf() const;
            StockID get_stock() const;
            Glib::ustring get_icon_name() const;
            int get_size() const;
            void set_screen(const Glib::RefPtr< Gdk::Screen > & screen);
            Glib::RefPtr< Gdk::Screen > get_screen();
            Glib::RefPtr< const Gdk::Screen > get_screen() const;
            void set_tooltip(const Glib::ustring & tooltip_text);
            void set_visible(bool visible = true);
            bool get_visible() const;
            void set_blinking(bool blinking = true);
            bool get_blinking() const;
            bool is_embedded() const;
            void popup_menu_at_position(Menu & menu, guint button, guint32 activate_time);
            bool get_geometry(Glib::RefPtr< Gdk::Screen > & screen, Gdk::Rectangle & area, Orientation & orientation);
            Glib::PropertyProxy< Glib::RefPtr< Gdk::Pixbuf > > property_pixbuf();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Gdk::Pixbuf > > property_pixbuf() const;
            Glib::PropertyProxy_WriteOnly< std::string > property_file();
            Glib::PropertyProxy< StockID > property_stock();
            Glib::PropertyProxy_ReadOnly< StockID > property_stock() const;
            Glib::PropertyProxy< Glib::ustring > property_icon_name();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_icon_name() const;
            Glib::PropertyProxy_ReadOnly< ImageType > property_storage_type() const;
            Glib::PropertyProxy_ReadOnly< int > property_size() const;
            Glib::PropertyProxy< bool > property_blinking();
            Glib::PropertyProxy_ReadOnly< bool > property_blinking() const;
            Glib::SignalProxy1< bool, int > signal_size_changed();
            Glib::SignalProxy0< void > signal_activate();
            Glib::SignalProxy2< void, guint, guint32 > signal_popup_menu();
        public :
        public :
        protected :
            virtual bool on_size_changed(int size);
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::StatusIcon > wrap(GtkStatusIcon * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkStockItem GtkStockItem;
}
namespace Gtk {
    class StockItem
    {
        public :
            typedef StockItem CppObjectType;
            typedef GtkStockItem BaseObjectType;
            StockItem();
            explicit StockItem(GtkStockItem * castitem, bool make_a_copy = false);
            StockItem(const StockItem & src);
            StockItem & operator =(const StockItem & src);
            ~StockItem();
            GtkStockItem * gobj()
            {
                return gobject_;
            }
            const GtkStockItem * gobj() const
            {
                return gobject_;
            }
            GtkStockItem * gobj_copy() const;
        protected :
            GtkStockItem * gobject_;
        private :
        public :
            StockItem(const Gtk::StockID & stock_id, const Glib::ustring & label, Gdk::ModifierType modifier = Gdk::ModifierType(0), unsigned int keyval = 0, const Glib::ustring & translation_domain = Glib::ustring());
            StockID get_stock_id() const;
            Glib::ustring get_label() const;
            Gdk::ModifierType get_modifier() const;
            guint get_keyval() const;
            Glib::ustring get_translation_domain() const;
            static bool lookup(const Gtk::StockID & stock_id, Gtk::StockItem & item);
    };
}
namespace Glib {
    Gtk::StockItem wrap(GtkStockItem * object, bool take_copy = false);
}
namespace Gtk {
    struct BuiltinStockID
    {
            const char * id;
    };
    namespace Stock {
        extern const Gtk::BuiltinStockID DIALOG_AUTHENTICATION;
        extern const Gtk::BuiltinStockID DIALOG_INFO;
        extern const Gtk::BuiltinStockID DIALOG_WARNING;
        extern const Gtk::BuiltinStockID DIALOG_ERROR;
        extern const Gtk::BuiltinStockID DIALOG_QUESTION;
        extern const Gtk::BuiltinStockID DND;
        extern const Gtk::BuiltinStockID DND_MULTIPLE;
        extern const Gtk::BuiltinStockID ABOUT;
        extern const Gtk::BuiltinStockID ADD;
        extern const Gtk::BuiltinStockID APPLY;
        extern const Gtk::BuiltinStockID BOLD;
        extern const Gtk::BuiltinStockID CANCEL;
        extern const Gtk::BuiltinStockID CDROM;
        extern const Gtk::BuiltinStockID CLEAR;
        extern const Gtk::BuiltinStockID CLOSE;
        extern const Gtk::BuiltinStockID COLOR_PICKER;
        extern const Gtk::BuiltinStockID CONVERT;
        extern const Gtk::BuiltinStockID CONNECT;
        extern const Gtk::BuiltinStockID COPY;
        extern const Gtk::BuiltinStockID CUT;
        extern const Gtk::BuiltinStockID DELETE;
        extern const Gtk::BuiltinStockID DIRECTORY;
        extern const Gtk::BuiltinStockID DISCARD;
        extern const Gtk::BuiltinStockID DISCONNECT;
        extern const Gtk::BuiltinStockID EDIT;
        extern const Gtk::BuiltinStockID EXECUTE;
        extern const Gtk::BuiltinStockID FILE;
        extern const Gtk::BuiltinStockID FIND;
        extern const Gtk::BuiltinStockID FIND_AND_REPLACE;
        extern const Gtk::BuiltinStockID FLOPPY;
        extern const Gtk::BuiltinStockID FULLSCREEN;
        extern const Gtk::BuiltinStockID LEAVE_FULLSCREEN;
        extern const Gtk::BuiltinStockID GOTO_BOTTOM;
        extern const Gtk::BuiltinStockID GOTO_FIRST;
        extern const Gtk::BuiltinStockID GOTO_LAST;
        extern const Gtk::BuiltinStockID GOTO_TOP;
        extern const Gtk::BuiltinStockID GO_BACK;
        extern const Gtk::BuiltinStockID GO_DOWN;
        extern const Gtk::BuiltinStockID GO_FORWARD;
        extern const Gtk::BuiltinStockID GO_UP;
        extern const Gtk::BuiltinStockID HARDDISK;
        extern const Gtk::BuiltinStockID HELP;
        extern const Gtk::BuiltinStockID HOME;
        extern const Gtk::BuiltinStockID INDEX;
        extern const Gtk::BuiltinStockID INFO;
        extern const Gtk::BuiltinStockID INDENT;
        extern const Gtk::BuiltinStockID UNINDENT;
        extern const Gtk::BuiltinStockID ITALIC;
        extern const Gtk::BuiltinStockID JUMP_TO;
        extern const Gtk::BuiltinStockID JUSTIFY_CENTER;
        extern const Gtk::BuiltinStockID JUSTIFY_FILL;
        extern const Gtk::BuiltinStockID JUSTIFY_LEFT;
        extern const Gtk::BuiltinStockID JUSTIFY_RIGHT;
        extern const Gtk::BuiltinStockID MISSING_IMAGE;
        extern const Gtk::BuiltinStockID MEDIA_FORWARD;
        extern const Gtk::BuiltinStockID MEDIA_NEXT;
        extern const Gtk::BuiltinStockID MEDIA_PAUSE;
        extern const Gtk::BuiltinStockID MEDIA_PLAY;
        extern const Gtk::BuiltinStockID MEDIA_PREVIOUS;
        extern const Gtk::BuiltinStockID MEDIA_RECORD;
        extern const Gtk::BuiltinStockID MEDIA_REWIND;
        extern const Gtk::BuiltinStockID MEDIA_STOP;
        extern const Gtk::BuiltinStockID NETWORK;
        extern const Gtk::BuiltinStockID NEW;
        extern const Gtk::BuiltinStockID NO;
        extern const Gtk::BuiltinStockID OK;
        extern const Gtk::BuiltinStockID OPEN;
        extern const Gtk::BuiltinStockID ORIENTATION_PORTRAIT;
        extern const Gtk::BuiltinStockID ORIENTATION_LANDSCAPE;
        extern const Gtk::BuiltinStockID ORIENTATION_REVERSE_LANDSCAPE;
        extern const Gtk::BuiltinStockID ORIENTATION_REVERSE_PORTRAIT;
        extern const Gtk::BuiltinStockID PASTE;
        extern const Gtk::BuiltinStockID PREFERENCES;
        extern const Gtk::BuiltinStockID PRINT;
        extern const Gtk::BuiltinStockID PRINT_PREVIEW;
        extern const Gtk::BuiltinStockID PROPERTIES;
        extern const Gtk::BuiltinStockID QUIT;
        extern const Gtk::BuiltinStockID REDO;
        extern const Gtk::BuiltinStockID REFRESH;
        extern const Gtk::BuiltinStockID REMOVE;
        extern const Gtk::BuiltinStockID REVERT_TO_SAVED;
        extern const Gtk::BuiltinStockID SAVE;
        extern const Gtk::BuiltinStockID SAVE_AS;
        extern const Gtk::BuiltinStockID SELECT_ALL;
        extern const Gtk::BuiltinStockID SELECT_COLOR;
        extern const Gtk::BuiltinStockID SELECT_FONT;
        extern const Gtk::BuiltinStockID SORT_ASCENDING;
        extern const Gtk::BuiltinStockID SORT_DESCENDING;
        extern const Gtk::BuiltinStockID SPELL_CHECK;
        extern const Gtk::BuiltinStockID STOP;
        extern const Gtk::BuiltinStockID STRIKETHROUGH;
        extern const Gtk::BuiltinStockID UNDELETE;
        extern const Gtk::BuiltinStockID UNDERLINE;
        extern const Gtk::BuiltinStockID UNDO;
        extern const Gtk::BuiltinStockID YES;
        extern const Gtk::BuiltinStockID ZOOM_100;
        extern const Gtk::BuiltinStockID ZOOM_FIT;
        extern const Gtk::BuiltinStockID ZOOM_IN;
        extern const Gtk::BuiltinStockID ZOOM_OUT;
        void add(const Gtk::StockItem & item);
        bool lookup(const Gtk::StockID & stock_id, Gtk::StockItem & item);
        bool lookup(const Gtk::StockID & stock_id, Gtk::IconSet & iconset);
        bool lookup(const Gtk::StockID & stock_id, Gtk::IconSize size, Gtk::Image & image);
        Glib::SListHandle< Gtk::StockID, Gtk::StockID_Traits > get_ids();
    }
}
extern "C"
{
    typedef struct _GtkTable GtkTable;
    typedef struct _GtkTableClass GtkTableClass;
    typedef struct _GtkTableChild GtkTableChild;
    typedef struct _GtkTableRowCol GtkTableRowCol;
    struct _GtkTable
    {
            GtkContainer container;
            GList * children;
            GtkTableRowCol * rows;
            GtkTableRowCol * cols;
            guint16 nrows;
            guint16 ncols;
            guint16 column_spacing;
            guint16 row_spacing;
            guint homogeneous : 1;
    };
    struct _GtkTableClass
    {
            GtkContainerClass parent_class;
    };
    struct _GtkTableChild
    {
            GtkWidget * widget;
            guint16 left_attach;
            guint16 right_attach;
            guint16 top_attach;
            guint16 bottom_attach;
            guint16 xpadding;
            guint16 ypadding;
            guint xexpand : 1;
            guint yexpand : 1;
            guint xshrink : 1;
            guint yshrink : 1;
            guint xfill : 1;
            guint yfill : 1;
    };
    struct _GtkTableRowCol
    {
            guint16 requisition;
            guint16 allocation;
            guint16 spacing;
            guint need_expand : 1;
            guint need_shrink : 1;
            guint expand : 1;
            guint shrink : 1;
            guint empty : 1;
    };
    GType gtk_table_get_type(void) __attribute__((__const__));
    GtkWidget * gtk_table_new(guint rows, guint columns, gboolean homogeneous);
    void gtk_table_resize(GtkTable * table, guint rows, guint columns);
    void gtk_table_attach(GtkTable * table, GtkWidget * child, guint left_attach, guint right_attach, guint top_attach, guint bottom_attach, GtkAttachOptions xoptions, GtkAttachOptions yoptions, guint xpadding, guint ypadding);
    void gtk_table_attach_defaults(GtkTable * table, GtkWidget * widget, guint left_attach, guint right_attach, guint top_attach, guint bottom_attach);
    void gtk_table_set_row_spacing(GtkTable * table, guint row, guint spacing);
    guint gtk_table_get_row_spacing(GtkTable * table, guint row);
    void gtk_table_set_col_spacing(GtkTable * table, guint column, guint spacing);
    guint gtk_table_get_col_spacing(GtkTable * table, guint column);
    void gtk_table_set_row_spacings(GtkTable * table, guint spacing);
    guint gtk_table_get_default_row_spacing(GtkTable * table);
    void gtk_table_set_col_spacings(GtkTable * table, guint spacing);
    guint gtk_table_get_default_col_spacing(GtkTable * table);
    void gtk_table_set_homogeneous(GtkTable * table, gboolean homogeneous);
    gboolean gtk_table_get_homogeneous(GtkTable * table);
}
typedef struct _GtkTable GtkTable;
typedef struct _GtkTableClass GtkTableClass;
namespace Gtk {
    class Table_Class;
}
namespace Gtk {
    class Table;
    namespace Table_Helpers {
        class Child : protected _GtkTableChild
        {
            private :
                Child & operator =(const Child &);
                Child(const Child &);
            public :
                inline _GtkTableChild * gobj()
                {
                    return (this);
                }
                inline const _GtkTableChild * gobj() const
                {
                    return (this);
                }
                Widget * get_widget() const;
                guint16 get_left_attach() const;
                guint16 get_right_attach() const;
                guint16 get_top_attach() const;
                guint16 get_bottom_attach() const;
                guint16 get_xpadding() const;
                guint16 get_ypadding() const;
                bool get_xexpand() const;
                bool get_yexpand() const;
                bool get_xshrink() const;
                bool get_yshrink() const;
                bool get_xfill() const;
                bool get_yfill() const;
            protected :
                inline GtkTable * parent()
                {
                    return (GtkTable *) (gobj()->widget->parent);
                }
                friend class Dummy_;
        };
        class TableList : public Glib::HelperList< Child, Widget, Glib::List_Iterator< Child > >
        {
            public :
                TableList();
                explicit TableList(GtkTable * gparent);
                TableList(const TableList & src);
                virtual ~TableList()
                {
                }
                TableList & operator =(const TableList & src);
                typedef Glib::HelperList< Child, Widget, Glib::List_Iterator< Child > > type_base;
                GtkTable * gparent();
                const GtkTable * gparent() const;
                virtual GList * & glist() const;
                virtual void erase(iterator start, iterator stop);
                virtual iterator erase(iterator);
                virtual void remove(const_reference);
                reference operator [](size_type l) const;
            protected :
                iterator insert(iterator position, element_type & e);
                inline void pop_front();
                inline void pop_back();
                virtual void remove(Widget & w);
        };
    }
    class Table : public Container
    {
        public :
            typedef Table CppObjectType;
            typedef Table_Class CppClassType;
            typedef GtkTable BaseObjectType;
            typedef GtkTableClass BaseClassType;
            virtual ~Table();
        private :
            friend class Table_Class;
            static CppClassType table_class_;
            Table(const Table &);
            Table & operator =(const Table &);
        protected :
            explicit Table(const Glib::ConstructParams & construct_params);
            explicit Table(GtkTable * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTable * gobj()
            {
                return reinterpret_cast<GtkTable * >(gobject_);
            }
            const GtkTable * gobj() const
            {
                return reinterpret_cast<GtkTable * >(gobject_);
            }
        public :
        protected :
        private :
        public :
            explicit Table(guint n_rows = 1, guint n_columns = 1, bool homogeneous = false);
            void attach(Widget & child, guint left_attach, guint right_attach, guint top_attach, guint bottom_attach, AttachOptions xoptions = FILL | EXPAND, AttachOptions yoptions = FILL | EXPAND, guint xpadding = 0, guint ypadding = 0);
            void resize(guint rows, guint columns);
            void set_row_spacing(guint row, guint spacing);
            guint get_row_spacing(guint row) const;
            void set_col_spacing(guint column, guint spacing);
            guint get_col_spacing(guint column) const;
            void set_row_spacings(guint spacing);
            void set_col_spacings(guint spacing);
            void set_spacings(guint spacing);
            guint get_default_row_spacing();
            guint get_default_col_spacing();
            void set_homogeneous(bool homogeneous = true);
            bool get_homogeneous() const;
            typedef Table_Helpers::TableList TableList;
            TableList & children();
            const TableList & children() const;
            Glib::PropertyProxy< guint > property_n_rows();
            Glib::PropertyProxy_ReadOnly< guint > property_n_rows() const;
            Glib::PropertyProxy< guint > property_n_columns();
            Glib::PropertyProxy_ReadOnly< guint > property_n_columns() const;
            Glib::PropertyProxy< guint > property_column_spacing();
            Glib::PropertyProxy_ReadOnly< guint > property_column_spacing() const;
            Glib::PropertyProxy< guint > property_row_spacing();
            Glib::PropertyProxy_ReadOnly< guint > property_row_spacing() const;
        protected :
            mutable TableList children_proxy_;
    };
}
namespace Glib {
    Gtk::Table * wrap(GtkTable * object, bool take_copy = false);
}
typedef struct _GtkTextTag GtkTextTag;
typedef struct _GtkTextTagClass GtkTextTagClass;
namespace Gtk {
    class TextTag_Class;
}
namespace Gtk {
    class TextIter;
    class TextTag : public Glib::Object
    {
        public :
            typedef TextTag CppObjectType;
            typedef TextTag_Class CppClassType;
            typedef GtkTextTag BaseObjectType;
            typedef GtkTextTagClass BaseClassType;
        private :
            friend class TextTag_Class;
            static CppClassType texttag_class_;
        private :
            TextTag(const TextTag &);
            TextTag & operator =(const TextTag &);
        protected :
            explicit TextTag(const Glib::ConstructParams & construct_params);
            explicit TextTag(GtkTextTag * castitem);
        public :
            virtual ~TextTag();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTextTag * gobj()
            {
                return reinterpret_cast<GtkTextTag * >(gobject_);
            }
            const GtkTextTag * gobj() const
            {
                return reinterpret_cast<GtkTextTag * >(gobject_);
            }
            GtkTextTag * gobj_copy();
        private :
        protected :
            TextTag();
            explicit TextTag(const Glib::ustring & name);
        public :
            static Glib::RefPtr< TextTag > create();
            static Glib::RefPtr< TextTag > create(const Glib::ustring & name);
            int get_priority() const;
            void set_priority(int priority);
            bool event(const Glib::RefPtr< Glib::Object > & event_object, GdkEvent * event, const TextIter & iter);
            Glib::SignalProxy3< bool, const Glib::RefPtr< Glib::Object > &, GdkEvent *, const TextIter & > signal_event();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_name() const;
            Glib::PropertyProxy_WriteOnly< Glib::ustring > property_background();
            Glib::PropertyProxy_WriteOnly< Glib::ustring > property_foreground();
            Glib::PropertyProxy< Gdk::Color > property_background_gdk();
            Glib::PropertyProxy_ReadOnly< Gdk::Color > property_background_gdk() const;
            Glib::PropertyProxy< Gdk::Color > property_foreground_gdk();
            Glib::PropertyProxy_ReadOnly< Gdk::Color > property_foreground_gdk() const;
            Glib::PropertyProxy< Glib::RefPtr< Gdk::Bitmap > > property_background_stipple();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Gdk::Bitmap > > property_background_stipple() const;
            Glib::PropertyProxy< Glib::RefPtr< Gdk::Bitmap > > property_foreground_stipple();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< Gdk::Bitmap > > property_foreground_stipple() const;
            Glib::PropertyProxy< Glib::ustring > property_font();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_font() const;
            Glib::PropertyProxy< Pango::FontDescription > property_font_desc();
            Glib::PropertyProxy_ReadOnly< Pango::FontDescription > property_font_desc() const;
            Glib::PropertyProxy< Glib::ustring > property_family();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_family() const;
            Glib::PropertyProxy< Pango::Style > property_style();
            Glib::PropertyProxy_ReadOnly< Pango::Style > property_style() const;
            Glib::PropertyProxy< Pango::Variant > property_variant();
            Glib::PropertyProxy_ReadOnly< Pango::Variant > property_variant() const;
            Glib::PropertyProxy< int > property_weight();
            Glib::PropertyProxy_ReadOnly< int > property_weight() const;
            Glib::PropertyProxy< Pango::Stretch > property_stretch();
            Glib::PropertyProxy_ReadOnly< Pango::Stretch > property_stretch() const;
            Glib::PropertyProxy< int > property_size();
            Glib::PropertyProxy_ReadOnly< int > property_size() const;
            Glib::PropertyProxy< double > property_size_points();
            Glib::PropertyProxy_ReadOnly< double > property_size_points() const;
            Glib::PropertyProxy< double > property_scale();
            Glib::PropertyProxy_ReadOnly< double > property_scale() const;
            Glib::PropertyProxy< int > property_pixels_above_lines();
            Glib::PropertyProxy_ReadOnly< int > property_pixels_above_lines() const;
            Glib::PropertyProxy< int > property_pixels_below_lines();
            Glib::PropertyProxy_ReadOnly< int > property_pixels_below_lines() const;
            Glib::PropertyProxy< int > property_pixels_inside_wrap();
            Glib::PropertyProxy_ReadOnly< int > property_pixels_inside_wrap() const;
            Glib::PropertyProxy< bool > property_editable();
            Glib::PropertyProxy_ReadOnly< bool > property_editable() const;
            Glib::PropertyProxy< WrapMode > property_wrap_mode();
            Glib::PropertyProxy_ReadOnly< WrapMode > property_wrap_mode() const;
            Glib::PropertyProxy< Justification > property_justification();
            Glib::PropertyProxy_ReadOnly< Justification > property_justification() const;
            Glib::PropertyProxy< TextDirection > property_direction();
            Glib::PropertyProxy_ReadOnly< TextDirection > property_direction() const;
            Glib::PropertyProxy< int > property_left_margin();
            Glib::PropertyProxy_ReadOnly< int > property_left_margin() const;
            Glib::PropertyProxy< int > property_indent();
            Glib::PropertyProxy_ReadOnly< int > property_indent() const;
            Glib::PropertyProxy< bool > property_strikethrough();
            Glib::PropertyProxy_ReadOnly< bool > property_strikethrough() const;
            Glib::PropertyProxy< int > property_right_margin();
            Glib::PropertyProxy_ReadOnly< int > property_right_margin() const;
            Glib::PropertyProxy< Pango::Underline > property_underline();
            Glib::PropertyProxy_ReadOnly< Pango::Underline > property_underline() const;
            Glib::PropertyProxy< int > property_rise();
            Glib::PropertyProxy_ReadOnly< int > property_rise() const;
            Glib::PropertyProxy< bool > property_background_full_height();
            Glib::PropertyProxy_ReadOnly< bool > property_background_full_height() const;
            Glib::PropertyProxy< Glib::ustring > property_language();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_language() const;
            Glib::PropertyProxy< Pango::TabArray > property_tabs();
            Glib::PropertyProxy_ReadOnly< Pango::TabArray > property_tabs() const;
            Glib::PropertyProxy< bool > property_invisible();
            Glib::PropertyProxy_ReadOnly< bool > property_invisible() const;
            Glib::PropertyProxy_WriteOnly< Glib::ustring > property_paragraph_background();
            Glib::PropertyProxy< Gdk::Color > property_paragraph_background_gdk();
            Glib::PropertyProxy_ReadOnly< Gdk::Color > property_paragraph_background_gdk() const;
            Glib::PropertyProxy< bool > property_accumulative_margin();
            Glib::PropertyProxy_ReadOnly< bool > property_accumulative_margin() const;
            Glib::PropertyProxy< bool > property_background_set();
            Glib::PropertyProxy_ReadOnly< bool > property_background_set() const;
            Glib::PropertyProxy< bool > property_foreground_set();
            Glib::PropertyProxy_ReadOnly< bool > property_foreground_set() const;
            Glib::PropertyProxy< bool > property_background_stipple_set();
            Glib::PropertyProxy_ReadOnly< bool > property_background_stipple_set() const;
            Glib::PropertyProxy< bool > property_foreground_stipple_set();
            Glib::PropertyProxy_ReadOnly< bool > property_foreground_stipple_set() const;
            Glib::PropertyProxy< bool > property_family_set();
            Glib::PropertyProxy_ReadOnly< bool > property_family_set() const;
            Glib::PropertyProxy< bool > property_style_set();
            Glib::PropertyProxy_ReadOnly< bool > property_style_set() const;
            Glib::PropertyProxy< bool > property_variant_set();
            Glib::PropertyProxy_ReadOnly< bool > property_variant_set() const;
            Glib::PropertyProxy< bool > property_weight_set();
            Glib::PropertyProxy_ReadOnly< bool > property_weight_set() const;
            Glib::PropertyProxy< bool > property_stretch_set();
            Glib::PropertyProxy_ReadOnly< bool > property_stretch_set() const;
            Glib::PropertyProxy< bool > property_size_set();
            Glib::PropertyProxy_ReadOnly< bool > property_size_set() const;
            Glib::PropertyProxy< bool > property_scale_set();
            Glib::PropertyProxy_ReadOnly< bool > property_scale_set() const;
            Glib::PropertyProxy< bool > property_pixels_above_lines_set();
            Glib::PropertyProxy_ReadOnly< bool > property_pixels_above_lines_set() const;
            Glib::PropertyProxy< bool > property_pixels_below_lines_set();
            Glib::PropertyProxy_ReadOnly< bool > property_pixels_below_lines_set() const;
            Glib::PropertyProxy< bool > property_pixels_inside_wrap_set();
            Glib::PropertyProxy_ReadOnly< bool > property_pixels_inside_wrap_set() const;
            Glib::PropertyProxy< bool > property_editable_set();
            Glib::PropertyProxy_ReadOnly< bool > property_editable_set() const;
            Glib::PropertyProxy< bool > property_wrap_mode_set();
            Glib::PropertyProxy_ReadOnly< bool > property_wrap_mode_set() const;
            Glib::PropertyProxy< bool > property_justification_set();
            Glib::PropertyProxy_ReadOnly< bool > property_justification_set() const;
            Glib::PropertyProxy< bool > property_left_margin_set();
            Glib::PropertyProxy_ReadOnly< bool > property_left_margin_set() const;
            Glib::PropertyProxy< bool > property_indent_set();
            Glib::PropertyProxy_ReadOnly< bool > property_indent_set() const;
            Glib::PropertyProxy< bool > property_strikethrough_set();
            Glib::PropertyProxy_ReadOnly< bool > property_strikethrough_set() const;
            Glib::PropertyProxy< bool > property_right_margin_set();
            Glib::PropertyProxy_ReadOnly< bool > property_right_margin_set() const;
            Glib::PropertyProxy< bool > property_underline_set();
            Glib::PropertyProxy_ReadOnly< bool > property_underline_set() const;
            Glib::PropertyProxy< bool > property_rise_set();
            Glib::PropertyProxy_ReadOnly< bool > property_rise_set() const;
            Glib::PropertyProxy< bool > property_background_full_height_set();
            Glib::PropertyProxy_ReadOnly< bool > property_background_full_height_set() const;
            Glib::PropertyProxy< bool > property_language_set();
            Glib::PropertyProxy_ReadOnly< bool > property_language_set() const;
            Glib::PropertyProxy< bool > property_tabs_set();
            Glib::PropertyProxy_ReadOnly< bool > property_tabs_set() const;
            Glib::PropertyProxy< bool > property_invisible_set();
            Glib::PropertyProxy_ReadOnly< bool > property_invisible_set() const;
            Glib::PropertyProxy< bool > property_paragraph_background_set();
            Glib::PropertyProxy_ReadOnly< bool > property_paragraph_background_set() const;
        public :
        public :
        protected :
            virtual bool on_event(const Glib::RefPtr< Glib::Object > & event_object, GdkEvent * event, const TextIter & iter);
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::TextTag > wrap(GtkTextTag * object, bool take_copy = false);
}
typedef struct _GtkTextTagTable GtkTextTagTable;
typedef struct _GtkTextTagTableClass GtkTextTagTableClass;
namespace Gtk {
    class TextTagTable_Class;
}
namespace Gtk {
    class TextTag;
    class TextTagTable : public Glib::Object
    {
        public :
            typedef TextTagTable CppObjectType;
            typedef TextTagTable_Class CppClassType;
            typedef GtkTextTagTable BaseObjectType;
            typedef GtkTextTagTableClass BaseClassType;
        private :
            friend class TextTagTable_Class;
            static CppClassType texttagtable_class_;
        private :
            TextTagTable(const TextTagTable &);
            TextTagTable & operator =(const TextTagTable &);
        protected :
            explicit TextTagTable(const Glib::ConstructParams & construct_params);
            explicit TextTagTable(GtkTextTagTable * castitem);
        public :
            virtual ~TextTagTable();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTextTagTable * gobj()
            {
                return reinterpret_cast<GtkTextTagTable * >(gobject_);
            }
            const GtkTextTagTable * gobj() const
            {
                return reinterpret_cast<GtkTextTagTable * >(gobject_);
            }
            GtkTextTagTable * gobj_copy();
        private :
        protected :
            TextTagTable();
        public :
            static Glib::RefPtr< TextTagTable > create();
            void add(const Glib::RefPtr< TextTag > & tag);
            void remove(const Glib::RefPtr< TextTag > & tag);
            Glib::RefPtr< TextTag > lookup(const Glib::ustring & name);
            Glib::RefPtr< const TextTag > lookup(const Glib::ustring & name) const;
            typedef sigc::slot< void, const Glib::RefPtr< TextTag > & > SlotForEach;
            void foreach(const SlotForEach & slot);
            int get_size() const;
            Glib::SignalProxy2< void, const Glib::RefPtr< TextTag > &, bool > signal_tag_changed();
            Glib::SignalProxy1< void, const Glib::RefPtr< TextTag > & > signal_tag_added();
            Glib::SignalProxy1< void, const Glib::RefPtr< TextTag > & > signal_tag_removed();
        public :
        public :
        protected :
            virtual void on_tag_changed(const Glib::RefPtr< TextTag > & tag, bool size_changed);
            virtual void on_tag_added(const Glib::RefPtr< TextTag > & tag);
            virtual void on_tag_removed(const Glib::RefPtr< TextTag > & tag);
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::TextTagTable > wrap(GtkTextTagTable * object, bool take_copy = false);
}
typedef struct _GtkTextChildAnchor GtkTextChildAnchor;
typedef struct _GtkTextChildAnchorClass GtkTextChildAnchorClass;
namespace Gtk {
    class TextChildAnchor_Class;
}
namespace Gtk {
    class TextChildAnchor : public Glib::Object
    {
        public :
            typedef TextChildAnchor CppObjectType;
            typedef TextChildAnchor_Class CppClassType;
            typedef GtkTextChildAnchor BaseObjectType;
            typedef GtkTextChildAnchorClass BaseClassType;
        private :
            friend class TextChildAnchor_Class;
            static CppClassType textchildanchor_class_;
        private :
            TextChildAnchor(const TextChildAnchor &);
            TextChildAnchor & operator =(const TextChildAnchor &);
        protected :
            explicit TextChildAnchor(const Glib::ConstructParams & construct_params);
            explicit TextChildAnchor(GtkTextChildAnchor * castitem);
        public :
            virtual ~TextChildAnchor();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTextChildAnchor * gobj()
            {
                return reinterpret_cast<GtkTextChildAnchor * >(gobject_);
            }
            const GtkTextChildAnchor * gobj() const
            {
                return reinterpret_cast<GtkTextChildAnchor * >(gobject_);
            }
            GtkTextChildAnchor * gobj_copy();
        private :
        protected :
            TextChildAnchor();
        public :
            static Glib::RefPtr< TextChildAnchor > create();
            Glib::ListHandle< Widget * > get_widgets();
            Glib::ListHandle< const Widget * > get_widgets() const;
            bool get_deleted() const;
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::TextChildAnchor > wrap(GtkTextChildAnchor * object, bool take_copy = false);
}
typedef struct _GtkTextMark GtkTextMark;
typedef struct _GtkTextMarkClass GtkTextMarkClass;
namespace Gtk {
    class TextMark_Class;
}
namespace Gtk {
    class TextBuffer;
    class TextIter;
    class TextMark : public Glib::Object
    {
        public :
            typedef TextMark CppObjectType;
            typedef TextMark_Class CppClassType;
            typedef GtkTextMark BaseObjectType;
            typedef GtkTextMarkClass BaseClassType;
        private :
            friend class TextMark_Class;
            static CppClassType textmark_class_;
        private :
            TextMark(const TextMark &);
            TextMark & operator =(const TextMark &);
        protected :
            explicit TextMark(const Glib::ConstructParams & construct_params);
            explicit TextMark(GtkTextMark * castitem);
        public :
            virtual ~TextMark();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTextMark * gobj()
            {
                return reinterpret_cast<GtkTextMark * >(gobject_);
            }
            const GtkTextMark * gobj() const
            {
                return reinterpret_cast<GtkTextMark * >(gobject_);
            }
            GtkTextMark * gobj_copy();
        private :
        protected :
            explicit TextMark(bool left_gravity = true);
            explicit TextMark(const Glib::ustring & name, bool left_gravity = true);
        public :
            static Glib::RefPtr< TextMark > create(bool left_gravity = true);
            static Glib::RefPtr< TextMark > create(const Glib::ustring & name, bool left_gravity = true);
            void set_visible(bool setting = true);
            bool get_visible() const;
            Glib::ustring get_name() const;
            bool get_deleted() const;
            Glib::RefPtr< TextBuffer > get_buffer();
            Glib::RefPtr< const TextBuffer > get_buffer() const;
            bool get_left_gravity() const;
            TextIter get_iter();
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::TextMark > wrap(GtkTextMark * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkTextAttributes GtkTextAttributes;
}
namespace Gtk {
    class TextAttributes
    {
        public :
            typedef TextAttributes CppObjectType;
            typedef GtkTextAttributes BaseObjectType;
            static GType get_type() __attribute__((__const__));
            TextAttributes();
            explicit TextAttributes(GtkTextAttributes * gobject, bool make_a_copy = true);
            TextAttributes(const TextAttributes & other);
            TextAttributes & operator =(const TextAttributes & other);
            ~TextAttributes();
            void swap(TextAttributes & other);
            GtkTextAttributes * gobj()
            {
                return gobject_;
            }
            const GtkTextAttributes * gobj() const
            {
                return gobject_;
            }
            GtkTextAttributes * gobj_copy() const;
        protected :
            GtkTextAttributes * gobject_;
        private :
        public :
    };
}
namespace Gtk {
    inline void swap(TextAttributes & lhs, TextAttributes & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    Gtk::TextAttributes wrap(GtkTextAttributes * object, bool take_copy = false);
    template<>
    class Value< Gtk::TextAttributes > : public Glib::Value_Boxed< Gtk::TextAttributes >
    {
    };
}
namespace Gtk {
    enum TextSearchFlags
    {
        TEXT_SEARCH_VISIBLE_ONLY = 1 << 0, 
        TEXT_SEARCH_TEXT_ONLY = 1 << 1
    };
    inline TextSearchFlags operator |(TextSearchFlags lhs, TextSearchFlags rhs)
    {
        return static_cast<TextSearchFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline TextSearchFlags operator &(TextSearchFlags lhs, TextSearchFlags rhs)
    {
        return static_cast<TextSearchFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline TextSearchFlags operator ^(TextSearchFlags lhs, TextSearchFlags rhs)
    {
        return static_cast<TextSearchFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline TextSearchFlags operator ~(TextSearchFlags flags)
    {
        return static_cast<TextSearchFlags >(~static_cast<unsigned >(flags));
    }
    inline TextSearchFlags & operator |=(TextSearchFlags & lhs, TextSearchFlags rhs)
    {
        return (lhs = static_cast<TextSearchFlags >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline TextSearchFlags & operator &=(TextSearchFlags & lhs, TextSearchFlags rhs)
    {
        return (lhs = static_cast<TextSearchFlags >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline TextSearchFlags & operator ^=(TextSearchFlags & lhs, TextSearchFlags rhs)
    {
        return (lhs = static_cast<TextSearchFlags >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gtk::TextSearchFlags > : public Glib::Value_Flags< Gtk::TextSearchFlags >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class TextBuffer;
    class TextMark;
    class TextIter
    {
        public :
            typedef TextIter CppObjectType;
            typedef GtkTextIter BaseObjectType;
            static GType get_type() __attribute__((__const__));
            TextIter();
            explicit TextIter(const GtkTextIter * gobject);
            GtkTextIter * gobj()
            {
                return &gobject_;
            }
            const GtkTextIter * gobj() const
            {
                return &gobject_;
            }
        protected :
            GtkTextIter gobject_;
        private :
        public :
            typedef std::bidirectional_iterator_tag iterator_category;
            typedef gunichar value_type;
            typedef int difference_type;
            typedef value_type reference;
            typedef void pointer;
            inline TextIter & operator ++();
            inline const TextIter operator ++(int);
            inline TextIter & operator --();
            inline const TextIter operator --(int);
            inline value_type operator *() const;
            inline operator bool() const;
        protected :
            template<class Predicate >
            struct PredicateAdapter
            {
                    Predicate predicate_;
                    inline PredicateAdapter(const Predicate & predicate);
                    static gboolean gtk_callback(gunichar uc, void * user_data);
            };
            bool forward_find_char_impl(GtkTextCharPredicate predicate, void * user_data, const GtkTextIter * limit);
            bool backward_find_char_impl(GtkTextCharPredicate predicate, void * user_data, const GtkTextIter * limit);
        public :
            Glib::RefPtr< TextBuffer > get_buffer() const;
            int get_offset() const;
            int get_line() const;
            int get_line_offset() const;
            int get_line_index() const;
            int get_visible_line_offset() const;
            int get_visible_line_index() const;
            gunichar get_char() const;
            Glib::ustring get_slice(const TextIter & end) const;
            Glib::ustring get_text(const TextIter & end) const;
            Glib::ustring get_visible_slice(const TextIter & end) const;
            Glib::ustring get_visible_text(const TextIter & end) const;
            Glib::RefPtr< Gdk::Pixbuf > get_pixbuf() const;
            Glib::SListHandle< Glib::RefPtr< TextMark > > get_marks();
            Glib::SListHandle< Glib::RefPtr< const TextMark > > get_marks() const;
            Glib::RefPtr< TextChildAnchor > get_child_anchor();
            Glib::RefPtr< const TextChildAnchor > get_child_anchor() const;
            Glib::SListHandle< Glib::RefPtr< TextTag > > get_toggled_tags(bool toggled_on = true);
            Glib::SListHandle< Glib::RefPtr< const TextTag > > get_toggled_tags(bool toggled_on = true) const;
            bool begins_tag(const Glib::RefPtr< const TextTag > & tag) const;
            bool begins_tag() const;
            bool ends_tag(const Glib::RefPtr< const TextTag > & tag) const;
            bool ends_tag() const;
            bool toggles_tag(const Glib::RefPtr< const TextTag > & tag) const;
            bool toggles_tag() const;
            bool has_tag(const Glib::RefPtr< const TextTag > & tag) const;
            bool has_tag() const;
            Glib::SListHandle< Glib::RefPtr< TextTag > > get_tags();
            Glib::SListHandle< Glib::RefPtr< const TextTag > > get_tags() const;
            bool editable(bool default_setting = true) const;
            bool can_insert(bool default_editability = true) const;
            bool starts_word() const;
            bool ends_word() const;
            bool inside_word() const;
            bool starts_sentence() const;
            bool ends_sentence() const;
            bool inside_sentence() const;
            bool starts_line() const;
            bool ends_line() const;
            bool is_cursor_position() const;
            int get_chars_in_line() const;
            int get_bytes_in_line() const;
            bool get_attributes(TextAttributes & values) const;
            Pango::Language get_language() const;
            bool is_end() const;
            bool is_start() const;
            bool forward_char();
            bool backward_char();
            bool forward_chars(int count);
            bool backward_chars(int count);
            bool forward_line();
            bool backward_line();
            bool forward_lines(int count);
            bool backward_lines(int count);
            bool forward_word_end();
            bool backward_word_start();
            bool forward_word_ends(int count);
            bool backward_word_starts(int count);
            bool forward_visible_line();
            bool backward_visible_line();
            bool forward_visible_line(int count);
            bool backward_visible_lines(int count);
            bool forward_visible_word_end();
            bool backward_visible_word_start();
            bool forward_visible_word_ends(int count);
            bool backward_visible_word_starts(int count);
            bool forward_sentence_end();
            bool backward_sentence_start();
            bool forward_sentence_ends(int count);
            bool backward_sentence_starts(int count);
            bool forward_cursor_position();
            bool backward_cursor_position();
            bool forward_cursor_positions(int count);
            bool backward_cursor_positions(int count);
            bool forward_visible_cursor_position();
            bool backward_visible_cursor_position();
            bool forward_visible_cursor_positions(int count);
            bool backward_visible_cursor_positions(int count);
            void set_offset(int char_offset);
            void set_line(int line_number);
            void set_line_offset(int char_on_line);
            void set_line_index(int byte_on_line);
            void forward_to_end();
            bool forward_to_line_end();
            void set_visible_line_offset(int char_on_line);
            void set_visible_line_index(int byte_on_line);
            bool forward_to_tag_toggle(const Glib::RefPtr< TextTag > & tag);
            bool backward_to_tag_toggle(const Glib::RefPtr< TextTag > & tag);
            template<class Predicate >
            bool forward_find_char(const Predicate & predicate, const TextIter & limit);
            template<class Predicate >
            bool forward_find_char(const Predicate & predicate);
            template<class Predicate >
            bool backward_find_char(const Predicate & predicate, const TextIter & limit);
            template<class Predicate >
            bool backward_find_char(const Predicate & predicate);
            bool forward_search(const Glib::ustring & str, TextSearchFlags flags, TextIter & match_start, TextIter & match_end, const TextIter & limit) const;
            bool forward_search(const Glib::ustring & str, TextSearchFlags flags, TextIter & match_start, TextIter & match_end) const;
            bool backward_search(const Glib::ustring & str, TextSearchFlags flags, TextIter & match_start, TextIter & match_end, const TextIter & limit) const;
            bool backward_search(const Glib::ustring & str, TextSearchFlags flags, TextIter & match_start, TextIter & match_end) const;
            int compare(const TextIter & rhs) const;
            bool in_range(const TextIter & start, const TextIter & end) const;
            void order(TextIter & second);
    };
    template<class Predicate >
    inline TextIter::PredicateAdapter< Predicate >::PredicateAdapter(const Predicate & predicate)
        : predicate_(predicate) 
    {
    }
    template<class Predicate >
    gboolean TextIter::PredicateAdapter< Predicate >::gtk_callback(gunichar uc, void * user_data)
    {
        try
        {
            return (static_cast<TextIter::PredicateAdapter< Predicate > * >(user_data)->predicate_(uc)) ? 1 : 0;
        }
        catch (...)
        {
            Glib::exception_handlers_invoke();
            return 0;
        }
    }
    inline TextIter & TextIter::operator ++()
    {
        forward_char();
        return *this;
    }
    inline const TextIter TextIter::operator ++(int)
    {
        const TextIter temp(*this);
        forward_char();
        return temp;
    }
    inline TextIter & TextIter::operator --()
    {
        backward_char();
        return *this;
    }
    inline const TextIter TextIter::operator --(int)
    {
        const TextIter temp(*this);
        backward_char();
        return temp;
    }
    inline TextIter::value_type TextIter::operator *() const
    {
        return get_char();
    }
    inline TextIter::operator bool() const
    {
        return !is_end();
    }
    template<class Predicate >
    bool TextIter::forward_find_char(const Predicate & predicate, const TextIter & limit)
    {
        typedef TextIter::PredicateAdapter< Predicate > PredAdapter;
        PredAdapter adapter(predicate);
        return this->forward_find_char_impl(&PredAdapter::gtk_callback, &adapter, limit.gobj());
    }
    template<class Predicate >
    bool TextIter::forward_find_char(const Predicate & predicate)
    {
        typedef TextIter::PredicateAdapter< Predicate > PredAdapter;
        PredAdapter adapter(predicate);
        return this->forward_find_char_impl(&PredAdapter::gtk_callback, &adapter, 0);
    }
    template<class Predicate >
    bool TextIter::backward_find_char(const Predicate & predicate, const TextIter & limit)
    {
        typedef TextIter::PredicateAdapter< Predicate > PredAdapter;
        PredAdapter adapter(predicate);
        return this->backward_find_char_impl(&PredAdapter::gtk_callback, &adapter, limit.gobj());
    }
    template<class Predicate >
    bool TextIter::backward_find_char(const Predicate & predicate)
    {
        typedef TextIter::PredicateAdapter< Predicate > PredAdapter;
        PredAdapter adapter(predicate);
        return this->backward_find_char_impl(&PredAdapter::gtk_callback, &adapter, 0);
    }
}
namespace Gtk {
    bool operator ==(const TextIter & lhs, const TextIter & rhs);
    bool operator !=(const TextIter & lhs, const TextIter & rhs);
    bool operator <(const TextIter & lhs, const TextIter & rhs);
    bool operator >(const TextIter & lhs, const TextIter & rhs);
    bool operator <=(const TextIter & lhs, const TextIter & rhs);
    bool operator >=(const TextIter & lhs, const TextIter & rhs);
}
namespace Glib {
    Gtk::TextIter & wrap(GtkTextIter * object);
    const Gtk::TextIter & wrap(const GtkTextIter * object);
    template<>
    class Value< Gtk::TextIter > : public Glib::Value_Boxed< Gtk::TextIter >
    {
    };
}
typedef struct _GtkTextBuffer GtkTextBuffer;
typedef struct _GtkTextBufferClass GtkTextBufferClass;
namespace Gtk {
    class TextBuffer_Class;
}
namespace Gtk {
    class TextMark;
    class TextIter;
    class TextBuffer : public Glib::Object
    {
        public :
            typedef TextBuffer CppObjectType;
            typedef TextBuffer_Class CppClassType;
            typedef GtkTextBuffer BaseObjectType;
            typedef GtkTextBufferClass BaseClassType;
        private :
            friend class TextBuffer_Class;
            static CppClassType textbuffer_class_;
        private :
            TextBuffer(const TextBuffer &);
            TextBuffer & operator =(const TextBuffer &);
        protected :
            explicit TextBuffer(const Glib::ConstructParams & construct_params);
            explicit TextBuffer(GtkTextBuffer * castitem);
        public :
            virtual ~TextBuffer();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTextBuffer * gobj()
            {
                return reinterpret_cast<GtkTextBuffer * >(gobject_);
            }
            const GtkTextBuffer * gobj() const
            {
                return reinterpret_cast<GtkTextBuffer * >(gobject_);
            }
            GtkTextBuffer * gobj_copy();
        private :
        public :
            typedef TextIter iterator;
            typedef TextTag Tag;
            typedef TextTagTable TagTable;
            typedef TextMark Mark;
            typedef TextChildAnchor ChildAnchor;
        protected :
            TextBuffer();
            explicit TextBuffer(const Glib::RefPtr< TagTable > & tag_table);
        public :
            static Glib::RefPtr< TextBuffer > create();
            static Glib::RefPtr< TextBuffer > create(const Glib::RefPtr< TagTable > & tag_table);
            int get_line_count() const;
            int get_char_count() const;
            int size() const;
            Glib::RefPtr< TextBuffer::TagTable > get_tag_table();
            Glib::RefPtr< const TextBuffer::TagTable > get_tag_table() const;
            void set_text(const Glib::ustring & text);
            void set_text(const char * text_begin, const char * text_end);
            void assign(const Glib::ustring & text);
            void assign(const char * text_begin, const char * text_end);
            iterator insert(const iterator & pos, const Glib::ustring & text);
            iterator insert(const iterator & pos, const char * text_begin, const char * text_end);
            void insert_at_cursor(const Glib::ustring & text);
            void insert_at_cursor(const char * text_begin, const char * text_end);
            std::pair< iterator, bool > insert_interactive(const iterator & pos, const Glib::ustring & text, bool default_editable = true);
            std::pair< iterator, bool > insert_interactive(const iterator & pos, const char * text_begin, const char * text_end, bool default_editable = true);
            bool insert_interactive_at_cursor(const Glib::ustring & text, bool default_editable = true);
            bool insert_interactive_at_cursor(const char * text_begin, const char * text_end, bool default_editable = true);
            iterator insert(const iterator & pos, const iterator & range_begin, const iterator & range_end);
            std::pair< iterator, bool > insert_interactive(const iterator & pos, const iterator & range_begin, const iterator & range_end, bool default_editable = true);
            iterator insert_with_tag(const iterator & pos, const Glib::ustring & text, const Glib::RefPtr< Tag > & tag);
            iterator insert_with_tag(const iterator & pos, const char * text_begin, const char * text_end, const Glib::RefPtr< Tag > & tag);
            iterator insert_with_tag(const iterator & pos, const Glib::ustring & text, const Glib::ustring & tag_name);
            iterator insert_with_tag(const iterator & pos, const char * text_begin, const char * text_end, const Glib::ustring & tag_name);
            iterator insert_with_tags(const iterator & pos, const Glib::ustring & text, const Glib::ArrayHandle< Glib::RefPtr< Tag > > & tags);
            iterator insert_with_tags(const iterator & pos, const char * text_begin, const char * text_end, const Glib::ArrayHandle< Glib::RefPtr< Tag > > & tags);
            iterator insert_with_tags_by_name(const iterator & pos, const Glib::ustring & text, const Glib::StringArrayHandle & tag_names);
            iterator insert_with_tags_by_name(const iterator & pos, const char * text_begin, const char * text_end, const Glib::StringArrayHandle & tag_names);
            iterator erase(const iterator & range_begin, const iterator & range_end);
            std::pair< iterator, bool > erase_interactive(const iterator & range_begin, const iterator & range_end, bool default_editable = true);
            iterator backspace(const iterator & iter, bool interactive = true, bool default_editable = true);
            Glib::ustring get_text(const iterator & start, const iterator & end, bool include_hidden_chars = true);
            Glib::ustring get_text(const iterator & start, const iterator & end, bool include_hidden_chars = true) const;
            Glib::ustring get_text(bool include_hidden_chars = true);
            Glib::ustring get_text(bool include_hidden_chars = true) const;
            Glib::ustring get_slice(const iterator & start, const iterator & end, bool include_hidden_chars = true);
            Glib::ustring get_slice(const iterator & start, const iterator & end, bool include_hidden_chars = true) const;
            iterator insert_pixbuf(const iterator & pos, const Glib::RefPtr< Gdk::Pixbuf > & pixbuf);
            iterator insert_child_anchor(const iterator & pos, const Glib::RefPtr< ChildAnchor > & anchor);
            Glib::RefPtr< ChildAnchor > create_child_anchor(const iterator & pos);
            void add_mark(const Glib::RefPtr< TextBuffer::Mark > & mark, const iterator & where);
            Glib::RefPtr< TextBuffer::Mark > create_mark(const Glib::ustring & mark_name, const iterator & where, bool left_gravity = true);
            Glib::RefPtr< Mark > create_mark(const iterator & where, bool left_gravity = true);
            void move_mark(const Glib::RefPtr< Mark > & mark, const iterator & where);
            void delete_mark(const Glib::RefPtr< Mark > & mark);
            Glib::RefPtr< TextBuffer::Mark > get_mark(const Glib::ustring & name);
            Glib::RefPtr< const TextBuffer::Mark > get_mark(const Glib::ustring & name) const;
            void move_mark_by_name(const Glib::ustring & name, const iterator & where);
            void delete_mark_by_name(const Glib::ustring & name);
            Glib::RefPtr< TextBuffer::Mark > get_insert();
            Glib::RefPtr< TextBuffer::Mark > get_selection_bound();
            void place_cursor(const iterator & where);
            void apply_tag(const Glib::RefPtr< Tag > & tag, const iterator & start, const iterator & end);
            void remove_tag(const Glib::RefPtr< Tag > & tag, const iterator & start, const iterator & end);
            void apply_tag_by_name(const Glib::ustring & name, const iterator & start, const iterator & end);
            void remove_tag_by_name(const Glib::ustring & name, const iterator & start, const iterator & end);
            void remove_all_tags(const iterator & start, const iterator & end);
            Glib::RefPtr< Tag > create_tag(const Glib::ustring & tag_name);
            Glib::RefPtr< Tag > create_tag();
            iterator get_iter_at_line_offset(int line_number, int char_offset);
            iterator get_iter_at_line_index(int line_number, int byte_index);
            iterator get_iter_at_offset(int char_offset);
            iterator get_iter_at_line(int line_number);
            iterator begin();
            iterator end();
            void get_bounds(iterator & range_begin, iterator & range_end);
            iterator get_iter_at_mark(const Glib::RefPtr< Mark > & mark);
            iterator get_iter_at_child_anchor(const Glib::RefPtr< ChildAnchor > & anchor);
            bool get_modified() const;
            void set_modified(bool setting = true);
            bool get_has_selection() const;
            void add_selection_clipboard(const Glib::RefPtr< Clipboard > & clipboard);
            void remove_selection_clipboard(const Glib::RefPtr< Clipboard > & clipboard);
            void cut_clipboard(const Glib::RefPtr< Clipboard > & clipboard, bool default_editable = true);
            void copy_clipboard(const Glib::RefPtr< Clipboard > & clipboard);
            void paste_clipboard(const Glib::RefPtr< Clipboard > & clipboard, const iterator & override_location, bool default_editable = true);
            void paste_clipboard(const Glib::RefPtr< Clipboard > & clipboard, bool default_editable = true);
            bool get_selection_bounds(iterator & start, iterator & end) const;
            bool erase_selection(bool interactive = true, bool default_editable = true);
            void select_range(const iterator & ins, const iterator & bound);
            void begin_user_action();
            void end_user_action();
            Glib::ustring register_serialize_tagset(const Glib::ustring & tagset_name);
            Glib::ustring register_deserialize_tagset(const Glib::ustring & tagset_name);
            void unregister_serialize_format(const Glib::ustring & format);
            void unregister_deserialize_format(const Glib::ustring & format);
            void set_can_create_tags(const Glib::ustring & format, bool can_create_tags = true);
            bool get_can_create_tags(const Glib::ustring & format) const;
            Glib::StringArrayHandle get_serialize_formats() const;
            Glib::StringArrayHandle get_deserialize_formats() const;
            Glib::SignalProxy3< void, const TextBuffer::iterator &, const Glib::ustring &, int > signal_insert();
            Glib::SignalProxy2< void, const TextBuffer::iterator &, const Glib::RefPtr< Gdk::Pixbuf > & > signal_insert_pixbuf();
            Glib::SignalProxy2< void, const TextBuffer::iterator &, const Glib::RefPtr< ChildAnchor > & > signal_insert_child_anchor();
            Glib::SignalProxy2< void, const TextBuffer::iterator &, const TextBuffer::iterator & > signal_erase();
            Glib::SignalProxy0< void > signal_changed();
            Glib::SignalProxy0< void > signal_modified_changed();
            Glib::SignalProxy2< void, const TextBuffer::iterator &, const Glib::RefPtr< TextBuffer::Mark > & > signal_mark_set();
            Glib::SignalProxy1< void, const Glib::RefPtr< TextBuffer::Mark > & > signal_mark_deleted();
            Glib::SignalProxy3< void, const Glib::RefPtr< TextBuffer::Tag > &, const TextBuffer::iterator &, const TextBuffer::iterator & > signal_apply_tag();
            Glib::SignalProxy3< void, const Glib::RefPtr< TextBuffer::Tag > &, const TextBuffer::iterator &, const TextBuffer::iterator & > signal_remove_tag();
            Glib::SignalProxy0< void > signal_begin_user_action();
            Glib::SignalProxy0< void > signal_end_user_action();
            Glib::PropertyProxy< Glib::ustring > property_text();
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_text() const;
            Glib::PropertyProxy_ReadOnly< bool > property_has_selection() const;
            Glib::PropertyProxy_ReadOnly< int > property_cursor_position() const;
        public :
        public :
        protected :
            virtual void on_insert(const TextBuffer::iterator & pos, const Glib::ustring & text, int bytes);
            virtual void on_insert_pixbuf(const TextBuffer::iterator & pos, const Glib::RefPtr< Gdk::Pixbuf > & pixbuf);
            virtual void on_insert_child_anchor(const TextBuffer::iterator & pos, const Glib::RefPtr< ChildAnchor > & anchor);
            virtual void on_erase(const TextBuffer::iterator & start, const TextBuffer::iterator & end);
            virtual void on_changed();
            virtual void on_modified_changed();
            virtual void on_mark_set(const TextBuffer::iterator & location, const Glib::RefPtr< TextBuffer::Mark > & mark);
            virtual void on_mark_deleted(const Glib::RefPtr< TextBuffer::Mark > & mark);
            virtual void on_apply_tag(const Glib::RefPtr< TextBuffer::Tag > & tag, const TextBuffer::iterator & range_begin, const TextBuffer::iterator & range_end);
            virtual void on_remove_tag(const Glib::RefPtr< TextBuffer::Tag > & tag, const TextBuffer::iterator & range_begin, const TextBuffer::iterator & range_end);
            virtual void on_begin_user_action();
            virtual void on_end_user_action();
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::TextBuffer > wrap(GtkTextBuffer * object, bool take_copy = false);
}
typedef struct _GtkTextView GtkTextView;
typedef struct _GtkTextViewClass GtkTextViewClass;
namespace Gtk {
    class TextView_Class;
}
namespace Gtk {
    enum TextWindowType
    {
        TEXT_WINDOW_PRIVATE, 
        TEXT_WINDOW_WIDGET, 
        TEXT_WINDOW_TEXT, 
        TEXT_WINDOW_LEFT, 
        TEXT_WINDOW_RIGHT, 
        TEXT_WINDOW_TOP, 
        TEXT_WINDOW_BOTTOM
    };
}
namespace Glib {
    template<>
    class Value< Gtk::TextWindowType > : public Glib::Value_Enum< Gtk::TextWindowType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class TextView : public Container
    {
        public :
            typedef TextView CppObjectType;
            typedef TextView_Class CppClassType;
            typedef GtkTextView BaseObjectType;
            typedef GtkTextViewClass BaseClassType;
            virtual ~TextView();
        private :
            friend class TextView_Class;
            static CppClassType textview_class_;
            TextView(const TextView &);
            TextView & operator =(const TextView &);
        protected :
            explicit TextView(const Glib::ConstructParams & construct_params);
            explicit TextView(GtkTextView * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTextView * gobj()
            {
                return reinterpret_cast<GtkTextView * >(gobject_);
            }
            const GtkTextView * gobj() const
            {
                return reinterpret_cast<GtkTextView * >(gobject_);
            }
        public :
        protected :
            virtual void on_set_scroll_adjustments(Adjustment * hadjustment, Adjustment * vadjustment);
            virtual void on_populate_popup(Menu * menu);
            virtual void on_set_anchor();
            virtual void on_insert_at_cursor(const Glib::ustring & str);
        private :
        public :
            TextView();
            explicit TextView(const Glib::RefPtr< TextBuffer > & buffer);
            void set_buffer(const Glib::RefPtr< TextBuffer > & buffer);
            Glib::RefPtr< TextBuffer > get_buffer();
            Glib::RefPtr< const TextBuffer > get_buffer() const;
            bool scroll_to_iter(TextBuffer::iterator & iter, double within_margin);
            void scroll_to_mark(const Glib::RefPtr< TextBuffer::Mark > & mark, double within_margin);
            void scroll_mark_onscreen(const Glib::RefPtr< TextBuffer::Mark > & mark);
            bool scroll_to(TextBuffer::iterator & iter, double within_margin = 0);
            bool scroll_to(TextBuffer::iterator & iter, double within_margin, double xalign, double yalign);
            void scroll_to(const Glib::RefPtr< TextBuffer::Mark > & mark, double within_margin = 0);
            void scroll_to(const Glib::RefPtr< TextBuffer::Mark > & mark, double within_margin, double xalign, double yalign);
            bool move_mark_onscreen(const Glib::RefPtr< TextBuffer::Mark > & mark);
            bool place_cursor_onscreen();
            void get_visible_rect(Gdk::Rectangle & visible_rect) const;
            void set_cursor_visible(bool setting = true);
            bool get_cursor_visible() const;
            void get_iter_location(const TextBuffer::iterator & iter, Gdk::Rectangle & location) const;
            void get_iter_at_location(TextBuffer::iterator & iter, int x, int y) const;
            void get_iter_at_position(TextBuffer::iterator & iter, int & trailing, int x, int y) const;
            void get_line_yrange(const TextBuffer::iterator & iter, int & y, int & height) const;
            void get_line_at_y(TextBuffer::iterator & target_iter, int y, int & line_top) const;
            void buffer_to_window_coords(TextWindowType win, int buffer_x, int buffer_y, int & window_x, int & window_y) const;
            void window_to_buffer_coords(TextWindowType win, int window_x, int window_y, int & buffer_x, int & buffer_y) const;
            Glib::RefPtr< Gdk::Window > get_window(TextWindowType win);
            Glib::RefPtr< const Gdk::Window > get_window(TextWindowType win) const;
            TextWindowType get_window_type(const Glib::RefPtr< Gdk::Window > & window);
            void set_border_window_size(TextWindowType type, int size);
            int get_border_window_size(TextWindowType type) const;
            bool forward_display_line(TextBuffer::iterator & iter);
            bool backward_display_line(TextBuffer::iterator & iter);
            bool forward_display_line_end(TextBuffer::iterator & iter);
            bool backward_display_line_start(TextBuffer::iterator & iter);
            bool starts_display_line(const TextBuffer::iterator & iter);
            bool move_visually(TextBuffer::iterator & iter, int count);
            void add_child_at_anchor(Widget & child, const Glib::RefPtr< TextBuffer::ChildAnchor > & anchor);
            void add_child_in_window(Widget & child, TextWindowType which_window, int xpos, int ypos);
            void move_child(Widget & child, int xpos, int ypos);
            void set_wrap_mode(WrapMode wrap_mode);
            WrapMode get_wrap_mode() const;
            void set_editable(bool setting = true);
            bool get_editable() const;
            void set_pixels_above_lines(int pixels_above_lines);
            int get_pixels_above_lines() const;
            void set_pixels_below_lines(int pixels_below_lines);
            int get_pixels_below_lines() const;
            void set_pixels_inside_wrap(int pixels_inside_wrap);
            int get_pixels_inside_wrap() const;
            void set_justification(Justification justification);
            Justification get_justification() const;
            void set_left_margin(int left_margin);
            int get_left_margin() const;
            void set_right_margin(int right_margin);
            int get_right_margin() const;
            void set_indent(int indent);
            int get_indent() const;
            void set_tabs(Pango::TabArray & tabs);
            Pango::TabArray get_tabs() const;
            TextAttributes get_default_attributes() const;
            void set_overwrite(bool overwrite = true);
            bool get_overwrite() const;
            void set_accepts_tab(bool accepts_tab = true);
            bool get_accepts_tab() const;
            Glib::SignalProxy2< void, Adjustment *, Adjustment * > signal_set_scroll_adjustments();
            Glib::SignalProxy1< void, Menu * > signal_populate_popup();
            Glib::SignalProxy0< void > signal_set_anchor();
            Glib::SignalProxy1< void, const Glib::ustring & > signal_insert_at_cursor();
            Glib::PropertyProxy< int > property_pixels_above_lines();
            Glib::PropertyProxy_ReadOnly< int > property_pixels_above_lines() const;
            Glib::PropertyProxy< int > property_pixels_below_lines();
            Glib::PropertyProxy_ReadOnly< int > property_pixels_below_lines() const;
            Glib::PropertyProxy< int > property_pixels_inside_wrap();
            Glib::PropertyProxy_ReadOnly< int > property_pixels_inside_wrap() const;
            Glib::PropertyProxy< bool > property_editable();
            Glib::PropertyProxy_ReadOnly< bool > property_editable() const;
            Glib::PropertyProxy< WrapMode > property_wrap_mode();
            Glib::PropertyProxy_ReadOnly< WrapMode > property_wrap_mode() const;
            Glib::PropertyProxy< Justification > property_justification();
            Glib::PropertyProxy_ReadOnly< Justification > property_justification() const;
            Glib::PropertyProxy< int > property_left_margin();
            Glib::PropertyProxy_ReadOnly< int > property_left_margin() const;
            Glib::PropertyProxy< int > property_right_margin();
            Glib::PropertyProxy_ReadOnly< int > property_right_margin() const;
            Glib::PropertyProxy< int > property_indent();
            Glib::PropertyProxy_ReadOnly< int > property_indent() const;
            Glib::PropertyProxy< Pango::TabArray > property_tabs();
            Glib::PropertyProxy_ReadOnly< Pango::TabArray > property_tabs() const;
            Glib::PropertyProxy< bool > property_cursor_visible();
            Glib::PropertyProxy_ReadOnly< bool > property_cursor_visible() const;
            Glib::PropertyProxy< Glib::RefPtr< TextBuffer > > property_buffer();
            Glib::PropertyProxy_ReadOnly< Glib::RefPtr< TextBuffer > > property_buffer() const;
            Glib::PropertyProxy< bool > property_overwrite();
            Glib::PropertyProxy_ReadOnly< bool > property_overwrite() const;
            Glib::PropertyProxy< bool > property_accepts_tab();
            Glib::PropertyProxy_ReadOnly< bool > property_accepts_tab() const;
    };
}
namespace Glib {
    Gtk::TextView * wrap(GtkTextView * object, bool take_copy = false);
}
typedef struct _GtkMenuToolButton GtkMenuToolButton;
typedef struct _GtkMenuToolButtonClass GtkMenuToolButtonClass;
namespace Gtk {
    class MenuToolButton_Class;
}
namespace Gtk {
    class MenuToolButton : public ToolButton
    {
        public :
            typedef MenuToolButton CppObjectType;
            typedef MenuToolButton_Class CppClassType;
            typedef GtkMenuToolButton BaseObjectType;
            typedef GtkMenuToolButtonClass BaseClassType;
            virtual ~MenuToolButton();
        private :
            friend class MenuToolButton_Class;
            static CppClassType menutoolbutton_class_;
            MenuToolButton(const MenuToolButton &);
            MenuToolButton & operator =(const MenuToolButton &);
        protected :
            explicit MenuToolButton(const Glib::ConstructParams & construct_params);
            explicit MenuToolButton(GtkMenuToolButton * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkMenuToolButton * gobj()
            {
                return reinterpret_cast<GtkMenuToolButton * >(gobject_);
            }
            const GtkMenuToolButton * gobj() const
            {
                return reinterpret_cast<GtkMenuToolButton * >(gobject_);
            }
        public :
        protected :
            virtual void on_show_menu();
        private :
        public :
            MenuToolButton();
            explicit MenuToolButton(const Gtk::StockID & stock_id);
            explicit MenuToolButton(const Glib::ustring & label);
            explicit MenuToolButton(Widget & icon_widget, const Glib::ustring & label = Glib::ustring());
            void set_menu(Menu & menu);
            Menu * get_menu();
            const Menu * get_menu() const;
            void set_arrow_tooltip(Tooltips & tooltips, const Glib::ustring & tip_text, const Glib::ustring & tip_private);
            void set_arrow_tooltip_text(const Glib::ustring & text);
            void set_arrow_tooltip_markup(const Glib::ustring & markup);
            Glib::SignalProxy0< void > signal_show_menu();
            Glib::PropertyProxy< Menu * > property_menu();
            Glib::PropertyProxy_ReadOnly< Menu * > property_menu() const;
    };
}
namespace Glib {
    Gtk::MenuToolButton * wrap(GtkMenuToolButton * object, bool take_copy = false);
}
typedef struct _GtkTreeModelFilter GtkTreeModelFilter;
typedef struct _GtkTreeModelFilterClass GtkTreeModelFilterClass;
namespace Gtk {
    class TreeModelFilter_Class;
}
namespace Gtk {
    class TreeModelFilter : public Glib::Object, public TreeModel
    {
        public :
            typedef TreeModelFilter CppObjectType;
            typedef TreeModelFilter_Class CppClassType;
            typedef GtkTreeModelFilter BaseObjectType;
            typedef GtkTreeModelFilterClass BaseClassType;
        private :
            friend class TreeModelFilter_Class;
            static CppClassType treemodelfilter_class_;
        private :
            TreeModelFilter(const TreeModelFilter &);
            TreeModelFilter & operator =(const TreeModelFilter &);
        protected :
            explicit TreeModelFilter(const Glib::ConstructParams & construct_params);
            explicit TreeModelFilter(GtkTreeModelFilter * castitem);
        public :
            virtual ~TreeModelFilter();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTreeModelFilter * gobj()
            {
                return reinterpret_cast<GtkTreeModelFilter * >(gobject_);
            }
            const GtkTreeModelFilter * gobj() const
            {
                return reinterpret_cast<GtkTreeModelFilter * >(gobject_);
            }
            GtkTreeModelFilter * gobj_copy();
        private :
        protected :
            explicit TreeModelFilter(const Glib::RefPtr< TreeModel > & child_model);
            explicit TreeModelFilter(const Glib::RefPtr< TreeModel > & child_model, const TreeModel::Path & virtual_root);
        public :
            static Glib::RefPtr< TreeModelFilter > create(const Glib::RefPtr< TreeModel > & child_model);
            static Glib::RefPtr< TreeModelFilter > create(const Glib::RefPtr< TreeModel > & child_model, const TreeModel::Path & virtual_root);
            typedef sigc::slot< bool, const TreeModel::const_iterator & > SlotVisible;
            void set_visible_func(const SlotVisible & slot);
            typedef sigc::slot< void, const Gtk::TreeModel::iterator &, Glib::ValueBase &, int > SlotModify;
            void set_modify_func(const TreeModelColumnRecord & columns, const SlotModify & slot);
            void set_visible_column(const TreeModelColumnBase & column);
            void set_visible_column(int column);
            Glib::RefPtr< TreeModel > get_model();
            Glib::RefPtr< const TreeModel > get_model() const;
            iterator convert_child_iter_to_iter(const iterator & child_iter) const;
            iterator convert_iter_to_child_iter(const iterator & filter_iter) const;
            Path convert_child_path_to_path(const Path & child_path);
            Path convert_path_to_child_path(const Path & filter_path);
            Path convert_child_path_to_path(const Path & child_path) const;
            Path convert_path_to_child_path(const Path & filter_path) const;
            void refilter();
            void clear_cache();
        protected :
            virtual void set_value_impl(const iterator & row, int column, const Glib::ValueBase & value);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::TreeModelFilter > wrap(GtkTreeModelFilter * object, bool take_copy = false);
}
typedef struct _GtkTreeModelSort GtkTreeModelSort;
typedef struct _GtkTreeModelSortClass GtkTreeModelSortClass;
namespace Gtk {
    class TreeModelSort_Class;
}
namespace Gtk {
    class TreeModelSort : public Glib::Object, public TreeModel, public TreeSortable
    {
        public :
            typedef TreeModelSort CppObjectType;
            typedef TreeModelSort_Class CppClassType;
            typedef GtkTreeModelSort BaseObjectType;
            typedef GtkTreeModelSortClass BaseClassType;
        private :
            friend class TreeModelSort_Class;
            static CppClassType treemodelsort_class_;
        private :
            TreeModelSort(const TreeModelSort &);
            TreeModelSort & operator =(const TreeModelSort &);
        protected :
            explicit TreeModelSort(const Glib::ConstructParams & construct_params);
            explicit TreeModelSort(GtkTreeModelSort * castitem);
        public :
            virtual ~TreeModelSort();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTreeModelSort * gobj()
            {
                return reinterpret_cast<GtkTreeModelSort * >(gobject_);
            }
            const GtkTreeModelSort * gobj() const
            {
                return reinterpret_cast<GtkTreeModelSort * >(gobject_);
            }
            GtkTreeModelSort * gobj_copy();
        private :
        protected :
            explicit TreeModelSort(const Glib::RefPtr< TreeModel > & model);
        public :
            static Glib::RefPtr< TreeModelSort > create(const Glib::RefPtr< TreeModel > & model);
            Glib::RefPtr< TreeModel > get_model();
            Glib::RefPtr< const TreeModel > get_model() const;
            Path convert_child_path_to_path(const Path & child_path) const;
            iterator convert_child_iter_to_iter(const iterator & child_iter) const;
            Path convert_path_to_child_path(const Path & sorted_path) const;
            iterator convert_iter_to_child_iter(const iterator & sorted_iter) const;
            void reset_default_sort_func();
            void clear_cache();
            bool iter_is_valid(const iterator & iter) const;
        protected :
            virtual void set_value_impl(const iterator & row, int column, const Glib::ValueBase & value);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::TreeModelSort > wrap(GtkTreeModelSort * object, bool take_copy = false);
}
extern "C"
{
    typedef struct _GtkTreeRowReference GtkTreeRowReference;
}
namespace Gtk {
    class TreeRowReference
    {
        public :
            typedef TreeRowReference CppObjectType;
            typedef GtkTreeRowReference BaseObjectType;
            static GType get_type() __attribute__((__const__));
            TreeRowReference();
            explicit TreeRowReference(GtkTreeRowReference * gobject, bool make_a_copy = true);
            TreeRowReference(const TreeRowReference & other);
            TreeRowReference & operator =(const TreeRowReference & other);
            ~TreeRowReference();
            void swap(TreeRowReference & other);
            GtkTreeRowReference * gobj()
            {
                return gobject_;
            }
            const GtkTreeRowReference * gobj() const
            {
                return gobject_;
            }
            GtkTreeRowReference * gobj_copy() const;
        protected :
            GtkTreeRowReference * gobject_;
        private :
        public :
            TreeRowReference(const Glib::RefPtr< TreeModel > & model, const TreeModel::Path & path);
            operator bool() const;
            TreeModel::Path get_path() const;
            Glib::RefPtr< TreeModel > get_model();
            Glib::RefPtr< const TreeModel > get_model() const;
            bool is_valid() const;
    };
}
namespace Gtk {
    inline void swap(TreeRowReference & lhs, TreeRowReference & rhs)
    {
        lhs.swap(rhs);
    }
}
namespace Glib {
    Gtk::TreeRowReference wrap(GtkTreeRowReference * object, bool take_copy = false);
    template<>
    class Value< Gtk::TreeRowReference > : public Glib::Value_Boxed< Gtk::TreeRowReference >
    {
    };
}
typedef struct _GtkTreeStore GtkTreeStore;
typedef struct _GtkTreeStoreClass GtkTreeStoreClass;
namespace Gtk {
    class TreeStore_Class;
}
namespace Gtk {
    class TreeStore : public Glib::Object, public Gtk::TreeModel, public TreeSortable, public TreeDragSource, public TreeDragDest
    {
        public :
            typedef TreeStore CppObjectType;
            typedef TreeStore_Class CppClassType;
            typedef GtkTreeStore BaseObjectType;
            typedef GtkTreeStoreClass BaseClassType;
        private :
            friend class TreeStore_Class;
            static CppClassType treestore_class_;
        private :
            TreeStore(const TreeStore &);
            TreeStore & operator =(const TreeStore &);
        protected :
            explicit TreeStore(const Glib::ConstructParams & construct_params);
            explicit TreeStore(GtkTreeStore * castitem);
        public :
            virtual ~TreeStore();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkTreeStore * gobj()
            {
                return reinterpret_cast<GtkTreeStore * >(gobject_);
            }
            const GtkTreeStore * gobj() const
            {
                return reinterpret_cast<GtkTreeStore * >(gobject_);
            }
            GtkTreeStore * gobj_copy();
        private :
        protected :
            TreeStore();
            explicit TreeStore(const TreeModelColumnRecord & columns);
        public :
            static Glib::RefPtr< TreeStore > create(const TreeModelColumnRecord & columns);
            void set_column_types(const TreeModelColumnRecord & columns);
            iterator erase(const iterator & iter);
            iterator insert(const iterator & iter);
            iterator insert_after(const iterator & iter);
            iterator prepend();
            iterator prepend(const TreeNodeChildren & node);
            iterator append();
            iterator append(const TreeNodeChildren & node);
            void iter_swap(const iterator & a, const iterator & b);
            void move(const iterator & source, const iterator & destination);
            void reorder(const TreeNodeChildren & node, const Glib::ArrayHandle< int > & new_order);
            void clear();
            bool is_ancestor(const iterator & iter, const iterator & descendant) const;
            int iter_depth(const iterator & iter) const;
            bool iter_is_valid(const iterator & iter) const;
        protected :
            virtual void set_value_impl(const iterator & row, int column, const Glib::ValueBase & value);
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::TreeStore > wrap(GtkTreeStore * object, bool take_copy = false);
}
typedef struct _GtkActionGroup GtkActionGroup;
typedef struct _GtkActionGroupClass GtkActionGroupClass;
namespace Gtk {
    class ActionGroup_Class;
}
namespace Gtk {
    class ActionGroup : public Glib::Object
    {
        public :
            typedef ActionGroup CppObjectType;
            typedef ActionGroup_Class CppClassType;
            typedef GtkActionGroup BaseObjectType;
            typedef GtkActionGroupClass BaseClassType;
        private :
            friend class ActionGroup_Class;
            static CppClassType actiongroup_class_;
        private :
            ActionGroup(const ActionGroup &);
            ActionGroup & operator =(const ActionGroup &);
        protected :
            explicit ActionGroup(const Glib::ConstructParams & construct_params);
            explicit ActionGroup(GtkActionGroup * castitem);
        public :
            virtual ~ActionGroup();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkActionGroup * gobj()
            {
                return reinterpret_cast<GtkActionGroup * >(gobject_);
            }
            const GtkActionGroup * gobj() const
            {
                return reinterpret_cast<GtkActionGroup * >(gobject_);
            }
            GtkActionGroup * gobj_copy();
        private :
        protected :
            explicit ActionGroup(const Glib::ustring & name = Glib::ustring());
        public :
            static Glib::RefPtr< ActionGroup > create(const Glib::ustring & name = Glib::ustring());
            Glib::ustring get_name() const;
            bool get_sensitive() const;
            void set_sensitive(bool sensitive = true);
            bool get_visible() const;
            void set_visible(bool visible = true);
            Glib::RefPtr< Action > get_action(const Glib::ustring & action_name);
            Glib::RefPtr< const Action > get_action(const Glib::ustring & action_name) const;
            Glib::ListHandle< Glib::RefPtr< Action > > get_actions();
            Glib::ListHandle< Glib::RefPtr< const Action > > get_actions() const;
            void add(const Glib::RefPtr< Action > & action);
            void add(const Glib::RefPtr< Action > & action, const AccelKey & accel_key);
            void add(const Glib::RefPtr< Action > & action, const Action::SlotActivate & slot);
            void add(const Glib::RefPtr< Action > & action, const AccelKey & accel_key, const Action::SlotActivate & slot);
            void remove(const Glib::RefPtr< Action > & action);
            Glib::ustring translate_string(const Glib::ustring & str) const;
            Glib::SignalProxy2< void, const Glib::RefPtr< Action > &, Widget * > signal_connect_proxy();
            Glib::SignalProxy2< void, const Glib::RefPtr< Action > &, Widget * > signal_disconnect_proxy();
            Glib::SignalProxy1< void, const Glib::RefPtr< Action > & > signal_pre_activate();
            Glib::SignalProxy1< void, const Glib::RefPtr< Action > & > signal_post_activate();
        public :
        public :
        protected :
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::ActionGroup > wrap(GtkActionGroup * object, bool take_copy = false);
}
typedef struct _GtkUIManager GtkUIManager;
typedef struct _GtkUIManagerClass GtkUIManagerClass;
namespace Gtk {
    class UIManager_Class;
}
namespace Gtk {
    enum UIManagerItemType
    {
        UI_MANAGER_AUTO = 0, 
        UI_MANAGER_MENUBAR = 1 << 0, 
        UI_MANAGER_MENU = 1 << 1, 
        UI_MANAGER_TOOLBAR = 1 << 2, 
        UI_MANAGER_PLACEHOLDER = 1 << 3, 
        UI_MANAGER_POPUP = 1 << 4, 
        UI_MANAGER_MENUITEM = 1 << 5, 
        UI_MANAGER_TOOLITEM = 1 << 6, 
        UI_MANAGER_SEPARATOR = 1 << 7, 
        UI_MANAGER_ACCELERATOR = 1 << 8
    };
    inline UIManagerItemType operator |(UIManagerItemType lhs, UIManagerItemType rhs)
    {
        return static_cast<UIManagerItemType >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs));
    }
    inline UIManagerItemType operator &(UIManagerItemType lhs, UIManagerItemType rhs)
    {
        return static_cast<UIManagerItemType >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs));
    }
    inline UIManagerItemType operator ^(UIManagerItemType lhs, UIManagerItemType rhs)
    {
        return static_cast<UIManagerItemType >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs));
    }
    inline UIManagerItemType operator ~(UIManagerItemType flags)
    {
        return static_cast<UIManagerItemType >(~static_cast<unsigned >(flags));
    }
    inline UIManagerItemType & operator |=(UIManagerItemType & lhs, UIManagerItemType rhs)
    {
        return (lhs = static_cast<UIManagerItemType >(static_cast<unsigned >(lhs) | static_cast<unsigned >(rhs)));
    }
    inline UIManagerItemType & operator &=(UIManagerItemType & lhs, UIManagerItemType rhs)
    {
        return (lhs = static_cast<UIManagerItemType >(static_cast<unsigned >(lhs) & static_cast<unsigned >(rhs)));
    }
    inline UIManagerItemType & operator ^=(UIManagerItemType & lhs, UIManagerItemType rhs)
    {
        return (lhs = static_cast<UIManagerItemType >(static_cast<unsigned >(lhs) ^ static_cast<unsigned >(rhs)));
    }
}
namespace Glib {
    template<>
    class Value< Gtk::UIManagerItemType > : public Glib::Value_Flags< Gtk::UIManagerItemType >
    {
        public :
            static GType value_type() __attribute__((__const__));
    };
}
namespace Gtk {
    class UIManager : public Glib::Object
    {
        public :
            typedef UIManager CppObjectType;
            typedef UIManager_Class CppClassType;
            typedef GtkUIManager BaseObjectType;
            typedef GtkUIManagerClass BaseClassType;
        private :
            friend class UIManager_Class;
            static CppClassType uimanager_class_;
        private :
            UIManager(const UIManager &);
            UIManager & operator =(const UIManager &);
        protected :
            explicit UIManager(const Glib::ConstructParams & construct_params);
            explicit UIManager(GtkUIManager * castitem);
        public :
            virtual ~UIManager();
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkUIManager * gobj()
            {
                return reinterpret_cast<GtkUIManager * >(gobject_);
            }
            const GtkUIManager * gobj() const
            {
                return reinterpret_cast<GtkUIManager * >(gobject_);
            }
            GtkUIManager * gobj_copy();
        private :
        protected :
            UIManager();
        public :
            static Glib::RefPtr< UIManager > create();
            void set_add_tearoffs(bool add_tearoffs = true);
            bool get_add_tearoffs() const;
            void insert_action_group(const Glib::RefPtr< ActionGroup > & action_group, int pos = 0);
            void remove_action_group(const Glib::RefPtr< ActionGroup > & action_group);
            Glib::ListHandle< Glib::RefPtr< ActionGroup > > get_action_groups();
            Glib::ListHandle< Glib::RefPtr< const ActionGroup > > get_action_groups() const;
            Glib::RefPtr< AccelGroup > get_accel_group();
            Glib::RefPtr< const AccelGroup > get_accel_group() const;
            Widget * get_widget(const Glib::ustring & path);
            const Widget * get_widget(const Glib::ustring & path) const;
            Glib::SListHandle< Widget * > get_toplevels(UIManagerItemType types);
            Glib::SListHandle< const Widget * > get_toplevels(UIManagerItemType types) const;
            Glib::RefPtr< Action > get_action(const Glib::ustring & path);
            Glib::RefPtr< const Action > get_action(const Glib::ustring & path) const;
            typedef guint ui_merge_id;
            ui_merge_id add_ui_from_string(const Glib::ustring & buffer);
            ui_merge_id add_ui_from_file(const Glib::ustring & filename);
            void add_ui(ui_merge_id merge_id, const Glib::ustring & path, const Glib::ustring & name, const Glib::ustring & action, UIManagerItemType type = Gtk::UI_MANAGER_AUTO, bool top = true);
            void add_ui_separator(ui_merge_id merge_id, const Glib::ustring & path, const Glib::ustring & name = "", UIManagerItemType type = Gtk::UI_MANAGER_AUTO, bool top = true);
            void remove_ui(ui_merge_id merge_id);
            Glib::ustring get_ui() const;
            void ensure_update();
            ui_merge_id new_merge_id();
            Glib::SignalProxy1< void, Widget * > signal_add_widget();
            Glib::SignalProxy0< void > signal_actions_changed();
            Glib::SignalProxy2< void, const Glib::RefPtr< Action > &, Widget * > signal_connect_proxy();
            Glib::SignalProxy2< void, const Glib::RefPtr< Action > &, Widget * > signal_disconnect_proxy();
            Glib::SignalProxy1< void, const Glib::RefPtr< Action > & > signal_pre_activate();
            Glib::SignalProxy1< void, const Glib::RefPtr< Action > & > signal_post_activate();
            Glib::PropertyProxy< bool > property_add_tearoffs();
            Glib::PropertyProxy_ReadOnly< bool > property_add_tearoffs() const;
            Glib::PropertyProxy_ReadOnly< Glib::ustring > property_ui() const;
        public :
        public :
        protected :
            virtual void on_add_widget(Widget * widget);
            virtual void on_actions_changed();
    };
}
namespace Glib {
    Glib::RefPtr< Gtk::UIManager > wrap(GtkUIManager * object, bool take_copy = false);
}
typedef struct _GtkViewport GtkViewport;
typedef struct _GtkViewportClass GtkViewportClass;
namespace Gtk {
    class Viewport_Class;
}
namespace Gtk {
    class Adjustment;
    class Viewport : public Bin
    {
        public :
            typedef Viewport CppObjectType;
            typedef Viewport_Class CppClassType;
            typedef GtkViewport BaseObjectType;
            typedef GtkViewportClass BaseClassType;
            virtual ~Viewport();
        private :
            friend class Viewport_Class;
            static CppClassType viewport_class_;
            Viewport(const Viewport &);
            Viewport & operator =(const Viewport &);
        protected :
            explicit Viewport(const Glib::ConstructParams & construct_params);
            explicit Viewport(GtkViewport * castitem);
        public :
            static GType get_type() __attribute__((__const__));
            static GType get_base_type() __attribute__((__const__));
            GtkViewport * gobj()
            {
                return reinterpret_cast<GtkViewport * >(gobject_);
            }
            const GtkViewport * gobj() const
            {
                return reinterpret_cast<GtkViewport * >(gobject_);
            }
        public :
        protected :
            virtual void on_set_scroll_adjustments(Gtk::Adjustment * hadjustment, Gtk::Adjustment * vadjustment);
        private :
        public :
            explicit Viewport(Adjustment & hadjustment, Adjustment & vadjustment);
            Gtk::Adjustment * get_hadjustment();
            const Gtk::Adjustment * get_hadjustment() const;
            Gtk::Adjustment * get_vadjustment();
            const Gtk::Adjustment * get_vadjustment() const;
            void set_hadjustment(Gtk::Adjustment * adjustment = 0);
            void set_hadjustment(Gtk::Adjustment & adjustment);
            void set_vadjustment(Gtk::Adjustment * adjustment = 0);
            void set_vadjustment(Gtk::Adjustment & adjustment);
            void set_shadow_type(ShadowType type);
            ShadowType get_shadow_type() const;
            Glib::SignalProxy2< void, Gtk::Adjustment *, Gtk::Adjustment * > signal_set_scroll_adjustments();
            Glib::PropertyProxy< Gtk::Adjustment * > property_hadjustment();
            Glib::PropertyProxy_ReadOnly< Gtk::Adjustment * > property_hadjustment() const;
            Glib::PropertyProxy< Gtk::Adjustment * > property_vadjustment();
            Glib::PropertyProxy_ReadOnly< Gtk::Adjustment * > property_vadjustment() const;
            Glib::PropertyProxy< ShadowType > property_shadow_type();
            Glib::PropertyProxy_ReadOnly< ShadowType > property_shadow_type() const;
    };
}
namespace Glib {
    Gtk::Viewport * wrap(GtkViewport * object, bool take_copy = false);
}
