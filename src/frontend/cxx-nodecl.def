#
#   rule : another-rule
#        | NODECL_TREE_CONSTRUCTOR([child_name] rule-name, ...) options
#
#
# Up to 4 children, [child_name] is mandatory and must be a valid C/C++/Fortran name
#
# options is a blank-separated sequence of the following. Each option-name declares extra
# information that is mandatory to the tree (i.e. it cannot be NULL).
#
#    option-name               frontend type
#        symbol                    scope_entry_t*
#        type                      type_t*
#        text                      const char*
#        const-value               const_value_t*
#        template-parameters       template_parameter_list_t*
#        context                   const decl_context_t*
#
# The order that appears here is the order in which this extra information is
# passed (regardless of the precise syntax of the rule, i.e. 'symbol' is always
# considered before 'type'). An option-name can be appeneded "-opt" to state
# that the node may contain a value of that option, but that value is not
# mandatory for the node. Use this when you want to ensure that copy routines
# copy these values as well (otherwise these extra values will be ignored)
#
# There is a special rule 'nodecl' which is the root of the whole hierarchy and,
# while not enforced, every rule should be referenced in another rule. The
# structure must be nonambiguous (i.e. there must be a single way of
# constructing a given hierarchy).
#
# There is a special rule 'any' intended only for the frontends that allows
# to root any parse tree as a child of a nodecl node. Such uses are limited
# in the frontend itself since the parse trees are freed after the frontend
# is run. Do not let outlive such children after the FE has run. Currently
# the only user of this rule is NODECL_CXX_DEP_NAME_CONVERSION due to some
# oddities in the C++ syntax of conversion-function-id.
#

nodecl : NODECL_TOP_LEVEL([top_level] top-level-seq-opt)
top-level : function-code
          | object-init
          | pragma-directive
          | compatibility
          | cxx-decl

name : NODECL_SYMBOL() symbol type-opt const-value-opt
type : NODECL_TYPE() type

function-code: regular-function-code
             | template-function-code
             | vector-regular-function-code

regular-function-code : NODECL_FUNCTION_CODE([statements]context, [initializers]mem-init-seq-opt) symbol
template-function-code: NODECL_TEMPLATE_FUNCTION_CODE([statements]context, [initializers]mem-init-seq-opt) symbol
vector-regular-function-code : NODECL_VECTOR_FUNCTION_CODE([function_code] regular-function-code)

object-init : NODECL_OBJECT_INIT() symbol

mem-init: NODECL_MEMBER_INIT([init_expr]expression) symbol
          | NODECL_IMPLICIT_MEMBER_INIT([init_expr]expression) symbol
          | cxx-mem-init


statement : statement-but-object-init
          | object-init
          | cxx-decl
          | context
          | function-code

context : NODECL_CONTEXT([in_context] statement-seq-opt) context

statement-but-object-init: NODECL_EMPTY_STATEMENT()
          | NODECL_EXPRESSION_STATEMENT([nest]expression)
          | compound-statement
          | NODECL_DO_STATEMENT([statement]statement-seq, [condition]expression)
          | NODECL_WHILE_STATEMENT([condition]expression, [statement]statement-seq, [loop_name]name-opt)
          | NODECL_FOR_STATEMENT([loop_header]loop-control, [statement]statement-seq, [loop_name]name-opt)
          | NODECL_IF_ELSE_STATEMENT([condition]expression, [then]statement-seq, [else]statement-seq-opt)
          | NODECL_LABELED_STATEMENT([statement]statement-seq) symbol
          | NODECL_SWITCH_STATEMENT([switch]expression, [statement]statement-seq)
          | NODECL_DEFAULT_STATEMENT([statement]statement-seq)
          | NODECL_CASE_STATEMENT([case]expression-seq, [statement]statement-seq)
          | NODECL_BREAK_STATEMENT([construct_name]name-opt)
          | NODECL_CONTINUE_STATEMENT([construct_name]name-opt)
          | NODECL_GOTO_STATEMENT() symbol
          | NODECL_RETURN_STATEMENT([value]expression-opt)
          | pragma-directive
          | pragma-statement
          | c-cxx-only-statements
          | fortran-only-statements
          | compatibility
          | NODECL_ERR_STATEMENT()
          | assert-construct

compound-statement : NODECL_COMPOUND_STATEMENT([statements]statement-seq-opt, [finally]statement-seq-opt)

loop-control: NODECL_LOOP_CONTROL([init]expression-seq-opt, [cond]expression-opt, [next]expression-opt)
            | range-loop-control
            | NODECL_UNBOUNDED_LOOP_CONTROL()

range-loop-control : NODECL_RANGE_LOOP_CONTROL([induction_variable] name, [lower]expression, [upper]expression, [step]expression-opt)
# Next one is for C++2011
    | NODECL_ITERATOR_LOOP_CONTROL([range_iterator] name, [initializer]expression)

pragma-directive: NODECL_PRAGMA_CUSTOM_DIRECTIVE([pragma_line]pragma-line, [context_of_decl]pragma-context) text
                | pragma-declaration

pragma-declaration: NODECL_PRAGMA_CUSTOM_DECLARATION([pragma_line]pragma-line, [nested_pragma]pragma-declaration-opt, [context_of_decl]pragma-context, [context_of_parameters]pragma-context-opt) text symbol

pragma-context : NODECL_PRAGMA_CONTEXT() context

pragma-statement : NODECL_PRAGMA_CUSTOM_STATEMENT([pragma_line]pragma-line, [statements]statement-seq) text

pragma-line: NODECL_PRAGMA_CUSTOM_LINE([parameters]pragma-clause-arg-seq-opt, [clauses]pragma-custom-clause-seq-opt, [end_clauses]pragma-custom-clause-seq-opt) text
# The type of a NODECL_PRAGMA_CUSTOM_CLAUSE can be used to mark this clause as "used"
# this is needed for diagnostics
pragma-custom-clause: NODECL_PRAGMA_CUSTOM_CLAUSE([arguments]pragma-clause-arg-seq-opt) text type-opt
pragma-clause-arg: NODECL_PRAGMA_CLAUSE_ARG() text

c-cxx-only-statements : NODECL_TRY_BLOCK([statement]statement-seq, [catch_handlers]statement-seq-opt, [any]statement-seq-opt)
# C++2011: for(T symbol : range)
    | NODECL_CXX_FOR_RANGED([range]expression, [statement]statement-seq) symbol
# This one should only appear inside a NODECL_TRY_BLOCK
    | NODECL_CATCH_HANDLER([name]object-init-opt, [statement]statement-seq) type
# C++2011: dependent static asserts
    | NODECL_CXX_STATIC_ASSERT([predicate]expression, [message]expression-opt)

literal : NODECL_INTEGER_LITERAL() type const-value
    | NODECL_FLOATING_LITERAL() type const-value
    | NODECL_COMPLEX_LITERAL() type const-value
    | NODECL_BOOLEAN_LITERAL() type const-value
    | string-literal
    | structured-value

string-literal: NODECL_STRING_LITERAL() type const-value text-opt

vector-flags: NODECL_ALIGNED_FLAG()
    | NODECL_ALIGNMENT_INFO() const-value
    | NODECL_IN_PLACE_FLAG()
    | NODECL_ON_TOP_FLAG()
    | NODECL_EVICT_FLAG()
    | NODECL_RELAXED_FLAG()
    | NODECL_NONTEMPORAL_FLAG()
    | NODECL_HAS_BEEN_DEFINED_FLAG()
    | expression

expression : literal
           | name
           | context
           | NODECL_FUNCTION_CALL([called] expression, [arguments] argument-seq-opt, [alternate_name]expression-opt, [function_form] function-form-opt) type const-value-opt
           | NODECL_ARRAY_SUBSCRIPT([subscripted] expression, [subscripts]expression-seq) type const-value-opt
           | range-expression
           | NODECL_CLASS_MEMBER_ACCESS([lhs]expression, [member]name, [member_literal]cxx-dependent-name-opt) type const-value-opt text-opt
           | NODECL_PLUS([rhs]expression) type const-value-opt
           | NODECL_NEG([rhs]expression) type const-value-opt
           | NODECL_MUL([lhs]expression, [rhs]expression) type const-value-opt
           | NODECL_POWER([lhs]expression, [rhs]expression) type const-value-opt
           | NODECL_DIV([lhs]expression, [rhs]expression) type const-value-opt
           | NODECL_MOD([lhs]expression, [rhs]expression) type const-value-opt
           | NODECL_ADD([lhs]expression, [rhs]expression) type const-value-opt
           | NODECL_MINUS([lhs]expression, [rhs]expression) type const-value-opt
           | NODECL_CONCAT([lhs]expression, [rhs]expression) type const-value-opt
           | NODECL_EQUAL([lhs]expression, [rhs]expression) type const-value-opt
           | NODECL_DIFFERENT([lhs]expression, [rhs]expression) type const-value-opt
           | NODECL_LOWER_THAN([lhs]expression, [rhs]expression) type const-value-opt
           | NODECL_LOWER_OR_EQUAL_THAN([lhs]expression, [rhs]expression) type const-value-opt
           | NODECL_GREATER_THAN([lhs]expression, [rhs]expression) type const-value-opt
           | NODECL_GREATER_OR_EQUAL_THAN([lhs]expression, [rhs]expression) type const-value-opt
           | NODECL_LOGICAL_NOT([rhs]expression) type const-value-opt
           | NODECL_LOGICAL_AND([lhs] expression, [rhs] expression) type const-value-opt
           | NODECL_LOGICAL_OR([lhs] expression, [rhs] expression) type const-value-opt
           | NODECL_BITWISE_NOT([rhs]expression) type const-value-opt
           | NODECL_BITWISE_AND([lhs] expression, [rhs] expression) type const-value-opt
           | NODECL_BITWISE_OR([lhs] expression, [rhs] expression) type const-value-opt
           | NODECL_BITWISE_XOR([lhs] expression, [rhs] expression) type const-value-opt
           | NODECL_BITWISE_SHL([lhs] expression, [rhs] expression) type const-value-opt
           | NODECL_ARITHMETIC_SHR([lhs] expression, [rhs] expression) type const-value-opt
           | NODECL_BITWISE_SHR([lhs] expression, [rhs] expression) type const-value-opt
           | NODECL_ASSIGNMENT([lhs] expression, [rhs] expression) type const-value-opt
           | NODECL_PARENTHESIZED_EXPRESSION([nest]expression) type const-value-opt
           | NODECL_DEREFERENCE([rhs]expression) type const-value-opt
           | NODECL_COMPOUND_EXPRESSION([nest]context) type const-value-opt
           | NODECL_VECTOR_SUBSCRIPT([subscripted] expression, [subscript]expression) type const-value-opt
           | NODECL_VECTOR_ADD([lhs]expression, [rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_FMADD([first_op]expression, [second_op]expression, [third_op]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_MINUS([lhs]expression, [rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_FMMINUS([first_mul_op]expression, [second_mul_op]expression, [minus_op]expression-opt, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_MUL([lhs]expression, [rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_DIV([lhs]expression, [rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_RCP([rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_MOD([lhs]expression, [rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_NEG([rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_SQRT([rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_RSQRT([rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_REDUCTION_ADD([vector_src]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_REDUCTION_MINUS([vector_src]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_REDUCTION_MUL([vector_src]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_EQUAL([lhs]expression, [rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_DIFFERENT([lhs]expression, [rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_LOWER_THAN([lhs]expression, [rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_LOWER_OR_EQUAL_THAN([lhs]expression, [rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_GREATER_THAN([lhs]expression, [rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_GREATER_OR_EQUAL_THAN([lhs]expression, [rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_LOGICAL_NOT([rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_LOGICAL_AND([lhs] expression, [rhs] expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_LOGICAL_OR([lhs] expression, [rhs] expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_BITWISE_NOT([rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_BITWISE_AND([lhs] expression, [rhs] expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_BITWISE_OR([lhs] expression, [rhs] expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_BITWISE_XOR([lhs] expression, [rhs] expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_BITWISE_SHL([lhs] expression, [rhs] expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_ARITHMETIC_SHR([lhs] expression, [rhs] expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_BITWISE_SHR([lhs] expression, [rhs] expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_ALIGN_RIGHT([left_vector] expression, [right_vector] expression, [num_elements] expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_ASSIGNMENT([lhs] expression, [rhs] expression, [mask]expression-opt, [has_been_defined]vector-flags-opt) type const-value-opt
           | NODECL_VECTOR_STORE([lhs] expression, [rhs] expression, [mask]expression-opt,[flags] vector-flags-seq-opt) type const-value-opt
           | NODECL_VECTOR_SCATTER([base] expression, [strides] expression, [source] expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_LOAD([rhs] expression, [mask]expression-opt, [flags] vector-flags-seq-opt) type const-value-opt
           | NODECL_VECTOR_GATHER([base] expression, [strides] expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_PROMOTION([rhs] expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_PREFETCH([address] expression, [prefetch_kind] expression) type const-value-opt
           | NODECL_VECTOR_LITERAL([scalar_values] expression-seq, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_LANE_ID() type const-value
           | NODECL_VECTOR_CONVERSION([nest] expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_CAST([rhs]expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_FUNCTION_CALL([function_call] expression, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_FABS([argument] argument, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_SINCOS([source] argument, [sin_pointer] argument, [cos_pointer] argument, [mask]expression-opt) type const-value-opt
           | NODECL_VECTOR_MASK_ASSIGNMENT([lhs] expression, [rhs] expression) type const-value-opt
           | NODECL_VECTOR_MASK_CONVERSION([nest] expression) type const-value-opt
           | NODECL_VECTOR_MASK_NOT([rhs] expression) type const-value-opt
           | NODECL_VECTOR_MASK_AND([lhs] expression, [rhs] expression) type const-value-opt
           | NODECL_VECTOR_MASK_OR([lhs] expression, [rhs] expression) type const-value-opt
           | NODECL_VECTOR_MASK_XOR([lhs] expression, [rhs] expression) type const-value-opt
           | NODECL_VECTOR_MASK_AND_1_NOT([lhs] expression, [rhs] expression) type const-value-opt
           | NODECL_VECTOR_MASK_AND_2_NOT([lhs] expression, [rhs] expression) type const-value-opt
           | NODECL_VECTOR_LOOP([peeling] expression, [main_loop] expression, [epilog] expression) type const-value-opt
           | NODECL_NOEXCEPT_IMPLICIT_TRUE() type const-value
           | c-cxx-expressions
           | fortran-expressions
           | object-init
           | compatibility
           | NODECL_ERR_EXPR()
# This one is intended to represent implicit conversions allowed by the base language
           | NODECL_CONVERSION([nest] expression) type const-value-opt text-opt
# This one is used when we need an expression only for its type
           | NODECL_DUMMY() type

range-expression : NODECL_RANGE([lower] expression-opt, [upper] expression-opt, [stride] expression) type const-value-opt

structured-value: NODECL_STRUCTURED_VALUE([items]initializer-item-seq-opt, [form]structured-value-form-opt) type const-value-opt

structured-value-form : NODECL_STRUCTURED_VALUE_PARENTHESIZED()
  | NODECL_STRUCTURED_VALUE_BRACED_TYPECAST()
  | NODECL_STRUCTURED_VALUE_BRACED_IMPLICIT()
  | NODECL_STRUCTURED_VALUE_COMPOUND_LITERAL()
  | NODECL_STRUCTURED_VALUE_FORTRAN_TYPESPEC_ARRAY_CONSTRUCTOR()

initializer-item: NODECL_FIELD_DESIGNATOR([field]name, [next]initializer-item) type const-value-opt
      | NODECL_INDEX_DESIGNATOR([index]expression, [next]initializer-item) type const-value-opt
      | expression
      | fortran-implied-do

fortran-implied-do: NODECL_FORTRAN_IMPLIED_DO([name]name, [range]expression, [items]initializer-item-seq)

argument : expression
         | default-arg
         | fortran-actual-argument

# Note, the text in NODECL_FORTRAN_ACTUAL_ARGUMENT is only used by the
# frontend. Any other part of the compiler should not use it
fortran-actual-argument: NODECL_FORTRAN_ACTUAL_ARGUMENT([argument]fortran-argument) text-opt
                       | NODECL_FORTRAN_NOT_PRESENT()

fortran-argument: expression
                | alt-return

default-arg: NODECL_DEFAULT_ARGUMENT([argument]expression)

alt-return: NODECL_FORTRAN_ALTERNATE_RETURN_ARGUMENT() symbol type const-value-opt

c-cxx-expressions : NODECL_CONDITIONAL_EXPRESSION([condition]expression, [true]expression, [false]expression) type const-value-opt
                  | NODECL_REFERENCE([rhs]expression) type const-value-opt
                  | NODECL_COMMA([lhs]expression, [rhs]expression) type const-value-opt
                  | NODECL_THROW([rhs]expression-opt) type const-value-opt
                  | NODECL_VIRTUAL_FUNCTION_CALL([called] expression, [arguments] argument-seq, [function_form] function-form-opt) type const-value-opt
                  | NODECL_MUL_ASSIGNMENT([lhs] expression, [rhs] expression) type const-value-opt
                  | NODECL_DIV_ASSIGNMENT([lhs] expression, [rhs] expression) type const-value-opt
                  | NODECL_ADD_ASSIGNMENT([lhs] expression, [rhs] expression) type const-value-opt
                  | NODECL_MINUS_ASSIGNMENT([lhs] expression, [rhs] expression) type const-value-opt
                  | NODECL_BITWISE_SHL_ASSIGNMENT([lhs] expression, [rhs] expression) type const-value-opt
                  | NODECL_BITWISE_SHR_ASSIGNMENT([lhs] expression, [rhs] expression) type const-value-opt
                  | NODECL_ARITHMETIC_SHR_ASSIGNMENT([lhs] expression, [rhs] expression) type const-value-opt
                  | NODECL_BITWISE_AND_ASSIGNMENT([lhs] expression, [rhs] expression) type const-value-opt
                  | NODECL_BITWISE_OR_ASSIGNMENT([lhs] expression, [rhs] expression) type const-value-opt
                  | NODECL_BITWISE_XOR_ASSIGNMENT([lhs] expression, [rhs] expression) type const-value-opt
                  | NODECL_MOD_ASSIGNMENT([lhs] expression, [rhs] expression) type const-value-opt
                  | NODECL_PREINCREMENT([rhs]expression) type const-value-opt
                  | NODECL_POSTINCREMENT([rhs]expression) type const-value-opt
                  | NODECL_PREDECREMENT([rhs]expression) type const-value-opt
                  | NODECL_POSTDECREMENT([rhs]expression) type const-value-opt
                  | NODECL_SIZEOF([size_type]type, [expr]expression-opt) type const-value-opt
                  | NODECL_ALIGNOF([align_type]type-or-expr) type const-value-opt
                  | NODECL_OFFSET([base]expression, [offset]expression) type const-value-opt
                  | NODECL_TYPEID([arg]type-or-expr) type const-value-opt
                  | NODECL_NEW([init]expression-opt, [init_real_type] type-opt, [placement]expression-seq-opt, [alloc_func]name-opt) type text const-value-opt
                  | NODECL_DELETE([rhs]expression) type const-value-opt
                  | NODECL_DELETE_ARRAY([rhs]expression) type const-value-opt
                  | NODECL_POINTER_TO_MEMBER() symbol type const-value-opt
                  | NODECL_REAL_PART([rhs]expression) type const-value-opt
                  | NODECL_IMAG_PART([rhs]expression) type const-value-opt
                  | NODECL_OFFSETOF([offset_type]type, [designator]cxx-dependent-initializer-seq) type const-value-opt
                  | NODECL_SHAPING([postfix] expression, [shape] expression-seq) type const-value-opt
                  | NODECL_PSEUDO_DESTRUCTOR_NAME([accessed] expression) type const-value-opt
                  | NODECL_VECTOR_CONDITIONAL_EXPRESSION([condition]expression, [true]expression, [false]expression) type const-value-opt
                  | NODECL_VLA_WILDCARD() type
                  | NODECL_GXX_BUILTIN_ADDRESSOF([expr]expression) type
                  | cxx-expr-dependent-nodecls
                  | cuda-expressions
                  | mask-expressions
                  | cxx-pack

# Used for C++11 lambdas
explicit-capture: NODECL_CXX_CAPTURE_COPY([init] expression-opt) symbol
                | NODECL_CXX_CAPTURE_REFERENCE([init] expression-opt) symbol

mask-expressions : NODECL_MASK_LITERAL() type const-value

# This is only for dependent parts of C++. These nodecls exist because
# usual nodecls may not retain enough semantic information for a successful
# instantiation. These nodecls should never appear in the code (but may be accessible
# through symbols for instantiation purposes)
cxx-expr-dependent-nodecls: cxx-dependent-name
   | cxx-dependent-initializer
   | cxx-dependent-expressions

cxx-pack : NODECL_CXX_VALUE_PACK([pack]expression) type
         # This one materializes a subvalue of a pack. const-value should be an integer
         # Here we materialize the expansion, used for nontype template-arguments packs
         | NODECL_CXX_VALUE_PACK_EXPANDED([values]expression-seq-opt) type

# nodecl was created entirely to avoid this kind of "declaration nodes" but we
# will not be able to get rid of them until we instantiate template functions
cxx-decl : NODECL_CXX_DECL([context] context-opt) symbol
         | NODECL_CXX_DEF([context] context-opt) symbol
         | NODECL_CXX_EXPLICIT_INSTANTIATION_DEF([declarator_name] cxx-dependent-name-opt, [context] context) symbol
         | NODECL_CXX_EXPLICIT_INSTANTIATION_DECL([declarator_name] cxx-dependent-name-opt, [context] context) symbol
         | NODECL_CXX_USING_NAMESPACE([context] context, [used_name]cxx-dependent-name) symbol
         | NODECL_CXX_USING_DECL([context] context, [used_name]cxx-dependent-name) symbol
         # Used only in weird cases where parsing must be delayed in the frontend itself
         # not to be used after the FE
         | NODECL_CXX_PARSE_LATER()
# experimental
         | NODECL_CXX_IMPLICIT_INSTANTIATION() symbol

# Special nodes for dependent names
cxx-dependent-name : NODECL_CXX_DEP_GLOBAL_NAME_NESTED([items] cxx-atom-dependent-name-seq) symbol-opt type-opt
                   | NODECL_CXX_DEP_NAME_NESTED([items] cxx-atom-dependent-name-seq) symbol-opt type-opt
                   | cxx-atom-dependent-name
cxx-atom-dependent-name : cxx-simple-name
                   | NODECL_CXX_DEP_TEMPLATE_ID([name]cxx-atom-dependent-name) text symbol-opt template-parameters type-opt
                   | NODECL_CXX_DEP_NAME_CONVERSION([context] context, [conversion_type] type-opt, [literal_conversion] any-opt) symbol-opt type-opt
                   | NODECL_CXX_DEP_DECLTYPE() type

cxx-simple-name: NODECL_CXX_DEP_NAME_SIMPLE() text symbol-opt type-opt

cxx-dependent-initializer : NODECL_CXX_INITIALIZER([init] expression) type
    | NODECL_CXX_BRACED_INITIALIZER([init]expression-seq-opt) type
    | NODECL_CXX_EQUAL_INITIALIZER([init]expression) type
    | NODECL_CXX_PARENTHESIZED_INITIALIZER([init]expression-seq-opt) type
    | NODECL_C99_DESIGNATED_INITIALIZER([designation]cxx-dependent-initializer-seq, [init]expression)
    | NODECL_C99_FIELD_DESIGNATOR([name]cxx-simple-name)
    | NODECL_C99_INDEX_DESIGNATOR([expr]expression)

# a.b
cxx-dependent-expressions: NODECL_CXX_CLASS_MEMBER_ACCESS([lhs]expression, [member]expression) type const-value-opt text-opt
# a->b
    | NODECL_CXX_ARROW([lhs]expression, [member]expression) type const-value-opt text
# a.*b
    | NODECL_CXX_DOT_PTR_MEMBER([lhs]expression, [ptr]expression) type const-value-opt
# a->*b
    | NODECL_CXX_ARROW_PTR_MEMBER([lhs]expression, [ptr]expression) type const-value-opt
# sizeof(expr)
    | NODECL_CXX_SIZEOF([expr] expression) type const-value-opt
# sizeof...(expr)
    | NODECL_CXX_SIZEOF_PACK([expr] expression) type const-value-opt
# alignof(expr)
    | NODECL_CXX_ALIGNOF([expr] expression) type const-value-opt
# (type) { ... }
    | NODECL_CXX_POSTFIX_INITIALIZER([postfix]expression) type const-value-opt
# dependent-cast
    | NODECL_CXX_CAST([rhs]expression) type text const-value-opt
# T(expr-list)
    | NODECL_CXX_EXPLICIT_TYPE_CAST([init_list]cxx-dependent-initializer) type const-value-opt
# T(expr-list) (T being an expression)
    | NODECL_CXX_DEP_FUNCTION_CALL([called] expression, [arguments] argument-seq-opt, [alternate_name]name-opt) type const-value-opt
    | NODECL_CXX_DEP_NEW([init]expression-opt, [init_real_type] type-opt, [placement]expression-seq-opt) type text
# noexcept(expr)
    | NODECL_CXX_NOEXCEPT([expr] expression) type const-value-opt
# [dependent] C+11 lambdas
    | NODECL_CXX_LAMBDA([explicit_captures]explicit-capture-seq-opt) type symbol
# [dependent] alignas
    | NODECL_CXX_ALIGNAS([values]expression-seq) type

# id-expr(expr) in a member initializer
cxx-mem-init: NODECL_CXX_MEMBER_INIT([name]cxx-dependent-name, [initializer]expression) type const-value-opt

function-form: NODECL_CXX_FUNCTION_FORM_TEMPLATE_ID() template-parameters-opt
    | NODECL_CXX_FUNCTION_FORM_IMPLICIT()
    | NODECL_CXX_FUNCTION_FORM_BINARY_INFIX()
    | NODECL_CXX_FUNCTION_FORM_UNARY_PREFIX()
    | NODECL_CXX_FUNCTION_FORM_UNARY_POSTFIX()
    | NODECL_CXX_FUNCTION_FORM_DEFAULT_INIT()
    | NODECL_CXX_FUNCTION_FORM_DEFAULT_INIT_BRACED()

type-or-expr : type
             | expression

fortran-only-statements : NODECL_FORTRAN_ALLOCATE_STATEMENT([items]expression-seq, [options]fortran-io-spec-seq-opt, [allocate_type]type-opt)
                        | NODECL_FORTRAN_ARITHMETIC_IF_STATEMENT([expr]expression, [lower]name, [equal]name, [upper]name)
                        | NODECL_FORTRAN_ASSIGNED_GOTO_STATEMENT([index]name, [label_seq]name-seq-opt)
                        | NODECL_FORTRAN_OPEN_STATEMENT([io_items] fortran-io-spec-seq-opt)
                        | NODECL_FORTRAN_CLOSE_STATEMENT([io_items] fortran-io-spec-seq-opt)
                        | NODECL_FORTRAN_COMPUTED_GOTO_STATEMENT([label_seq]name-seq, [index] expression)
                        | NODECL_FORTRAN_ALTERNATE_RETURN_STATEMENT([index] expression)
                        | NODECL_FORTRAN_DEALLOCATE_STATEMENT([items]expression-seq, [options]fortran-io-spec-seq-opt)
                        | NODECL_FORTRAN_IO_STATEMENT([io_spec_list]fortran-io-spec-seq-opt, [io_items]fortran-io-item-seq-opt) text
                        | NODECL_FORTRAN_LABEL_ASSIGN_STATEMENT([value]expression, [label_var]name)
                        | NODECL_FORTRAN_NULLIFY_STATEMENT([items]expression-seq)
                        | NODECL_FORTRAN_PRINT_STATEMENT([format] expression, [io_items]fortran-io-item-seq-opt)
                        | NODECL_FORTRAN_READ_STATEMENT([io_spec_list]fortran-io-spec-seq-opt, [io_items]fortran-io-item-seq-opt)
                        | NODECL_FORTRAN_WRITE_STATEMENT([io_spec_list]fortran-io-spec-seq-opt, [io_items]fortran-io-item-seq-opt)
                        | NODECL_FORTRAN_STOP_STATEMENT([stop_code]expression-opt)
                        | NODECL_FORTRAN_PAUSE_STATEMENT([pause_code]expression-opt)
                        | NODECL_FORTRAN_ENTRY_STATEMENT() symbol
                        | NODECL_FORTRAN_WHERE([where_set] where-pair-seq)
                        | NODECL_FORTRAN_FORALL([loop_control] loop-control-seq, [mask] expression-opt, [statement] statement-seq)

where-pair: NODECL_FORTRAN_WHERE_PAIR([mask] expression-opt, [statement] statement-seq-opt)

# NODECL_FORTRAN_DATA
#   This is used only for .data variable which holds the initializations by means
#   of DATA statements
# NODECL_FORTRAN_EQUIVALENCE
#   This is used only for .equivalence variable which holds the equivalence of
#   data storage
# NODECL_FORTRAN_USE
# NODECL_FORTRAN_USE_ONLY
#   These are used only for .used_modules needed to faithfully regenerate the
#   USE statements in each program unit.
fortran-expressions : NODECL_FORTRAN_DATA([objects]fortran-data-item-seq, [values]fortran-data-item-seq)
                    | NODECL_FORTRAN_EQUIVALENCE([first]expression, [second]expression-seq)
                    | NODECL_FORTRAN_BOZ_LITERAL() type text const-value
                    | NODECL_FORTRAN_BIND_C([name] expression-opt)
                    | NODECL_FORTRAN_HOLLERITH() type text const-value
                    | NODECL_FORTRAN_USE([module]name, [renamed_items]name-seq-opt)
                    | NODECL_FORTRAN_USE_ONLY([module]name, [only_items]name-seq)

fortran-data-item : expression
                  | fortran-implied-do

fortran-io-spec: NODECL_FORTRAN_IO_SPEC([value]expression-opt) text

fortran-io-item : expression
           | fortran-implied-do

compatibility: unknown-pragma
          | source-comment
          | preprocessor-text
          | verbatim
          | asm-definition
          | gcc-asm-definition
          | gcc-asm-spec
          | upc-sync-statement
          | gcc-builtin-va-arg
          | gxx-traits
          | text
          | intel-expressions

gcc-builtin-va-arg: NODECL_GCC_BUILTIN_VA_ARG([expr] expression, [va_type]type) type

asm-definition : NODECL_ASM_DEFINITION([asm_text]text-seq)

unknown-pragma : NODECL_UNKNOWN_PRAGMA() text
source-comment: NODECL_SOURCE_COMMENT() text
preprocessor-text : NODECL_PREPROCESSOR_LINE() text
verbatim: NODECL_VERBATIM() text

gcc-asm-spec : NODECL_GCC_ASM_SPEC() text

gcc-asm-definition : NODECL_GCC_ASM_DEFINITION([operands0]gcc-asm-operand-seq-opt, [operands1]gcc-asm-operand-seq-opt, [operands2]gcc-asm-operand-seq-opt, [specs]text-seq-opt) text
gcc-asm-operand : NODECL_GCC_ASM_OPERAND( [identifier]text-opt, [constraint]text, [expr]expression-opt)

upc-sync-statement : NODECL_UPC_SYNC_STATEMENT([expr]expression) text

gxx-traits: NODECL_GXX_TRAIT([lhs]type, [rhs]type-opt) text type const-value-opt

text : NODECL_TEXT() text

intel-expressions : NODECL_INTEL_ASSUME_ALIGNED([pointer] expression, [alignment] expression) type const-value-opt
                  | NODECL_INTEL_ASSUME([assumed] expression) type const-value-opt

# extension used for multidependences/multicopies and other places where we
# want a range expression
expression : NODECL_MULTI_EXPRESSION([iterators]multi-expr-iterator-seq, [expr]expression) type const-value-opt


multi-expr-iterator : NODECL_MULTI_EXPRESSION_ITERATOR([range]multi-expr-range-expression) symbol type const-value-opt

multi-expr-range-expression : range-expression
                            | range-discrete

range-discrete : NODECL_RANGE_DISCRETE([discrete_seq]expression-seq-opt)

##############################
# OpenMP                     #
##############################
# Note that we use OPEN_M_P as we want nice names (OpenMP instead of Openmp) in the C++ part

top-level : device-constructs-top-level
statement-but-object-init: parallel-statements

parallel-statements : parallel-execution
                    | synchronization

parallel-execution : task-construct
                   | taskyield-construct
                   | single-construct
                   | critical-construct
                   | parallel-construct
                   | omp-for-construct
                   | taskloop-construct
                   | atomic-construct
                   | sections-construct
                   | master-construct
                   | workshare-construct
                   | simd-constructs
                   | device-constructs

# single
single-construct : NODECL_OPEN_M_P*SINGLE([environment]omp-exec-environment-seq-opt, [statements]statement-seq-opt)

# master
master-construct : NODECL_OPEN_M_P*MASTER([statements]statement-seq-opt)

# critical
critical-construct : NODECL_OPEN_M_P*CRITICAL([environment]omp-exec-environment-seq-opt, [statements]statement-seq-opt)

# inline task
task-construct : NODECL_OPEN_M_P*TASK([environment]omp-exec-environment-seq-opt, [statements]statement-seq-opt)

# parallel
parallel-construct : NODECL_OPEN_M_P*PARALLEL([environment]omp-exec-environment-seq-opt, [num_replicas]expression-opt, [statements]statement-seq)

# for
omp-for-construct : NODECL_OPEN_M_P*FOR([environment]omp-exec-environment-seq-opt, [loop]statement)

taskloop-construct : NODECL_OPEN_M_P*TASKLOOP([environment]omp-exec-environment-seq-opt, [loop]statement)

# workshare (Fortran only)
workshare-construct : NODECL_OPEN_M_P*WORKSHARE([environment]omp-exec-environment-seq-opt, [statements]statement-seq)

# atomic
atomic-construct : NODECL_OPEN_M_P*ATOMIC([environment]omp-exec-environment-seq-opt, [statements]statement-seq)

# sections
sections-construct : NODECL_OPEN_M_P*SECTIONS([environment]omp-exec-environment-seq-opt, [sections]section-construct-seq)

section-construct : NODECL_OPEN_M_P*SECTION([statements]statement-seq)

synchronization : NODECL_OPEN_M_P*TASKWAIT([environment]omp-exec-environment-seq-opt)
                | NODECL_OPEN_M_P*TASKGROUP([environment]omp-exec-environment-seq-opt, [statements]statement-seq-opt)
# All levels of async
                | NODECL_OPEN_M_P*FLUSH_MEMORY([expressions] expression-seq-opt)
# Full barrier
                | NODECL_OPEN_M_P*BARRIER_FULL([environment]omp-exec-environment-seq-opt)
# First half of a barrier (signaling phase)
                | NODECL_OPEN_M_P*BARRIER_SIGNAL()
# Second half of a barrier (waiting phase)
                | NODECL_OPEN_M_P*BARRIER_WAIT()

taskyield-construct: NODECL_OPEN_M_P*TASKYIELD()

omp-exec-environment : omp-data-sharings-info
                 | omp-construct-info
                 | omp-sync-info
                 | omp-memory-info
                 | omp-loop-info
                 | omp-taskloop-info
                 | omp-deps-info
                 | omp-execution-control
                 | omp-critical-info
                 | omp-simd-info
                 | omp-device-info
                 | omp-task-flags

omp-data-sharings-info : NODECL_OPEN_M_P*FIRSTPRIVATE([symbols]name-seq)
                       | NODECL_OPEN_M_P*LASTPRIVATE([symbols]name-seq)
                       | NODECL_OPEN_M_P*FIRST_LASTPRIVATE([symbols]name-seq)
                       | NODECL_OPEN_M_P*SHARED([symbols]name-seq)
                       | NODECL_OPEN_M_P*THREADPRIVATE([symbols]name-seq)
                       | NODECL_OPEN_M_P*PRIVATE([symbols]name-seq)
                       | NODECL_OPEN_M_P*AUTO([symbols]name-seq)
                       | NODECL_OPEN_M_P*REDUCTION([reductions]omp-reduction-item-seq)
                       | NODECL_OPEN_M_P*TASK_REDUCTION([reductions]omp-reduction-item-seq)
                       | NODECL_OPEN_M_P*IN_REDUCTION([reductions]omp-reduction-item-seq)
                       | NODECL_OPEN_M_P*PRIVATE_INIT([value]expression-opt) symbol

omp-reduction-item : NODECL_OPEN_M_P*REDUCTION_ITEM([reductor]name, [reduced_symbol]name, [reduction_type]type)

omp-construct-info : NODECL_OPEN_M_P*COMBINED_WITH_PARALLEL()
                   | NODECL_OPEN_M_P*FUNCTION_TASK_PARSING_CONTEXT([context]pragma-context)

# These nodes are not generated by TL::OpenMP::Base. They are internally used by our Lowering phases
# to express that we are representing a certain construct (such as a Taskwait or a TaskCall) as a task
omp-task-flags : NODECL_OPEN_M_P*TASK_IS_TASKWAIT()
               | NODECL_OMP_SS*TASK_IS_LOOP()
               | NODECL_OMP_SS*TASK_IS_TASK_CALL()

omp-sync-info : NODECL_OPEN_M_P*BARRIER_AT_END()

omp-memory-info : NODECL_OPEN_M_P*FLUSH_AT_ENTRY()
                | NODECL_OPEN_M_P*FLUSH_AT_EXIT()
                | NODECL_OPEN_M_P*NO_FLUSH()

omp-loop-info : NODECL_OPEN_M_P*SCHEDULE([chunk]expression-opt) text
              | NODECL_OPEN_M_P*DIST_SCHEDULE([chunk]expression-opt) text

omp-taskloop-info : NODECL_OPEN_M_P*NUM_TASKS([num_tasks]expression)
                  | NODECL_OPEN_M_P*GRAINSIZE([grainsize]expression)
                  | NODECL_OMP_SS*CHUNKSIZE([chunksize]expression)

omp-deps-info :  NODECL_OPEN_M_P*DEP_IN([exprs]expression-seq)
                 | NODECL_OPEN_M_P*DEP_OUT([exprs]expression-seq)
                 | NODECL_OPEN_M_P*DEP_INOUT([exprs]expression-seq)

omp-execution-control : NODECL_OPEN_M_P*IF([condition]expression)
                      | NODECL_OPEN_M_P*FINAL([condition]expression)
                      | NODECL_OPEN_M_P*PRIORITY([priority]expression)
                      | NODECL_OPEN_M_P*MERGEABLE()
                      | NODECL_OPEN_M_P*UNTIED()
# OmpSsv2 clause that  means that a task/taskloop has to wait for its children
                      | NODECL_OMP_SS*WAIT()

omp-critical-info: NODECL_OPEN_M_P*CRITICAL_NAME() text

omp-simd-info: NODECL_OPEN_M_P*ALIGNED([aligned_expressions] expression-seq, [alignment] expression)
             | NODECL_OPEN_M_P*VECTOR_LENGTH([vector_length] expression) 
             | NODECL_OPEN_M_P*VECTOR_LENGTH_FOR() type
             | NODECL_OPEN_M_P*UNIFORM([uniform_expressions] expression-seq)
             | NODECL_OPEN_M_P*LINEAR([linear_expressions] expression-seq, [step] expression)
             | NODECL_OPEN_M_P*SUITABLE([suitable_expressions] expression-seq)
             | NODECL_OPEN_M_P*OVERLAP([overlap_expressions] expression-seq, [min_group_loads] expression, [max_group_registers] expression, [max_groups] expression)
             | NODECL_OPEN_M_P*UNROLL([unroll_factor] expression)
             | NODECL_OPEN_M_P*UNROLL_AND_JAM([unroll_factor] expression)
             | NODECL_OPEN_M_P*NONTEMPORAL([nontemporal_expressions] expression-seq, [flags] vector-flags-seq-opt)
             | NODECL_OPEN_M_P*PREFETCH([distances] expression-seq, [strategy] vector-flags)
             | NODECL_OPEN_M_P*NO_PREFETCH()
             | NODECL_OPEN_M_P*MASK()
             | NODECL_OPEN_M_P*NO_MASK()
             | NODECL_OPEN_M_P*SIMD_REDUCTION([reductions]omp-reduction-item-seq)

omp-device-info: NODECL_OPEN_M_P*DEVICE([device_id] expression)
               | NODECL_OPEN_M_P*MAP_TO([map_to] expression-seq)
               | NODECL_OPEN_M_P*MAP_FROM([map_from] expression-seq)
               | NODECL_OPEN_M_P*MAP_TO_FROM([map_tofrom] expression-seq)
               | NODECL_OPEN_M_P*MAP_ALLOC([map_alloc] expression-seq)
               | NODECL_OPEN_M_P*MOTION_TO([map_to] expression-seq)
               | NODECL_OPEN_M_P*MOTION_FROM([map_from] expression-seq)
               | NODECL_OPEN_M_P*NUM_TEAMS([num_teams] expression)
               | NODECL_OPEN_M_P*THREAD_LIMIT([thread_limit] expression)
               | NODECL_OPEN_M_P*TARGET_TASK_UNDEFERRED()

device-constructs : NODECL_OPEN_M_P*TARGET_DATA([environment]omp-exec-environment-seq-opt, [statements]statement-seq-opt)
                  | NODECL_OPEN_M_P*TARGET([environment]omp-exec-environment-seq-opt, [statements]statement-seq-opt)
                  | NODECL_OPEN_M_P*TARGET_UPDATE([environment]omp-exec-environment-seq-opt)
                  | NODECL_OPEN_M_P*TEAMS([environment]omp-exec-environment-seq-opt, [statements]statement-seq-opt)
                  | NODECL_OPEN_M_P*DISTRIBUTE([environment]omp-exec-environment-seq-opt, [loop]statement)

device-constructs-top-level : NODECL_OPEN_M_P*DECLARE_TARGET([declarations]name-seq)

##############################
# OpenMP SIMD                #
##############################
top-level : simd-func-construct

simd-constructs : simd-construct
                | simd-for-construct
                | parallel-simd-for-construct

simd-construct : NODECL_OPEN_M_P*SIMD([statement] statement, [environment] omp-exec-environment-seq-opt)
simd-func-construct : NODECL_OPEN_M_P*SIMD_FUNCTION([statement] statement, [environment] omp-exec-environment-seq-opt)
simd-for-construct : NODECL_OPEN_M_P*SIMD_FOR([openmp_for] omp-for-construct, [environment] omp-exec-environment-seq-opt)
parallel-simd-for-construct : NODECL_OPEN_M_P*PARALLEL_SIMD_FOR([statement] statement, [environment] omp-exec-environment-seq-opt)

omp-for-construct : NODECL_OPEN_M_P*FOR_APPENDIX([environment]omp-exec-environment-seq-opt, [loop]statement, [prependix]statement-seq-opt, [appendix]statement-seq-opt)

##############################
# OmpSs specific nodes       #
##############################

expression : task-call
           | task-expression


# function task
# Note: do not rely on the information in site_environment
task-call : NODECL_OMP_SS*TASK_CALL([environment]omp-exec-environment-seq-opt, [call]expression, [site_environment]omp-exec-environment-seq-opt)

# task expression
task-expression : NODECL_OMP_SS*TASK_EXPRESSION([join_task] statement, [task_calls] statement-seq, [sequential_code] statement)

# target
top-level: target-declaration

target-declaration : NODECL_OMP_SS*TARGET_DECLARATION([devices] text-seq, [symbols] name-seq)

# Some OmpSs/OmpSs-2 additional constructs
parallel-statements: oss-specific-constructs
                    | data-coordination-constructs
                    | release-deps-construct

# OmpSs-2 specific constructs
oss-specific-constructs: NODECL_OMP_SS*TASK_WORKSHARING([environment]omp-exec-environment-seq-opt, [loop]statement)
                       | NODECL_OMP_SS*TASKLOOP_WORKSHARING([environment]omp-exec-environment-seq-opt, [loop]statement)

# register
data-coordination-constructs : NODECL_OMP_SS*REGISTER([registered_set]expression-seq)
                | NODECL_OMP_SS*UNREGISTER([unregistered_set]expression-seq)

# release dependences construct
release-deps-construct: NODECL_OMP_SS*RELEASE([environment] omp-exec-environment-seq-opt)

omp-exec-environment: NODECL_OMP_SS*ALLOCA([exprs] expression-seq)
                | NODECL_OMP_SS*SHARED_AND_ALLOCA([exprs]expression-seq)
                | NODECL_OMP_SS*WEAK_REDUCTION([reductions]omp-reduction-item-seq)
                | NODECL_OMP_SS*COST([cost]expression)
                | NODECL_OMP_SS*STREAM([stream]expression)
                | NODECL_OMP_SS*NODE([node]expression)
                | NODECL_OMP_SS*LINT_VERIFIED([expr]expression)
                | NODECL_OMP_SS*ONREADY([onready]expression)
                | NODECL_OMP_SS*TASK_LABEL() text

omp-exec-environment : ompss-device-info

omp-deps-info: NODECL_OMP_SS*DEP_CONCURRENT([exprs]expression-seq)
                | NODECL_OMP_SS*DEP_COMMUTATIVE([exprs]expression-seq)
                | NODECL_OMP_SS*DEP_REDUCTION([exprs]expression-seq)
                | NODECL_OMP_SS*DEP_WEAK_REDUCTION([exprs]expression-seq)
                | NODECL_OMP_SS*DEP_IN_PRIVATE([exprs]expression-seq)
                | NODECL_OMP_SS*DEP_WEAK_IN([exprs]expression-seq)
                | NODECL_OMP_SS*DEP_WEAK_OUT([exprs]expression-seq)
                | NODECL_OMP_SS*DEP_WEAK_INOUT([exprs]expression-seq)
                | NODECL_OMP_SS*DEP_WEAK_COMMUTATIVE([exprs]expression-seq)
                | NODECL_OMP_SS*DEP_WEAK_CONCURRENT([exprs]expression-seq)

ompss-device-info : NODECL_OMP_SS*TARGET([devices]text-seq, [items]ompss-device-info-clauses-seq-opt)

ompss-device-info-clauses : NODECL_OMP_SS*COPY_IN([input_copies]expression-seq)
            | NODECL_OMP_SS*COPY_OUT([output_copies]expression-seq)
            | NODECL_OMP_SS*COPY_INOUT([inout_copies]expression-seq)
            | NODECL_OMP_SS*N_D_RANGE([ndrange_expressions]expression-seq)
            | NODECL_OMP_SS*SH_MEM([shmem_expressions]expression-seq)
            | NODECL_OMP_SS*FILE([filename]text)
            | NODECL_OMP_SS*NAME([name]text)
            | NODECL_OMP_SS*ONTO([onto_expressions]expression-seq)
            | NODECL_OMP_SS*IMPLEMENTS([device]text, [function_name]name)


##############################
# CUDA                       #
##############################

cuda-expressions : NODECL_CUDA_KERNEL_CALL([kernel_config] expression-seq, [function_call] expression) type const-value-opt

##############################
# ANALYSIS                   #
##############################

# Used for range analysis

constraint_expression : NODECL_ANALYSIS*PHI([expressions] expression-seq) type
                      | NODECL_ANALYSIS*RANGE_UNION([lhs] expression, [rhs] expression) type
                      | NODECL_ANALYSIS*RANGE_INTERSECTION([lhs] expression, [rhs] expression) type
                      | NODECL_ANALYSIS*RANGE_SUB([lhs] expression, [rhs] expression) type
                      | NODECL_ANALYSIS*EMPTY_RANGE()
                      | NODECL_ANALYSIS*MINUS_INFINITY() type const-value
                      | NODECL_ANALYSIS*PLUS_INFINITY() type const-value
                      | NODECL_ANALYSIS*MINIMUM([expressions] expression-seq) type
                      | NODECL_ANALYSIS*MAXIMUM([expressions] expression-seq) type

expression : constraint_expression
           | NODECL_UNKNOWN()

# Used for analysis checking
reach_def_expression : NODECL_ANALYSIS*REACH_DEF_EXPR([expression] expression, [value] expression)

induction_var_expression : NODECL_ANALYSIS*INDUCTION_VAR_EXPR([variable] expression, [lower] expression-seq, [upper] expression-seq, [stride] expression)

analysis-exec-environment : NODECL_ANALYSIS*UPPER_EXPOSED([upper_exposed_exprs] expression-seq-opt)
                          | NODECL_ANALYSIS*DEFINED([defined_exprs] expression-seq-opt)
                          | NODECL_ANALYSIS*UNDEFINED([undefined_exprs] expression-seq-opt)
                          | NODECL_ANALYSIS*LIVE_IN([live_in_exprs] expression-seq-opt)
                          | NODECL_ANALYSIS*LIVE_OUT([live_out_exprs] expression-seq-opt)
                          | NODECL_ANALYSIS*DEAD([dead_exprs] expression-seq-opt)
                          | NODECL_ANALYSIS*REACHING_DEFINITION_IN([reaching_definitions_in] reach_def_expression-seq-opt)
                          | NODECL_ANALYSIS*REACHING_DEFINITION_OUT([reaching_definitions_out] reach_def_expression-seq-opt)
                          | NODECL_ANALYSIS*INDUCTION_VARIABLE([induction_variables] induction_var_expression-seq-opt)
                          | NODECL_ANALYSIS*AUTO_SCOPE*FIRSTPRIVATE([scoped_variables] expression-seq-opt)
                          | NODECL_ANALYSIS*AUTO_SCOPE*PRIVATE([scoped_variables] expression-seq-opt)
                          | NODECL_ANALYSIS*AUTO_SCOPE*SHARED([scoped_variables] expression-seq-opt)
                          | NODECL_ANALYSIS*RANGE([range_variables] induction_var_expression-seq-opt)
                          | NODECL_ANALYSIS*CORRECTNESS*AUTO_STORAGE([correctness_vars] expression-seq-opt)
                          | NODECL_ANALYSIS*CORRECTNESS*DEAD([correctness_vars] expression-seq-opt)
                          | NODECL_ANALYSIS*CORRECTNESS*INCOHERENT_FP([correctness_vars] expression-seq-opt)
                          | NODECL_ANALYSIS*CORRECTNESS*INCOHERENT_P([correctness_vars] expression-seq-opt)
                          | NODECL_ANALYSIS*CORRECTNESS*INCOHERENT_IN([correctness_vars] expression-seq-opt)
                          | NODECL_ANALYSIS*CORRECTNESS*INCOHERENT_OUT([correctness_vars] expression-seq-opt)
                          | NODECL_ANALYSIS*CORRECTNESS*INCOHERENT_IN_POINTED([correctness_vars] expression-seq-opt)
                          | NODECL_ANALYSIS*CORRECTNESS*INCOHERENT_OUT_POINTED([correctness_vars] expression-seq-opt)
                          | NODECL_ANALYSIS*CORRECTNESS*RACE([correctness_vars] expression-seq-opt)

assert-construct : NODECL_ANALYSIS*ASSERT([statements] statement-seq, [environment] analysis-exec-environment-seq-opt)

top-level : assert-directive

assert-directive : NODECL_ANALYSIS*ASSERT_DECL([environment] analysis-exec-environment-seq-opt) symbol


##############################
# CHECKPOINT                 #
##############################

statement-but-object-init : checkpoint_directives

checkpoint_directives : NODECL_CHECKPOINT*STORE([environment] checkpoint-environment-seq-opt])
                      | NODECL_CHECKPOINT*LOAD([environment] checkpoint-environment-seq-opt])
                      | NODECL_CHECKPOINT*INIT([environment] checkpoint-environment-seq-opt])
                      | NODECL_CHECKPOINT*SHUTDOWN()

checkpoint-environment : NODECL_CHECKPOINT*DATA([exprs] expression-seq)
                       | NODECL_CHECKPOINT*LEVEL([expr] expression)
                       | NODECL_CHECKPOINT*ID([expr] expression)
                       | NODECL_CHECKPOINT*COMM([expr] expression)
                       | NODECL_CHECKPOINT*IF([expr] expression)
                       | NODECL_CHECKPOINT*KIND([expr] expression)


##############################
# LINT                       #
##############################

statement-but-object-init: lint-construct

lint-construct : NODECL_OMP_SS*LINT([environment]lint-exec-environment-seq-opt,[statements]statement-seq-opt)

lint-exec-environment : omp-exec-environment
                      | NODECL_OMP_SS*LINT_FREE([exprs]expression-seq)
                      | NODECL_OMP_SS*LINT_ALLOC([exprs]expression-seq)
